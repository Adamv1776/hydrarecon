"""
3D Exploit Chain Visualization

Interactive visualization of:
- Exploit chain paths
- Vulnerability connections
- Attack stages
- MITRE ATT&CK mapping
- Defense points
- Kill chain progression
"""

import math
import time
import numpy as np
from dataclasses import dataclass, field
from typing import Dict, List, Any, Optional, Tuple
from enum import Enum

from PyQt6.QtCore import Qt, QTimer, pyqtSignal

from .engine_3d import (
    Visualization3DEngine, Scene3D, Object3D, Mesh3D, Material3D,
    Light3D, Camera3D, LightType
)
from .particle_system import ParticleSystem, EffectPresets


class AttackPhase(Enum):
    """Cyber Kill Chain phases"""
    RECONNAISSANCE = "reconnaissance"
    WEAPONIZATION = "weaponization"
    DELIVERY = "delivery"
    EXPLOITATION = "exploitation"
    INSTALLATION = "installation"
    COMMAND_CONTROL = "command_and_control"
    ACTIONS = "actions_on_objectives"


class ExploitSeverity(Enum):
    """Exploit severity levels"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class NodeStatus(Enum):
    """Node status"""
    SECURE = "secure"
    VULNERABLE = "vulnerable"
    COMPROMISED = "compromised"
    PATCHED = "patched"


@dataclass
class Vulnerability:
    """Vulnerability information"""
    id: str
    cve_id: str = ""
    name: str = ""
    description: str = ""
    
    severity: ExploitSeverity = ExploitSeverity.MEDIUM
    cvss_score: float = 5.0
    
    # MITRE ATT&CK
    tactic: str = ""
    technique: str = ""
    technique_id: str = ""
    
    # Status
    is_exploited: bool = False
    is_patched: bool = False
    
    data: Dict[str, Any] = field(default_factory=dict)


@dataclass
class ExploitNode:
    """Node in exploit chain"""
    id: str
    name: str
    position: Tuple[float, float, float]
    
    # Type
    node_type: str = "system"  # system, service, credential, data, network
    
    # Vulnerabilities
    vulnerabilities: List[Vulnerability] = field(default_factory=list)
    
    # Status
    status: NodeStatus = NodeStatus.SECURE
    phase: Optional[AttackPhase] = None
    
    # Connections
    incoming: List[str] = field(default_factory=list)
    outgoing: List[str] = field(default_factory=list)
    
    # Visual
    object_3d: Optional[Object3D] = None
    
    data: Dict[str, Any] = field(default_factory=dict)


@dataclass
class ExploitLink:
    """Link between nodes in exploit chain"""
    id: str
    source_id: str
    target_id: str
    
    # Exploit info
    exploit_name: str = ""
    vulnerability: Optional[Vulnerability] = None
    
    # Status
    is_active: bool = False
    success_probability: float = 0.5
    
    # Visual
    object_3d: Optional[Object3D] = None
    
    data: Dict[str, Any] = field(default_factory=dict)


@dataclass
class ExploitChain:
    """Complete exploit chain"""
    id: str
    name: str
    
    nodes: List[str] = field(default_factory=list)
    links: List[str] = field(default_factory=list)
    
    # Progress
    current_step: int = 0
    is_complete: bool = False
    is_blocked: bool = False
    
    # Defense
    defense_points: List[str] = field(default_factory=list)
    
    data: Dict[str, Any] = field(default_factory=dict)


class ExploitChain3D(Visualization3DEngine):
    """3D Exploit Chain Visualization"""
    
    nodeClicked = pyqtSignal(object)
    linkClicked = pyqtSignal(object)
    chainProgressed = pyqtSignal(object)
    exploitTriggered = pyqtSignal(object)
    defenseActivated = pyqtSignal(object)
    
    # Phase colors
    PHASE_COLORS = {
        AttackPhase.RECONNAISSANCE: (0.3, 0.5, 0.8),
        AttackPhase.WEAPONIZATION: (0.5, 0.4, 0.7),
        AttackPhase.DELIVERY: (0.7, 0.5, 0.3),
        AttackPhase.EXPLOITATION: (0.9, 0.4, 0.2),
        AttackPhase.INSTALLATION: (0.8, 0.3, 0.4),
        AttackPhase.COMMAND_CONTROL: (0.6, 0.2, 0.5),
        AttackPhase.ACTIONS: (0.9, 0.1, 0.2),
    }
    
    # Severity colors
    SEVERITY_COLORS = {
        ExploitSeverity.LOW: (0.3, 0.7, 0.3),
        ExploitSeverity.MEDIUM: (0.9, 0.7, 0.1),
        ExploitSeverity.HIGH: (0.9, 0.4, 0.1),
        ExploitSeverity.CRITICAL: (0.9, 0.1, 0.1),
    }
    
    # Status colors
    STATUS_COLORS = {
        NodeStatus.SECURE: (0.2, 0.8, 0.3),
        NodeStatus.VULNERABLE: (0.9, 0.7, 0.1),
        NodeStatus.COMPROMISED: (0.9, 0.2, 0.2),
        NodeStatus.PATCHED: (0.3, 0.6, 0.9),
    }
    
    def __init__(self, parent=None):
        super().__init__(parent)
        
        self.nodes: Dict[str, ExploitNode] = {}
        self.links: Dict[str, ExploitLink] = {}
        self.chains: Dict[str, ExploitChain] = {}
        
        # Particle system for effects
        self.particle_system = ParticleSystem()
        
        # Animation
        self.animation_speed = 1.0
        self.is_animating = False
        self.current_chain: Optional[str] = None
        
        # Layout
        self.phase_positions: Dict[AttackPhase, float] = {
            AttackPhase.RECONNAISSANCE: -12,
            AttackPhase.WEAPONIZATION: -8,
            AttackPhase.DELIVERY: -4,
            AttackPhase.EXPLOITATION: 0,
            AttackPhase.INSTALLATION: 4,
            AttackPhase.COMMAND_CONTROL: 8,
            AttackPhase.ACTIONS: 12,
        }
        
        self._setup_scene()
    
    def _setup_scene(self):
        """Setup the 3D scene"""
        self.scene.background_color = (0.02, 0.01, 0.03)
        self.scene.ambient_color = (0.08, 0.06, 0.1)
        
        self._setup_lighting()
        self._create_phase_indicators()
        
        self.scene.camera.position = (0, 20, 30)
        self.scene.camera.target = (0, 2, 0)
    
    def _setup_lighting(self):
        """Setup lighting"""
        # Main light
        self.scene.add_light(Light3D(
            light_type=LightType.POINT,
            position=(0, 25, 15),
            color=(1.0, 0.95, 0.9),
            intensity=300.0
        ))
        
        # Red accent for danger
        self.scene.add_light(Light3D(
            light_type=LightType.POINT,
            position=(15, 10, 0),
            color=(1.0, 0.3, 0.2),
            intensity=100.0
        ))
        
        # Blue accent for defense
        self.scene.add_light(Light3D(
            light_type=LightType.POINT,
            position=(-15, 10, 0),
            color=(0.2, 0.4, 1.0),
            intensity=100.0
        ))
    
    def _create_phase_indicators(self):
        """Create visual indicators for kill chain phases"""
        for phase, x_pos in self.phase_positions.items():
            color = self.PHASE_COLORS.get(phase, (0.5, 0.5, 0.5))
            
            # Phase marker plane
            mesh = Mesh3D.create_plane(4, 20)
            
            material = Material3D(
                name=f"phase_{phase.value}",
                albedo=color,
                emission=color,
                emission_strength=0.2,
                opacity=0.1,
                double_sided=True
            )
            
            plane = Object3D(
                name=f"phase_{phase.value}",
                mesh=mesh,
                material=material,
                position=(x_pos, 5, 0),
                rotation=(0, 0, 90)  # Vertical
            )
            
            self.scene.add_object(plane)
            
            # Phase label (simplified - would need text rendering)
            # For now, create a small sphere indicator at top
            label_mesh = Mesh3D.create_sphere(0.3, 8, 4)
            label_material = Material3D(
                name=f"label_{phase.value}",
                albedo=color,
                emission=color,
                emission_strength=1.0
            )
            
            label = Object3D(
                name=f"label_{phase.value}",
                mesh=label_mesh,
                material=label_material,
                position=(x_pos, 12, 0)
            )
            
            self.scene.add_object(label)
    
    def add_node(self, node: ExploitNode):
        """Add an exploit chain node"""
        self.nodes[node.id] = node
        
        # Auto-position based on phase if not set
        if node.position == (0, 0, 0) and node.phase:
            x = self.phase_positions.get(node.phase, 0)
            y = len([n for n in self.nodes.values() if n.phase == node.phase]) * 3
            node.position = (x, y + 2, 0)
        
        # Create visualization
        node_obj = self._create_node_object(node)
        node.object_3d = node_obj
        self.scene.add_object(node_obj)
        
        # Add vulnerability indicators
        for vuln in node.vulnerabilities:
            self._create_vulnerability_indicator(node, vuln)
    
    def _create_node_object(self, node: ExploitNode) -> Object3D:
        """Create 3D object for node"""
        color = self.STATUS_COLORS.get(node.status, (0.5, 0.5, 0.5))
        
        # Different shapes for different types
        if node.node_type == "system":
            mesh = Mesh3D.create_box(1.5, 1.5, 1.5)
        elif node.node_type == "service":
            mesh = Mesh3D.create_sphere(0.8, 16, 8)
        elif node.node_type == "credential":
            mesh = Mesh3D.create_box(0.5, 1.0, 0.5)
        elif node.node_type == "data":
            mesh = Mesh3D.create_sphere(0.6, 8, 8)
        elif node.node_type == "network":
            mesh = Mesh3D.create_box(2.0, 0.3, 1.0)
        else:
            mesh = Mesh3D.create_box(1.0, 1.0, 1.0)
        
        material = Material3D(
            name=f"node_{node.id}",
            albedo=color,
            emission=color,
            emission_strength=0.4,
            metallic=0.3,
            roughness=0.5
        )
        
        node_obj = Object3D(
            name=f"node_{node.id}",
            mesh=mesh,
            material=material,
            position=node.position,
            data={"type": "node", "node_id": node.id}
        )
        
        # Animation based on status
        def animate_node(obj: Object3D, dt: float):
            if node.status == NodeStatus.COMPROMISED:
                # Pulsing red
                pulse = math.sin(time.time() * 4) * 0.3 + 0.7
                obj.material.emission_strength = pulse
            elif node.status == NodeStatus.VULNERABLE:
                # Slow pulse yellow
                pulse = math.sin(time.time() * 2) * 0.2 + 0.5
                obj.material.emission_strength = pulse
        
        node_obj.animation_callback = animate_node
        
        return node_obj
    
    def _create_vulnerability_indicator(self, node: ExploitNode, vuln: Vulnerability):
        """Create small indicator for vulnerability"""
        color = self.SEVERITY_COLORS.get(vuln.severity, (0.5, 0.5, 0.5))
        
        # Offset from node
        offset_angle = len([v for v in node.vulnerabilities if v.id < vuln.id]) * (2 * math.pi / max(1, len(node.vulnerabilities)))
        offset = 1.5
        
        x = node.position[0] + offset * math.cos(offset_angle)
        y = node.position[1]
        z = node.position[2] + offset * math.sin(offset_angle)
        
        size = 0.2 + vuln.cvss_score * 0.03
        mesh = Mesh3D.create_sphere(size, 8, 4)
        
        material = Material3D(
            name=f"vuln_{vuln.id}",
            albedo=color,
            emission=color,
            emission_strength=0.8,
            opacity=0.8
        )
        
        vuln_obj = Object3D(
            name=f"vuln_{vuln.id}",
            mesh=mesh,
            material=material,
            position=(x, y, z),
            data={"type": "vulnerability", "vuln_id": vuln.id, "node_id": node.id}
        )
        
        self.scene.add_object(vuln_obj)
    
    def add_link(self, link: ExploitLink):
        """Add an exploit link between nodes"""
        self.links[link.id] = link
        
        if link.source_id not in self.nodes or link.target_id not in self.nodes:
            return
        
        source = self.nodes[link.source_id]
        target = self.nodes[link.target_id]
        
        # Update node connections
        source.outgoing.append(link.id)
        target.incoming.append(link.id)
        
        # Create link visualization
        link_obj = self._create_link_object(link, source, target)
        link.object_3d = link_obj
        self.scene.add_object(link_obj)
    
    def _create_link_object(self, link: ExploitLink, source: ExploitNode,
                            target: ExploitNode) -> Object3D:
        """Create 3D link visualization"""
        # Create curved path
        vertices = self._create_bezier_path_3d(
            source.position, target.position
        )
        
        indices = []
        for i in range(len(vertices) // 3 - 1):
            indices.extend([i, i + 1])
        
        mesh = Mesh3D(
            vertices=np.array(vertices, dtype=np.float32),
            indices=np.array(indices, dtype=np.uint32)
        )
        
        # Color based on severity if vulnerability present
        if link.vulnerability:
            color = self.SEVERITY_COLORS.get(link.vulnerability.severity, (0.5, 0.5, 0.5))
        else:
            color = (0.4, 0.4, 0.5)
        
        # Dim inactive links
        emission = 0.5 if link.is_active else 0.2
        opacity = 0.8 if link.is_active else 0.3
        
        material = Material3D(
            name=f"link_{link.id}",
            albedo=color,
            emission=color,
            emission_strength=emission,
            opacity=opacity,
            wireframe=True
        )
        
        link_obj = Object3D(
            name=f"link_{link.id}",
            mesh=mesh,
            material=material,
            data={"type": "link", "link_id": link.id}
        )
        
        # Animation for active links
        def animate_link(obj: Object3D, dt: float):
            if link.is_active:
                pulse = (math.sin(time.time() * 6) + 1) * 0.5
                obj.material.emission_strength = 0.3 + pulse * 0.5
        
        link_obj.animation_callback = animate_link
        
        return link_obj
    
    def _create_bezier_path_3d(self, start: Tuple[float, float, float],
                               end: Tuple[float, float, float],
                               segments: int = 30) -> List[float]:
        """Create 3D bezier path"""
        start = np.array(start)
        end = np.array(end)
        
        # Control points
        mid = (start + end) / 2
        distance = np.linalg.norm(end - start)
        
        # Arc upward
        mid[1] += min(4.0, distance * 0.3)
        
        # Also offset in Z for 3D effect
        direction = end - start
        perpendicular = np.cross(direction, np.array([0, 1, 0]))
        if np.linalg.norm(perpendicular) > 0:
            perpendicular = perpendicular / np.linalg.norm(perpendicular)
            mid += perpendicular * distance * 0.1
        
        vertices = []
        
        for i in range(segments + 1):
            t = i / segments
            point = (1-t)**2 * start + 2*(1-t)*t * mid + t**2 * end
            vertices.extend(point.tolist())
        
        return vertices
    
    def add_chain(self, chain: ExploitChain):
        """Add a complete exploit chain"""
        self.chains[chain.id] = chain
    
    def animate_chain(self, chain_id: str):
        """Animate an exploit chain execution"""
        if chain_id not in self.chains:
            return
        
        chain = self.chains[chain_id]
        self.current_chain = chain_id
        self.is_animating = True
        
        # Reset chain
        chain.current_step = 0
        chain.is_complete = False
        chain.is_blocked = False
        
        # Start animation timer
        self._animate_step()
    
    def _animate_step(self):
        """Animate current step of chain"""
        if not self.is_animating or not self.current_chain:
            return
        
        chain = self.chains[self.current_chain]
        
        if chain.current_step >= len(chain.links):
            chain.is_complete = True
            self.is_animating = False
            return
        
        link_id = chain.links[chain.current_step]
        
        if link_id in self.links:
            link = self.links[link_id]
            
            # Activate link
            link.is_active = True
            if link.object_3d:
                color = self.SEVERITY_COLORS.get(
                    link.vulnerability.severity if link.vulnerability else ExploitSeverity.MEDIUM,
                    (0.9, 0.4, 0.2)
                )
                link.object_3d.material.emission = color
                link.object_3d.material.emission_strength = 1.0
            
            # Compromise target node
            if link.target_id in self.nodes:
                target = self.nodes[link.target_id]
                target.status = NodeStatus.COMPROMISED
                
                if target.object_3d:
                    color = self.STATUS_COLORS[NodeStatus.COMPROMISED]
                    target.object_3d.material.albedo = color
                    target.object_3d.material.emission = color
                
                # Create breach effect
                self._create_breach_effect(target.position)
            
            self.exploitTriggered.emit(link)
        
        chain.current_step += 1
        self.chainProgressed.emit(chain)
        
        # Schedule next step
        QTimer.singleShot(int(1500 / self.animation_speed), self._animate_step)
    
    def _create_breach_effect(self, position: Tuple[float, float, float]):
        """Create visual effect for breach"""
        emitters = EffectPresets.create_breach_effect(position)
        
        for i, emitter in enumerate(emitters):
            name = f"breach_{int(time.time() * 1000)}_{i}"
            self.particle_system.add_emitter(name, emitter)
            emitter.emit_burst()
            
            # Auto-remove after effect
            def remove_emitter(n=name):
                self.particle_system.remove_emitter(n)
            
            QTimer.singleShot(3000, remove_emitter)
    
    def add_defense(self, node_id: str, defense_type: str = "firewall"):
        """Add defense to a node"""
        if node_id not in self.nodes:
            return
        
        node = self.nodes[node_id]
        
        # Create defense visualization (shield effect)
        emitter = EffectPresets.create_defense_shield(node.position, 2.0)
        self.particle_system.add_emitter(f"defense_{node_id}", emitter)
        
        # Mark node as defended
        node.status = NodeStatus.PATCHED
        
        if node.object_3d:
            color = self.STATUS_COLORS[NodeStatus.PATCHED]
            node.object_3d.material.albedo = color
            node.object_3d.material.emission = color
        
        self.defenseActivated.emit(node)
    
    def block_link(self, link_id: str):
        """Block an exploit link"""
        if link_id not in self.links:
            return
        
        link = self.links[link_id]
        link.is_active = False
        link.success_probability = 0.0
        
        if link.object_3d:
            link.object_3d.material.opacity = 0.1
            link.object_3d.material.emission_strength = 0.0
    
    def reset_chain(self, chain_id: str):
        """Reset chain to initial state"""
        if chain_id not in self.chains:
            return
        
        chain = self.chains[chain_id]
        chain.current_step = 0
        chain.is_complete = False
        chain.is_blocked = False
        
        # Reset all links
        for link_id in chain.links:
            if link_id in self.links:
                link = self.links[link_id]
                link.is_active = False
                if link.object_3d:
                    link.object_3d.material.emission_strength = 0.2
                    link.object_3d.material.opacity = 0.3
        
        # Reset all nodes
        for node_id in chain.nodes:
            if node_id in self.nodes:
                node = self.nodes[node_id]
                node.status = NodeStatus.VULNERABLE if node.vulnerabilities else NodeStatus.SECURE
                
                if node.object_3d:
                    color = self.STATUS_COLORS[node.status]
                    node.object_3d.material.albedo = color
                    node.object_3d.material.emission = color
    
    def highlight_path(self, node_ids: List[str], highlight: bool = True):
        """Highlight a path through nodes"""
        for i, node_id in enumerate(node_ids):
            if node_id in self.nodes:
                node = self.nodes[node_id]
                
                if node.object_3d:
                    if highlight:
                        node.object_3d.material.emission_strength = 1.0
                        node.object_3d.scale = (1.3, 1.3, 1.3)
                    else:
                        node.object_3d.material.emission_strength = 0.4
                        node.object_3d.scale = (1.0, 1.0, 1.0)
                
                # Highlight connecting links
                if i < len(node_ids) - 1:
                    next_id = node_ids[i + 1]
                    for link_id in node.outgoing:
                        if link_id in self.links:
                            link = self.links[link_id]
                            if link.target_id == next_id:
                                if link.object_3d:
                                    link.object_3d.material.emission_strength = 1.0 if highlight else 0.2
    
    def get_attack_surface(self) -> Dict[str, Any]:
        """Calculate attack surface metrics"""
        total_vulns = 0
        critical_vulns = 0
        high_vulns = 0
        
        vulnerable_nodes = 0
        compromised_nodes = 0
        
        for node in self.nodes.values():
            if node.status == NodeStatus.VULNERABLE:
                vulnerable_nodes += 1
            elif node.status == NodeStatus.COMPROMISED:
                compromised_nodes += 1
            
            for vuln in node.vulnerabilities:
                total_vulns += 1
                if vuln.severity == ExploitSeverity.CRITICAL:
                    critical_vulns += 1
                elif vuln.severity == ExploitSeverity.HIGH:
                    high_vulns += 1
        
        return {
            "total_nodes": len(self.nodes),
            "vulnerable_nodes": vulnerable_nodes,
            "compromised_nodes": compromised_nodes,
            "total_vulnerabilities": total_vulns,
            "critical_vulnerabilities": critical_vulns,
            "high_vulnerabilities": high_vulns,
            "total_links": len(self.links),
            "active_chains": len(self.chains),
        }
    
    def create_demo_chain(self):
        """Create a demo exploit chain"""
        # Create nodes for each phase
        nodes = [
            ExploitNode("recon", "Target Discovery", (-12, 3, 0), "system",
                       phase=AttackPhase.RECONNAISSANCE),
            ExploitNode("weapon", "Payload Creation", (-8, 3, 0), "service",
                       phase=AttackPhase.WEAPONIZATION),
            ExploitNode("phishing", "Phishing Email", (-4, 3, 0), "network",
                       phase=AttackPhase.DELIVERY,
                       vulnerabilities=[Vulnerability("v1", "CVE-2024-1234", "Email Bypass",
                                                      severity=ExploitSeverity.MEDIUM)]),
            ExploitNode("workstation", "User Workstation", (0, 3, 0), "system",
                       phase=AttackPhase.EXPLOITATION,
                       vulnerabilities=[Vulnerability("v2", "CVE-2024-5678", "RCE Vuln",
                                                      severity=ExploitSeverity.CRITICAL)]),
            ExploitNode("malware", "Backdoor Install", (4, 3, 0), "service",
                       phase=AttackPhase.INSTALLATION),
            ExploitNode("c2", "C2 Connection", (8, 3, 0), "network",
                       phase=AttackPhase.COMMAND_CONTROL),
            ExploitNode("data", "Sensitive Data", (12, 3, 0), "data",
                       phase=AttackPhase.ACTIONS,
                       vulnerabilities=[Vulnerability("v3", "CVE-2024-9999", "Data Access",
                                                      severity=ExploitSeverity.HIGH)]),
        ]
        
        for node in nodes:
            node.status = NodeStatus.VULNERABLE if node.vulnerabilities else NodeStatus.SECURE
            self.add_node(node)
        
        # Create links
        links = [
            ExploitLink("l1", "recon", "weapon", "OSINT Gathering"),
            ExploitLink("l2", "weapon", "phishing", "Payload Delivery",
                       vulnerability=nodes[2].vulnerabilities[0] if nodes[2].vulnerabilities else None),
            ExploitLink("l3", "phishing", "workstation", "Remote Code Execution",
                       vulnerability=nodes[3].vulnerabilities[0] if nodes[3].vulnerabilities else None),
            ExploitLink("l4", "workstation", "malware", "Persistence Mechanism"),
            ExploitLink("l5", "malware", "c2", "Command & Control"),
            ExploitLink("l6", "c2", "data", "Data Exfiltration",
                       vulnerability=nodes[6].vulnerabilities[0] if nodes[6].vulnerabilities else None),
        ]
        
        for link in links:
            self.add_link(link)
        
        # Create chain
        chain = ExploitChain(
            id="demo_chain",
            name="APT Attack Chain",
            nodes=[n.id for n in nodes],
            links=[l.id for l in links]
        )
        
        self.add_chain(chain)
