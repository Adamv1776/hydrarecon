#!/usr/bin/env python3
"""
HydraRecon Deception Technology Module
Enterprise honeypot deployment, decoy management, and attacker tracking.
"""

import asyncio
import json
import hashlib
import random
import string
import socket
import threading
from datetime import datetime, timedelta
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import Dict, List, Optional, Any, Callable, Set
from pathlib import Path
import logging


class DecoyType(Enum):
    """Types of deception assets"""
    HONEYPOT = "honeypot"
    HONEYTOKEN = "honeytoken"
    HONEYCRED = "honeycred"
    HONEYFILE = "honeyfile"
    HONEYNET = "honeynet"
    BREADCRUMB = "breadcrumb"
    CANARY = "canary"
    FAKE_SERVICE = "fake_service"


class InteractionLevel(Enum):
    """Honeypot interaction levels"""
    LOW = "low"           # Basic port listeners
    MEDIUM = "medium"     # Emulated services
    HIGH = "high"         # Full OS emulation
    PURE = "pure"         # Real vulnerable systems


class DecoyStatus(Enum):
    """Status of deception assets"""
    ACTIVE = "active"
    INACTIVE = "inactive"
    TRIGGERED = "triggered"
    COMPROMISED = "compromised"
    MAINTENANCE = "maintenance"


class AlertSeverity(Enum):
    """Alert severity levels"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


@dataclass
class DecoyAsset:
    """Represents a deception asset"""
    id: str
    name: str
    type: DecoyType
    status: DecoyStatus
    interaction_level: InteractionLevel
    ip_address: Optional[str] = None
    hostname: Optional[str] = None
    services: List[str] = field(default_factory=list)
    location: str = ""
    created_at: datetime = field(default_factory=datetime.now)
    last_activity: Optional[datetime] = None
    trigger_count: int = 0
    configuration: Dict[str, Any] = field(default_factory=dict)
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class HoneyToken:
    """Represents a honeytoken (credential, API key, etc.)"""
    id: str
    name: str
    token_type: str  # credential, api_key, document, database_record
    value: str
    hash_value: str
    planted_locations: List[str] = field(default_factory=list)
    triggered: bool = False
    trigger_count: int = 0
    created_at: datetime = field(default_factory=datetime.now)
    last_triggered: Optional[datetime] = None
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class DeceptionAlert:
    """Alert generated by deception technology"""
    id: str
    timestamp: datetime
    severity: AlertSeverity
    decoy_id: str
    decoy_name: str
    decoy_type: DecoyType
    source_ip: str
    source_port: int
    activity_type: str  # scan, access, exfil, lateral_movement
    details: Dict[str, Any] = field(default_factory=dict)
    raw_data: Optional[bytes] = None
    acknowledged: bool = False
    investigated: bool = False


@dataclass 
class AttackerProfile:
    """Profile of potential attacker based on deception interactions"""
    id: str
    first_seen: datetime
    last_seen: datetime
    source_ips: Set[str] = field(default_factory=set)
    triggered_decoys: List[str] = field(default_factory=list)
    techniques_observed: List[str] = field(default_factory=list)
    tools_detected: List[str] = field(default_factory=list)
    credentials_attempted: List[str] = field(default_factory=list)
    threat_score: float = 0.0
    ttps: Dict[str, Any] = field(default_factory=dict)  # MITRE ATT&CK mapping


@dataclass
class DeceptionCampaign:
    """Coordinated deception campaign"""
    id: str
    name: str
    description: str
    decoys: List[str] = field(default_factory=list)
    honeytokens: List[str] = field(default_factory=list)
    start_date: datetime = field(default_factory=datetime.now)
    end_date: Optional[datetime] = None
    active: bool = True
    objectives: List[str] = field(default_factory=list)
    metrics: Dict[str, Any] = field(default_factory=dict)


class DeceptionEngine:
    """Enterprise deception technology engine"""
    
    def __init__(self):
        self.logger = logging.getLogger("DeceptionEngine")
        self.decoys: Dict[str, DecoyAsset] = {}
        self.honeytokens: Dict[str, HoneyToken] = {}
        self.alerts: List[DeceptionAlert] = []
        self.attacker_profiles: Dict[str, AttackerProfile] = {}
        self.campaigns: Dict[str, DeceptionCampaign] = {}
        self.callbacks: Dict[str, List[Callable]] = {
            "alert": [],
            "trigger": [],
            "compromise": []
        }
        self.active_listeners: Dict[str, threading.Thread] = {}
        self._init_templates()
    
    def _init_templates(self):
        """Initialize deception templates"""
        self.honeypot_templates = {
            "ssh_honeypot": {
                "name": "SSH Honeypot",
                "type": DecoyType.HONEYPOT,
                "services": ["ssh"],
                "port": 22,
                "interaction": InteractionLevel.MEDIUM,
                "emulation": "openssh"
            },
            "rdp_honeypot": {
                "name": "RDP Honeypot",
                "type": DecoyType.HONEYPOT,
                "services": ["rdp"],
                "port": 3389,
                "interaction": InteractionLevel.MEDIUM,
                "emulation": "windows_rdp"
            },
            "web_honeypot": {
                "name": "Web Application Honeypot",
                "type": DecoyType.HONEYPOT,
                "services": ["http", "https"],
                "ports": [80, 443],
                "interaction": InteractionLevel.MEDIUM,
                "emulation": "apache_php"
            },
            "database_honeypot": {
                "name": "Database Honeypot",
                "type": DecoyType.HONEYPOT,
                "services": ["mysql", "mssql", "postgresql"],
                "ports": [3306, 1433, 5432],
                "interaction": InteractionLevel.MEDIUM
            },
            "smb_honeypot": {
                "name": "SMB/CIFS Honeypot",
                "type": DecoyType.HONEYPOT,
                "services": ["smb"],
                "port": 445,
                "interaction": InteractionLevel.MEDIUM
            },
            "ftp_honeypot": {
                "name": "FTP Honeypot",
                "type": DecoyType.HONEYPOT,
                "services": ["ftp"],
                "port": 21,
                "interaction": InteractionLevel.MEDIUM
            },
            "telnet_honeypot": {
                "name": "Telnet Honeypot",
                "type": DecoyType.HONEYPOT,
                "services": ["telnet"],
                "port": 23,
                "interaction": InteractionLevel.LOW
            },
            "ics_honeypot": {
                "name": "ICS/SCADA Honeypot",
                "type": DecoyType.HONEYPOT,
                "services": ["modbus", "s7comm", "dnp3"],
                "ports": [502, 102, 20000],
                "interaction": InteractionLevel.HIGH
            }
        }
        
        self.honeytoken_templates = {
            "aws_credential": {
                "name": "AWS Access Key",
                "type": "credential",
                "format": "AKIA{20_chars}",
                "secret_format": "{40_base64_chars}"
            },
            "api_key": {
                "name": "Generic API Key",
                "type": "api_key",
                "format": "{prefix}_{32_hex}"
            },
            "database_cred": {
                "name": "Database Credential",
                "type": "credential",
                "username_format": "db_admin_{suffix}",
                "password_format": "{complex_password}"
            },
            "jwt_token": {
                "name": "JWT Token",
                "type": "token",
                "format": "eyJ{base64}.eyJ{base64}.{signature}"
            }
        }
        
        self.breadcrumb_templates = {
            "config_file": {
                "name": "Configuration File",
                "type": DecoyType.BREADCRUMB,
                "filenames": [".env", "config.json", "settings.ini", "database.yml"]
            },
            "ssh_key": {
                "name": "SSH Private Key",
                "type": DecoyType.BREADCRUMB,
                "filenames": ["id_rsa", "id_ed25519", ".ssh/authorized_keys"]
            },
            "password_file": {
                "name": "Password File",
                "type": DecoyType.BREADCRUMB,
                "filenames": ["passwords.txt", "credentials.csv", "secrets.json"]
            }
        }
    
    async def deploy_honeypot(
        self,
        template: str,
        ip_address: str,
        hostname: Optional[str] = None,
        custom_config: Optional[Dict] = None
    ) -> DecoyAsset:
        """Deploy a honeypot from template"""
        if template not in self.honeypot_templates:
            raise ValueError(f"Unknown honeypot template: {template}")
        
        tmpl = self.honeypot_templates[template]
        decoy_id = hashlib.sha256(
            f"{ip_address}{template}{datetime.now().isoformat()}".encode()
        ).hexdigest()[:16]
        
        config = tmpl.copy()
        if custom_config:
            config.update(custom_config)
        
        decoy = DecoyAsset(
            id=decoy_id,
            name=f"{tmpl['name']} - {ip_address}",
            type=tmpl["type"],
            status=DecoyStatus.ACTIVE,
            interaction_level=tmpl["interaction"],
            ip_address=ip_address,
            hostname=hostname or f"decoy-{decoy_id[:8]}",
            services=tmpl["services"],
            configuration=config
        )
        
        self.decoys[decoy_id] = decoy
        
        # Start listener for this honeypot
        await self._start_honeypot_listener(decoy)
        
        self.logger.info(f"Deployed honeypot: {decoy.name} at {ip_address}")
        return decoy
    
    async def _start_honeypot_listener(self, decoy: DecoyAsset):
        """Start listener thread for honeypot"""
        # Simulated listener - in production would bind to actual ports
        pass
    
    def generate_honeytoken(
        self,
        template: str,
        name: str,
        metadata: Optional[Dict] = None
    ) -> HoneyToken:
        """Generate a honeytoken from template"""
        if template not in self.honeytoken_templates:
            raise ValueError(f"Unknown honeytoken template: {template}")
        
        tmpl = self.honeytoken_templates[template]
        
        # Generate token value based on template
        if template == "aws_credential":
            value = self._generate_fake_aws_key()
        elif template == "api_key":
            value = self._generate_fake_api_key()
        elif template == "database_cred":
            value = self._generate_fake_db_cred()
        elif template == "jwt_token":
            value = self._generate_fake_jwt()
        else:
            value = self._generate_random_token()
        
        token_id = hashlib.sha256(
            f"{name}{value}{datetime.now().isoformat()}".encode()
        ).hexdigest()[:16]
        
        token = HoneyToken(
            id=token_id,
            name=name,
            token_type=tmpl["type"],
            value=value,
            hash_value=hashlib.sha256(value.encode()).hexdigest(),
            metadata=metadata or {}
        )
        
        self.honeytokens[token_id] = token
        self.logger.info(f"Generated honeytoken: {name} ({template})")
        return token
    
    def _generate_fake_aws_key(self) -> str:
        """Generate fake AWS access key"""
        chars = string.ascii_uppercase + string.digits
        key_id = 'AKIA' + ''.join(random.choices(chars, k=16))
        return key_id
    
    def _generate_fake_api_key(self) -> str:
        """Generate fake API key"""
        prefix = random.choice(['sk', 'pk', 'api', 'key'])
        suffix = ''.join(random.choices(string.hexdigits.lower(), k=32))
        return f"{prefix}_{suffix}"
    
    def _generate_fake_db_cred(self) -> str:
        """Generate fake database credential"""
        username = f"db_admin_{random.randint(1000, 9999)}"
        password = ''.join(random.choices(
            string.ascii_letters + string.digits + "!@#$%", k=16
        ))
        return f"{username}:{password}"
    
    def _generate_fake_jwt(self) -> str:
        """Generate fake JWT token"""
        import base64
        header = base64.b64encode(b'{"alg":"HS256","typ":"JWT"}').decode().rstrip('=')
        payload = base64.b64encode(b'{"sub":"decoy","iat":1234567890}').decode().rstrip('=')
        signature = ''.join(random.choices(string.ascii_letters + string.digits, k=43))
        return f"{header}.{payload}.{signature}"
    
    def _generate_random_token(self) -> str:
        """Generate random token"""
        return ''.join(random.choices(string.hexdigits.lower(), k=64))
    
    async def plant_breadcrumbs(
        self,
        target_systems: List[str],
        breadcrumb_type: str,
        content: Optional[str] = None
    ) -> List[Dict[str, Any]]:
        """Plant breadcrumbs on target systems to attract attackers"""
        if breadcrumb_type not in self.breadcrumb_templates:
            raise ValueError(f"Unknown breadcrumb type: {breadcrumb_type}")
        
        tmpl = self.breadcrumb_templates[breadcrumb_type]
        planted = []
        
        for system in target_systems:
            for filename in tmpl["filenames"]:
                # Generate decoy content if not provided
                decoy_content = content or self._generate_breadcrumb_content(
                    breadcrumb_type, filename
                )
                
                breadcrumb_id = hashlib.sha256(
                    f"{system}{filename}{datetime.now().isoformat()}".encode()
                ).hexdigest()[:16]
                
                planted.append({
                    "id": breadcrumb_id,
                    "system": system,
                    "filename": filename,
                    "content_hash": hashlib.sha256(decoy_content.encode()).hexdigest(),
                    "type": breadcrumb_type
                })
        
        return planted
    
    def _generate_breadcrumb_content(self, btype: str, filename: str) -> str:
        """Generate realistic breadcrumb content"""
        if btype == "config_file":
            if filename.endswith(".env"):
                return f"""
# Production Environment Variables
DATABASE_URL=postgresql://admin:SuperSecret123!@db.internal.corp:5432/production
AWS_ACCESS_KEY_ID={self._generate_fake_aws_key()}
AWS_SECRET_ACCESS_KEY={''.join(random.choices(string.ascii_letters + string.digits, k=40))}
REDIS_URL=redis://redis.internal.corp:6379
API_SECRET_KEY={''.join(random.choices(string.hexdigits.lower(), k=64))}
"""
            elif filename.endswith(".json"):
                return json.dumps({
                    "database": {
                        "host": "db.internal.corp",
                        "port": 5432,
                        "username": "admin",
                        "password": "SuperSecret123!"
                    },
                    "api": {
                        "key": self._generate_fake_api_key()
                    }
                }, indent=2)
        elif btype == "password_file":
            creds = []
            for i in range(random.randint(5, 15)):
                creds.append(f"admin{i}:{''.join(random.choices(string.ascii_letters + string.digits, k=12))}")
            return '\n'.join(creds)
        
        return "# Decoy content"
    
    async def process_interaction(
        self,
        decoy_id: str,
        source_ip: str,
        source_port: int,
        activity_type: str,
        details: Dict[str, Any]
    ) -> DeceptionAlert:
        """Process an interaction with a deception asset"""
        if decoy_id not in self.decoys:
            raise ValueError(f"Unknown decoy: {decoy_id}")
        
        decoy = self.decoys[decoy_id]
        decoy.trigger_count += 1
        decoy.last_activity = datetime.now()
        
        if decoy.status == DecoyStatus.ACTIVE:
            decoy.status = DecoyStatus.TRIGGERED
        
        # Determine severity based on activity type
        severity = self._calculate_severity(activity_type, details)
        
        # Create alert
        alert_id = hashlib.sha256(
            f"{decoy_id}{source_ip}{datetime.now().isoformat()}".encode()
        ).hexdigest()[:16]
        
        alert = DeceptionAlert(
            id=alert_id,
            timestamp=datetime.now(),
            severity=severity,
            decoy_id=decoy_id,
            decoy_name=decoy.name,
            decoy_type=decoy.type,
            source_ip=source_ip,
            source_port=source_port,
            activity_type=activity_type,
            details=details
        )
        
        self.alerts.append(alert)
        
        # Update attacker profile
        await self._update_attacker_profile(source_ip, alert)
        
        # Trigger callbacks
        for callback in self.callbacks.get("trigger", []):
            try:
                callback(alert)
            except Exception as e:
                self.logger.error(f"Callback error: {e}")
        
        return alert
    
    def _calculate_severity(self, activity_type: str, details: Dict) -> AlertSeverity:
        """Calculate alert severity based on activity"""
        high_severity_activities = [
            "credential_theft", "lateral_movement", "data_exfiltration",
            "privilege_escalation", "command_execution"
        ]
        medium_severity_activities = [
            "authentication_attempt", "file_access", "enumeration"
        ]
        
        if activity_type in high_severity_activities:
            return AlertSeverity.CRITICAL
        elif activity_type in medium_severity_activities:
            return AlertSeverity.HIGH
        elif "scan" in activity_type:
            return AlertSeverity.MEDIUM
        else:
            return AlertSeverity.LOW
    
    async def _update_attacker_profile(self, source_ip: str, alert: DeceptionAlert):
        """Update attacker profile based on new activity"""
        # Find or create profile
        profile = None
        for p in self.attacker_profiles.values():
            if source_ip in p.source_ips:
                profile = p
                break
        
        if not profile:
            profile_id = hashlib.sha256(
                f"{source_ip}{datetime.now().isoformat()}".encode()
            ).hexdigest()[:16]
            profile = AttackerProfile(
                id=profile_id,
                first_seen=datetime.now(),
                last_seen=datetime.now(),
                source_ips={source_ip}
            )
            self.attacker_profiles[profile_id] = profile
        
        # Update profile
        profile.last_seen = datetime.now()
        profile.source_ips.add(source_ip)
        profile.triggered_decoys.append(alert.decoy_id)
        
        # Map to MITRE ATT&CK
        ttps = self._map_to_mitre(alert.activity_type, alert.details)
        profile.ttps.update(ttps)
        
        # Calculate threat score
        profile.threat_score = self._calculate_threat_score(profile)
    
    def _map_to_mitre(self, activity_type: str, details: Dict) -> Dict[str, Any]:
        """Map observed activity to MITRE ATT&CK techniques"""
        mitre_mapping = {
            "port_scan": {"tactic": "Reconnaissance", "technique": "T1046"},
            "credential_attempt": {"tactic": "Credential Access", "technique": "T1110"},
            "file_access": {"tactic": "Collection", "technique": "T1005"},
            "lateral_movement": {"tactic": "Lateral Movement", "technique": "T1021"},
            "data_exfiltration": {"tactic": "Exfiltration", "technique": "T1041"},
            "command_execution": {"tactic": "Execution", "technique": "T1059"}
        }
        return mitre_mapping.get(activity_type, {})
    
    def _calculate_threat_score(self, profile: AttackerProfile) -> float:
        """Calculate threat score for attacker profile"""
        score = 0.0
        
        # Base score from number of interactions
        score += min(len(profile.triggered_decoys) * 10, 50)
        
        # Score from techniques observed
        high_risk_techniques = ["T1110", "T1021", "T1041", "T1059"]
        for ttp in profile.ttps.values():
            if isinstance(ttp, dict) and ttp.get("technique") in high_risk_techniques:
                score += 20
        
        # Score from recency
        hours_since_last = (datetime.now() - profile.last_seen).total_seconds() / 3600
        if hours_since_last < 1:
            score += 30
        elif hours_since_last < 24:
            score += 15
        
        return min(score, 100)
    
    async def create_campaign(
        self,
        name: str,
        description: str,
        decoy_ids: List[str],
        honeytoken_ids: List[str],
        objectives: List[str]
    ) -> DeceptionCampaign:
        """Create a coordinated deception campaign"""
        campaign_id = hashlib.sha256(
            f"{name}{datetime.now().isoformat()}".encode()
        ).hexdigest()[:16]
        
        campaign = DeceptionCampaign(
            id=campaign_id,
            name=name,
            description=description,
            decoys=decoy_ids,
            honeytokens=honeytoken_ids,
            objectives=objectives,
            metrics={
                "total_triggers": 0,
                "unique_attackers": 0,
                "techniques_detected": []
            }
        )
        
        self.campaigns[campaign_id] = campaign
        return campaign
    
    def get_campaign_metrics(self, campaign_id: str) -> Dict[str, Any]:
        """Get metrics for a deception campaign"""
        if campaign_id not in self.campaigns:
            raise ValueError(f"Unknown campaign: {campaign_id}")
        
        campaign = self.campaigns[campaign_id]
        
        # Calculate metrics
        total_triggers = 0
        unique_ips = set()
        techniques = set()
        
        for alert in self.alerts:
            if alert.decoy_id in campaign.decoys:
                total_triggers += 1
                unique_ips.add(alert.source_ip)
        
        for token_id in campaign.honeytokens:
            if token_id in self.honeytokens:
                token = self.honeytokens[token_id]
                total_triggers += token.trigger_count
        
        # Get techniques from attacker profiles
        for profile in self.attacker_profiles.values():
            for decoy_id in campaign.decoys:
                if decoy_id in profile.triggered_decoys:
                    techniques.update(profile.ttps.keys())
        
        return {
            "campaign_id": campaign_id,
            "name": campaign.name,
            "active": campaign.active,
            "duration_days": (datetime.now() - campaign.start_date).days,
            "total_triggers": total_triggers,
            "unique_attackers": len(unique_ips),
            "techniques_detected": list(techniques),
            "decoy_status": {
                did: self.decoys[did].status.value
                for did in campaign.decoys if did in self.decoys
            }
        }
    
    def register_callback(self, event_type: str, callback: Callable):
        """Register callback for deception events"""
        if event_type in self.callbacks:
            self.callbacks[event_type].append(callback)
    
    async def generate_report(self, time_range: timedelta = None) -> Dict[str, Any]:
        """Generate deception technology report"""
        if time_range:
            cutoff = datetime.now() - time_range
            alerts = [a for a in self.alerts if a.timestamp >= cutoff]
        else:
            alerts = self.alerts
        
        # Aggregate statistics
        alerts_by_severity = {}
        alerts_by_type = {}
        alerts_by_decoy = {}
        
        for alert in alerts:
            sev = alert.severity.value
            alerts_by_severity[sev] = alerts_by_severity.get(sev, 0) + 1
            
            atype = alert.activity_type
            alerts_by_type[atype] = alerts_by_type.get(atype, 0) + 1
            
            decoy = alert.decoy_name
            alerts_by_decoy[decoy] = alerts_by_decoy.get(decoy, 0) + 1
        
        # Top attackers
        attacker_scores = sorted(
            [(p.id, p.threat_score, len(p.source_ips))
             for p in self.attacker_profiles.values()],
            key=lambda x: x[1],
            reverse=True
        )[:10]
        
        return {
            "generated_at": datetime.now().isoformat(),
            "summary": {
                "total_decoys": len(self.decoys),
                "active_decoys": sum(1 for d in self.decoys.values() if d.status == DecoyStatus.ACTIVE),
                "triggered_decoys": sum(1 for d in self.decoys.values() if d.status == DecoyStatus.TRIGGERED),
                "total_honeytokens": len(self.honeytokens),
                "triggered_honeytokens": sum(1 for t in self.honeytokens.values() if t.triggered),
                "total_alerts": len(alerts),
                "unique_attackers": len(self.attacker_profiles),
                "active_campaigns": sum(1 for c in self.campaigns.values() if c.active)
            },
            "alerts_by_severity": alerts_by_severity,
            "alerts_by_type": alerts_by_type,
            "alerts_by_decoy": alerts_by_decoy,
            "top_attackers": attacker_scores,
            "active_campaigns": [
                {"id": c.id, "name": c.name, "decoys": len(c.decoys)}
                for c in self.campaigns.values() if c.active
            ]
        }
    
    async def export_iocs(self) -> List[Dict[str, Any]]:
        """Export indicators of compromise from deception interactions"""
        iocs = []
        
        for profile in self.attacker_profiles.values():
            for ip in profile.source_ips:
                iocs.append({
                    "type": "ip",
                    "value": ip,
                    "threat_score": profile.threat_score,
                    "first_seen": profile.first_seen.isoformat(),
                    "last_seen": profile.last_seen.isoformat(),
                    "techniques": list(profile.ttps.keys())
                })
        
        return iocs
