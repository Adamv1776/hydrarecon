"""
HydraRecon Advanced Malware Analysis Sandbox Module
Dynamic malware analysis, behavioral analysis, and threat detection
"""

import asyncio
import hashlib
import json
import logging
import os
import re
import shutil
import struct
import subprocess
import tempfile
import time
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Any, Callable, Dict, List, Optional, Set, Tuple, Union

logger = logging.getLogger(__name__)


class MalwareType(Enum):
    """Malware classification"""
    UNKNOWN = "unknown"
    TROJAN = "trojan"
    RANSOMWARE = "ransomware"
    WORM = "worm"
    VIRUS = "virus"
    BACKDOOR = "backdoor"
    ROOTKIT = "rootkit"
    SPYWARE = "spyware"
    ADWARE = "adware"
    CRYPTOMINER = "cryptominer"
    BOT = "bot"
    RAT = "rat"
    DROPPER = "dropper"
    DOWNLOADER = "downloader"
    KEYLOGGER = "keylogger"
    BANKER = "banker"
    STEALER = "stealer"


class ThreatLevel(Enum):
    """Threat severity level"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    BENIGN = "benign"


class BehaviorCategory(Enum):
    """Behavioral categories"""
    FILE_SYSTEM = "file_system"
    REGISTRY = "registry"
    NETWORK = "network"
    PROCESS = "process"
    PERSISTENCE = "persistence"
    EVASION = "evasion"
    CREDENTIAL_ACCESS = "credential_access"
    DISCOVERY = "discovery"
    COLLECTION = "collection"
    EXFILTRATION = "exfiltration"
    IMPACT = "impact"


@dataclass
class SampleInfo:
    """Malware sample information"""
    sample_id: str
    filename: str
    file_size: int
    md5: str
    sha1: str
    sha256: str
    ssdeep: str = ""
    imphash: str = ""
    file_type: str = ""
    mime_type: str = ""
    architecture: str = ""
    compiler: str = ""
    packer: str = ""
    is_signed: bool = False
    first_seen: datetime = field(default_factory=datetime.now)


@dataclass
class NetworkIndicator:
    """Network-based indicator"""
    indicator_type: str  # ip, domain, url
    value: str
    port: int = 0
    protocol: str = ""
    country: str = ""
    asn: str = ""
    is_c2: bool = False
    is_malicious: bool = False


@dataclass
class FileIndicator:
    """File-based indicator"""
    operation: str  # create, modify, delete, read
    path: str
    hash_value: str = ""
    is_executable: bool = False
    is_suspicious: bool = False


@dataclass
class ProcessIndicator:
    """Process-based indicator"""
    pid: int
    name: str
    command_line: str = ""
    parent_pid: int = 0
    parent_name: str = ""
    is_injected: bool = False
    injected_into: List[int] = field(default_factory=list)


@dataclass
class BehaviorIndicator:
    """Behavioral indicator"""
    behavior_id: str
    category: BehaviorCategory
    description: str
    severity: ThreatLevel
    technique_id: str = ""  # MITRE ATT&CK
    evidence: Dict[str, Any] = field(default_factory=dict)
    timestamp: datetime = field(default_factory=datetime.now)


@dataclass
class AnalysisResult:
    """Complete analysis result"""
    sample: SampleInfo
    threat_level: ThreatLevel = ThreatLevel.BENIGN
    malware_type: MalwareType = MalwareType.UNKNOWN
    malware_family: str = ""
    behaviors: List[BehaviorIndicator] = field(default_factory=list)
    network_iocs: List[NetworkIndicator] = field(default_factory=list)
    file_iocs: List[FileIndicator] = field(default_factory=list)
    process_iocs: List[ProcessIndicator] = field(default_factory=list)
    yara_matches: List[str] = field(default_factory=list)
    signatures_matched: List[str] = field(default_factory=list)
    mitre_techniques: List[str] = field(default_factory=list)
    analysis_duration: float = 0.0


class PEAnalyzer:
    """Windows PE file analyzer"""
    
    def __init__(self):
        self.suspicious_imports = {
            'VirtualAlloc': 'Memory allocation for code injection',
            'VirtualAllocEx': 'Remote memory allocation',
            'WriteProcessMemory': 'Process injection',
            'CreateRemoteThread': 'Remote thread injection',
            'NtUnmapViewOfSection': 'Process hollowing',
            'SetWindowsHookEx': 'Keylogging/DLL injection',
            'GetAsyncKeyState': 'Keylogging',
            'GetKeyState': 'Keylogging',
            'InternetOpen': 'Network communication',
            'URLDownloadToFile': 'Downloading files',
            'WinExec': 'Command execution',
            'ShellExecute': 'Command execution',
            'CreateProcess': 'Process creation',
            'OpenProcess': 'Process manipulation',
            'RegSetValue': 'Registry modification',
            'CryptEncrypt': 'Encryption (ransomware indicator)',
            'GetSystemDefaultLangID': 'Geographic targeting',
            'IsDebuggerPresent': 'Anti-debugging',
            'CheckRemoteDebuggerPresent': 'Anti-debugging',
            'NtQueryInformationProcess': 'Anti-analysis',
        }
        
        self.suspicious_sections = {
            '.ndata': 'NSIS installer',
            'UPX': 'UPX packed',
            '.aspack': 'ASPack packed',
            '.adata': 'Armadillo packed',
            '.themida': 'Themida packed',
            '.vmp': 'VMProtect packed',
        }
        
    def analyze(self, file_path: str) -> Dict[str, Any]:
        """Analyze PE file"""
        result = {
            'is_pe': False,
            'architecture': 'unknown',
            'subsystem': 'unknown',
            'timestamp': None,
            'imphash': '',
            'imports': [],
            'exports': [],
            'sections': [],
            'resources': [],
            'suspicious_imports': [],
            'packer': None,
            'is_signed': False,
            'signature_valid': False
        }
        
        try:
            with open(file_path, 'rb') as f:
                data = f.read()
                
            # Check MZ header
            if not data.startswith(b'MZ'):
                return result
                
            result['is_pe'] = True
            
            # Get PE header offset
            pe_offset = struct.unpack('<I', data[0x3C:0x40])[0]
            
            if data[pe_offset:pe_offset+4] != b'PE\x00\x00':
                return result
                
            # Parse COFF header
            machine = struct.unpack('<H', data[pe_offset+4:pe_offset+6])[0]
            
            if machine == 0x14c:
                result['architecture'] = 'x86'
            elif machine == 0x8664:
                result['architecture'] = 'x64'
            elif machine == 0x1c0:
                result['architecture'] = 'ARM'
                
            # Timestamp
            timestamp = struct.unpack('<I', data[pe_offset+8:pe_offset+12])[0]
            result['timestamp'] = datetime.fromtimestamp(timestamp).isoformat()
            
            # Parse sections
            num_sections = struct.unpack('<H', data[pe_offset+6:pe_offset+8])[0]
            optional_header_size = struct.unpack('<H', data[pe_offset+20:pe_offset+22])[0]
            section_offset = pe_offset + 24 + optional_header_size
            
            for i in range(num_sections):
                section_data = data[section_offset + i*40:section_offset + (i+1)*40]
                name = section_data[:8].rstrip(b'\x00').decode('ascii', errors='ignore')
                
                virtual_size = struct.unpack('<I', section_data[8:12])[0]
                raw_size = struct.unpack('<I', section_data[16:20])[0]
                characteristics = struct.unpack('<I', section_data[36:40])[0]
                
                section_info = {
                    'name': name,
                    'virtual_size': virtual_size,
                    'raw_size': raw_size,
                    'executable': bool(characteristics & 0x20000000),
                    'writable': bool(characteristics & 0x80000000)
                }
                
                result['sections'].append(section_info)
                
                # Check for suspicious sections
                for sus_section, description in self.suspicious_sections.items():
                    if sus_section.lower() in name.lower():
                        result['packer'] = description
                        
            # Calculate entropy for packed detection
            entropy = self._calculate_entropy(data)
            if entropy > 7.0:
                if not result['packer']:
                    result['packer'] = 'Unknown (high entropy)'
                    
            # Extract strings for analysis
            strings = self._extract_strings(data)
            
            # Check for suspicious strings
            for s in strings:
                for import_name, description in self.suspicious_imports.items():
                    if import_name.lower() in s.lower():
                        result['suspicious_imports'].append({
                            'name': import_name,
                            'description': description
                        })
                        
        except Exception as e:
            logger.error(f"PE analysis error: {e}")
            
        return result
        
    def _calculate_entropy(self, data: bytes) -> float:
        """Calculate Shannon entropy"""
        import math
        
        if not data:
            return 0.0
            
        freq = {}
        for byte in data:
            freq[byte] = freq.get(byte, 0) + 1
            
        entropy = 0.0
        length = len(data)
        
        for count in freq.values():
            prob = count / length
            entropy -= prob * math.log2(prob)
            
        return entropy
        
    def _extract_strings(self, data: bytes, min_length: int = 4) -> List[str]:
        """Extract ASCII and Unicode strings"""
        strings = []
        
        # ASCII strings
        ascii_pattern = rb'[\x20-\x7e]{' + str(min_length).encode() + rb',}'
        strings.extend(match.decode('ascii') for match in re.findall(ascii_pattern, data))
        
        # Unicode strings
        unicode_pattern = rb'(?:[\x20-\x7e]\x00){' + str(min_length).encode() + rb',}'
        for match in re.findall(unicode_pattern, data):
            try:
                strings.append(match.decode('utf-16-le'))
            except Exception:
                pass
                
        return strings


class ELFAnalyzer:
    """Linux ELF file analyzer"""
    
    def __init__(self):
        self.suspicious_symbols = [
            'ptrace', 'fork', 'execve', 'system', 'popen',
            'socket', 'connect', 'bind', 'listen', 'accept',
            'unlink', 'chmod', 'chown', 'setuid', 'setgid',
            'mprotect', 'mmap', 'dlopen', 'dlsym'
        ]
        
    def analyze(self, file_path: str) -> Dict[str, Any]:
        """Analyze ELF file"""
        result = {
            'is_elf': False,
            'architecture': 'unknown',
            'type': 'unknown',
            'interpreter': '',
            'libraries': [],
            'symbols': [],
            'suspicious_symbols': [],
            'is_stripped': True,
            'has_debug': False
        }
        
        try:
            with open(file_path, 'rb') as f:
                data = f.read()
                
            if not data.startswith(b'\x7fELF'):
                return result
                
            result['is_elf'] = True
            
            # ELF class (32/64 bit)
            ei_class = data[4]
            if ei_class == 1:
                result['architecture'] = 'x86'
            elif ei_class == 2:
                result['architecture'] = 'x86_64'
                
            # Machine type
            e_machine = struct.unpack('<H', data[18:20])[0]
            machine_map = {
                0x03: 'x86',
                0x3E: 'x86_64',
                0x28: 'ARM',
                0xB7: 'ARM64',
                0x08: 'MIPS'
            }
            result['architecture'] = machine_map.get(e_machine, result['architecture'])
            
            # File type
            e_type = struct.unpack('<H', data[16:18])[0]
            type_map = {
                1: 'relocatable',
                2: 'executable',
                3: 'shared_object',
                4: 'core'
            }
            result['type'] = type_map.get(e_type, 'unknown')
            
            # Extract strings for symbol analysis
            strings = self._extract_strings(data)
            
            for s in strings:
                for sym in self.suspicious_symbols:
                    if sym in s:
                        result['suspicious_symbols'].append(sym)
                        
            result['suspicious_symbols'] = list(set(result['suspicious_symbols']))
            
        except Exception as e:
            logger.error(f"ELF analysis error: {e}")
            
        return result
        
    def _extract_strings(self, data: bytes, min_length: int = 4) -> List[str]:
        """Extract strings from binary"""
        strings = []
        pattern = rb'[\x20-\x7e]{' + str(min_length).encode() + rb',}'
        
        for match in re.findall(pattern, data):
            strings.append(match.decode('ascii', errors='ignore'))
            
        return strings


class YaraEngine:
    """YARA rule matching engine"""
    
    def __init__(self):
        self.rules = self._load_rules()
        
    def _load_rules(self) -> List[Dict]:
        """Load YARA rules"""
        return [
            {
                'name': 'Suspicious_PowerShell',
                'patterns': [
                    b'powershell', b'-ExecutionPolicy', b'-EncodedCommand',
                    b'Invoke-Expression', b'IEX', b'DownloadString'
                ],
                'description': 'Suspicious PowerShell usage',
                'severity': 'high'
            },
            {
                'name': 'Base64_Executable',
                'patterns': [b'TVqQAAMA', b'TVpQAAIA'],  # Base64 MZ header
                'description': 'Base64 encoded executable',
                'severity': 'high'
            },
            {
                'name': 'Crypto_Ransom_Strings',
                'patterns': [
                    b'Your files have been encrypted',
                    b'bitcoin', b'ransom', b'decrypt',
                    b'.onion', b'tor2web'
                ],
                'description': 'Ransomware indicators',
                'severity': 'critical'
            },
            {
                'name': 'Keylogger_Indicators',
                'patterns': [
                    b'GetAsyncKeyState', b'GetKeyState',
                    b'SetWindowsHookEx', b'keylog'
                ],
                'description': 'Keylogger indicators',
                'severity': 'high'
            },
            {
                'name': 'Anti_Analysis',
                'patterns': [
                    b'IsDebuggerPresent', b'CheckRemoteDebuggerPresent',
                    b'vmware', b'virtualbox', b'sandbox',
                    b'SbieDll', b'dbghelp'
                ],
                'description': 'Anti-analysis techniques',
                'severity': 'medium'
            },
            {
                'name': 'Process_Injection',
                'patterns': [
                    b'VirtualAllocEx', b'WriteProcessMemory',
                    b'CreateRemoteThread', b'NtUnmapViewOfSection'
                ],
                'description': 'Process injection techniques',
                'severity': 'high'
            },
            {
                'name': 'Persistence_Registry',
                'patterns': [
                    b'CurrentVersion\\Run', b'CurrentVersion\\RunOnce',
                    b'Winlogon\\Shell', b'Winlogon\\Userinit'
                ],
                'description': 'Registry persistence',
                'severity': 'medium'
            },
            {
                'name': 'Network_C2',
                'patterns': [
                    b'InternetOpen', b'InternetConnect',
                    b'HttpSendRequest', b'socket', b'WSAStartup'
                ],
                'description': 'Network communication',
                'severity': 'low'
            },
            {
                'name': 'Cryptocurrency_Miner',
                'patterns': [
                    b'stratum+tcp', b'xmrig', b'monero',
                    b'cryptonight', b'coinhive'
                ],
                'description': 'Cryptocurrency miner',
                'severity': 'medium'
            }
        ]
        
    def scan(self, data: bytes) -> List[Dict]:
        """Scan data with YARA rules"""
        matches = []
        
        for rule in self.rules:
            matched_patterns = []
            
            for pattern in rule['patterns']:
                if pattern.lower() in data.lower():
                    matched_patterns.append(pattern.decode('utf-8', errors='ignore'))
                    
            if matched_patterns:
                matches.append({
                    'rule': rule['name'],
                    'description': rule['description'],
                    'severity': rule['severity'],
                    'matched_patterns': matched_patterns
                })
                
        return matches


class BehaviorAnalyzer:
    """Analyze malware behavior"""
    
    def __init__(self):
        self.behavior_signatures = self._load_signatures()
        
    def _load_signatures(self) -> Dict[str, Dict]:
        """Load behavior signatures"""
        return {
            'file_encryption': {
                'indicators': ['CryptEncrypt', 'BCryptEncrypt', '.encrypted', '.locked'],
                'category': BehaviorCategory.IMPACT,
                'technique': 'T1486',
                'description': 'File encryption (ransomware behavior)',
                'severity': ThreatLevel.CRITICAL
            },
            'credential_dump': {
                'indicators': ['lsass.exe', 'SAM', 'SECURITY', 'mimikatz'],
                'category': BehaviorCategory.CREDENTIAL_ACCESS,
                'technique': 'T1003',
                'description': 'Credential dumping',
                'severity': ThreatLevel.HIGH
            },
            'process_injection': {
                'indicators': ['WriteProcessMemory', 'CreateRemoteThread', 'NtQueueApcThread'],
                'category': BehaviorCategory.EVASION,
                'technique': 'T1055',
                'description': 'Process injection',
                'severity': ThreatLevel.HIGH
            },
            'persistence_run_key': {
                'indicators': ['CurrentVersion\\Run', 'CurrentVersion\\RunOnce'],
                'category': BehaviorCategory.PERSISTENCE,
                'technique': 'T1547.001',
                'description': 'Registry Run key persistence',
                'severity': ThreatLevel.MEDIUM
            },
            'persistence_service': {
                'indicators': ['CreateService', 'services.exe', 'ControlService'],
                'category': BehaviorCategory.PERSISTENCE,
                'technique': 'T1543.003',
                'description': 'Service creation for persistence',
                'severity': ThreatLevel.MEDIUM
            },
            'defense_evasion': {
                'indicators': ['IsDebuggerPresent', 'CheckRemoteDebuggerPresent', 'RDTSC'],
                'category': BehaviorCategory.EVASION,
                'technique': 'T1622',
                'description': 'Debugger evasion',
                'severity': ThreatLevel.LOW
            },
            'data_exfiltration': {
                'indicators': ['ftp://', 'http://', 'POST', 'upload'],
                'category': BehaviorCategory.EXFILTRATION,
                'technique': 'T1041',
                'description': 'Data exfiltration over network',
                'severity': ThreatLevel.HIGH
            },
            'keylogging': {
                'indicators': ['GetAsyncKeyState', 'SetWindowsHookEx', 'GetKeyboardState'],
                'category': BehaviorCategory.COLLECTION,
                'technique': 'T1056.001',
                'description': 'Keylogging',
                'severity': ThreatLevel.HIGH
            },
            'screen_capture': {
                'indicators': ['GetDC', 'BitBlt', 'CreateCompatibleBitmap', 'screenshot'],
                'category': BehaviorCategory.COLLECTION,
                'technique': 'T1113',
                'description': 'Screen capture',
                'severity': ThreatLevel.MEDIUM
            }
        }
        
    def analyze(self, data: bytes, strings: List[str]) -> List[BehaviorIndicator]:
        """Analyze for behavioral indicators"""
        behaviors = []
        
        # Combine data and strings for searching
        search_text = data.decode('utf-8', errors='ignore') + ' '.join(strings)
        
        for sig_name, sig_info in self.behavior_signatures.items():
            matched = []
            
            for indicator in sig_info['indicators']:
                if indicator.lower() in search_text.lower():
                    matched.append(indicator)
                    
            if matched:
                behaviors.append(BehaviorIndicator(
                    behavior_id=sig_name,
                    category=sig_info['category'],
                    description=sig_info['description'],
                    severity=sig_info['severity'],
                    technique_id=sig_info['technique'],
                    evidence={'matched_indicators': matched}
                ))
                
        return behaviors


class NetworkAnalyzer:
    """Extract network indicators"""
    
    def __init__(self):
        self.ip_pattern = re.compile(
            r'\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}'
            r'(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b'
        )
        self.domain_pattern = re.compile(
            r'\b(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}\b'
        )
        self.url_pattern = re.compile(
            r'https?://[^\s<>"{}|\\^`\[\]]+',
            re.IGNORECASE
        )
        
        # Known malicious TLDs
        self.suspicious_tlds = {'.tk', '.ml', '.ga', '.cf', '.gq', '.top', '.xyz', '.work'}
        
        # Private IP ranges
        self.private_ranges = [
            (0x0A000000, 0x0AFFFFFF),  # 10.0.0.0/8
            (0xAC100000, 0xAC1FFFFF),  # 172.16.0.0/12
            (0xC0A80000, 0xC0A8FFFF),  # 192.168.0.0/16
        ]
        
    def extract_indicators(self, data: bytes) -> Dict[str, List]:
        """Extract network indicators from data"""
        text = data.decode('utf-8', errors='ignore')
        
        indicators = {
            'ips': [],
            'domains': [],
            'urls': []
        }
        
        # Extract IPs
        for ip in self.ip_pattern.findall(text):
            if not self._is_private_ip(ip):
                indicators['ips'].append(ip)
                
        # Extract domains
        for domain in self.domain_pattern.findall(text):
            # Filter out common false positives
            if not domain.endswith(('.dll', '.exe', '.sys', '.inf')):
                indicators['domains'].append(domain)
                
        # Extract URLs
        for url in self.url_pattern.findall(text):
            indicators['urls'].append(url)
            
        # Deduplicate
        indicators['ips'] = list(set(indicators['ips']))
        indicators['domains'] = list(set(indicators['domains']))
        indicators['urls'] = list(set(indicators['urls']))
        
        return indicators
        
    def _is_private_ip(self, ip: str) -> bool:
        """Check if IP is private"""
        try:
            parts = [int(p) for p in ip.split('.')]
            ip_int = (parts[0] << 24) + (parts[1] << 16) + (parts[2] << 8) + parts[3]
            
            for start, end in self.private_ranges:
                if start <= ip_int <= end:
                    return True
                    
            # Loopback
            if parts[0] == 127:
                return True
                
        except Exception:
            pass
            
        return False
        
    def is_suspicious_domain(self, domain: str) -> bool:
        """Check if domain is suspicious"""
        # Check TLD
        for tld in self.suspicious_tlds:
            if domain.endswith(tld):
                return True
                
        # Check for random-looking domains
        if self._has_high_entropy(domain.split('.')[0]):
            return True
            
        return False
        
    def _has_high_entropy(self, s: str) -> bool:
        """Check for high entropy string"""
        import math
        
        if len(s) < 8:
            return False
            
        freq = {}
        for c in s:
            freq[c] = freq.get(c, 0) + 1
            
        entropy = 0.0
        for count in freq.values():
            prob = count / len(s)
            entropy -= prob * math.log2(prob)
            
        return entropy > 3.5


class MalwareSandbox:
    """Malware analysis sandbox"""
    
    def __init__(self):
        self.pe_analyzer = PEAnalyzer()
        self.elf_analyzer = ELFAnalyzer()
        self.yara_engine = YaraEngine()
        self.behavior_analyzer = BehaviorAnalyzer()
        self.network_analyzer = NetworkAnalyzer()
        
    async def analyze(self, sample_path: str, timeout: int = 120) -> AnalysisResult:
        """Analyze malware sample"""
        start_time = time.time()
        
        # Read sample
        with open(sample_path, 'rb') as f:
            data = f.read()
            
        # Calculate hashes
        md5 = hashlib.md5(data).hexdigest()
        sha1 = hashlib.sha1(data).hexdigest()
        sha256 = hashlib.sha256(data).hexdigest()
        
        sample = SampleInfo(
            sample_id=sha256[:12],
            filename=os.path.basename(sample_path),
            file_size=len(data),
            md5=md5,
            sha1=sha1,
            sha256=sha256
        )
        
        result = AnalysisResult(sample=sample)
        
        # Detect file type
        if data.startswith(b'MZ'):
            sample.file_type = 'PE'
            pe_info = self.pe_analyzer.analyze(sample_path)
            sample.architecture = pe_info.get('architecture', 'unknown')
            sample.packer = pe_info.get('packer', '')
            
            # Add suspicious imports as findings
            for imp in pe_info.get('suspicious_imports', []):
                result.behaviors.append(BehaviorIndicator(
                    behavior_id=f"import_{imp['name']}",
                    category=BehaviorCategory.DISCOVERY,
                    description=imp['description'],
                    severity=ThreatLevel.MEDIUM,
                    evidence={'import': imp['name']}
                ))
                
        elif data.startswith(b'\x7fELF'):
            sample.file_type = 'ELF'
            elf_info = self.elf_analyzer.analyze(sample_path)
            sample.architecture = elf_info.get('architecture', 'unknown')
            
        # YARA scanning
        yara_matches = self.yara_engine.scan(data)
        for match in yara_matches:
            result.yara_matches.append(match['rule'])
            result.signatures_matched.append(match['description'])
            
            # Map YARA severity to threat level
            if match['severity'] == 'critical':
                result.threat_level = ThreatLevel.CRITICAL
            elif match['severity'] == 'high' and result.threat_level != ThreatLevel.CRITICAL:
                result.threat_level = ThreatLevel.HIGH
            elif match['severity'] == 'medium' and result.threat_level in [ThreatLevel.LOW, ThreatLevel.BENIGN]:
                result.threat_level = ThreatLevel.MEDIUM
                
        # Behavior analysis
        strings = self._extract_strings(data)
        behaviors = self.behavior_analyzer.analyze(data, strings)
        result.behaviors.extend(behaviors)
        
        # Update threat level based on behaviors
        for behavior in behaviors:
            if behavior.severity == ThreatLevel.CRITICAL:
                result.threat_level = ThreatLevel.CRITICAL
            elif behavior.severity == ThreatLevel.HIGH and result.threat_level != ThreatLevel.CRITICAL:
                result.threat_level = ThreatLevel.HIGH
                
        # MITRE techniques
        result.mitre_techniques = list(set(b.technique_id for b in behaviors if b.technique_id))
        
        # Network indicators
        network_iocs = self.network_analyzer.extract_indicators(data)
        
        for ip in network_iocs['ips']:
            result.network_iocs.append(NetworkIndicator(
                indicator_type='ip',
                value=ip
            ))
            
        for domain in network_iocs['domains']:
            is_malicious = self.network_analyzer.is_suspicious_domain(domain)
            result.network_iocs.append(NetworkIndicator(
                indicator_type='domain',
                value=domain,
                is_malicious=is_malicious
            ))
            
        for url in network_iocs['urls']:
            result.network_iocs.append(NetworkIndicator(
                indicator_type='url',
                value=url
            ))
            
        # Classify malware type
        result.malware_type = self._classify_malware(result)
        
        result.analysis_duration = time.time() - start_time
        
        return result
        
    def _extract_strings(self, data: bytes, min_length: int = 4) -> List[str]:
        """Extract strings from binary"""
        strings = []
        
        # ASCII
        pattern = rb'[\x20-\x7e]{' + str(min_length).encode() + rb',}'
        for match in re.findall(pattern, data):
            strings.append(match.decode('ascii', errors='ignore'))
            
        return strings
        
    def _classify_malware(self, result: AnalysisResult) -> MalwareType:
        """Classify malware type based on analysis"""
        # Check for ransomware indicators
        if 'Crypto_Ransom_Strings' in result.yara_matches:
            return MalwareType.RANSOMWARE
            
        # Check behaviors for classification
        categories = [b.category for b in result.behaviors]
        
        if BehaviorCategory.IMPACT in categories:
            for b in result.behaviors:
                if 'encrypt' in b.description.lower():
                    return MalwareType.RANSOMWARE
                    
        if BehaviorCategory.CREDENTIAL_ACCESS in categories:
            return MalwareType.STEALER
            
        if 'Keylogger_Indicators' in result.yara_matches:
            return MalwareType.KEYLOGGER
            
        if 'Cryptocurrency_Miner' in result.yara_matches:
            return MalwareType.CRYPTOMINER
            
        if result.network_iocs and any(ioc.is_c2 for ioc in result.network_iocs):
            return MalwareType.RAT
            
        if BehaviorCategory.PERSISTENCE in categories:
            return MalwareType.TROJAN
            
        return MalwareType.UNKNOWN


class AdvancedMalwareAnalysis:
    """Main integration class for malware analysis"""
    
    def __init__(self):
        self.sandbox = MalwareSandbox()
        
    async def analyze_sample(self, sample_path: str) -> Dict[str, Any]:
        """Analyze malware sample"""
        result = await self.sandbox.analyze(sample_path)
        
        return {
            'sample': {
                'id': result.sample.sample_id,
                'filename': result.sample.filename,
                'size': result.sample.file_size,
                'md5': result.sample.md5,
                'sha256': result.sample.sha256,
                'type': result.sample.file_type,
                'architecture': result.sample.architecture,
                'packer': result.sample.packer
            },
            'verdict': {
                'threat_level': result.threat_level.value,
                'malware_type': result.malware_type.value,
                'malware_family': result.malware_family
            },
            'signatures': result.signatures_matched,
            'yara_matches': result.yara_matches,
            'behaviors': [
                {
                    'id': b.behavior_id,
                    'category': b.category.value,
                    'description': b.description,
                    'severity': b.severity.value,
                    'technique': b.technique_id
                }
                for b in result.behaviors
            ],
            'network_iocs': [
                {
                    'type': ioc.indicator_type,
                    'value': ioc.value,
                    'is_malicious': ioc.is_malicious
                }
                for ioc in result.network_iocs
            ],
            'mitre_techniques': result.mitre_techniques,
            'analysis_duration': result.analysis_duration
        }
        
    def generate_report(self, analysis: Dict) -> str:
        """Generate analysis report"""
        report = []
        
        report.append("=" * 70)
        report.append("MALWARE ANALYSIS REPORT")
        report.append("=" * 70)
        
        sample = analysis['sample']
        report.append(f"\n{'=' * 50}")
        report.append("SAMPLE INFORMATION")
        report.append("=" * 50)
        report.append(f"Filename: {sample['filename']}")
        report.append(f"Size: {sample['size']} bytes")
        report.append(f"MD5: {sample['md5']}")
        report.append(f"SHA256: {sample['sha256']}")
        report.append(f"File Type: {sample['type']}")
        report.append(f"Architecture: {sample['architecture']}")
        if sample.get('packer'):
            report.append(f"Packer: {sample['packer']}")
            
        verdict = analysis['verdict']
        report.append(f"\n{'=' * 50}")
        report.append("VERDICT")
        report.append("=" * 50)
        report.append(f"Threat Level: {verdict['threat_level'].upper()}")
        report.append(f"Malware Type: {verdict['malware_type'].upper()}")
        if verdict.get('malware_family'):
            report.append(f"Family: {verdict['malware_family']}")
            
        if analysis['yara_matches']:
            report.append(f"\n{'=' * 50}")
            report.append("YARA MATCHES")
            report.append("=" * 50)
            for match in analysis['yara_matches']:
                report.append(f"  - {match}")
                
        if analysis['behaviors']:
            report.append(f"\n{'=' * 50}")
            report.append("BEHAVIORAL ANALYSIS")
            report.append("=" * 50)
            
            for behavior in analysis['behaviors']:
                report.append(f"\n[{behavior['severity'].upper()}] {behavior['description']}")
                report.append(f"  Category: {behavior['category']}")
                if behavior.get('technique'):
                    report.append(f"  MITRE ATT&CK: {behavior['technique']}")
                    
        if analysis['network_iocs']:
            report.append(f"\n{'=' * 50}")
            report.append("NETWORK INDICATORS")
            report.append("=" * 50)
            
            for ioc in analysis['network_iocs']:
                status = "[MALICIOUS]" if ioc['is_malicious'] else ""
                report.append(f"  [{ioc['type'].upper()}] {ioc['value']} {status}")
                
        if analysis['mitre_techniques']:
            report.append(f"\n{'=' * 50}")
            report.append("MITRE ATT&CK TECHNIQUES")
            report.append("=" * 50)
            for tech in analysis['mitre_techniques']:
                report.append(f"  - {tech}")
                
        report.append(f"\n{'=' * 50}")
        report.append("RECOMMENDATIONS")
        report.append("=" * 50)
        
        threat_level = verdict['threat_level']
        
        if threat_level == 'critical':
            report.append("\n1. IMMEDIATELY isolate affected systems")
            report.append("2. Block all identified network indicators")
            report.append("3. Initiate incident response procedures")
            report.append("4. Preserve evidence for forensic analysis")
        elif threat_level == 'high':
            report.append("\n1. Quarantine the sample and affected systems")
            report.append("2. Block identified IoCs at perimeter")
            report.append("3. Conduct thorough scan of environment")
            report.append("4. Review and strengthen security controls")
        else:
            report.append("\n1. Add sample hashes to block lists")
            report.append("2. Update endpoint protection signatures")
            report.append("3. Monitor for related activity")
            
        return "\n".join(report)
