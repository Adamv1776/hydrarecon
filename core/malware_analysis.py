"""
Malware Analysis Engine - Advanced malware research and analysis
Capabilities: Static analysis, dynamic analysis, behavioral analysis, YARA rules, sandbox execution
"""

import asyncio
import hashlib
import json
import os
import re
import struct
import subprocess
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional, Callable
import logging

logger = logging.getLogger(__name__)


class MalwareType(Enum):
    """Types of malware"""
    UNKNOWN = "unknown"
    TROJAN = "trojan"
    RANSOMWARE = "ransomware"
    WORM = "worm"
    ROOTKIT = "rootkit"
    BACKDOOR = "backdoor"
    SPYWARE = "spyware"
    ADWARE = "adware"
    CRYPTOMINER = "cryptominer"
    RAT = "rat"
    LOADER = "loader"
    DROPPER = "dropper"
    BOTNET = "botnet"
    APT = "apt"


class ThreatLevel(Enum):
    """Threat severity levels"""
    UNKNOWN = "unknown"
    BENIGN = "benign"
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class AnalysisType(Enum):
    """Types of analysis"""
    STATIC = "static"
    DYNAMIC = "dynamic"
    BEHAVIORAL = "behavioral"
    NETWORK = "network"
    MEMORY = "memory"
    CODE = "code"


@dataclass
class FileInfo:
    """File metadata"""
    path: str
    name: str
    size: int
    md5: str
    sha1: str
    sha256: str
    ssdeep: str = ""
    file_type: str = ""
    magic_bytes: str = ""
    entropy: float = 0.0
    created: Optional[datetime] = None
    modified: Optional[datetime] = None


@dataclass 
class StringAnalysis:
    """Extracted strings analysis"""
    total_strings: int = 0
    ascii_strings: List[str] = field(default_factory=list)
    unicode_strings: List[str] = field(default_factory=list)
    urls: List[str] = field(default_factory=list)
    ip_addresses: List[str] = field(default_factory=list)
    domains: List[str] = field(default_factory=list)
    emails: List[str] = field(default_factory=list)
    registry_keys: List[str] = field(default_factory=list)
    file_paths: List[str] = field(default_factory=list)
    crypto_strings: List[str] = field(default_factory=list)
    suspicious_strings: List[str] = field(default_factory=list)


@dataclass
class PEAnalysis:
    """PE file analysis results"""
    is_pe: bool = False
    architecture: str = ""
    entry_point: int = 0
    image_base: int = 0
    compile_time: Optional[datetime] = None
    subsystem: str = ""
    dll_characteristics: List[str] = field(default_factory=list)
    sections: List[Dict[str, Any]] = field(default_factory=list)
    imports: Dict[str, List[str]] = field(default_factory=dict)
    exports: List[str] = field(default_factory=list)
    resources: List[Dict[str, Any]] = field(default_factory=list)
    tls_callbacks: List[int] = field(default_factory=list)
    debug_info: Dict[str, Any] = field(default_factory=dict)
    signatures: List[Dict[str, Any]] = field(default_factory=list)
    anomalies: List[str] = field(default_factory=list)


@dataclass
class BehaviorIndicator:
    """Behavioral indicator"""
    category: str
    description: str
    severity: ThreatLevel
    iocs: List[str] = field(default_factory=list)
    mitre_attack: List[str] = field(default_factory=list)


@dataclass
class YaraMatch:
    """YARA rule match"""
    rule_name: str
    tags: List[str]
    meta: Dict[str, Any]
    strings: List[Dict[str, Any]]
    namespace: str = "default"


@dataclass
class NetworkActivity:
    """Network activity from dynamic analysis"""
    dns_queries: List[Dict[str, Any]] = field(default_factory=list)
    http_requests: List[Dict[str, Any]] = field(default_factory=list)
    tcp_connections: List[Dict[str, Any]] = field(default_factory=list)
    udp_connections: List[Dict[str, Any]] = field(default_factory=list)
    c2_communications: List[Dict[str, Any]] = field(default_factory=list)


@dataclass
class ProcessActivity:
    """Process activity from dynamic analysis"""
    created_processes: List[Dict[str, Any]] = field(default_factory=list)
    injected_processes: List[Dict[str, Any]] = field(default_factory=list)
    terminated_processes: List[str] = field(default_factory=list)
    api_calls: List[Dict[str, Any]] = field(default_factory=list)
    syscalls: List[Dict[str, Any]] = field(default_factory=list)


@dataclass
class FileActivity:
    """File system activity"""
    files_created: List[str] = field(default_factory=list)
    files_modified: List[str] = field(default_factory=list)
    files_deleted: List[str] = field(default_factory=list)
    files_read: List[str] = field(default_factory=list)
    dropped_files: List[Dict[str, Any]] = field(default_factory=list)


@dataclass
class RegistryActivity:
    """Windows registry activity"""
    keys_created: List[str] = field(default_factory=list)
    keys_modified: List[Dict[str, Any]] = field(default_factory=list)
    keys_deleted: List[str] = field(default_factory=list)
    persistence_keys: List[str] = field(default_factory=list)


@dataclass
class AnalysisReport:
    """Complete malware analysis report"""
    sample_id: str
    file_info: FileInfo
    threat_level: ThreatLevel = ThreatLevel.UNKNOWN
    malware_type: MalwareType = MalwareType.UNKNOWN
    malware_family: str = ""
    confidence: float = 0.0
    strings: Optional[StringAnalysis] = None
    pe_analysis: Optional[PEAnalysis] = None
    yara_matches: List[YaraMatch] = field(default_factory=list)
    behaviors: List[BehaviorIndicator] = field(default_factory=list)
    network_activity: Optional[NetworkActivity] = None
    process_activity: Optional[ProcessActivity] = None
    file_activity: Optional[FileActivity] = None
    registry_activity: Optional[RegistryActivity] = None
    iocs: List[Dict[str, Any]] = field(default_factory=list)
    mitre_techniques: List[Dict[str, str]] = field(default_factory=list)
    similar_samples: List[Dict[str, Any]] = field(default_factory=list)
    analysis_time: float = 0.0
    timestamp: datetime = field(default_factory=datetime.now)


class MalwareAnalysisEngine:
    """
    Advanced Malware Analysis Engine
    Provides comprehensive static and dynamic analysis capabilities
    """
    
    def __init__(self, config: Optional[Dict] = None):
        self.config = config or {}
        self.yara_rules_path = self.config.get("yara_rules", "rules/")
        self.sandbox_path = self.config.get("sandbox", "/tmp/malware_sandbox")
        self.max_file_size = self.config.get("max_file_size", 100 * 1024 * 1024)  # 100MB
        self.analysis_timeout = self.config.get("timeout", 300)  # 5 minutes
        
        # Analysis callbacks
        self.progress_callback: Optional[Callable] = None
        self.log_callback: Optional[Callable] = None
        
        # YARA rules cache
        self.yara_rules = {}
        
        # Suspicious API patterns
        self.suspicious_apis = {
            "process_injection": [
                "VirtualAllocEx", "WriteProcessMemory", "CreateRemoteThread",
                "NtMapViewOfSection", "QueueUserAPC", "SetThreadContext"
            ],
            "code_execution": [
                "CreateProcess", "ShellExecute", "WinExec", "system", "popen",
                "CreateThread", "NtCreateThreadEx"
            ],
            "persistence": [
                "RegSetValue", "RegCreateKey", "CreateService", "SchTasks",
                "StartupFolder", "RunKey"
            ],
            "evasion": [
                "IsDebuggerPresent", "CheckRemoteDebuggerPresent", "NtQueryInformationProcess",
                "GetTickCount", "Sleep", "VirtualProtect"
            ],
            "credential_theft": [
                "CredEnumerate", "LsaEnumerateLogonSessions", "SamQueryInformationUser",
                "NetUserEnum", "mimikatz"
            ],
            "network": [
                "InternetOpen", "HttpSendRequest", "WSASocket", "connect", "send", "recv"
            ],
            "crypto": [
                "CryptEncrypt", "CryptDecrypt", "CryptImportKey", "BCryptEncrypt"
            ],
            "keylogger": [
                "SetWindowsHookEx", "GetAsyncKeyState", "GetKeyState", "RegisterHotKey"
            ],
            "file_ops": [
                "CreateFile", "WriteFile", "DeleteFile", "MoveFile", "CopyFile"
            ]
        }
        
        # MITRE ATT&CK mapping
        self.mitre_mapping = {
            "process_injection": {"id": "T1055", "name": "Process Injection"},
            "code_execution": {"id": "T1059", "name": "Command and Scripting Interpreter"},
            "persistence": {"id": "T1547", "name": "Boot or Logon Autostart Execution"},
            "evasion": {"id": "T1497", "name": "Virtualization/Sandbox Evasion"},
            "credential_theft": {"id": "T1003", "name": "OS Credential Dumping"},
            "keylogger": {"id": "T1056", "name": "Input Capture"},
            "crypto": {"id": "T1486", "name": "Data Encrypted for Impact"}
        }
        
        self._log("Malware Analysis Engine initialized")
    
    def _log(self, message: str, level: str = "info"):
        """Log message with callback support"""
        if self.log_callback:
            self.log_callback(message, level)
        logger.log(getattr(logging, level.upper(), logging.INFO), message)
    
    def _update_progress(self, progress: int, status: str):
        """Update progress with callback"""
        if self.progress_callback:
            self.progress_callback(progress, status)
    
    async def analyze_sample(self, file_path: str, 
                            analysis_types: Optional[List[AnalysisType]] = None) -> AnalysisReport:
        """
        Perform comprehensive malware analysis on a sample
        """
        start_time = datetime.now()
        
        if not analysis_types:
            analysis_types = [AnalysisType.STATIC, AnalysisType.BEHAVIORAL]
        
        self._update_progress(5, "Starting analysis...")
        
        # Get file info
        file_info = await self._get_file_info(file_path)
        sample_id = file_info.sha256[:16]
        
        report = AnalysisReport(
            sample_id=sample_id,
            file_info=file_info
        )
        
        try:
            # Static analysis
            if AnalysisType.STATIC in analysis_types:
                self._update_progress(10, "Performing static analysis...")
                await self._static_analysis(file_path, report)
            
            # String analysis
            self._update_progress(30, "Extracting strings...")
            report.strings = await self._extract_strings(file_path)
            
            # PE Analysis (if applicable)
            if file_info.file_type in ["PE32", "PE32+", "executable"]:
                self._update_progress(40, "Analyzing PE structure...")
                report.pe_analysis = await self._analyze_pe(file_path)
            
            # YARA scanning
            self._update_progress(50, "Scanning with YARA rules...")
            report.yara_matches = await self._scan_yara(file_path)
            
            # Behavioral analysis
            if AnalysisType.BEHAVIORAL in analysis_types:
                self._update_progress(60, "Behavioral analysis...")
                await self._behavioral_analysis(file_path, report)
            
            # Dynamic analysis (if enabled)
            if AnalysisType.DYNAMIC in analysis_types:
                self._update_progress(70, "Dynamic analysis in sandbox...")
                await self._dynamic_analysis(file_path, report)
            
            # Network analysis
            if AnalysisType.NETWORK in analysis_types:
                self._update_progress(80, "Network analysis...")
                await self._network_analysis(file_path, report)
            
            # Memory analysis
            if AnalysisType.MEMORY in analysis_types:
                self._update_progress(85, "Memory analysis...")
                await self._memory_analysis(file_path, report)
            
            # Generate IOCs
            self._update_progress(90, "Generating IOCs...")
            report.iocs = await self._generate_iocs(report)
            
            # Determine threat level and classification
            self._update_progress(95, "Classifying sample...")
            await self._classify_sample(report)
            
            # Find similar samples
            report.similar_samples = await self._find_similar_samples(report)
            
            report.analysis_time = (datetime.now() - start_time).total_seconds()
            
            self._update_progress(100, "Analysis complete")
            self._log(f"Analysis complete: {report.malware_type.value} - {report.threat_level.value}")
            
        except Exception as e:
            self._log(f"Analysis error: {e}", "error")
            raise
        
        return report
    
    async def _get_file_info(self, file_path: str) -> FileInfo:
        """Extract file metadata and hashes"""
        path = Path(file_path)
        
        if not path.exists():
            raise FileNotFoundError(f"File not found: {file_path}")
        
        stat = path.stat()
        
        # Calculate hashes
        md5 = hashlib.md5()
        sha1 = hashlib.sha1()
        sha256 = hashlib.sha256()
        
        with open(file_path, "rb") as f:
            data = f.read()
            md5.update(data)
            sha1.update(data)
            sha256.update(data)
        
        # Get magic bytes
        magic_bytes = data[:16].hex() if len(data) >= 16 else data.hex()
        
        # Determine file type
        file_type = self._detect_file_type(data)
        
        # Calculate entropy
        entropy = self._calculate_entropy(data)
        
        return FileInfo(
            path=str(path.absolute()),
            name=path.name,
            size=stat.st_size,
            md5=md5.hexdigest(),
            sha1=sha1.hexdigest(),
            sha256=sha256.hexdigest(),
            file_type=file_type,
            magic_bytes=magic_bytes,
            entropy=entropy,
            created=datetime.fromtimestamp(stat.st_ctime),
            modified=datetime.fromtimestamp(stat.st_mtime)
        )
    
    def _detect_file_type(self, data: bytes) -> str:
        """Detect file type from magic bytes"""
        magic_signatures = {
            b"MZ": "PE32",
            b"\x7fELF": "ELF",
            b"PK\x03\x04": "ZIP",
            b"PK\x05\x06": "ZIP",
            b"\xd0\xcf\x11\xe0": "OLE",
            b"%PDF": "PDF",
            b"\x89PNG": "PNG",
            b"GIF8": "GIF",
            b"\xff\xd8\xff": "JPEG",
            b"Rar!": "RAR",
            b"\x1f\x8b": "GZIP",
            b"BZ": "BZIP2",
            b"\xca\xfe\xba\xbe": "MACH-O",
            b"\xfe\xed\xfa\xce": "MACH-O",
            b"\xfe\xed\xfa\xcf": "MACH-O-64"
        }
        
        for magic, file_type in magic_signatures.items():
            if data.startswith(magic):
                return file_type
        
        # Check for script types
        try:
            text = data[:1000].decode("utf-8", errors="ignore")
            if text.startswith("#!/"):
                if "python" in text:
                    return "Python"
                elif "bash" in text or "sh" in text:
                    return "Shell"
                elif "perl" in text:
                    return "Perl"
            if "<script" in text.lower() or "function" in text:
                return "JavaScript"
            if "<?php" in text or "<?=" in text:
                return "PHP"
            if "<html" in text.lower() or "<!doctype" in text.lower():
                return "HTML"
        except Exception:
            pass
        
        return "Unknown"
    
    def _calculate_entropy(self, data: bytes) -> float:
        """Calculate Shannon entropy of data"""
        if not data:
            return 0.0
        
        import math
        
        freq = {}
        for byte in data:
            freq[byte] = freq.get(byte, 0) + 1
        
        entropy = 0.0
        for count in freq.values():
            p = count / len(data)
            entropy -= p * math.log2(p)
        
        return round(entropy, 4)
    
    async def _extract_strings(self, file_path: str) -> StringAnalysis:
        """Extract and categorize strings from file"""
        analysis = StringAnalysis()
        
        with open(file_path, "rb") as f:
            data = f.read()
        
        # ASCII strings (4+ chars)
        ascii_pattern = re.compile(rb"[\x20-\x7e]{4,}")
        analysis.ascii_strings = [s.decode("ascii") for s in ascii_pattern.findall(data)]
        
        # Unicode strings (4+ chars)
        unicode_pattern = re.compile(rb"(?:[\x20-\x7e]\x00){4,}")
        analysis.unicode_strings = [s.decode("utf-16-le", errors="ignore").rstrip('\x00') 
                                    for s in unicode_pattern.findall(data)]
        
        all_strings = analysis.ascii_strings + analysis.unicode_strings
        analysis.total_strings = len(all_strings)
        
        # Extract patterns
        for s in all_strings:
            # URLs
            if re.match(r"https?://", s):
                analysis.urls.append(s)
            
            # IP addresses
            if re.match(r"\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}", s):
                analysis.ip_addresses.append(s)
            
            # Domains
            if re.match(r"^[a-zA-Z0-9][a-zA-Z0-9-]{1,61}[a-zA-Z0-9]\.[a-zA-Z]{2,}$", s):
                analysis.domains.append(s)
            
            # Email addresses
            if re.match(r"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}", s):
                analysis.emails.append(s)
            
            # Registry keys
            if re.match(r"(HKEY_|HKLM|HKCU|HKU)", s, re.I):
                analysis.registry_keys.append(s)
            
            # File paths
            if re.match(r"[A-Za-z]:\\|/[a-z]+/", s, re.I):
                analysis.file_paths.append(s)
            
            # Crypto-related strings
            crypto_keywords = ["encrypt", "decrypt", "aes", "rsa", "key", "cipher", 
                              "bitcoin", "wallet", "ransom"]
            if any(kw in s.lower() for kw in crypto_keywords):
                analysis.crypto_strings.append(s)
            
            # Suspicious strings
            suspicious_keywords = ["cmd.exe", "powershell", "wscript", "cscript",
                                  "password", "admin", "root", "shadow", "passwd",
                                  "mimikatz", "meterpreter", "shellcode"]
            if any(kw in s.lower() for kw in suspicious_keywords):
                analysis.suspicious_strings.append(s)
        
        return analysis
    
    async def _analyze_pe(self, file_path: str) -> PEAnalysis:
        """Analyze PE file structure"""
        analysis = PEAnalysis()
        
        try:
            with open(file_path, "rb") as f:
                data = f.read()
            
            # Check for MZ header
            if not data.startswith(b"MZ"):
                return analysis
            
            analysis.is_pe = True
            
            # Get PE header offset
            pe_offset = struct.unpack("<I", data[0x3c:0x40])[0]
            
            if data[pe_offset:pe_offset+4] != b"PE\x00\x00":
                analysis.anomalies.append("Invalid PE signature")
                return analysis
            
            # Machine type
            machine = struct.unpack("<H", data[pe_offset+4:pe_offset+6])[0]
            if machine == 0x14c:
                analysis.architecture = "x86"
            elif machine == 0x8664:
                analysis.architecture = "x64"
            else:
                analysis.architecture = f"Unknown (0x{machine:04x})"
            
            # Number of sections
            num_sections = struct.unpack("<H", data[pe_offset+6:pe_offset+8])[0]
            
            # Timestamp
            timestamp = struct.unpack("<I", data[pe_offset+8:pe_offset+12])[0]
            try:
                analysis.compile_time = datetime.fromtimestamp(timestamp)
            except Exception:
                analysis.anomalies.append(f"Invalid timestamp: {timestamp}")
            
            # Optional header size
            optional_header_size = struct.unpack("<H", data[pe_offset+20:pe_offset+22])[0]
            
            # Characteristics
            characteristics = struct.unpack("<H", data[pe_offset+22:pe_offset+24])[0]
            if characteristics & 0x0002:
                analysis.dll_characteristics.append("EXECUTABLE_IMAGE")
            if characteristics & 0x0020:
                analysis.dll_characteristics.append("LARGE_ADDRESS_AWARE")
            if characteristics & 0x0100:
                analysis.dll_characteristics.append("32BIT_MACHINE")
            if characteristics & 0x2000:
                analysis.dll_characteristics.append("DLL")
            
            # Optional header
            optional_offset = pe_offset + 24
            magic = struct.unpack("<H", data[optional_offset:optional_offset+2])[0]
            
            if magic == 0x10b:  # PE32
                analysis.entry_point = struct.unpack("<I", data[optional_offset+16:optional_offset+20])[0]
                analysis.image_base = struct.unpack("<I", data[optional_offset+28:optional_offset+32])[0]
                subsystem = struct.unpack("<H", data[optional_offset+68:optional_offset+70])[0]
            elif magic == 0x20b:  # PE32+
                analysis.architecture = "x64"
                analysis.entry_point = struct.unpack("<I", data[optional_offset+16:optional_offset+20])[0]
                analysis.image_base = struct.unpack("<Q", data[optional_offset+24:optional_offset+32])[0]
                subsystem = struct.unpack("<H", data[optional_offset+68:optional_offset+70])[0]
            else:
                analysis.anomalies.append(f"Unknown PE magic: 0x{magic:04x}")
                subsystem = 0
            
            # Subsystem
            subsystem_names = {
                0: "Unknown", 1: "Native", 2: "Windows GUI", 3: "Windows CUI",
                5: "OS/2 CUI", 7: "POSIX CUI", 9: "Windows CE GUI",
                10: "EFI Application", 11: "EFI Boot Driver", 12: "EFI Runtime Driver"
            }
            analysis.subsystem = subsystem_names.get(subsystem, f"Unknown ({subsystem})")
            
            # Parse sections
            section_offset = optional_offset + optional_header_size
            for i in range(num_sections):
                sec_start = section_offset + (i * 40)
                sec_name = data[sec_start:sec_start+8].rstrip(b"\x00").decode("ascii", errors="ignore")
                virtual_size = struct.unpack("<I", data[sec_start+8:sec_start+12])[0]
                virtual_addr = struct.unpack("<I", data[sec_start+12:sec_start+16])[0]
                raw_size = struct.unpack("<I", data[sec_start+16:sec_start+20])[0]
                raw_offset = struct.unpack("<I", data[sec_start+20:sec_start+24])[0]
                sec_characteristics = struct.unpack("<I", data[sec_start+36:sec_start+40])[0]
                
                # Calculate section entropy
                if raw_size > 0 and raw_offset + raw_size <= len(data):
                    sec_data = data[raw_offset:raw_offset + raw_size]
                    sec_entropy = self._calculate_entropy(sec_data)
                else:
                    sec_entropy = 0.0
                
                section = {
                    "name": sec_name,
                    "virtual_size": virtual_size,
                    "virtual_address": virtual_addr,
                    "raw_size": raw_size,
                    "raw_offset": raw_offset,
                    "entropy": sec_entropy,
                    "executable": bool(sec_characteristics & 0x20000000),
                    "writable": bool(sec_characteristics & 0x80000000),
                    "readable": bool(sec_characteristics & 0x40000000)
                }
                analysis.sections.append(section)
                
                # Detect anomalies
                if sec_entropy > 7.5:
                    analysis.anomalies.append(f"High entropy section: {sec_name} ({sec_entropy:.2f})")
                if sec_name not in [".text", ".data", ".rdata", ".bss", ".rsrc", ".reloc", ".idata", ".edata", ".pdata"]:
                    if not sec_name.startswith("."):
                        analysis.anomalies.append(f"Unusual section name: {sec_name}")
            
            # Check for packing indicators
            if any(s["entropy"] > 7.0 for s in analysis.sections):
                analysis.anomalies.append("Possible packed/encrypted content detected")
            
        except Exception as e:
            analysis.anomalies.append(f"PE parsing error: {str(e)}")
        
        return analysis
    
    async def _scan_yara(self, file_path: str) -> List[YaraMatch]:
        """Scan file with YARA rules"""
        matches = []
        
        try:
            import yara
            
            # Load YARA rules
            if os.path.isdir(self.yara_rules_path):
                for rule_file in Path(self.yara_rules_path).glob("*.yar"):
                    try:
                        rules = yara.compile(filepath=str(rule_file))
                        yara_matches = rules.match(file_path)
                        
                        for match in yara_matches:
                            matches.append(YaraMatch(
                                rule_name=match.rule,
                                tags=list(match.tags),
                                meta=dict(match.meta),
                                strings=[{
                                    "offset": s[0],
                                    "identifier": s[1],
                                    "data": s[2].hex() if isinstance(s[2], bytes) else s[2]
                                } for s in match.strings],
                                namespace=match.namespace
                            ))
                    except Exception as e:
                        self._log(f"YARA rule error ({rule_file}): {e}", "warning")
            
        except ImportError:
            self._log("YARA library not available", "warning")
            # Use built-in pattern matching as fallback
            matches.extend(await self._builtin_yara_scan(file_path))
        
        return matches
    
    async def _builtin_yara_scan(self, file_path: str) -> List[YaraMatch]:
        """Fallback pattern matching when YARA is not available"""
        matches = []
        
        with open(file_path, "rb") as f:
            data = f.read()
        
        # Known malware signatures
        signatures = {
            "metasploit_shellcode": {
                "pattern": rb"\xfc\xe8\x82\x00\x00\x00|\xfc\x48\x83\xe4\xf0",
                "tags": ["shellcode", "metasploit"],
                "severity": "high"
            },
            "cobalt_strike_beacon": {
                "pattern": rb"ReflectiveLoader|BeaconPayload|\x4d\x5a.{0,100}This program cannot",
                "tags": ["c2", "cobalt_strike"],
                "severity": "critical"
            },
            "mimikatz": {
                "pattern": rb"mimikatz|sekurlsa|kerberos|wdigest|credman",
                "tags": ["credential_theft", "mimikatz"],
                "severity": "critical"
            },
            "ransomware_indicators": {
                "pattern": rb"YOUR FILES|ENCRYPTED|DECRYPT|BITCOIN|RANSOM|PAYMENT",
                "tags": ["ransomware"],
                "severity": "critical"
            },
            "powershell_encoded": {
                "pattern": rb"powershell.*-[eE][nN][cC]|-[eE]ncoded[cC]ommand",
                "tags": ["powershell", "encoded"],
                "severity": "high"
            },
            "base64_powershell": {
                "pattern": rb"JABzAD0A|SQBuAHYAbwBrAGUA|SW52b2tlL",
                "tags": ["powershell", "base64"],
                "severity": "high"
            },
            "reverse_shell": {
                "pattern": rb"/bin/sh|/bin/bash|cmd\.exe|nc\.exe|-e /bin|connect back",
                "tags": ["reverse_shell", "backdoor"],
                "severity": "high"
            },
            "keylogger": {
                "pattern": rb"GetAsyncKeyState|SetWindowsHookEx|keylog|keystroke",
                "tags": ["keylogger", "spyware"],
                "severity": "high"
            },
            "anti_analysis": {
                "pattern": rb"IsDebuggerPresent|CheckRemoteDebuggerPresent|vmware|vbox|sandbox",
                "tags": ["anti-analysis", "evasion"],
                "severity": "medium"
            }
        }
        
        for rule_name, sig in signatures.items():
            pattern = re.compile(sig["pattern"], re.IGNORECASE)
            found = pattern.findall(data)
            if found:
                matches.append(YaraMatch(
                    rule_name=rule_name,
                    tags=sig["tags"],
                    meta={"severity": sig["severity"], "builtin": True},
                    strings=[{"data": f.hex() if isinstance(f, bytes) else f, 
                             "identifier": rule_name} for f in found[:5]]
                ))
        
        return matches
    
    async def _static_analysis(self, file_path: str, report: AnalysisReport):
        """Perform static code analysis"""
        # Analyze for suspicious patterns
        with open(file_path, "rb") as f:
            data = f.read()
        
        # Check for suspicious API imports
        for category, apis in self.suspicious_apis.items():
            for api in apis:
                if api.encode() in data:
                    behavior = BehaviorIndicator(
                        category=category,
                        description=f"Suspicious API detected: {api}",
                        severity=ThreatLevel.MEDIUM,
                        iocs=[api],
                        mitre_attack=[self.mitre_mapping.get(category, {}).get("id", "")]
                    )
                    report.behaviors.append(behavior)
                    
                    if category in self.mitre_mapping:
                        technique = self.mitre_mapping[category]
                        if technique not in report.mitre_techniques:
                            report.mitre_techniques.append(technique)
    
    async def _behavioral_analysis(self, file_path: str, report: AnalysisReport):
        """Analyze behavioral indicators"""
        # Check file entropy
        if report.file_info.entropy > 7.5:
            report.behaviors.append(BehaviorIndicator(
                category="packing",
                description=f"High entropy ({report.file_info.entropy:.2f}) indicates packing/encryption",
                severity=ThreatLevel.MEDIUM,
                mitre_attack=["T1027"]
            ))
        
        # Check for suspicious strings
        if report.strings:
            if report.strings.crypto_strings:
                report.behaviors.append(BehaviorIndicator(
                    category="encryption",
                    description=f"Encryption-related strings found ({len(report.strings.crypto_strings)})",
                    severity=ThreatLevel.MEDIUM,
                    iocs=report.strings.crypto_strings[:10],
                    mitre_attack=["T1486"]
                ))
            
            if report.strings.urls:
                report.behaviors.append(BehaviorIndicator(
                    category="network",
                    description=f"URLs found in binary ({len(report.strings.urls)})",
                    severity=ThreatLevel.LOW,
                    iocs=report.strings.urls[:10],
                    mitre_attack=["T1071"]
                ))
            
            if report.strings.registry_keys:
                report.behaviors.append(BehaviorIndicator(
                    category="persistence",
                    description=f"Registry key references found ({len(report.strings.registry_keys)})",
                    severity=ThreatLevel.MEDIUM,
                    iocs=report.strings.registry_keys[:10],
                    mitre_attack=["T1547"]
                ))
    
    async def _dynamic_analysis(self, file_path: str, report: AnalysisReport):
        """
        Perform dynamic analysis in sandbox
        Note: This is a framework - actual sandbox execution would require
        additional infrastructure (Cuckoo, CAPE, custom sandbox, etc.)
        """
        self._log("Dynamic analysis requires sandbox environment", "warning")
        
        # Initialize activity tracking
        report.network_activity = NetworkActivity()
        report.process_activity = ProcessActivity()
        report.file_activity = FileActivity()
        report.registry_activity = RegistryActivity()
        
        # Placeholder for actual sandbox integration
        # In production, this would:
        # 1. Copy sample to isolated VM
        # 2. Execute with monitoring
        # 3. Capture API calls, network traffic, file/registry changes
        # 4. Analyze memory dumps
    
    async def _network_analysis(self, file_path: str, report: AnalysisReport):
        """Analyze network-related indicators"""
        if not report.strings:
            return
        
        # Analyze URLs for C2 patterns
        c2_patterns = [
            r"/gate\.php", r"/panel", r"/admin", r"/bot",
            r"\.onion", r"\.(tk|ml|ga|cf|gq)$",
            r"/post\.php", r"/data\.php", r"/api/"
        ]
        
        for url in report.strings.urls:
            for pattern in c2_patterns:
                if re.search(pattern, url, re.I):
                    report.behaviors.append(BehaviorIndicator(
                        category="c2_communication",
                        description=f"Potential C2 URL pattern: {url}",
                        severity=ThreatLevel.HIGH,
                        iocs=[url],
                        mitre_attack=["T1071"]
                    ))
                    break
    
    async def _memory_analysis(self, file_path: str, report: AnalysisReport):
        """Analyze memory-related indicators"""
        with open(file_path, "rb") as f:
            data = f.read()
        
        # Look for shellcode patterns
        shellcode_patterns = [
            (rb"\xfc\xe8", "x86 shellcode prologue"),
            (rb"\xfc\x48\x83\xe4\xf0", "x64 shellcode prologue"),
            (rb"\x31\xc0\x50\x68", "x86 push/call pattern"),
            (rb"\x48\x31\xc0", "x64 xor rax,rax"),
            (rb"\xe8\x00\x00\x00\x00\x58", "call/pop getPC"),
            (rb"\xeb\xfe", "infinite loop (anti-debug)")
        ]
        
        for pattern, description in shellcode_patterns:
            if pattern in data:
                report.behaviors.append(BehaviorIndicator(
                    category="shellcode",
                    description=f"Shellcode pattern: {description}",
                    severity=ThreatLevel.HIGH,
                    iocs=[pattern.hex()],
                    mitre_attack=["T1059"]
                ))
    
    async def _generate_iocs(self, report: AnalysisReport) -> List[Dict[str, Any]]:
        """Generate Indicators of Compromise"""
        iocs = []
        
        # File hashes
        iocs.append({
            "type": "file_hash",
            "value": report.file_info.md5,
            "hash_type": "md5",
            "confidence": 100
        })
        iocs.append({
            "type": "file_hash",
            "value": report.file_info.sha256,
            "hash_type": "sha256",
            "confidence": 100
        })
        
        # Network IOCs
        if report.strings:
            for url in report.strings.urls[:20]:
                iocs.append({
                    "type": "url",
                    "value": url,
                    "confidence": 70
                })
            
            for ip in report.strings.ip_addresses[:20]:
                iocs.append({
                    "type": "ip",
                    "value": ip,
                    "confidence": 60
                })
            
            for domain in report.strings.domains[:20]:
                iocs.append({
                    "type": "domain",
                    "value": domain,
                    "confidence": 60
                })
        
        # Registry IOCs
        if report.strings and report.strings.registry_keys:
            for key in report.strings.registry_keys[:10]:
                iocs.append({
                    "type": "registry",
                    "value": key,
                    "confidence": 50
                })
        
        return iocs
    
    async def _classify_sample(self, report: AnalysisReport):
        """Classify malware type and determine threat level"""
        threat_score = 0
        classification_hints = []
        
        # Score based on YARA matches
        for match in report.yara_matches:
            severity = match.meta.get("severity", "low")
            if severity == "critical":
                threat_score += 40
            elif severity == "high":
                threat_score += 25
            elif severity == "medium":
                threat_score += 15
            else:
                threat_score += 5
            
            # Classification hints from tags
            classification_hints.extend(match.tags)
        
        # Score based on behaviors
        for behavior in report.behaviors:
            if behavior.severity == ThreatLevel.CRITICAL:
                threat_score += 30
            elif behavior.severity == ThreatLevel.HIGH:
                threat_score += 20
            elif behavior.severity == ThreatLevel.MEDIUM:
                threat_score += 10
            else:
                threat_score += 5
            
            classification_hints.append(behavior.category)
        
        # Score based on strings
        if report.strings:
            if report.strings.suspicious_strings:
                threat_score += len(report.strings.suspicious_strings) * 2
            if report.strings.crypto_strings:
                threat_score += 10
        
        # Score based on PE anomalies
        if report.pe_analysis and report.pe_analysis.anomalies:
            threat_score += len(report.pe_analysis.anomalies) * 5
        
        # Determine threat level
        if threat_score >= 80:
            report.threat_level = ThreatLevel.CRITICAL
        elif threat_score >= 50:
            report.threat_level = ThreatLevel.HIGH
        elif threat_score >= 25:
            report.threat_level = ThreatLevel.MEDIUM
        elif threat_score >= 10:
            report.threat_level = ThreatLevel.LOW
        else:
            report.threat_level = ThreatLevel.BENIGN
        
        # Determine malware type
        hint_counts = {}
        for hint in classification_hints:
            hint_lower = hint.lower()
            for mtype in MalwareType:
                if mtype.value in hint_lower:
                    hint_counts[mtype] = hint_counts.get(mtype, 0) + 1
        
        if hint_counts:
            report.malware_type = max(hint_counts, key=hint_counts.get)
        elif threat_score >= 25:
            report.malware_type = MalwareType.UNKNOWN
        
        # Set confidence
        if threat_score >= 60:
            report.confidence = min(95, 50 + threat_score * 0.5)
        else:
            report.confidence = max(10, threat_score)
    
    async def _find_similar_samples(self, report: AnalysisReport) -> List[Dict[str, Any]]:
        """Find similar samples based on characteristics"""
        # This would typically query a malware database
        # Placeholder for integration with VirusTotal, MalwareBazaar, etc.
        return []
    
    async def generate_report(self, analysis: AnalysisReport, 
                             format: str = "json") -> str:
        """Generate analysis report in specified format"""
        if format == "json":
            return json.dumps(self._report_to_dict(analysis), indent=2, default=str)
        elif format == "markdown":
            return self._report_to_markdown(analysis)
        elif format == "html":
            return self._report_to_html(analysis)
        else:
            raise ValueError(f"Unsupported format: {format}")
    
    def _report_to_dict(self, report: AnalysisReport) -> Dict:
        """Convert report to dictionary"""
        return {
            "sample_id": report.sample_id,
            "file_info": {
                "name": report.file_info.name,
                "size": report.file_info.size,
                "md5": report.file_info.md5,
                "sha1": report.file_info.sha1,
                "sha256": report.file_info.sha256,
                "file_type": report.file_info.file_type,
                "entropy": report.file_info.entropy
            },
            "classification": {
                "threat_level": report.threat_level.value,
                "malware_type": report.malware_type.value,
                "malware_family": report.malware_family,
                "confidence": report.confidence
            },
            "yara_matches": [
                {"rule": m.rule_name, "tags": m.tags}
                for m in report.yara_matches
            ],
            "behaviors": [
                {
                    "category": b.category,
                    "description": b.description,
                    "severity": b.severity.value,
                    "mitre": b.mitre_attack
                }
                for b in report.behaviors
            ],
            "mitre_techniques": report.mitre_techniques,
            "iocs": report.iocs,
            "analysis_time": report.analysis_time,
            "timestamp": report.timestamp.isoformat()
        }
    
    def _report_to_markdown(self, report: AnalysisReport) -> str:
        """Generate markdown report"""
        md = f"""# Malware Analysis Report

## Sample Information
- **File:** {report.file_info.name}
- **Size:** {report.file_info.size:,} bytes
- **Type:** {report.file_info.file_type}
- **MD5:** `{report.file_info.md5}`
- **SHA256:** `{report.file_info.sha256}`
- **Entropy:** {report.file_info.entropy:.2f}

## Classification
- **Threat Level:** {report.threat_level.value.upper()}
- **Malware Type:** {report.malware_type.value}
- **Confidence:** {report.confidence:.1f}%

## YARA Matches
"""
        for match in report.yara_matches:
            md += f"- **{match.rule_name}** - Tags: {', '.join(match.tags)}\n"
        
        md += "\n## Behavioral Indicators\n"
        for behavior in report.behaviors:
            md += f"- [{behavior.severity.value.upper()}] {behavior.description}\n"
        
        md += "\n## MITRE ATT&CK Techniques\n"
        for technique in report.mitre_techniques:
            md += f"- **{technique.get('id', 'N/A')}:** {technique.get('name', 'N/A')}\n"
        
        md += f"\n---\n*Analysis completed in {report.analysis_time:.2f} seconds*\n"
        
        return md
    
    def _report_to_html(self, report: AnalysisReport) -> str:
        """Generate HTML report"""
        threat_colors = {
            ThreatLevel.BENIGN: "#00ff00",
            ThreatLevel.LOW: "#ffff00",
            ThreatLevel.MEDIUM: "#ffa500",
            ThreatLevel.HIGH: "#ff4500",
            ThreatLevel.CRITICAL: "#ff0000"
        }
        
        return f"""
<!DOCTYPE html>
<html>
<head>
    <title>Malware Analysis Report - {report.file_info.name}</title>
    <style>
        body {{ font-family: Arial, sans-serif; background: #1a1a2e; color: #eee; padding: 20px; }}
        .header {{ background: #16213e; padding: 20px; border-radius: 10px; }}
        .threat-badge {{ background: {threat_colors[report.threat_level]}; color: #000; 
                        padding: 5px 15px; border-radius: 5px; font-weight: bold; }}
        .section {{ background: #16213e; margin: 20px 0; padding: 15px; border-radius: 10px; }}
        .hash {{ font-family: monospace; background: #0f0f23; padding: 5px; }}
        table {{ width: 100%; border-collapse: collapse; }}
        th, td {{ padding: 10px; text-align: left; border-bottom: 1px solid #333; }}
    </style>
</head>
<body>
    <div class="header">
        <h1>üî¨ Malware Analysis Report</h1>
        <span class="threat-badge">{report.threat_level.value.upper()}</span>
        <span style="margin-left: 10px;">{report.malware_type.value}</span>
    </div>
    
    <div class="section">
        <h2>üìÅ Sample Information</h2>
        <table>
            <tr><td>Filename</td><td>{report.file_info.name}</td></tr>
            <tr><td>Size</td><td>{report.file_info.size:,} bytes</td></tr>
            <tr><td>Type</td><td>{report.file_info.file_type}</td></tr>
            <tr><td>MD5</td><td class="hash">{report.file_info.md5}</td></tr>
            <tr><td>SHA256</td><td class="hash">{report.file_info.sha256}</td></tr>
            <tr><td>Entropy</td><td>{report.file_info.entropy:.2f}</td></tr>
        </table>
    </div>
    
    <div class="section">
        <h2>üéØ YARA Matches ({len(report.yara_matches)})</h2>
        <table>
            <tr><th>Rule</th><th>Tags</th></tr>
            {''.join(f"<tr><td>{m.rule_name}</td><td>{', '.join(m.tags)}</td></tr>" for m in report.yara_matches)}
        </table>
    </div>
    
    <div class="section">
        <h2>‚ö†Ô∏è Behavioral Indicators ({len(report.behaviors)})</h2>
        <table>
            <tr><th>Severity</th><th>Category</th><th>Description</th></tr>
            {''.join(f"<tr><td>{b.severity.value}</td><td>{b.category}</td><td>{b.description}</td></tr>" for b in report.behaviors)}
        </table>
    </div>
    
    <footer style="margin-top: 20px; color: #666;">
        Analysis completed in {report.analysis_time:.2f} seconds | {report.timestamp.isoformat()}
    </footer>
</body>
</html>
"""
