"""
HydraRecon Exploit Chain Builder
Visual drag-and-drop attack path orchestration with automated chaining
"""

import asyncio
import json
import sqlite3
import uuid
from datetime import datetime
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any, Set, Tuple
from enum import Enum
import hashlib


class NodeType(Enum):
    """Types of nodes in exploit chain"""
    ENTRY_POINT = "entry_point"
    VULNERABILITY = "vulnerability"
    EXPLOIT = "exploit"
    PAYLOAD = "payload"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    LATERAL_MOVEMENT = "lateral_movement"
    PERSISTENCE = "persistence"
    DATA_ACCESS = "data_access"
    EXFILTRATION = "exfiltration"
    COMMAND_CONTROL = "command_control"
    OBJECTIVE = "objective"
    CONDITION = "condition"
    DECISION = "decision"


class ExecutionStatus(Enum):
    """Status of chain execution"""
    PENDING = "pending"
    RUNNING = "running"
    SUCCESS = "success"
    FAILED = "failed"
    BLOCKED = "blocked"
    SKIPPED = "skipped"
    TIMEOUT = "timeout"


class ChainComplexity(Enum):
    """Complexity rating for exploit chains"""
    TRIVIAL = "trivial"
    EASY = "easy"
    MODERATE = "moderate"
    DIFFICULT = "difficult"
    EXPERT = "expert"
    NATION_STATE = "nation_state"


@dataclass
class ChainNode:
    """A node in the exploit chain"""
    node_id: str
    name: str
    node_type: NodeType
    description: str
    technique_id: str = ""  # MITRE ATT&CK technique
    tactic: str = ""
    prerequisites: List[str] = field(default_factory=list)  # Required node IDs
    provides: List[str] = field(default_factory=list)  # Capabilities provided
    requires: List[str] = field(default_factory=list)  # Capabilities required
    success_probability: float = 0.8
    detection_risk: float = 0.3
    time_estimate_seconds: int = 60
    automated: bool = True
    payload: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    position_x: int = 0
    position_y: int = 0
    status: ExecutionStatus = ExecutionStatus.PENDING
    output: Dict[str, Any] = field(default_factory=dict)


@dataclass
class ChainEdge:
    """Connection between nodes"""
    edge_id: str
    source_node_id: str
    target_node_id: str
    condition: str = ""  # Condition for traversal
    on_success: bool = True  # Traverse on success
    on_failure: bool = False  # Traverse on failure
    delay_seconds: int = 0
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class ExploitChain:
    """Complete exploit chain definition"""
    chain_id: str
    name: str
    description: str
    author: str
    created_at: datetime
    modified_at: datetime
    nodes: List[ChainNode]
    edges: List[ChainEdge]
    target_type: str
    objective: str
    complexity: ChainComplexity
    estimated_duration: int  # seconds
    success_rate: float
    detection_rate: float
    mitre_tactics: List[str] = field(default_factory=list)
    mitre_techniques: List[str] = field(default_factory=list)
    tags: List[str] = field(default_factory=list)
    version: str = "1.0"
    status: ExecutionStatus = ExecutionStatus.PENDING


@dataclass
class ChainTemplate:
    """Pre-built chain template"""
    template_id: str
    name: str
    description: str
    category: str
    chain_definition: Dict[str, Any]
    variables: List[Dict[str, str]]
    difficulty: ChainComplexity
    use_cases: List[str]
    created_by: str


@dataclass
class ExecutionResult:
    """Result of chain execution"""
    execution_id: str
    chain_id: str
    started_at: datetime
    completed_at: Optional[datetime]
    status: ExecutionStatus
    nodes_executed: int
    nodes_successful: int
    nodes_failed: int
    current_node: Optional[str]
    execution_log: List[Dict[str, Any]]
    artifacts: Dict[str, Any]
    total_duration: float


class ExploitChainBuilder:
    """
    Visual exploit chain builder with automated execution
    
    Features:
    - Drag-and-drop chain construction
    - MITRE ATT&CK mapping
    - Automated chain validation
    - Probability-based execution
    - Detection risk assessment
    - Chain optimization suggestions
    - Template library
    - Real-time execution visualization
    """
    
    def __init__(self, db_path: str = "exploit_chains.db"):
        self.db_path = db_path
        self.chains: Dict[str, ExploitChain] = {}
        self.templates: Dict[str, ChainTemplate] = {}
        self.active_executions: Dict[str, ExecutionResult] = {}
        self.node_library: Dict[str, ChainNode] = {}
        self._initialize_database()
        self._load_node_library()
        self._load_templates()
    
    def _initialize_database(self):
        """Initialize the database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS exploit_chains (
                chain_id TEXT PRIMARY KEY,
                name TEXT NOT NULL,
                description TEXT,
                author TEXT,
                created_at TIMESTAMP,
                modified_at TIMESTAMP,
                chain_data TEXT,
                target_type TEXT,
                objective TEXT,
                complexity TEXT,
                status TEXT,
                version TEXT
            )
        """)
        
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS chain_templates (
                template_id TEXT PRIMARY KEY,
                name TEXT NOT NULL,
                description TEXT,
                category TEXT,
                chain_definition TEXT,
                variables TEXT,
                difficulty TEXT,
                use_cases TEXT,
                created_by TEXT
            )
        """)
        
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS execution_history (
                execution_id TEXT PRIMARY KEY,
                chain_id TEXT,
                started_at TIMESTAMP,
                completed_at TIMESTAMP,
                status TEXT,
                nodes_executed INTEGER,
                nodes_successful INTEGER,
                nodes_failed INTEGER,
                execution_log TEXT,
                artifacts TEXT
            )
        """)
        
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS node_library (
                node_id TEXT PRIMARY KEY,
                name TEXT NOT NULL,
                node_type TEXT,
                description TEXT,
                technique_id TEXT,
                tactic TEXT,
                provides TEXT,
                requires TEXT,
                payload TEXT,
                parameters TEXT
            )
        """)
        
        conn.commit()
        conn.close()
    
    def _load_node_library(self):
        """Load the pre-built node library"""
        self.node_library = {
            # Entry Points
            "phishing_email": ChainNode(
                node_id="phishing_email",
                name="Phishing Email",
                node_type=NodeType.ENTRY_POINT,
                description="Send crafted phishing email to target",
                technique_id="T1566.001",
                tactic="initial-access",
                provides=["user_interaction", "initial_access"],
                success_probability=0.25,
                detection_risk=0.4
            ),
            "exploit_public_app": ChainNode(
                node_id="exploit_public_app",
                name="Exploit Public Application",
                node_type=NodeType.ENTRY_POINT,
                description="Exploit vulnerability in public-facing application",
                technique_id="T1190",
                tactic="initial-access",
                provides=["web_shell", "initial_access"],
                success_probability=0.6,
                detection_risk=0.5
            ),
            "drive_by_download": ChainNode(
                node_id="drive_by_download",
                name="Drive-by Download",
                node_type=NodeType.ENTRY_POINT,
                description="Compromise through malicious website",
                technique_id="T1189",
                tactic="initial-access",
                provides=["browser_access", "initial_access"],
                success_probability=0.3,
                detection_risk=0.6
            ),
            "supply_chain": ChainNode(
                node_id="supply_chain",
                name="Supply Chain Compromise",
                node_type=NodeType.ENTRY_POINT,
                description="Compromise through trusted software",
                technique_id="T1195",
                tactic="initial-access",
                provides=["trusted_access", "initial_access"],
                success_probability=0.2,
                detection_risk=0.1
            ),
            
            # Vulnerabilities
            "sql_injection": ChainNode(
                node_id="sql_injection",
                name="SQL Injection",
                node_type=NodeType.VULNERABILITY,
                description="Exploit SQL injection vulnerability",
                technique_id="T1190",
                tactic="initial-access",
                requires=["web_access"],
                provides=["database_access", "data_extraction"],
                success_probability=0.7,
                detection_risk=0.4
            ),
            "rce_vuln": ChainNode(
                node_id="rce_vuln",
                name="Remote Code Execution",
                node_type=NodeType.VULNERABILITY,
                description="Exploit RCE vulnerability",
                technique_id="T1203",
                tactic="execution",
                requires=["application_access"],
                provides=["code_execution", "shell_access"],
                success_probability=0.5,
                detection_risk=0.6
            ),
            "lfi_vuln": ChainNode(
                node_id="lfi_vuln",
                name="Local File Inclusion",
                node_type=NodeType.VULNERABILITY,
                description="Exploit LFI to read sensitive files",
                technique_id="T1005",
                tactic="collection",
                requires=["web_access"],
                provides=["file_read", "credential_access"],
                success_probability=0.6,
                detection_risk=0.3
            ),
            
            # Exploits
            "metasploit_exploit": ChainNode(
                node_id="metasploit_exploit",
                name="Metasploit Exploit",
                node_type=NodeType.EXPLOIT,
                description="Run Metasploit exploit module",
                technique_id="T1203",
                tactic="execution",
                requires=["vulnerability_identified"],
                provides=["shell_access", "code_execution"],
                success_probability=0.6,
                detection_risk=0.7
            ),
            "custom_exploit": ChainNode(
                node_id="custom_exploit",
                name="Custom Exploit",
                node_type=NodeType.EXPLOIT,
                description="Run custom exploit code",
                technique_id="T1203",
                tactic="execution",
                requires=["vulnerability_identified"],
                provides=["shell_access", "code_execution"],
                success_probability=0.4,
                detection_risk=0.3
            ),
            
            # Payloads
            "reverse_shell": ChainNode(
                node_id="reverse_shell",
                name="Reverse Shell",
                node_type=NodeType.PAYLOAD,
                description="Establish reverse shell connection",
                technique_id="T1059",
                tactic="execution",
                requires=["code_execution"],
                provides=["interactive_shell", "c2_channel"],
                success_probability=0.8,
                detection_risk=0.5
            ),
            "meterpreter": ChainNode(
                node_id="meterpreter",
                name="Meterpreter Session",
                node_type=NodeType.PAYLOAD,
                description="Deploy Meterpreter payload",
                technique_id="T1059.006",
                tactic="execution",
                requires=["code_execution"],
                provides=["interactive_shell", "c2_channel", "post_exploit"],
                success_probability=0.7,
                detection_risk=0.8
            ),
            "web_shell": ChainNode(
                node_id="web_shell",
                name="Web Shell",
                node_type=NodeType.PAYLOAD,
                description="Deploy web shell for persistence",
                technique_id="T1505.003",
                tactic="persistence",
                requires=["web_access", "file_write"],
                provides=["persistent_access", "command_execution"],
                success_probability=0.8,
                detection_risk=0.4
            ),
            
            # Privilege Escalation
            "kernel_exploit": ChainNode(
                node_id="kernel_exploit",
                name="Kernel Exploit",
                node_type=NodeType.PRIVILEGE_ESCALATION,
                description="Exploit kernel vulnerability for root",
                technique_id="T1068",
                tactic="privilege-escalation",
                requires=["shell_access"],
                provides=["root_access", "elevated_privileges"],
                success_probability=0.4,
                detection_risk=0.6
            ),
            "sudo_exploit": ChainNode(
                node_id="sudo_exploit",
                name="Sudo Misconfiguration",
                node_type=NodeType.PRIVILEGE_ESCALATION,
                description="Exploit sudo misconfiguration",
                technique_id="T1548.003",
                tactic="privilege-escalation",
                requires=["shell_access"],
                provides=["root_access"],
                success_probability=0.5,
                detection_risk=0.3
            ),
            "token_manipulation": ChainNode(
                node_id="token_manipulation",
                name="Token Manipulation",
                node_type=NodeType.PRIVILEGE_ESCALATION,
                description="Manipulate access tokens",
                technique_id="T1134",
                tactic="privilege-escalation",
                requires=["shell_access"],
                provides=["elevated_privileges"],
                success_probability=0.6,
                detection_risk=0.4
            ),
            
            # Lateral Movement
            "pass_the_hash": ChainNode(
                node_id="pass_the_hash",
                name="Pass the Hash",
                node_type=NodeType.LATERAL_MOVEMENT,
                description="Use NTLM hashes for lateral movement",
                technique_id="T1550.002",
                tactic="lateral-movement",
                requires=["credential_hashes", "network_access"],
                provides=["remote_access", "domain_access"],
                success_probability=0.7,
                detection_risk=0.5
            ),
            "psexec": ChainNode(
                node_id="psexec",
                name="PsExec",
                node_type=NodeType.LATERAL_MOVEMENT,
                description="Remote execution via PsExec",
                technique_id="T1569.002",
                tactic="lateral-movement",
                requires=["admin_credentials", "smb_access"],
                provides=["remote_shell", "code_execution"],
                success_probability=0.8,
                detection_risk=0.7
            ),
            "ssh_pivot": ChainNode(
                node_id="ssh_pivot",
                name="SSH Pivoting",
                node_type=NodeType.LATERAL_MOVEMENT,
                description="Pivot through SSH connections",
                technique_id="T1021.004",
                tactic="lateral-movement",
                requires=["ssh_credentials", "network_access"],
                provides=["remote_shell", "network_tunnel"],
                success_probability=0.9,
                detection_risk=0.2
            ),
            
            # Persistence
            "scheduled_task": ChainNode(
                node_id="scheduled_task",
                name="Scheduled Task",
                node_type=NodeType.PERSISTENCE,
                description="Create scheduled task for persistence",
                technique_id="T1053.005",
                tactic="persistence",
                requires=["elevated_privileges"],
                provides=["persistent_access"],
                success_probability=0.9,
                detection_risk=0.4
            ),
            "registry_run_key": ChainNode(
                node_id="registry_run_key",
                name="Registry Run Key",
                node_type=NodeType.PERSISTENCE,
                description="Add registry run key",
                technique_id="T1547.001",
                tactic="persistence",
                requires=["windows_access"],
                provides=["persistent_access"],
                success_probability=0.9,
                detection_risk=0.5
            ),
            "cron_job": ChainNode(
                node_id="cron_job",
                name="Cron Job",
                node_type=NodeType.PERSISTENCE,
                description="Create cron job for persistence",
                technique_id="T1053.003",
                tactic="persistence",
                requires=["linux_access"],
                provides=["persistent_access"],
                success_probability=0.9,
                detection_risk=0.3
            ),
            
            # Data Access
            "credential_dump": ChainNode(
                node_id="credential_dump",
                name="Credential Dumping",
                node_type=NodeType.DATA_ACCESS,
                description="Dump credentials from memory/registry",
                technique_id="T1003",
                tactic="credential-access",
                requires=["elevated_privileges"],
                provides=["credential_hashes", "cleartext_credentials"],
                success_probability=0.8,
                detection_risk=0.7
            ),
            "database_dump": ChainNode(
                node_id="database_dump",
                name="Database Exfiltration",
                node_type=NodeType.DATA_ACCESS,
                description="Extract data from database",
                technique_id="T1005",
                tactic="collection",
                requires=["database_access"],
                provides=["sensitive_data", "pii_data"],
                success_probability=0.9,
                detection_risk=0.4
            ),
            
            # Exfiltration
            "http_exfil": ChainNode(
                node_id="http_exfil",
                name="HTTP Exfiltration",
                node_type=NodeType.EXFILTRATION,
                description="Exfiltrate data over HTTP/HTTPS",
                technique_id="T1048.002",
                tactic="exfiltration",
                requires=["data_collected", "outbound_http"],
                provides=["data_exfiltrated"],
                success_probability=0.8,
                detection_risk=0.5
            ),
            "dns_exfil": ChainNode(
                node_id="dns_exfil",
                name="DNS Exfiltration",
                node_type=NodeType.EXFILTRATION,
                description="Exfiltrate data over DNS",
                technique_id="T1048.003",
                tactic="exfiltration",
                requires=["data_collected", "dns_access"],
                provides=["data_exfiltrated"],
                success_probability=0.9,
                detection_risk=0.2
            ),
            
            # C2
            "establish_c2": ChainNode(
                node_id="establish_c2",
                name="Establish C2 Channel",
                node_type=NodeType.COMMAND_CONTROL,
                description="Establish command and control channel",
                technique_id="T1071",
                tactic="command-and-control",
                requires=["code_execution", "network_access"],
                provides=["c2_channel", "remote_control"],
                success_probability=0.7,
                detection_risk=0.6
            ),
            
            # Objectives
            "domain_admin": ChainNode(
                node_id="domain_admin",
                name="Domain Admin Access",
                node_type=NodeType.OBJECTIVE,
                description="Achieve domain administrator access",
                technique_id="T1078.002",
                tactic="persistence",
                requires=["domain_access", "elevated_privileges"],
                provides=["domain_admin", "full_control"],
                success_probability=0.5,
                detection_risk=0.8
            ),
            "data_theft": ChainNode(
                node_id="data_theft",
                name="Data Theft Complete",
                node_type=NodeType.OBJECTIVE,
                description="Successfully exfiltrate target data",
                technique_id="T1041",
                tactic="exfiltration",
                requires=["data_exfiltrated"],
                provides=["mission_complete"],
                success_probability=0.9,
                detection_risk=0.3
            ),
            "ransomware_deploy": ChainNode(
                node_id="ransomware_deploy",
                name="Ransomware Deployment",
                node_type=NodeType.OBJECTIVE,
                description="Deploy ransomware across network",
                technique_id="T1486",
                tactic="impact",
                requires=["domain_admin", "network_access"],
                provides=["mission_complete"],
                success_probability=0.8,
                detection_risk=0.9
            ),
        }
    
    def _load_templates(self):
        """Load pre-built chain templates"""
        self.templates = {
            "web_to_shell": ChainTemplate(
                template_id="web_to_shell",
                name="Web App to Shell",
                description="Exploit web application to gain shell access",
                category="initial_access",
                chain_definition={
                    "nodes": ["exploit_public_app", "sql_injection", "web_shell", "reverse_shell"],
                    "edges": [
                        {"source": "exploit_public_app", "target": "sql_injection"},
                        {"source": "sql_injection", "target": "web_shell"},
                        {"source": "web_shell", "target": "reverse_shell"}
                    ]
                },
                variables=[
                    {"name": "target_url", "type": "string", "description": "Target web application URL"},
                    {"name": "callback_host", "type": "string", "description": "Callback host for reverse shell"}
                ],
                difficulty=ChainComplexity.MODERATE,
                use_cases=["Web application pentesting", "Initial access demonstration"],
                created_by="HydraRecon"
            ),
            "domain_takeover": ChainTemplate(
                template_id="domain_takeover",
                name="Domain Takeover",
                description="Full domain compromise chain",
                category="full_compromise",
                chain_definition={
                    "nodes": ["phishing_email", "meterpreter", "credential_dump", "pass_the_hash", "domain_admin"],
                    "edges": [
                        {"source": "phishing_email", "target": "meterpreter"},
                        {"source": "meterpreter", "target": "credential_dump"},
                        {"source": "credential_dump", "target": "pass_the_hash"},
                        {"source": "pass_the_hash", "target": "domain_admin"}
                    ]
                },
                variables=[
                    {"name": "target_email", "type": "string", "description": "Target user email"},
                    {"name": "domain_controller", "type": "string", "description": "Domain controller IP"}
                ],
                difficulty=ChainComplexity.DIFFICULT,
                use_cases=["Red team exercises", "Domain security assessment"],
                created_by="HydraRecon"
            ),
            "data_exfil": ChainTemplate(
                template_id="data_exfil",
                name="Data Exfiltration",
                description="Access and exfiltrate sensitive data",
                category="data_theft",
                chain_definition={
                    "nodes": ["exploit_public_app", "rce_vuln", "reverse_shell", "database_dump", "dns_exfil", "data_theft"],
                    "edges": [
                        {"source": "exploit_public_app", "target": "rce_vuln"},
                        {"source": "rce_vuln", "target": "reverse_shell"},
                        {"source": "reverse_shell", "target": "database_dump"},
                        {"source": "database_dump", "target": "dns_exfil"},
                        {"source": "dns_exfil", "target": "data_theft"}
                    ]
                },
                variables=[
                    {"name": "target_app", "type": "string", "description": "Target application"},
                    {"name": "exfil_domain", "type": "string", "description": "DNS exfiltration domain"}
                ],
                difficulty=ChainComplexity.DIFFICULT,
                use_cases=["Data breach simulation", "Exfiltration testing"],
                created_by="HydraRecon"
            ),
            "linux_privesc": ChainTemplate(
                template_id="linux_privesc",
                name="Linux Privilege Escalation",
                description="Escalate privileges on Linux system",
                category="privilege_escalation",
                chain_definition={
                    "nodes": ["reverse_shell", "sudo_exploit", "cron_job", "credential_dump"],
                    "edges": [
                        {"source": "reverse_shell", "target": "sudo_exploit"},
                        {"source": "sudo_exploit", "target": "cron_job"},
                        {"source": "sudo_exploit", "target": "credential_dump"}
                    ]
                },
                variables=[
                    {"name": "initial_shell", "type": "string", "description": "Initial shell connection"}
                ],
                difficulty=ChainComplexity.MODERATE,
                use_cases=["Linux security assessment", "Privilege escalation training"],
                created_by="HydraRecon"
            ),
        }
    
    def create_chain(self, name: str, description: str, author: str) -> ExploitChain:
        """Create a new exploit chain"""
        chain = ExploitChain(
            chain_id=str(uuid.uuid4()),
            name=name,
            description=description,
            author=author,
            created_at=datetime.now(),
            modified_at=datetime.now(),
            nodes=[],
            edges=[],
            target_type="",
            objective="",
            complexity=ChainComplexity.MODERATE,
            estimated_duration=0,
            success_rate=0.0,
            detection_rate=0.0
        )
        
        self.chains[chain.chain_id] = chain
        return chain
    
    def add_node(self, chain_id: str, node: ChainNode) -> bool:
        """Add a node to the chain"""
        if chain_id not in self.chains:
            return False
        
        chain = self.chains[chain_id]
        chain.nodes.append(node)
        chain.modified_at = datetime.now()
        self._recalculate_chain_metrics(chain)
        return True
    
    def add_node_from_library(self, chain_id: str, library_node_id: str,
                              position_x: int = 0, position_y: int = 0) -> Optional[ChainNode]:
        """Add a node from the library to the chain"""
        if library_node_id not in self.node_library:
            return None
        
        template = self.node_library[library_node_id]
        node = ChainNode(
            node_id=str(uuid.uuid4()),
            name=template.name,
            node_type=template.node_type,
            description=template.description,
            technique_id=template.technique_id,
            tactic=template.tactic,
            prerequisites=template.prerequisites.copy(),
            provides=template.provides.copy(),
            requires=template.requires.copy(),
            success_probability=template.success_probability,
            detection_risk=template.detection_risk,
            time_estimate_seconds=template.time_estimate_seconds,
            automated=template.automated,
            payload=template.payload,
            parameters=template.parameters.copy(),
            position_x=position_x,
            position_y=position_y
        )
        
        if self.add_node(chain_id, node):
            return node
        return None
    
    def add_edge(self, chain_id: str, source_node_id: str, target_node_id: str,
                 condition: str = "", on_success: bool = True, on_failure: bool = False) -> Optional[ChainEdge]:
        """Add an edge connecting two nodes"""
        if chain_id not in self.chains:
            return None
        
        chain = self.chains[chain_id]
        
        # Verify nodes exist
        source_exists = any(n.node_id == source_node_id for n in chain.nodes)
        target_exists = any(n.node_id == target_node_id for n in chain.nodes)
        
        if not source_exists or not target_exists:
            return None
        
        edge = ChainEdge(
            edge_id=str(uuid.uuid4()),
            source_node_id=source_node_id,
            target_node_id=target_node_id,
            condition=condition,
            on_success=on_success,
            on_failure=on_failure
        )
        
        chain.edges.append(edge)
        chain.modified_at = datetime.now()
        return edge
    
    def remove_node(self, chain_id: str, node_id: str) -> bool:
        """Remove a node and its connected edges"""
        if chain_id not in self.chains:
            return False
        
        chain = self.chains[chain_id]
        chain.nodes = [n for n in chain.nodes if n.node_id != node_id]
        chain.edges = [e for e in chain.edges 
                      if e.source_node_id != node_id and e.target_node_id != node_id]
        chain.modified_at = datetime.now()
        self._recalculate_chain_metrics(chain)
        return True
    
    def remove_edge(self, chain_id: str, edge_id: str) -> bool:
        """Remove an edge"""
        if chain_id not in self.chains:
            return False
        
        chain = self.chains[chain_id]
        chain.edges = [e for e in chain.edges if e.edge_id != edge_id]
        chain.modified_at = datetime.now()
        return True
    
    def _recalculate_chain_metrics(self, chain: ExploitChain):
        """Recalculate chain metrics"""
        if not chain.nodes:
            chain.estimated_duration = 0
            chain.success_rate = 0.0
            chain.detection_rate = 0.0
            chain.complexity = ChainComplexity.TRIVIAL
            return
        
        # Calculate total duration
        chain.estimated_duration = sum(n.time_estimate_seconds for n in chain.nodes)
        
        # Calculate success rate (product of individual probabilities)
        chain.success_rate = 1.0
        for node in chain.nodes:
            chain.success_rate *= node.success_probability
        
        # Calculate detection rate (1 - product of non-detection)
        non_detection = 1.0
        for node in chain.nodes:
            non_detection *= (1 - node.detection_risk)
        chain.detection_rate = 1 - non_detection
        
        # Determine complexity
        node_count = len(chain.nodes)
        if node_count <= 2:
            chain.complexity = ChainComplexity.TRIVIAL
        elif node_count <= 4:
            chain.complexity = ChainComplexity.EASY
        elif node_count <= 6:
            chain.complexity = ChainComplexity.MODERATE
        elif node_count <= 8:
            chain.complexity = ChainComplexity.DIFFICULT
        elif node_count <= 12:
            chain.complexity = ChainComplexity.EXPERT
        else:
            chain.complexity = ChainComplexity.NATION_STATE
        
        # Extract MITRE tactics and techniques
        chain.mitre_tactics = list(set(n.tactic for n in chain.nodes if n.tactic))
        chain.mitre_techniques = list(set(n.technique_id for n in chain.nodes if n.technique_id))
    
    def validate_chain(self, chain_id: str) -> Dict[str, Any]:
        """Validate a chain for completeness and correctness"""
        if chain_id not in self.chains:
            return {"valid": False, "errors": ["Chain not found"]}
        
        chain = self.chains[chain_id]
        errors = []
        warnings = []
        
        # Check for entry point
        entry_points = [n for n in chain.nodes if n.node_type == NodeType.ENTRY_POINT]
        if not entry_points:
            errors.append("Chain must have at least one entry point")
        
        # Check for objective
        objectives = [n for n in chain.nodes if n.node_type == NodeType.OBJECTIVE]
        if not objectives:
            warnings.append("Chain has no defined objective")
        
        # Check node connectivity
        connected_nodes = set()
        if chain.edges:
            for edge in chain.edges:
                connected_nodes.add(edge.source_node_id)
                connected_nodes.add(edge.target_node_id)
        
        orphan_nodes = [n for n in chain.nodes if n.node_id not in connected_nodes and len(chain.nodes) > 1]
        if orphan_nodes:
            warnings.append(f"{len(orphan_nodes)} node(s) are not connected")
        
        # Check capability requirements
        available_capabilities = set()
        for node in chain.nodes:
            missing = set(node.requires) - available_capabilities
            if missing:
                warnings.append(f"Node '{node.name}' requires unavailable capabilities: {missing}")
            available_capabilities.update(node.provides)
        
        # Check for cycles (simplified)
        # In production, use proper cycle detection algorithm
        
        return {
            "valid": len(errors) == 0,
            "errors": errors,
            "warnings": warnings,
            "metrics": {
                "node_count": len(chain.nodes),
                "edge_count": len(chain.edges),
                "estimated_duration": chain.estimated_duration,
                "success_rate": chain.success_rate,
                "detection_rate": chain.detection_rate,
                "complexity": chain.complexity.value
            }
        }
    
    def create_from_template(self, template_id: str, name: str, 
                            variables: Dict[str, str] = None) -> Optional[ExploitChain]:
        """Create a chain from a template"""
        if template_id not in self.templates:
            return None
        
        template = self.templates[template_id]
        chain = self.create_chain(name, template.description, template.created_by)
        
        # Add nodes from template
        node_mapping = {}  # Old node ID -> New node ID
        for node_id in template.chain_definition.get("nodes", []):
            new_node = self.add_node_from_library(chain.chain_id, node_id)
            if new_node:
                node_mapping[node_id] = new_node.node_id
        
        # Add edges from template
        for edge_def in template.chain_definition.get("edges", []):
            source = node_mapping.get(edge_def["source"])
            target = node_mapping.get(edge_def["target"])
            if source and target:
                self.add_edge(chain.chain_id, source, target)
        
        return chain
    
    async def execute_chain(self, chain_id: str, dry_run: bool = False) -> ExecutionResult:
        """Execute an exploit chain"""
        if chain_id not in self.chains:
            raise ValueError("Chain not found")
        
        chain = self.chains[chain_id]
        execution_id = str(uuid.uuid4())
        
        result = ExecutionResult(
            execution_id=execution_id,
            chain_id=chain_id,
            started_at=datetime.now(),
            completed_at=None,
            status=ExecutionStatus.RUNNING,
            nodes_executed=0,
            nodes_successful=0,
            nodes_failed=0,
            current_node=None,
            execution_log=[],
            artifacts={},
            total_duration=0.0
        )
        
        self.active_executions[execution_id] = result
        
        # Build execution order (topological sort)
        execution_order = self._get_execution_order(chain)
        
        for node in execution_order:
            result.current_node = node.node_id
            result.execution_log.append({
                "timestamp": datetime.now().isoformat(),
                "node_id": node.node_id,
                "node_name": node.name,
                "action": "starting"
            })
            
            if dry_run:
                # Simulate execution
                node.status = ExecutionStatus.SUCCESS
                result.nodes_successful += 1
            else:
                # Execute node
                success = await self._execute_node(node, result)
                if success:
                    node.status = ExecutionStatus.SUCCESS
                    result.nodes_successful += 1
                else:
                    node.status = ExecutionStatus.FAILED
                    result.nodes_failed += 1
                    
                    # Check if we should continue
                    if not self._should_continue_after_failure(chain, node):
                        break
            
            result.nodes_executed += 1
            result.execution_log.append({
                "timestamp": datetime.now().isoformat(),
                "node_id": node.node_id,
                "node_name": node.name,
                "action": "completed",
                "status": node.status.value
            })
        
        result.completed_at = datetime.now()
        result.total_duration = (result.completed_at - result.started_at).total_seconds()
        result.status = ExecutionStatus.SUCCESS if result.nodes_failed == 0 else ExecutionStatus.FAILED
        result.current_node = None
        
        # Persist result
        await self._persist_execution(result)
        
        return result
    
    def _get_execution_order(self, chain: ExploitChain) -> List[ChainNode]:
        """Get topological execution order for nodes"""
        # Simple topological sort based on edges
        in_degree = {n.node_id: 0 for n in chain.nodes}
        adjacency = {n.node_id: [] for n in chain.nodes}
        
        for edge in chain.edges:
            adjacency[edge.source_node_id].append(edge.target_node_id)
            in_degree[edge.target_node_id] += 1
        
        queue = [n for n in chain.nodes if in_degree[n.node_id] == 0]
        order = []
        
        while queue:
            node = queue.pop(0)
            order.append(node)
            
            for next_id in adjacency[node.node_id]:
                in_degree[next_id] -= 1
                if in_degree[next_id] == 0:
                    next_node = next((n for n in chain.nodes if n.node_id == next_id), None)
                    if next_node:
                        queue.append(next_node)
        
        return order
    
    async def _execute_node(self, node: ChainNode, result: ExecutionResult) -> bool:
        """Execute a single node"""
        import random
        
        # Simulate execution time
        await asyncio.sleep(0.1)  # Minimal delay for demo
        
        # Probability-based success
        success = random.random() < node.success_probability
        
        if success:
            node.output = {
                "success": True,
                "message": f"Successfully executed {node.name}",
                "capabilities_gained": node.provides
            }
        else:
            node.output = {
                "success": False,
                "message": f"Failed to execute {node.name}",
                "error": "Simulated failure"
            }
        
        return success
    
    def _should_continue_after_failure(self, chain: ExploitChain, failed_node: ChainNode) -> bool:
        """Determine if chain should continue after node failure"""
        # Check if there are alternative paths
        for edge in chain.edges:
            if edge.source_node_id == failed_node.node_id and edge.on_failure:
                return True
        return False
    
    async def _persist_execution(self, result: ExecutionResult):
        """Persist execution result to database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute("""
            INSERT OR REPLACE INTO execution_history VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            result.execution_id,
            result.chain_id,
            result.started_at.isoformat(),
            result.completed_at.isoformat() if result.completed_at else None,
            result.status.value,
            result.nodes_executed,
            result.nodes_successful,
            result.nodes_failed,
            json.dumps(result.execution_log),
            json.dumps(result.artifacts)
        ))
        
        conn.commit()
        conn.close()
    
    def export_chain(self, chain_id: str) -> Dict[str, Any]:
        """Export chain to JSON format"""
        if chain_id not in self.chains:
            return {}
        
        chain = self.chains[chain_id]
        return {
            "chain_id": chain.chain_id,
            "name": chain.name,
            "description": chain.description,
            "author": chain.author,
            "version": chain.version,
            "nodes": [
                {
                    "node_id": n.node_id,
                    "name": n.name,
                    "type": n.node_type.value,
                    "technique_id": n.technique_id,
                    "position": {"x": n.position_x, "y": n.position_y}
                }
                for n in chain.nodes
            ],
            "edges": [
                {
                    "source": e.source_node_id,
                    "target": e.target_node_id,
                    "condition": e.condition
                }
                for e in chain.edges
            ],
            "metrics": {
                "complexity": chain.complexity.value,
                "success_rate": chain.success_rate,
                "detection_rate": chain.detection_rate,
                "estimated_duration": chain.estimated_duration
            },
            "mitre": {
                "tactics": chain.mitre_tactics,
                "techniques": chain.mitre_techniques
            }
        }
    
    def get_optimization_suggestions(self, chain_id: str) -> List[Dict[str, str]]:
        """Get suggestions to optimize the chain"""
        if chain_id not in self.chains:
            return []
        
        chain = self.chains[chain_id]
        suggestions = []
        
        # Check for high detection risk
        high_detection_nodes = [n for n in chain.nodes if n.detection_risk > 0.7]
        if high_detection_nodes:
            for node in high_detection_nodes:
                suggestions.append({
                    "type": "detection_risk",
                    "severity": "high",
                    "message": f"Node '{node.name}' has {node.detection_risk*100:.0f}% detection risk",
                    "suggestion": "Consider using stealthier alternatives"
                })
        
        # Check for low success probability paths
        if chain.success_rate < 0.2:
            suggestions.append({
                "type": "success_rate",
                "severity": "high",
                "message": f"Overall chain success rate is only {chain.success_rate*100:.0f}%",
                "suggestion": "Add alternative paths or more reliable techniques"
            })
        
        # Check for missing persistence
        persistence_nodes = [n for n in chain.nodes if n.node_type == NodeType.PERSISTENCE]
        if not persistence_nodes and len(chain.nodes) > 3:
            suggestions.append({
                "type": "persistence",
                "severity": "medium",
                "message": "No persistence mechanism in chain",
                "suggestion": "Add a persistence node to maintain access"
            })
        
        # Check for missing C2
        c2_nodes = [n for n in chain.nodes if n.node_type == NodeType.COMMAND_CONTROL]
        objectives = [n for n in chain.nodes if n.node_type == NodeType.OBJECTIVE]
        if objectives and not c2_nodes:
            suggestions.append({
                "type": "c2",
                "severity": "low",
                "message": "No C2 channel established",
                "suggestion": "Add C2 node for better control during operation"
            })
        
        return suggestions
    
    def get_node_library(self) -> Dict[str, List[ChainNode]]:
        """Get node library organized by type"""
        library = {}
        for node in self.node_library.values():
            type_name = node.node_type.value
            if type_name not in library:
                library[type_name] = []
            library[type_name].append(node)
        return library
    
    def get_templates(self) -> List[ChainTemplate]:
        """Get all available templates"""
        return list(self.templates.values())
    
    def save_chain(self, chain_id: str) -> bool:
        """Save chain to database"""
        if chain_id not in self.chains:
            return False
        
        chain = self.chains[chain_id]
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute("""
            INSERT OR REPLACE INTO exploit_chains VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            chain.chain_id,
            chain.name,
            chain.description,
            chain.author,
            chain.created_at.isoformat(),
            chain.modified_at.isoformat(),
            json.dumps(self.export_chain(chain_id)),
            chain.target_type,
            chain.objective,
            chain.complexity.value,
            chain.status.value,
            chain.version
        ))
        
        conn.commit()
        conn.close()
        return True
