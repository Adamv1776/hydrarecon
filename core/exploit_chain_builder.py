"""
HydraRecon Exploit Chain Builder
Visual drag-and-drop attack path orchestration with automated chaining

Features:
- Visual chain construction with drag-and-drop
- MITRE ATT&CK framework integration
- Automated chain validation and optimization
- Real-time execution with rollback capabilities
- AI-powered chain suggestions
- Risk scoring and detection probability
- Export to multiple formats (JSON, YAML, ATT&CK Navigator)
- Chain versioning and collaboration
"""

import asyncio
import json
import sqlite3
import uuid
import copy
import yaml
import re
from datetime import datetime
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any, Set, Tuple, Callable
from enum import Enum
from pathlib import Path
import hashlib
import logging

logger = logging.getLogger(__name__)


class NodeType(Enum):
    """Types of nodes in exploit chain"""
    ENTRY_POINT = "entry_point"
    RECONNAISSANCE = "reconnaissance"
    VULNERABILITY = "vulnerability"
    EXPLOIT = "exploit"
    PAYLOAD = "payload"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    DEFENSE_EVASION = "defense_evasion"
    CREDENTIAL_ACCESS = "credential_access"
    LATERAL_MOVEMENT = "lateral_movement"
    PERSISTENCE = "persistence"
    DATA_ACCESS = "data_access"
    COLLECTION = "collection"
    EXFILTRATION = "exfiltration"
    COMMAND_CONTROL = "command_control"
    IMPACT = "impact"
    OBJECTIVE = "objective"
    CONDITION = "condition"
    DECISION = "decision"
    CLEANUP = "cleanup"
    VALIDATOR = "validator"


class ExecutionStatus(Enum):
    """Status of chain execution"""
    PENDING = "pending"
    RUNNING = "running"
    SUCCESS = "success"
    FAILED = "failed"
    BLOCKED = "blocked"
    SKIPPED = "skipped"
    TIMEOUT = "timeout"


class ChainComplexity(Enum):
    """Complexity rating for exploit chains"""
    TRIVIAL = "trivial"
    EASY = "easy"
    MODERATE = "moderate"
    DIFFICULT = "difficult"
    EXPERT = "expert"
    NATION_STATE = "nation_state"


@dataclass
class ChainNode:
    """A node in the exploit chain"""
    node_id: str
    name: str
    node_type: NodeType
    description: str
    technique_id: str = ""  # MITRE ATT&CK technique
    tactic: str = ""
    prerequisites: List[str] = field(default_factory=list)  # Required node IDs
    provides: List[str] = field(default_factory=list)  # Capabilities provided
    requires: List[str] = field(default_factory=list)  # Capabilities required
    success_probability: float = 0.8
    detection_risk: float = 0.3
    time_estimate_seconds: int = 60
    automated: bool = True
    payload: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    position_x: int = 0
    position_y: int = 0
    status: ExecutionStatus = ExecutionStatus.PENDING
    output: Dict[str, Any] = field(default_factory=dict)
    # New fields
    rollback_action: str = ""  # Command/action to rollback this node
    validators: List[str] = field(default_factory=list)  # Validation checks
    retry_count: int = 3  # Number of retries on failure
    timeout_seconds: int = 300  # Timeout for node execution
    environment: Dict[str, str] = field(default_factory=dict)  # Environment variables
    artifacts: List[str] = field(default_factory=list)  # Artifacts produced
    notes: str = ""  # User notes
    color: str = ""  # UI color override
    icon: str = ""  # UI icon


@dataclass
class ChainEdge:
    """Connection between nodes"""
    edge_id: str
    source_node_id: str
    target_node_id: str
    condition: str = ""  # Condition for traversal
    on_success: bool = True  # Traverse on success
    on_failure: bool = False  # Traverse on failure
    delay_seconds: int = 0
    metadata: Dict[str, Any] = field(default_factory=dict)
    # New fields
    probability: float = 1.0  # Probability of taking this edge
    label: str = ""  # Edge label for UI
    style: str = "solid"  # solid, dashed, dotted
    color: str = ""  # Edge color
    data_transform: str = ""  # Transform data between nodes


@dataclass
class ExploitChain:
    """Complete exploit chain definition"""
    chain_id: str
    name: str
    description: str
    author: str
    created_at: datetime
    modified_at: datetime
    nodes: List[ChainNode]
    edges: List[ChainEdge]
    target_type: str
    objective: str
    complexity: ChainComplexity
    estimated_duration: int  # seconds
    success_rate: float
    detection_rate: float
    mitre_tactics: List[str] = field(default_factory=list)
    mitre_techniques: List[str] = field(default_factory=list)
    tags: List[str] = field(default_factory=list)
    version: str = "1.0"
    status: ExecutionStatus = ExecutionStatus.PENDING
    # New fields
    parent_chain_id: Optional[str] = None  # For versioning
    locked: bool = False  # Prevent edits
    execution_history: List[str] = field(default_factory=list)  # Execution IDs
    risk_score: float = 0.0  # Overall risk assessment
    prerequisites: List[str] = field(default_factory=list)  # Required conditions
    post_conditions: List[str] = field(default_factory=list)  # Expected state after execution
    notes: str = ""  # User documentation
    
    def clone(self) -> 'ExploitChain':
        """Create a deep copy of this chain with new IDs"""
        import copy as copy_module
        import uuid
        new_chain = copy_module.deepcopy(self)
        new_chain.chain_id = str(uuid.uuid4())
        new_chain.parent_chain_id = self.chain_id
        new_chain.version = f"{float(self.version) + 0.1:.1f}"
        new_chain.created_at = datetime.now()
        new_chain.modified_at = datetime.now()
        new_chain.locked = False
        new_chain.execution_history = []
        return new_chain


@dataclass
class ChainTemplate:
    """Pre-built chain template"""
    template_id: str
    name: str
    description: str
    category: str
    chain_definition: Dict[str, Any]
    variables: List[Dict[str, str]]
    difficulty: ChainComplexity
    use_cases: List[str]
    created_by: str


@dataclass
class ExecutionResult:
    """Result of chain execution"""
    execution_id: str
    chain_id: str
    started_at: datetime
    completed_at: Optional[datetime]
    status: ExecutionStatus
    nodes_executed: int
    nodes_successful: int
    nodes_failed: int
    current_node: Optional[str]
    execution_log: List[Dict[str, Any]]
    artifacts: Dict[str, Any]
    total_duration: float


class ExploitChainBuilder:
    """
    Visual exploit chain builder with automated execution
    
    Features:
    - Drag-and-drop chain construction
    - MITRE ATT&CK mapping
    - Automated chain validation
    - Probability-based execution
    - Detection risk assessment
    - Chain optimization suggestions
    - Template library
    - Real-time execution visualization
    """
    
    def __init__(self, db_path: str = "exploit_chains.db"):
        self.db_path = db_path
        self.chains: Dict[str, ExploitChain] = {}
        self.templates: Dict[str, ChainTemplate] = {}
        self.active_executions: Dict[str, ExecutionResult] = {}
        self.node_library: Dict[str, ChainNode] = {}
        self._initialize_database()
        self._load_node_library()
        self._load_templates()
    
    def _initialize_database(self):
        """Initialize the database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS exploit_chains (
                chain_id TEXT PRIMARY KEY,
                name TEXT NOT NULL,
                description TEXT,
                author TEXT,
                created_at TIMESTAMP,
                modified_at TIMESTAMP,
                chain_data TEXT,
                target_type TEXT,
                objective TEXT,
                complexity TEXT,
                status TEXT,
                version TEXT
            )
        """)
        
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS chain_templates (
                template_id TEXT PRIMARY KEY,
                name TEXT NOT NULL,
                description TEXT,
                category TEXT,
                chain_definition TEXT,
                variables TEXT,
                difficulty TEXT,
                use_cases TEXT,
                created_by TEXT
            )
        """)
        
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS execution_history (
                execution_id TEXT PRIMARY KEY,
                chain_id TEXT,
                started_at TIMESTAMP,
                completed_at TIMESTAMP,
                status TEXT,
                nodes_executed INTEGER,
                nodes_successful INTEGER,
                nodes_failed INTEGER,
                execution_log TEXT,
                artifacts TEXT
            )
        """)
        
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS node_library (
                node_id TEXT PRIMARY KEY,
                name TEXT NOT NULL,
                node_type TEXT,
                description TEXT,
                technique_id TEXT,
                tactic TEXT,
                provides TEXT,
                requires TEXT,
                payload TEXT,
                parameters TEXT
            )
        """)
        
        conn.commit()
        conn.close()
    
    def _load_node_library(self):
        """Load the pre-built node library"""
        self.node_library = {
            # Entry Points
            "phishing_email": ChainNode(
                node_id="phishing_email",
                name="Phishing Email",
                node_type=NodeType.ENTRY_POINT,
                description="Send crafted phishing email to target",
                technique_id="T1566.001",
                tactic="initial-access",
                provides=["user_interaction", "initial_access"],
                success_probability=0.25,
                detection_risk=0.4
            ),
            "exploit_public_app": ChainNode(
                node_id="exploit_public_app",
                name="Exploit Public Application",
                node_type=NodeType.ENTRY_POINT,
                description="Exploit vulnerability in public-facing application",
                technique_id="T1190",
                tactic="initial-access",
                provides=["web_shell", "initial_access"],
                success_probability=0.6,
                detection_risk=0.5
            ),
            "drive_by_download": ChainNode(
                node_id="drive_by_download",
                name="Drive-by Download",
                node_type=NodeType.ENTRY_POINT,
                description="Compromise through malicious website",
                technique_id="T1189",
                tactic="initial-access",
                provides=["browser_access", "initial_access"],
                success_probability=0.3,
                detection_risk=0.6
            ),
            "supply_chain": ChainNode(
                node_id="supply_chain",
                name="Supply Chain Compromise",
                node_type=NodeType.ENTRY_POINT,
                description="Compromise through trusted software",
                technique_id="T1195",
                tactic="initial-access",
                provides=["trusted_access", "initial_access"],
                success_probability=0.2,
                detection_risk=0.1
            ),
            
            # Vulnerabilities
            "sql_injection": ChainNode(
                node_id="sql_injection",
                name="SQL Injection",
                node_type=NodeType.VULNERABILITY,
                description="Exploit SQL injection vulnerability",
                technique_id="T1190",
                tactic="initial-access",
                requires=["web_access"],
                provides=["database_access", "data_extraction"],
                success_probability=0.7,
                detection_risk=0.4
            ),
            "rce_vuln": ChainNode(
                node_id="rce_vuln",
                name="Remote Code Execution",
                node_type=NodeType.VULNERABILITY,
                description="Exploit RCE vulnerability",
                technique_id="T1203",
                tactic="execution",
                requires=["application_access"],
                provides=["code_execution", "shell_access"],
                success_probability=0.5,
                detection_risk=0.6
            ),
            "lfi_vuln": ChainNode(
                node_id="lfi_vuln",
                name="Local File Inclusion",
                node_type=NodeType.VULNERABILITY,
                description="Exploit LFI to read sensitive files",
                technique_id="T1005",
                tactic="collection",
                requires=["web_access"],
                provides=["file_read", "credential_access"],
                success_probability=0.6,
                detection_risk=0.3
            ),
            
            # Exploits
            "metasploit_exploit": ChainNode(
                node_id="metasploit_exploit",
                name="Metasploit Exploit",
                node_type=NodeType.EXPLOIT,
                description="Run Metasploit exploit module",
                technique_id="T1203",
                tactic="execution",
                requires=["vulnerability_identified"],
                provides=["shell_access", "code_execution"],
                success_probability=0.6,
                detection_risk=0.7
            ),
            "custom_exploit": ChainNode(
                node_id="custom_exploit",
                name="Custom Exploit",
                node_type=NodeType.EXPLOIT,
                description="Run custom exploit code",
                technique_id="T1203",
                tactic="execution",
                requires=["vulnerability_identified"],
                provides=["shell_access", "code_execution"],
                success_probability=0.4,
                detection_risk=0.3
            ),
            
            # Payloads
            "reverse_shell": ChainNode(
                node_id="reverse_shell",
                name="Reverse Shell",
                node_type=NodeType.PAYLOAD,
                description="Establish reverse shell connection",
                technique_id="T1059",
                tactic="execution",
                requires=["code_execution"],
                provides=["interactive_shell", "c2_channel"],
                success_probability=0.8,
                detection_risk=0.5
            ),
            "meterpreter": ChainNode(
                node_id="meterpreter",
                name="Meterpreter Session",
                node_type=NodeType.PAYLOAD,
                description="Deploy Meterpreter payload",
                technique_id="T1059.006",
                tactic="execution",
                requires=["code_execution"],
                provides=["interactive_shell", "c2_channel", "post_exploit"],
                success_probability=0.7,
                detection_risk=0.8
            ),
            "web_shell": ChainNode(
                node_id="web_shell",
                name="Web Shell",
                node_type=NodeType.PAYLOAD,
                description="Deploy web shell for persistence",
                technique_id="T1505.003",
                tactic="persistence",
                requires=["web_access", "file_write"],
                provides=["persistent_access", "command_execution"],
                success_probability=0.8,
                detection_risk=0.4
            ),
            
            # Privilege Escalation
            "kernel_exploit": ChainNode(
                node_id="kernel_exploit",
                name="Kernel Exploit",
                node_type=NodeType.PRIVILEGE_ESCALATION,
                description="Exploit kernel vulnerability for root",
                technique_id="T1068",
                tactic="privilege-escalation",
                requires=["shell_access"],
                provides=["root_access", "elevated_privileges"],
                success_probability=0.4,
                detection_risk=0.6
            ),
            "sudo_exploit": ChainNode(
                node_id="sudo_exploit",
                name="Sudo Misconfiguration",
                node_type=NodeType.PRIVILEGE_ESCALATION,
                description="Exploit sudo misconfiguration",
                technique_id="T1548.003",
                tactic="privilege-escalation",
                requires=["shell_access"],
                provides=["root_access"],
                success_probability=0.5,
                detection_risk=0.3
            ),
            "token_manipulation": ChainNode(
                node_id="token_manipulation",
                name="Token Manipulation",
                node_type=NodeType.PRIVILEGE_ESCALATION,
                description="Manipulate access tokens",
                technique_id="T1134",
                tactic="privilege-escalation",
                requires=["shell_access"],
                provides=["elevated_privileges"],
                success_probability=0.6,
                detection_risk=0.4
            ),
            
            # Lateral Movement
            "pass_the_hash": ChainNode(
                node_id="pass_the_hash",
                name="Pass the Hash",
                node_type=NodeType.LATERAL_MOVEMENT,
                description="Use NTLM hashes for lateral movement",
                technique_id="T1550.002",
                tactic="lateral-movement",
                requires=["credential_hashes", "network_access"],
                provides=["remote_access", "domain_access"],
                success_probability=0.7,
                detection_risk=0.5
            ),
            "psexec": ChainNode(
                node_id="psexec",
                name="PsExec",
                node_type=NodeType.LATERAL_MOVEMENT,
                description="Remote execution via PsExec",
                technique_id="T1569.002",
                tactic="lateral-movement",
                requires=["admin_credentials", "smb_access"],
                provides=["remote_shell", "code_execution"],
                success_probability=0.8,
                detection_risk=0.7
            ),
            "ssh_pivot": ChainNode(
                node_id="ssh_pivot",
                name="SSH Pivoting",
                node_type=NodeType.LATERAL_MOVEMENT,
                description="Pivot through SSH connections",
                technique_id="T1021.004",
                tactic="lateral-movement",
                requires=["ssh_credentials", "network_access"],
                provides=["remote_shell", "network_tunnel"],
                success_probability=0.9,
                detection_risk=0.2
            ),
            
            # Persistence
            "scheduled_task": ChainNode(
                node_id="scheduled_task",
                name="Scheduled Task",
                node_type=NodeType.PERSISTENCE,
                description="Create scheduled task for persistence",
                technique_id="T1053.005",
                tactic="persistence",
                requires=["elevated_privileges"],
                provides=["persistent_access"],
                success_probability=0.9,
                detection_risk=0.4
            ),
            "registry_run_key": ChainNode(
                node_id="registry_run_key",
                name="Registry Run Key",
                node_type=NodeType.PERSISTENCE,
                description="Add registry run key",
                technique_id="T1547.001",
                tactic="persistence",
                requires=["windows_access"],
                provides=["persistent_access"],
                success_probability=0.9,
                detection_risk=0.5
            ),
            "cron_job": ChainNode(
                node_id="cron_job",
                name="Cron Job",
                node_type=NodeType.PERSISTENCE,
                description="Create cron job for persistence",
                technique_id="T1053.003",
                tactic="persistence",
                requires=["linux_access"],
                provides=["persistent_access"],
                success_probability=0.9,
                detection_risk=0.3
            ),
            
            # Data Access
            "credential_dump": ChainNode(
                node_id="credential_dump",
                name="Credential Dumping",
                node_type=NodeType.DATA_ACCESS,
                description="Dump credentials from memory/registry",
                technique_id="T1003",
                tactic="credential-access",
                requires=["elevated_privileges"],
                provides=["credential_hashes", "cleartext_credentials"],
                success_probability=0.8,
                detection_risk=0.7
            ),
            "database_dump": ChainNode(
                node_id="database_dump",
                name="Database Exfiltration",
                node_type=NodeType.DATA_ACCESS,
                description="Extract data from database",
                technique_id="T1005",
                tactic="collection",
                requires=["database_access"],
                provides=["sensitive_data", "pii_data"],
                success_probability=0.9,
                detection_risk=0.4
            ),
            
            # Exfiltration
            "http_exfil": ChainNode(
                node_id="http_exfil",
                name="HTTP Exfiltration",
                node_type=NodeType.EXFILTRATION,
                description="Exfiltrate data over HTTP/HTTPS",
                technique_id="T1048.002",
                tactic="exfiltration",
                requires=["data_collected", "outbound_http"],
                provides=["data_exfiltrated"],
                success_probability=0.8,
                detection_risk=0.5
            ),
            "dns_exfil": ChainNode(
                node_id="dns_exfil",
                name="DNS Exfiltration",
                node_type=NodeType.EXFILTRATION,
                description="Exfiltrate data over DNS",
                technique_id="T1048.003",
                tactic="exfiltration",
                requires=["data_collected", "dns_access"],
                provides=["data_exfiltrated"],
                success_probability=0.9,
                detection_risk=0.2
            ),
            
            # C2
            "establish_c2": ChainNode(
                node_id="establish_c2",
                name="Establish C2 Channel",
                node_type=NodeType.COMMAND_CONTROL,
                description="Establish command and control channel",
                technique_id="T1071",
                tactic="command-and-control",
                requires=["code_execution", "network_access"],
                provides=["c2_channel", "remote_control"],
                success_probability=0.7,
                detection_risk=0.6
            ),
            
            # Objectives
            "domain_admin": ChainNode(
                node_id="domain_admin",
                name="Domain Admin Access",
                node_type=NodeType.OBJECTIVE,
                description="Achieve domain administrator access",
                technique_id="T1078.002",
                tactic="persistence",
                requires=["domain_access", "elevated_privileges"],
                provides=["domain_admin", "full_control"],
                success_probability=0.5,
                detection_risk=0.8
            ),
            "data_theft": ChainNode(
                node_id="data_theft",
                name="Data Theft Complete",
                node_type=NodeType.OBJECTIVE,
                description="Successfully exfiltrate target data",
                technique_id="T1041",
                tactic="exfiltration",
                requires=["data_exfiltrated"],
                provides=["mission_complete"],
                success_probability=0.9,
                detection_risk=0.3
            ),
            "ransomware_deploy": ChainNode(
                node_id="ransomware_deploy",
                name="Ransomware Deployment",
                node_type=NodeType.OBJECTIVE,
                description="Deploy ransomware across network",
                technique_id="T1486",
                tactic="impact",
                requires=["domain_admin", "network_access"],
                provides=["mission_complete"],
                success_probability=0.8,
                detection_risk=0.9
            ),
        }
    
    def _load_templates(self):
        """Load pre-built chain templates"""
        self.templates = {
            "web_to_shell": ChainTemplate(
                template_id="web_to_shell",
                name="Web App to Shell",
                description="Exploit web application to gain shell access",
                category="initial_access",
                chain_definition={
                    "nodes": ["exploit_public_app", "sql_injection", "web_shell", "reverse_shell"],
                    "edges": [
                        {"source": "exploit_public_app", "target": "sql_injection"},
                        {"source": "sql_injection", "target": "web_shell"},
                        {"source": "web_shell", "target": "reverse_shell"}
                    ]
                },
                variables=[
                    {"name": "target_url", "type": "string", "description": "Target web application URL"},
                    {"name": "callback_host", "type": "string", "description": "Callback host for reverse shell"}
                ],
                difficulty=ChainComplexity.MODERATE,
                use_cases=["Web application pentesting", "Initial access demonstration"],
                created_by="HydraRecon"
            ),
            "domain_takeover": ChainTemplate(
                template_id="domain_takeover",
                name="Domain Takeover",
                description="Full domain compromise chain",
                category="full_compromise",
                chain_definition={
                    "nodes": ["phishing_email", "meterpreter", "credential_dump", "pass_the_hash", "domain_admin"],
                    "edges": [
                        {"source": "phishing_email", "target": "meterpreter"},
                        {"source": "meterpreter", "target": "credential_dump"},
                        {"source": "credential_dump", "target": "pass_the_hash"},
                        {"source": "pass_the_hash", "target": "domain_admin"}
                    ]
                },
                variables=[
                    {"name": "target_email", "type": "string", "description": "Target user email"},
                    {"name": "domain_controller", "type": "string", "description": "Domain controller IP"}
                ],
                difficulty=ChainComplexity.DIFFICULT,
                use_cases=["Red team exercises", "Domain security assessment"],
                created_by="HydraRecon"
            ),
            "data_exfil": ChainTemplate(
                template_id="data_exfil",
                name="Data Exfiltration",
                description="Access and exfiltrate sensitive data",
                category="data_theft",
                chain_definition={
                    "nodes": ["exploit_public_app", "rce_vuln", "reverse_shell", "database_dump", "dns_exfil", "data_theft"],
                    "edges": [
                        {"source": "exploit_public_app", "target": "rce_vuln"},
                        {"source": "rce_vuln", "target": "reverse_shell"},
                        {"source": "reverse_shell", "target": "database_dump"},
                        {"source": "database_dump", "target": "dns_exfil"},
                        {"source": "dns_exfil", "target": "data_theft"}
                    ]
                },
                variables=[
                    {"name": "target_app", "type": "string", "description": "Target application"},
                    {"name": "exfil_domain", "type": "string", "description": "DNS exfiltration domain"}
                ],
                difficulty=ChainComplexity.DIFFICULT,
                use_cases=["Data breach simulation", "Exfiltration testing"],
                created_by="HydraRecon"
            ),
            "linux_privesc": ChainTemplate(
                template_id="linux_privesc",
                name="Linux Privilege Escalation",
                description="Escalate privileges on Linux system",
                category="privilege_escalation",
                chain_definition={
                    "nodes": ["reverse_shell", "sudo_exploit", "cron_job", "credential_dump"],
                    "edges": [
                        {"source": "reverse_shell", "target": "sudo_exploit"},
                        {"source": "sudo_exploit", "target": "cron_job"},
                        {"source": "sudo_exploit", "target": "credential_dump"}
                    ]
                },
                variables=[
                    {"name": "initial_shell", "type": "string", "description": "Initial shell connection"}
                ],
                difficulty=ChainComplexity.MODERATE,
                use_cases=["Linux security assessment", "Privilege escalation training"],
                created_by="HydraRecon"
            ),
            # New Advanced Templates
            "cloud_compromise": ChainTemplate(
                template_id="cloud_compromise",
                name="Cloud Infrastructure Compromise",
                description="Compromise cloud infrastructure through misconfiguration",
                category="cloud_attack",
                chain_definition={
                    "nodes": ["exploit_public_app", "rce_vuln", "credential_dump", "establish_c2"],
                    "edges": [
                        {"source": "exploit_public_app", "target": "rce_vuln"},
                        {"source": "rce_vuln", "target": "credential_dump"},
                        {"source": "credential_dump", "target": "establish_c2"}
                    ]
                },
                variables=[
                    {"name": "cloud_provider", "type": "string", "description": "AWS/Azure/GCP"},
                    {"name": "target_service", "type": "string", "description": "Target cloud service"}
                ],
                difficulty=ChainComplexity.DIFFICULT,
                use_cases=["Cloud security assessment", "Multi-cloud penetration testing"],
                created_by="HydraRecon"
            ),
            "insider_threat": ChainTemplate(
                template_id="insider_threat",
                name="Insider Threat Simulation",
                description="Simulate insider threat scenario with elevated access",
                category="insider",
                chain_definition={
                    "nodes": ["token_manipulation", "database_dump", "dns_exfil", "data_theft"],
                    "edges": [
                        {"source": "token_manipulation", "target": "database_dump"},
                        {"source": "database_dump", "target": "dns_exfil"},
                        {"source": "dns_exfil", "target": "data_theft"}
                    ]
                },
                variables=[
                    {"name": "user_role", "type": "string", "description": "Insider role/access level"}
                ],
                difficulty=ChainComplexity.MODERATE,
                use_cases=["Insider threat assessment", "DLP testing"],
                created_by="HydraRecon"
            ),
            "ransomware_simulation": ChainTemplate(
                template_id="ransomware_simulation",
                name="Ransomware Attack Simulation",
                description="Full ransomware attack chain for testing defenses",
                category="ransomware",
                chain_definition={
                    "nodes": ["phishing_email", "meterpreter", "credential_dump", "pass_the_hash", "ransomware_deploy"],
                    "edges": [
                        {"source": "phishing_email", "target": "meterpreter"},
                        {"source": "meterpreter", "target": "credential_dump"},
                        {"source": "credential_dump", "target": "pass_the_hash"},
                        {"source": "pass_the_hash", "target": "ransomware_deploy"}
                    ]
                },
                variables=[
                    {"name": "target_network", "type": "string", "description": "Target network range"},
                    {"name": "backup_check", "type": "boolean", "description": "Check for backups before deploy"}
                ],
                difficulty=ChainComplexity.EXPERT,
                use_cases=["Ransomware readiness assessment", "Incident response training"],
                created_by="HydraRecon"
            ),
            "api_exploitation": ChainTemplate(
                template_id="api_exploitation",
                name="API Security Exploitation",
                description="Exploit vulnerable APIs for data access",
                category="api_attack",
                chain_definition={
                    "nodes": ["exploit_public_app", "sql_injection", "database_dump", "http_exfil"],
                    "edges": [
                        {"source": "exploit_public_app", "target": "sql_injection"},
                        {"source": "sql_injection", "target": "database_dump"},
                        {"source": "database_dump", "target": "http_exfil"}
                    ]
                },
                variables=[
                    {"name": "api_endpoint", "type": "string", "description": "Target API endpoint"},
                    {"name": "auth_bypass", "type": "string", "description": "Authentication bypass method"}
                ],
                difficulty=ChainComplexity.MODERATE,
                use_cases=["API security testing", "OWASP API Top 10 assessment"],
                created_by="HydraRecon"
            ),
            "zero_trust_bypass": ChainTemplate(
                template_id="zero_trust_bypass",
                name="Zero Trust Architecture Bypass",
                description="Test zero trust controls through identity compromise",
                category="identity_attack",
                chain_definition={
                    "nodes": ["phishing_email", "token_manipulation", "ssh_pivot", "credential_dump", "domain_admin"],
                    "edges": [
                        {"source": "phishing_email", "target": "token_manipulation"},
                        {"source": "token_manipulation", "target": "ssh_pivot"},
                        {"source": "ssh_pivot", "target": "credential_dump"},
                        {"source": "credential_dump", "target": "domain_admin"}
                    ]
                },
                variables=[
                    {"name": "identity_provider", "type": "string", "description": "Target IdP (Okta/Azure AD/etc)"},
                    {"name": "mfa_type", "type": "string", "description": "MFA bypass method"}
                ],
                difficulty=ChainComplexity.EXPERT,
                use_cases=["Zero Trust validation", "Identity security assessment"],
                created_by="HydraRecon"
            ),
        }
    
    def create_chain(self, name: str, description: str, author: str) -> ExploitChain:
        """Create a new exploit chain"""
        chain = ExploitChain(
            chain_id=str(uuid.uuid4()),
            name=name,
            description=description,
            author=author,
            created_at=datetime.now(),
            modified_at=datetime.now(),
            nodes=[],
            edges=[],
            target_type="",
            objective="",
            complexity=ChainComplexity.MODERATE,
            estimated_duration=0,
            success_rate=0.0,
            detection_rate=0.0
        )
        
        self.chains[chain.chain_id] = chain
        return chain
    
    def add_node(self, chain_id: str, node: ChainNode) -> bool:
        """Add a node to the chain"""
        if chain_id not in self.chains:
            return False
        
        chain = self.chains[chain_id]
        chain.nodes.append(node)
        chain.modified_at = datetime.now()
        self._recalculate_chain_metrics(chain)
        return True
    
    def add_node_from_library(self, chain_id: str, library_node_id: str,
                              position_x: int = 0, position_y: int = 0) -> Optional[ChainNode]:
        """Add a node from the library to the chain"""
        if library_node_id not in self.node_library:
            return None
        
        template = self.node_library[library_node_id]
        node = ChainNode(
            node_id=str(uuid.uuid4()),
            name=template.name,
            node_type=template.node_type,
            description=template.description,
            technique_id=template.technique_id,
            tactic=template.tactic,
            prerequisites=template.prerequisites.copy(),
            provides=template.provides.copy(),
            requires=template.requires.copy(),
            success_probability=template.success_probability,
            detection_risk=template.detection_risk,
            time_estimate_seconds=template.time_estimate_seconds,
            automated=template.automated,
            payload=template.payload,
            parameters=template.parameters.copy(),
            position_x=position_x,
            position_y=position_y
        )
        
        if self.add_node(chain_id, node):
            return node
        return None
    
    def add_edge(self, chain_id: str, source_node_id: str, target_node_id: str,
                 condition: str = "", on_success: bool = True, on_failure: bool = False) -> Optional[ChainEdge]:
        """Add an edge connecting two nodes"""
        if chain_id not in self.chains:
            return None
        
        chain = self.chains[chain_id]
        
        # Verify nodes exist
        source_exists = any(n.node_id == source_node_id for n in chain.nodes)
        target_exists = any(n.node_id == target_node_id for n in chain.nodes)
        
        if not source_exists or not target_exists:
            return None
        
        edge = ChainEdge(
            edge_id=str(uuid.uuid4()),
            source_node_id=source_node_id,
            target_node_id=target_node_id,
            condition=condition,
            on_success=on_success,
            on_failure=on_failure
        )
        
        chain.edges.append(edge)
        chain.modified_at = datetime.now()
        return edge
    
    def remove_node(self, chain_id: str, node_id: str) -> bool:
        """Remove a node and its connected edges"""
        if chain_id not in self.chains:
            return False
        
        chain = self.chains[chain_id]
        chain.nodes = [n for n in chain.nodes if n.node_id != node_id]
        chain.edges = [e for e in chain.edges 
                      if e.source_node_id != node_id and e.target_node_id != node_id]
        chain.modified_at = datetime.now()
        self._recalculate_chain_metrics(chain)
        return True
    
    def remove_edge(self, chain_id: str, edge_id: str) -> bool:
        """Remove an edge"""
        if chain_id not in self.chains:
            return False
        
        chain = self.chains[chain_id]
        chain.edges = [e for e in chain.edges if e.edge_id != edge_id]
        chain.modified_at = datetime.now()
        return True
    
    def _recalculate_chain_metrics(self, chain: ExploitChain):
        """Recalculate chain metrics"""
        if not chain.nodes:
            chain.estimated_duration = 0
            chain.success_rate = 0.0
            chain.detection_rate = 0.0
            chain.complexity = ChainComplexity.TRIVIAL
            return
        
        # Calculate total duration
        chain.estimated_duration = sum(n.time_estimate_seconds for n in chain.nodes)
        
        # Calculate success rate (product of individual probabilities)
        chain.success_rate = 1.0
        for node in chain.nodes:
            chain.success_rate *= node.success_probability
        
        # Calculate detection rate (1 - product of non-detection)
        non_detection = 1.0
        for node in chain.nodes:
            non_detection *= (1 - node.detection_risk)
        chain.detection_rate = 1 - non_detection
        
        # Determine complexity
        node_count = len(chain.nodes)
        if node_count <= 2:
            chain.complexity = ChainComplexity.TRIVIAL
        elif node_count <= 4:
            chain.complexity = ChainComplexity.EASY
        elif node_count <= 6:
            chain.complexity = ChainComplexity.MODERATE
        elif node_count <= 8:
            chain.complexity = ChainComplexity.DIFFICULT
        elif node_count <= 12:
            chain.complexity = ChainComplexity.EXPERT
        else:
            chain.complexity = ChainComplexity.NATION_STATE
        
        # Extract MITRE tactics and techniques
        chain.mitre_tactics = list(set(n.tactic for n in chain.nodes if n.tactic))
        chain.mitre_techniques = list(set(n.technique_id for n in chain.nodes if n.technique_id))
    
    def validate_chain(self, chain_id: str) -> Dict[str, Any]:
        """Validate a chain for completeness and correctness"""
        if chain_id not in self.chains:
            return {"valid": False, "errors": ["Chain not found"]}
        
        chain = self.chains[chain_id]
        errors = []
        warnings = []
        
        # Check for entry point
        entry_points = [n for n in chain.nodes if n.node_type == NodeType.ENTRY_POINT]
        if not entry_points:
            errors.append("Chain must have at least one entry point")
        
        # Check for objective
        objectives = [n for n in chain.nodes if n.node_type == NodeType.OBJECTIVE]
        if not objectives:
            warnings.append("Chain has no defined objective")
        
        # Check node connectivity
        connected_nodes = set()
        if chain.edges:
            for edge in chain.edges:
                connected_nodes.add(edge.source_node_id)
                connected_nodes.add(edge.target_node_id)
        
        orphan_nodes = [n for n in chain.nodes if n.node_id not in connected_nodes and len(chain.nodes) > 1]
        if orphan_nodes:
            warnings.append(f"{len(orphan_nodes)} node(s) are not connected")
        
        # Check capability requirements
        available_capabilities = set()
        for node in chain.nodes:
            missing = set(node.requires) - available_capabilities
            if missing:
                warnings.append(f"Node '{node.name}' requires unavailable capabilities: {missing}")
            available_capabilities.update(node.provides)
        
        # Check for cycles (simplified)
        # In production, use proper cycle detection algorithm
        
        return {
            "valid": len(errors) == 0,
            "errors": errors,
            "warnings": warnings,
            "metrics": {
                "node_count": len(chain.nodes),
                "edge_count": len(chain.edges),
                "estimated_duration": chain.estimated_duration,
                "success_rate": chain.success_rate,
                "detection_rate": chain.detection_rate,
                "complexity": chain.complexity.value
            }
        }
    
    def create_from_template(self, template_id: str, name: str, 
                            variables: Dict[str, str] = None) -> Optional[ExploitChain]:
        """Create a chain from a template"""
        if template_id not in self.templates:
            return None
        
        template = self.templates[template_id]
        chain = self.create_chain(name, template.description, template.created_by)
        
        # Add nodes from template
        node_mapping = {}  # Old node ID -> New node ID
        for node_id in template.chain_definition.get("nodes", []):
            new_node = self.add_node_from_library(chain.chain_id, node_id)
            if new_node:
                node_mapping[node_id] = new_node.node_id
        
        # Add edges from template
        for edge_def in template.chain_definition.get("edges", []):
            source = node_mapping.get(edge_def["source"])
            target = node_mapping.get(edge_def["target"])
            if source and target:
                self.add_edge(chain.chain_id, source, target)
        
        return chain
    
    async def execute_chain(self, chain_id: str, dry_run: bool = False) -> ExecutionResult:
        """Execute an exploit chain"""
        if chain_id not in self.chains:
            raise ValueError("Chain not found")
        
        chain = self.chains[chain_id]
        execution_id = str(uuid.uuid4())
        
        result = ExecutionResult(
            execution_id=execution_id,
            chain_id=chain_id,
            started_at=datetime.now(),
            completed_at=None,
            status=ExecutionStatus.RUNNING,
            nodes_executed=0,
            nodes_successful=0,
            nodes_failed=0,
            current_node=None,
            execution_log=[],
            artifacts={},
            total_duration=0.0
        )
        
        self.active_executions[execution_id] = result
        
        # Build execution order (topological sort)
        execution_order = self._get_execution_order(chain)
        
        for node in execution_order:
            result.current_node = node.node_id
            result.execution_log.append({
                "timestamp": datetime.now().isoformat(),
                "node_id": node.node_id,
                "node_name": node.name,
                "action": "starting"
            })
            
            if dry_run:
                # Simulate execution
                node.status = ExecutionStatus.SUCCESS
                result.nodes_successful += 1
            else:
                # Execute node
                success = await self._execute_node(node, result)
                if success:
                    node.status = ExecutionStatus.SUCCESS
                    result.nodes_successful += 1
                else:
                    node.status = ExecutionStatus.FAILED
                    result.nodes_failed += 1
                    
                    # Check if we should continue
                    if not self._should_continue_after_failure(chain, node):
                        break
            
            result.nodes_executed += 1
            result.execution_log.append({
                "timestamp": datetime.now().isoformat(),
                "node_id": node.node_id,
                "node_name": node.name,
                "action": "completed",
                "status": node.status.value
            })
        
        result.completed_at = datetime.now()
        result.total_duration = (result.completed_at - result.started_at).total_seconds()
        result.status = ExecutionStatus.SUCCESS if result.nodes_failed == 0 else ExecutionStatus.FAILED
        result.current_node = None
        
        # Persist result
        await self._persist_execution(result)
        
        return result
    
    def _get_execution_order(self, chain: ExploitChain) -> List[ChainNode]:
        """Get topological execution order for nodes"""
        # Simple topological sort based on edges
        in_degree = {n.node_id: 0 for n in chain.nodes}
        adjacency = {n.node_id: [] for n in chain.nodes}
        
        for edge in chain.edges:
            adjacency[edge.source_node_id].append(edge.target_node_id)
            in_degree[edge.target_node_id] += 1
        
        queue = [n for n in chain.nodes if in_degree[n.node_id] == 0]
        order = []
        
        while queue:
            node = queue.pop(0)
            order.append(node)
            
            for next_id in adjacency[node.node_id]:
                in_degree[next_id] -= 1
                if in_degree[next_id] == 0:
                    next_node = next((n for n in chain.nodes if n.node_id == next_id), None)
                    if next_node:
                        queue.append(next_node)
        
        return order
    
    async def _execute_node(self, node: ChainNode, result: ExecutionResult) -> bool:
        """Execute a single node"""
        import random
        
        # Simulate execution time
        await asyncio.sleep(0.1)  # Minimal delay for demo
        
        # Probability-based success
        success = random.random() < node.success_probability
        
        if success:
            node.output = {
                "success": True,
                "message": f"Successfully executed {node.name}",
                "capabilities_gained": node.provides
            }
        else:
            node.output = {
                "success": False,
                "message": f"Failed to execute {node.name}",
                "error": "Simulated failure"
            }
        
        return success
    
    def _should_continue_after_failure(self, chain: ExploitChain, failed_node: ChainNode) -> bool:
        """Determine if chain should continue after node failure"""
        # Check if there are alternative paths
        for edge in chain.edges:
            if edge.source_node_id == failed_node.node_id and edge.on_failure:
                return True
        return False
    
    async def _persist_execution(self, result: ExecutionResult):
        """Persist execution result to database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Ensure table exists (for in-memory databases)
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS execution_history (
                execution_id TEXT PRIMARY KEY,
                chain_id TEXT,
                started_at TIMESTAMP,
                completed_at TIMESTAMP,
                status TEXT,
                nodes_executed INTEGER,
                nodes_successful INTEGER,
                nodes_failed INTEGER,
                execution_log TEXT,
                artifacts TEXT
            )
        """)
        
        cursor.execute("""
            INSERT OR REPLACE INTO execution_history VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            result.execution_id,
            result.chain_id,
            result.started_at.isoformat(),
            result.completed_at.isoformat() if result.completed_at else None,
            result.status.value,
            result.nodes_executed,
            result.nodes_successful,
            result.nodes_failed,
            json.dumps(result.execution_log),
            json.dumps(result.artifacts)
        ))
        
        conn.commit()
        conn.close()
    
    def export_chain(self, chain_id: str) -> Dict[str, Any]:
        """Export chain to JSON format"""
        if chain_id not in self.chains:
            return {}
        
        chain = self.chains[chain_id]
        return {
            "chain_id": chain.chain_id,
            "name": chain.name,
            "description": chain.description,
            "author": chain.author,
            "version": chain.version,
            "nodes": [
                {
                    "node_id": n.node_id,
                    "name": n.name,
                    "type": n.node_type.value,
                    "technique_id": n.technique_id,
                    "position": {"x": n.position_x, "y": n.position_y}
                }
                for n in chain.nodes
            ],
            "edges": [
                {
                    "source": e.source_node_id,
                    "target": e.target_node_id,
                    "condition": e.condition
                }
                for e in chain.edges
            ],
            "metrics": {
                "complexity": chain.complexity.value,
                "success_rate": chain.success_rate,
                "detection_rate": chain.detection_rate,
                "estimated_duration": chain.estimated_duration
            },
            "mitre": {
                "tactics": chain.mitre_tactics,
                "techniques": chain.mitre_techniques
            }
        }
    
    def get_optimization_suggestions(self, chain_id: str) -> List[Dict[str, str]]:
        """Get suggestions to optimize the chain"""
        if chain_id not in self.chains:
            return []
        
        chain = self.chains[chain_id]
        suggestions = []
        
        # Check for high detection risk
        high_detection_nodes = [n for n in chain.nodes if n.detection_risk > 0.7]
        if high_detection_nodes:
            for node in high_detection_nodes:
                suggestions.append({
                    "type": "detection_risk",
                    "severity": "high",
                    "message": f"Node '{node.name}' has {node.detection_risk*100:.0f}% detection risk",
                    "suggestion": "Consider using stealthier alternatives"
                })
        
        # Check for low success probability paths
        if chain.success_rate < 0.2:
            suggestions.append({
                "type": "success_rate",
                "severity": "high",
                "message": f"Overall chain success rate is only {chain.success_rate*100:.0f}%",
                "suggestion": "Add alternative paths or more reliable techniques"
            })
        
        # Check for missing persistence
        persistence_nodes = [n for n in chain.nodes if n.node_type == NodeType.PERSISTENCE]
        if not persistence_nodes and len(chain.nodes) > 3:
            suggestions.append({
                "type": "persistence",
                "severity": "medium",
                "message": "No persistence mechanism in chain",
                "suggestion": "Add a persistence node to maintain access"
            })
        
        # Check for missing C2
        c2_nodes = [n for n in chain.nodes if n.node_type == NodeType.COMMAND_CONTROL]
        objectives = [n for n in chain.nodes if n.node_type == NodeType.OBJECTIVE]
        if objectives and not c2_nodes:
            suggestions.append({
                "type": "c2",
                "severity": "low",
                "message": "No C2 channel established",
                "suggestion": "Add C2 node for better control during operation"
            })
        
        return suggestions
    
    def get_node_library(self) -> Dict[str, List[ChainNode]]:
        """Get node library organized by type"""
        library = {}
        for node in self.node_library.values():
            type_name = node.node_type.value
            if type_name not in library:
                library[type_name] = []
            library[type_name].append(node)
        return library
    
    def get_templates(self) -> List[ChainTemplate]:
        """Get all available templates"""
        return list(self.templates.values())
    
    def save_chain(self, chain_id: str) -> bool:
        """Save chain to database"""
        if chain_id not in self.chains:
            return False
        
        chain = self.chains[chain_id]
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute("""
            INSERT OR REPLACE INTO exploit_chains VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            chain.chain_id,
            chain.name,
            chain.description,
            chain.author,
            chain.created_at.isoformat(),
            chain.modified_at.isoformat(),
            json.dumps(self.export_chain(chain_id)),
            chain.target_type,
            chain.objective,
            chain.complexity.value,
            chain.status.value,
            chain.version
        ))
        
        conn.commit()
        conn.close()
        return True

    # ==================== NEW COMMERCIAL FEATURES ====================
    
    def clone_chain(self, chain_id: str, new_name: str = None) -> Optional[ExploitChain]:
        """Clone an existing chain with new IDs"""
        if chain_id not in self.chains:
            return None
        
        original = self.chains[chain_id]
        cloned = original.clone()
        if new_name:
            cloned.name = new_name
        else:
            cloned.name = f"{original.name} (Copy)"
        
        # Remap node IDs
        node_id_map = {}
        for node in cloned.nodes:
            old_id = node.node_id
            node.node_id = str(uuid.uuid4())
            node_id_map[old_id] = node.node_id
        
        # Update edge references
        for edge in cloned.edges:
            edge.edge_id = str(uuid.uuid4())
            edge.source_node_id = node_id_map.get(edge.source_node_id, edge.source_node_id)
            edge.target_node_id = node_id_map.get(edge.target_node_id, edge.target_node_id)
        
        self.chains[cloned.chain_id] = cloned
        return cloned
    
    def merge_chains(self, chain_ids: List[str], name: str, 
                     connection_points: List[Tuple[str, str, str]] = None) -> Optional[ExploitChain]:
        """
        Merge multiple chains into one.
        connection_points: List of (chain_id, from_node_id, to_chain_id, to_node_id)
        """
        if not all(cid in self.chains for cid in chain_ids):
            return None
        
        merged = self.create_chain(name, f"Merged from: {', '.join(chain_ids)}", "HydraRecon")
        node_id_map = {}  # (original_chain_id, original_node_id) -> new_node_id
        
        for chain_id in chain_ids:
            chain = self.chains[chain_id]
            for node in chain.nodes:
                new_node = ChainNode(
                    node_id=str(uuid.uuid4()),
                    name=node.name,
                    node_type=node.node_type,
                    description=node.description,
                    technique_id=node.technique_id,
                    tactic=node.tactic,
                    prerequisites=node.prerequisites.copy(),
                    provides=node.provides.copy(),
                    requires=node.requires.copy(),
                    success_probability=node.success_probability,
                    detection_risk=node.detection_risk,
                    time_estimate_seconds=node.time_estimate_seconds,
                    automated=node.automated,
                    payload=node.payload,
                    parameters=node.parameters.copy(),
                    position_x=node.position_x,
                    position_y=node.position_y
                )
                node_id_map[(chain_id, node.node_id)] = new_node.node_id
                merged.nodes.append(new_node)
            
            for edge in chain.edges:
                new_source = node_id_map.get((chain_id, edge.source_node_id))
                new_target = node_id_map.get((chain_id, edge.target_node_id))
                if new_source and new_target:
                    new_edge = ChainEdge(
                        edge_id=str(uuid.uuid4()),
                        source_node_id=new_source,
                        target_node_id=new_target,
                        condition=edge.condition,
                        on_success=edge.on_success,
                        on_failure=edge.on_failure
                    )
                    merged.edges.append(new_edge)
        
        # Add connection edges between chains
        if connection_points:
            for from_chain, from_node, to_chain, to_node in connection_points:
                source = node_id_map.get((from_chain, from_node))
                target = node_id_map.get((to_chain, to_node))
                if source and target:
                    conn_edge = ChainEdge(
                        edge_id=str(uuid.uuid4()),
                        source_node_id=source,
                        target_node_id=target,
                        label="Chain Connection"
                    )
                    merged.edges.append(conn_edge)
        
        self._recalculate_chain_metrics(merged)
        return merged
    
    def diff_chains(self, chain_id_1: str, chain_id_2: str) -> Dict[str, Any]:
        """Compare two chains and return differences"""
        if chain_id_1 not in self.chains or chain_id_2 not in self.chains:
            return {"error": "Chain not found"}
        
        chain1 = self.chains[chain_id_1]
        chain2 = self.chains[chain_id_2]
        
        chain1_techniques = set(n.technique_id for n in chain1.nodes if n.technique_id)
        chain2_techniques = set(n.technique_id for n in chain2.nodes if n.technique_id)
        
        chain1_node_names = set(n.name for n in chain1.nodes)
        chain2_node_names = set(n.name for n in chain2.nodes)
        
        return {
            "chain_1": {"id": chain_id_1, "name": chain1.name, "version": chain1.version},
            "chain_2": {"id": chain_id_2, "name": chain2.name, "version": chain2.version},
            "node_count_diff": len(chain2.nodes) - len(chain1.nodes),
            "edge_count_diff": len(chain2.edges) - len(chain1.edges),
            "success_rate_diff": chain2.success_rate - chain1.success_rate,
            "detection_rate_diff": chain2.detection_rate - chain1.detection_rate,
            "added_nodes": list(chain2_node_names - chain1_node_names),
            "removed_nodes": list(chain1_node_names - chain2_node_names),
            "added_techniques": list(chain2_techniques - chain1_techniques),
            "removed_techniques": list(chain1_techniques - chain2_techniques),
            "complexity_change": f"{chain1.complexity.value} -> {chain2.complexity.value}"
        }
    
    def export_to_attack_navigator(self, chain_id: str) -> Dict[str, Any]:
        """Export chain to MITRE ATT&CK Navigator JSON format"""
        if chain_id not in self.chains:
            return {}
        
        chain = self.chains[chain_id]
        techniques = []
        
        for node in chain.nodes:
            if node.technique_id:
                techniques.append({
                    "techniqueID": node.technique_id,
                    "tactic": node.tactic.replace("-", " ") if node.tactic else "",
                    "color": self._get_technique_color(node),
                    "comment": f"{node.name}: {node.description}",
                    "enabled": True,
                    "metadata": [],
                    "links": [],
                    "showSubtechniques": "." in node.technique_id
                })
        
        return {
            "name": f"HydraRecon - {chain.name}",
            "versions": {
                "attack": "14",
                "navigator": "4.9.1",
                "layer": "4.5"
            },
            "domain": "enterprise-attack",
            "description": chain.description,
            "filters": {
                "platforms": ["Windows", "Linux", "macOS", "Network"]
            },
            "sorting": 0,
            "layout": {
                "layout": "side",
                "aggregateFunction": "average",
                "showID": True,
                "showName": True,
                "showAggregateScores": False,
                "countUnscored": False
            },
            "hideDisabled": False,
            "techniques": techniques,
            "gradient": {
                "colors": ["#ff6666ff", "#ffe766ff", "#8ec843ff"],
                "minValue": 0,
                "maxValue": 100
            },
            "legendItems": [
                {"label": "Entry Point", "color": "#66b3ff"},
                {"label": "Vulnerability", "color": "#ff9999"},
                {"label": "Exploit", "color": "#ff6666"},
                {"label": "Lateral Movement", "color": "#ffcc00"},
                {"label": "Objective", "color": "#00cc66"}
            ],
            "metadata": [
                {"name": "chain_id", "value": chain.chain_id},
                {"name": "author", "value": chain.author},
                {"name": "success_rate", "value": f"{chain.success_rate*100:.1f}%"},
                {"name": "detection_rate", "value": f"{chain.detection_rate*100:.1f}%"}
            ],
            "showTacticRowBackground": True,
            "tacticRowBackground": "#dddddd",
            "selectTechniquesAcrossTactics": True,
            "selectSubtechniquesWithParent": False
        }
    
    def _get_technique_color(self, node: ChainNode) -> str:
        """Get color for technique based on node type"""
        colors = {
            NodeType.ENTRY_POINT: "#66b3ff",
            NodeType.VULNERABILITY: "#ff9999",
            NodeType.EXPLOIT: "#ff6666",
            NodeType.PAYLOAD: "#cc99ff",
            NodeType.PRIVILEGE_ESCALATION: "#ffcc00",
            NodeType.LATERAL_MOVEMENT: "#ff9933",
            NodeType.PERSISTENCE: "#99ccff",
            NodeType.DATA_ACCESS: "#ff66b3",
            NodeType.EXFILTRATION: "#cc6600",
            NodeType.COMMAND_CONTROL: "#9966ff",
            NodeType.OBJECTIVE: "#00cc66",
            NodeType.RECONNAISSANCE: "#99ff99",
            NodeType.DEFENSE_EVASION: "#666666",
            NodeType.CREDENTIAL_ACCESS: "#ffff66",
            NodeType.COLLECTION: "#ff99cc",
            NodeType.IMPACT: "#ff0000",
            NodeType.CLEANUP: "#cccccc",
            NodeType.VALIDATOR: "#00cccc"
        }
        return colors.get(node.node_type, "#ffffff")
    
    def export_to_yaml(self, chain_id: str) -> str:
        """Export chain to YAML format for sharing/storage"""
        if chain_id not in self.chains:
            return ""
        
        chain_data = self.export_chain(chain_id)
        return yaml.dump(chain_data, default_flow_style=False, sort_keys=False)
    
    def import_from_yaml(self, yaml_content: str, author: str = "Imported") -> Optional[ExploitChain]:
        """Import chain from YAML format"""
        try:
            data = yaml.safe_load(yaml_content)
            chain = self.create_chain(
                data.get("name", "Imported Chain"),
                data.get("description", ""),
                author
            )
            
            node_id_map = {}
            for node_data in data.get("nodes", []):
                node_type = NodeType(node_data.get("type", "exploit"))
                node = ChainNode(
                    node_id=str(uuid.uuid4()),
                    name=node_data.get("name", "Unknown"),
                    node_type=node_type,
                    description=node_data.get("description", ""),
                    technique_id=node_data.get("technique_id", ""),
                    position_x=node_data.get("position", {}).get("x", 0),
                    position_y=node_data.get("position", {}).get("y", 0)
                )
                node_id_map[node_data.get("node_id", "")] = node.node_id
                chain.nodes.append(node)
            
            for edge_data in data.get("edges", []):
                old_source = edge_data.get("source", "")
                old_target = edge_data.get("target", "")
                new_source = node_id_map.get(old_source)
                new_target = node_id_map.get(old_target)
                
                if new_source and new_target:
                    edge = ChainEdge(
                        edge_id=str(uuid.uuid4()),
                        source_node_id=new_source,
                        target_node_id=new_target,
                        condition=edge_data.get("condition", "")
                    )
                    chain.edges.append(edge)
            
            self._recalculate_chain_metrics(chain)
            return chain
        except Exception as e:
            logging.error(f"Failed to import YAML chain: {e}")
            return None
    
    def get_ai_suggestions(self, chain_id: str) -> List[Dict[str, Any]]:
        """Get AI-powered suggestions for improving the chain"""
        if chain_id not in self.chains:
            return []
        
        chain = self.chains[chain_id]
        suggestions = []
        
        # Analyze chain structure
        entry_points = [n for n in chain.nodes if n.node_type == NodeType.ENTRY_POINT]
        objectives = [n for n in chain.nodes if n.node_type == NodeType.OBJECTIVE]
        
        # Suggest alternative entry points
        if len(entry_points) == 1:
            alternative_entries = [n for n in self.node_library.values() 
                                   if n.node_type == NodeType.ENTRY_POINT 
                                   and n.node_id not in [e.node_id for e in entry_points]]
            if alternative_entries:
                best_alt = max(alternative_entries, key=lambda x: x.success_probability)
                suggestions.append({
                    "type": "alternative_entry",
                    "priority": "medium",
                    "title": "Add Alternative Entry Point",
                    "description": f"Consider adding '{best_alt.name}' as a backup entry point",
                    "node_suggestion": best_alt.node_id,
                    "rationale": f"Current single entry point has {entry_points[0].success_probability*100:.0f}% success rate"
                })
        
        # Suggest stealth improvements
        high_detection_nodes = [n for n in chain.nodes if n.detection_risk > 0.6]
        for node in high_detection_nodes:
            stealthier_options = [n for n in self.node_library.values()
                                  if n.node_type == node.node_type
                                  and n.detection_risk < node.detection_risk
                                  and n.node_id != node.node_id]
            if stealthier_options:
                best_stealth = min(stealthier_options, key=lambda x: x.detection_risk)
                suggestions.append({
                    "type": "stealth_improvement",
                    "priority": "high",
                    "title": f"Reduce Detection Risk for {node.name}",
                    "description": f"Replace with '{best_stealth.name}' (detection: {best_stealth.detection_risk*100:.0f}% vs {node.detection_risk*100:.0f}%)",
                    "node_suggestion": best_stealth.node_id,
                    "replace_node": node.node_id
                })
        
        # Suggest missing capabilities
        all_provides = set()
        all_requires = set()
        for node in chain.nodes:
            all_provides.update(node.provides)
            all_requires.update(node.requires)
        
        missing_capabilities = all_requires - all_provides
        for cap in missing_capabilities:
            providers = [n for n in self.node_library.values() if cap in n.provides]
            if providers:
                best_provider = max(providers, key=lambda x: x.success_probability)
                suggestions.append({
                    "type": "missing_capability",
                    "priority": "critical",
                    "title": f"Missing Capability: {cap}",
                    "description": f"Add '{best_provider.name}' to provide required capability '{cap}'",
                    "node_suggestion": best_provider.node_id,
                    "capability": cap
                })
        
        # Suggest persistence if missing
        persistence_nodes = [n for n in chain.nodes if n.node_type == NodeType.PERSISTENCE]
        if not persistence_nodes and len(chain.nodes) >= 4:
            persistence_options = [n for n in self.node_library.values() 
                                   if n.node_type == NodeType.PERSISTENCE]
            if persistence_options:
                best_persistence = max(persistence_options, key=lambda x: x.success_probability)
                suggestions.append({
                    "type": "add_persistence",
                    "priority": "medium",
                    "title": "Add Persistence Mechanism",
                    "description": f"Add '{best_persistence.name}' to maintain access after initial compromise",
                    "node_suggestion": best_persistence.node_id
                })
        
        # Sort by priority
        priority_order = {"critical": 0, "high": 1, "medium": 2, "low": 3}
        suggestions.sort(key=lambda x: priority_order.get(x.get("priority", "low"), 4))
        
        return suggestions
    
    def apply_ai_suggestion(self, chain_id: str, suggestion: Dict[str, Any]) -> bool:
        """Apply an AI suggestion to the chain"""
        if chain_id not in self.chains:
            return False
        
        suggestion_type = suggestion.get("type")
        node_id = suggestion.get("node_suggestion")
        
        if suggestion_type == "replace_node":
            # Remove old node and add new one
            old_node_id = suggestion.get("replace_node")
            if old_node_id:
                self.remove_node(chain_id, old_node_id)
            if node_id:
                self.add_node_from_library(chain_id, node_id)
            return True
        elif suggestion_type in ["alternative_entry", "missing_capability", "add_persistence", "stealth_improvement"]:
            if node_id:
                return self.add_node_from_library(chain_id, node_id) is not None
        
        return False
    
    async def execute_with_rollback(self, chain_id: str, dry_run: bool = False) -> ExecutionResult:
        """Execute chain with automatic rollback on failure"""
        if chain_id not in self.chains:
            raise ValueError("Chain not found")
        
        chain = self.chains[chain_id]
        executed_nodes = []  # Track for rollback
        
        result = await self.execute_chain(chain_id, dry_run)
        
        # If failed, attempt rollback
        if result.status == ExecutionStatus.FAILED and not dry_run:
            result.execution_log.append({
                "timestamp": datetime.now().isoformat(),
                "action": "rollback_initiated",
                "reason": "Chain execution failed"
            })
            
            # Rollback in reverse order
            for node in reversed(chain.nodes):
                if node.status == ExecutionStatus.SUCCESS and node.rollback_action:
                    try:
                        # Execute rollback action (simulated)
                        result.execution_log.append({
                            "timestamp": datetime.now().isoformat(),
                            "node_id": node.node_id,
                            "action": "rollback",
                            "rollback_action": node.rollback_action
                        })
                    except Exception as e:
                        result.execution_log.append({
                            "timestamp": datetime.now().isoformat(),
                            "node_id": node.node_id,
                            "action": "rollback_failed",
                            "error": str(e)
                        })
            
            result.execution_log.append({
                "timestamp": datetime.now().isoformat(),
                "action": "rollback_completed"
            })
        
        return result
    
    async def execute_parallel_branches(self, chain_id: str, branch_starts: List[str]) -> Dict[str, ExecutionResult]:
        """Execute multiple chain branches in parallel"""
        if chain_id not in self.chains:
            return {}
        
        chain = self.chains[chain_id]
        tasks = []
        results = {}
        
        for start_node_id in branch_starts:
            # Create sub-chain for each branch
            branch_nodes = self._get_branch_nodes(chain, start_node_id)
            if branch_nodes:
                task = asyncio.create_task(
                    self._execute_branch(chain, branch_nodes, start_node_id)
                )
                tasks.append((start_node_id, task))
        
        for start_id, task in tasks:
            try:
                results[start_id] = await task
            except Exception as e:
                results[start_id] = ExecutionResult(
                    execution_id=str(uuid.uuid4()),
                    chain_id=chain_id,
                    started_at=datetime.now(),
                    completed_at=datetime.now(),
                    status=ExecutionStatus.FAILED,
                    nodes_executed=0,
                    nodes_successful=0,
                    nodes_failed=1,
                    current_node=start_id,
                    execution_log=[{"error": str(e)}],
                    artifacts={},
                    total_duration=0.0
                )
        
        return results
    
    def _get_branch_nodes(self, chain: ExploitChain, start_node_id: str) -> List[ChainNode]:
        """Get all nodes in a branch starting from given node"""
        branch = []
        visited = set()
        queue = [start_node_id]
        
        while queue:
            node_id = queue.pop(0)
            if node_id in visited:
                continue
            visited.add(node_id)
            
            node = next((n for n in chain.nodes if n.node_id == node_id), None)
            if node:
                branch.append(node)
                
                for edge in chain.edges:
                    if edge.source_node_id == node_id:
                        queue.append(edge.target_node_id)
        
        return branch
    
    async def _execute_branch(self, chain: ExploitChain, nodes: List[ChainNode], 
                              branch_id: str) -> ExecutionResult:
        """Execute a single branch of nodes"""
        result = ExecutionResult(
            execution_id=str(uuid.uuid4()),
            chain_id=chain.chain_id,
            started_at=datetime.now(),
            completed_at=None,
            status=ExecutionStatus.RUNNING,
            nodes_executed=0,
            nodes_successful=0,
            nodes_failed=0,
            current_node=branch_id,
            execution_log=[],
            artifacts={},
            total_duration=0.0
        )
        
        for node in nodes:
            success = await self._execute_node(node, result)
            result.nodes_executed += 1
            if success:
                result.nodes_successful += 1
            else:
                result.nodes_failed += 1
        
        result.completed_at = datetime.now()
        result.total_duration = (result.completed_at - result.started_at).total_seconds()
        result.status = ExecutionStatus.SUCCESS if result.nodes_failed == 0 else ExecutionStatus.PARTIAL
        
        return result
    
    def generate_report(self, chain_id: str, format_type: str = "markdown") -> str:
        """Generate a detailed report for the chain"""
        if chain_id not in self.chains:
            return ""
        
        chain = self.chains[chain_id]
        validation = self.validate_chain(chain_id)
        suggestions = self.get_optimization_suggestions(chain_id)
        
        if format_type == "markdown":
            report = f"""# Exploit Chain Report: {chain.name}

## Overview
- **Chain ID**: `{chain.chain_id}`
- **Author**: {chain.author}
- **Version**: {chain.version}
- **Created**: {chain.created_at.strftime('%Y-%m-%d %H:%M:%S')}
- **Modified**: {chain.modified_at.strftime('%Y-%m-%d %H:%M:%S')}
- **Status**: {chain.status.value}

## Description
{chain.description}

## Metrics
| Metric | Value |
|--------|-------|
| Complexity | {chain.complexity.value} |
| Node Count | {len(chain.nodes)} |
| Edge Count | {len(chain.edges)} |
| Success Rate | {chain.success_rate*100:.1f}% |
| Detection Rate | {chain.detection_rate*100:.1f}% |
| Est. Duration | {chain.estimated_duration} seconds |

## MITRE ATT&CK Coverage
### Tactics
{', '.join(chain.mitre_tactics) or 'None mapped'}

### Techniques
{', '.join(chain.mitre_techniques) or 'None mapped'}

## Chain Nodes
"""
            for i, node in enumerate(chain.nodes, 1):
                report += f"""
### {i}. {node.name}
- **Type**: {node.node_type.value}
- **Technique**: {node.technique_id or 'N/A'}
- **Tactic**: {node.tactic or 'N/A'}
- **Success Probability**: {node.success_probability*100:.0f}%
- **Detection Risk**: {node.detection_risk*100:.0f}%
- **Description**: {node.description}
"""
            
            report += f"""
## Validation Results
- **Valid**: {' Yes' if validation['valid'] else ' No'}

### Errors
"""
            for error in validation.get('errors', []):
                report += f"-  {error}\n"
            
            report += "\n### Warnings\n"
            for warning in validation.get('warnings', []):
                report += f"-  {warning}\n"
            
            report += "\n## Optimization Suggestions\n"
            for sugg in suggestions:
                severity_icon = {"high": "", "medium": "", "low": ""}.get(sugg['severity'], "")
                report += f"- {severity_icon} **{sugg['type'].upper()}**: {sugg['message']}\n  -  {sugg['suggestion']}\n"
            
            report += f"""
---
*Generated by HydraRecon Exploit Chain Builder*
*Report Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*
"""
            return report
        
        return json.dumps(self.export_chain(chain_id), indent=2)
    
    def search_chains(self, query: str = "", tags: List[str] = None, 
                      complexity: ChainComplexity = None,
                      min_success_rate: float = 0.0) -> List[ExploitChain]:
        """Search chains by various criteria"""
        results = []
        
        for chain in self.chains.values():
            # Text search
            if query:
                query_lower = query.lower()
                if not (query_lower in chain.name.lower() or 
                        query_lower in chain.description.lower() or
                        any(query_lower in t.lower() for t in chain.mitre_techniques)):
                    continue
            
            # Tag filter
            if tags and not any(t in chain.tags for t in tags):
                continue
            
            # Complexity filter
            if complexity and chain.complexity != complexity:
                continue
            
            # Success rate filter
            if chain.success_rate < min_success_rate:
                continue
            
            results.append(chain)
        
        return results
    
    def get_chain_history(self, chain_id: str) -> List[Dict[str, Any]]:
        """Get execution history for a chain"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT * FROM execution_history 
            WHERE chain_id = ? 
            ORDER BY started_at DESC
        """, (chain_id,))
        
        history = []
        for row in cursor.fetchall():
            history.append({
                "execution_id": row[0],
                "chain_id": row[1],
                "started_at": row[2],
                "completed_at": row[3],
                "status": row[4],
                "nodes_executed": row[5],
                "nodes_successful": row[6],
                "nodes_failed": row[7]
            })
        
        conn.close()
        return history
    
    def get_statistics(self) -> Dict[str, Any]:
        """Get overall statistics for all chains"""
        total_chains = len(self.chains)
        total_nodes = sum(len(c.nodes) for c in self.chains.values())
        total_edges = sum(len(c.edges) for c in self.chains.values())
        
        complexity_dist = {}
        for chain in self.chains.values():
            comp = chain.complexity.value
            complexity_dist[comp] = complexity_dist.get(comp, 0) + 1
        
        avg_success = sum(c.success_rate for c in self.chains.values()) / max(total_chains, 1)
        avg_detection = sum(c.detection_rate for c in self.chains.values()) / max(total_chains, 1)
        
        technique_usage = {}
        for chain in self.chains.values():
            for tech in chain.mitre_techniques:
                technique_usage[tech] = technique_usage.get(tech, 0) + 1
        
        top_techniques = sorted(technique_usage.items(), key=lambda x: x[1], reverse=True)[:10]
        
        return {
            "total_chains": total_chains,
            "total_nodes": total_nodes,
            "total_edges": total_edges,
            "average_success_rate": avg_success,
            "average_detection_rate": avg_detection,
            "complexity_distribution": complexity_dist,
            "top_techniques": dict(top_techniques),
            "templates_available": len(self.templates),
            "library_nodes": len(self.node_library)
        }