"""
Exploit Browser & Database
Search and manage exploits from multiple sources
"""

import asyncio
import aiohttp
import json
import re
import os
import hashlib
import sqlite3
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
import ssl


class ExploitSource(Enum):
    """Sources for exploit information"""
    EXPLOITDB = "exploitdb"
    NVD = "nvd"
    CVE = "cve"
    METASPLOIT = "metasploit"
    NUCLEI = "nuclei"
    GITHUB = "github"
    PACKETSTORM = "packetstorm"
    LOCAL = "local"


class ExploitType(Enum):
    """Types of exploits"""
    REMOTE = "remote"
    LOCAL = "local"
    WEBAPPS = "webapps"
    DOS = "dos"
    SHELLCODE = "shellcode"
    PAPERS = "papers"


class Platform(Enum):
    """Target platforms"""
    LINUX = "linux"
    WINDOWS = "windows"
    MACOS = "macos"
    BSD = "bsd"
    UNIX = "unix"
    ANDROID = "android"
    IOS = "ios"
    HARDWARE = "hardware"
    MULTIPLE = "multiple"
    WEB = "web"


@dataclass
class Exploit:
    """Represents an exploit"""
    exploit_id: str
    title: str
    description: str
    cve_ids: List[str] = field(default_factory=list)
    exploit_type: ExploitType = ExploitType.REMOTE
    platform: Platform = Platform.MULTIPLE
    author: str = ""
    source: ExploitSource = ExploitSource.LOCAL
    source_url: str = ""
    code: str = ""
    file_path: str = ""
    published_date: str = ""
    verified: bool = False
    reliability: str = ""
    tags: List[str] = field(default_factory=list)
    affected_products: List[str] = field(default_factory=list)
    references: List[str] = field(default_factory=list)
    severity: str = ""
    cvss_score: float = 0.0
    created_at: str = field(default_factory=lambda: datetime.now().isoformat())


@dataclass
class SearchResult:
    """Search result container"""
    query: str
    total_results: int
    results: List[Exploit]
    sources_searched: List[str]
    search_time: float


class ExploitDatabase:
    """
    Local exploit database with SQLite backend
    """
    
    def __init__(self, db_path: str = "exploits.db"):
        self.db_path = db_path
        self.conn: Optional[sqlite3.Connection] = None
        self._init_db()
        
    def _init_db(self):
        """Initialize database schema"""
        self.conn = sqlite3.connect(self.db_path)
        self.conn.row_factory = sqlite3.Row
        
        cursor = self.conn.cursor()
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS exploits (
                exploit_id TEXT PRIMARY KEY,
                title TEXT NOT NULL,
                description TEXT,
                cve_ids TEXT,
                exploit_type TEXT,
                platform TEXT,
                author TEXT,
                source TEXT,
                source_url TEXT,
                code TEXT,
                file_path TEXT,
                published_date TEXT,
                verified INTEGER DEFAULT 0,
                reliability TEXT,
                tags TEXT,
                affected_products TEXT,
                references_json TEXT,
                severity TEXT,
                cvss_score REAL,
                created_at TEXT
            )
        ''')
        
        cursor.execute('''
            CREATE INDEX IF NOT EXISTS idx_exploits_cve ON exploits(cve_ids)
        ''')
        
        cursor.execute('''
            CREATE INDEX IF NOT EXISTS idx_exploits_platform ON exploits(platform)
        ''')
        
        cursor.execute('''
            CREATE INDEX IF NOT EXISTS idx_exploits_type ON exploits(exploit_type)
        ''')
        
        cursor.execute('''
            CREATE VIRTUAL TABLE IF NOT EXISTS exploits_fts USING fts5(
                title, description, tags, content=exploits, content_rowid=rowid
            )
        ''')
        
        self.conn.commit()
        
    def add_exploit(self, exploit: Exploit) -> bool:
        """Add exploit to database"""
        try:
            cursor = self.conn.cursor()
            
            cursor.execute('''
                INSERT OR REPLACE INTO exploits 
                (exploit_id, title, description, cve_ids, exploit_type, platform,
                 author, source, source_url, code, file_path, published_date,
                 verified, reliability, tags, affected_products, references_json,
                 severity, cvss_score, created_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                exploit.exploit_id,
                exploit.title,
                exploit.description,
                ','.join(exploit.cve_ids),
                exploit.exploit_type.value,
                exploit.platform.value,
                exploit.author,
                exploit.source.value,
                exploit.source_url,
                exploit.code,
                exploit.file_path,
                exploit.published_date,
                1 if exploit.verified else 0,
                exploit.reliability,
                ','.join(exploit.tags),
                ','.join(exploit.affected_products),
                json.dumps(exploit.references),
                exploit.severity,
                exploit.cvss_score,
                exploit.created_at,
            ))
            
            self.conn.commit()
            return True
            
        except Exception as e:
            print(f"Error adding exploit: {e}")
            return False
            
    def search(self, 
               query: str,
               exploit_type: Optional[ExploitType] = None,
               platform: Optional[Platform] = None,
               limit: int = 50) -> List[Exploit]:
        """Search exploits in database"""
        try:
            cursor = self.conn.cursor()
            
            # Build query
            sql = '''
                SELECT * FROM exploits 
                WHERE (title LIKE ? OR description LIKE ? OR cve_ids LIKE ? OR tags LIKE ?)
            '''
            params = [f'%{query}%', f'%{query}%', f'%{query}%', f'%{query}%']
            
            if exploit_type:
                sql += ' AND exploit_type = ?'
                params.append(exploit_type.value)
                
            if platform:
                sql += ' AND platform = ?'
                params.append(platform.value)
                
            sql += ' ORDER BY cvss_score DESC, published_date DESC LIMIT ?'
            params.append(limit)
            
            cursor.execute(sql, params)
            rows = cursor.fetchall()
            
            return [self._row_to_exploit(row) for row in rows]
            
        except Exception as e:
            print(f"Search error: {e}")
            return []
            
    def get_by_cve(self, cve_id: str) -> List[Exploit]:
        """Get exploits by CVE ID"""
        try:
            cursor = self.conn.cursor()
            cursor.execute(
                'SELECT * FROM exploits WHERE cve_ids LIKE ?',
                [f'%{cve_id}%']
            )
            rows = cursor.fetchall()
            return [self._row_to_exploit(row) for row in rows]
        except Exception:
            return []
            
    def get_by_id(self, exploit_id: str) -> Optional[Exploit]:
        """Get exploit by ID"""
        try:
            cursor = self.conn.cursor()
            cursor.execute(
                'SELECT * FROM exploits WHERE exploit_id = ?',
                [exploit_id]
            )
            row = cursor.fetchone()
            return self._row_to_exploit(row) if row else None
        except Exception:
            return None
            
    def _row_to_exploit(self, row: sqlite3.Row) -> Exploit:
        """Convert database row to Exploit object"""
        return Exploit(
            exploit_id=row['exploit_id'],
            title=row['title'],
            description=row['description'] or '',
            cve_ids=row['cve_ids'].split(',') if row['cve_ids'] else [],
            exploit_type=ExploitType(row['exploit_type']) if row['exploit_type'] else ExploitType.REMOTE,
            platform=Platform(row['platform']) if row['platform'] else Platform.MULTIPLE,
            author=row['author'] or '',
            source=ExploitSource(row['source']) if row['source'] else ExploitSource.LOCAL,
            source_url=row['source_url'] or '',
            code=row['code'] or '',
            file_path=row['file_path'] or '',
            published_date=row['published_date'] or '',
            verified=bool(row['verified']),
            reliability=row['reliability'] or '',
            tags=row['tags'].split(',') if row['tags'] else [],
            affected_products=row['affected_products'].split(',') if row['affected_products'] else [],
            references=json.loads(row['references_json']) if row['references_json'] else [],
            severity=row['severity'] or '',
            cvss_score=row['cvss_score'] or 0.0,
            created_at=row['created_at'] or '',
        )
        
    def get_stats(self) -> Dict[str, Any]:
        """Get database statistics"""
        cursor = self.conn.cursor()
        
        stats = {}
        
        cursor.execute('SELECT COUNT(*) FROM exploits')
        stats['total_exploits'] = cursor.fetchone()[0]
        
        cursor.execute('SELECT exploit_type, COUNT(*) FROM exploits GROUP BY exploit_type')
        stats['by_type'] = dict(cursor.fetchall())
        
        cursor.execute('SELECT platform, COUNT(*) FROM exploits GROUP BY platform')
        stats['by_platform'] = dict(cursor.fetchall())
        
        cursor.execute('SELECT source, COUNT(*) FROM exploits GROUP BY source')
        stats['by_source'] = dict(cursor.fetchall())
        
        cursor.execute('SELECT COUNT(*) FROM exploits WHERE verified = 1')
        stats['verified_count'] = cursor.fetchone()[0]
        
        return stats


class ExploitDBSearcher:
    """
    Exploit-DB API searcher
    """
    
    BASE_URL = "https://www.exploit-db.com"
    
    def __init__(self):
        self.session: Optional[aiohttp.ClientSession] = None
        
    async def __aenter__(self):
        await self.start()
        return self
        
    async def __aexit__(self, *args):
        await self.close()
        
    async def start(self):
        """Initialize session"""
        ssl_context = ssl.create_default_context()
        ssl_context.check_hostname = False
        ssl_context.verify_mode = ssl.CERT_NONE
        
        connector = aiohttp.TCPConnector(ssl=ssl_context)
        self.session = aiohttp.ClientSession(
            connector=connector,
            headers={
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                "Accept": "application/json",
            }
        )
        
    async def close(self):
        """Close session"""
        if self.session:
            await self.session.close()
            
    async def search(self, 
                     query: str,
                     exploit_type: Optional[str] = None,
                     platform: Optional[str] = None,
                     page: int = 1) -> List[Exploit]:
        """Search Exploit-DB"""
        exploits = []
        
        try:
            # Note: This is a simplified implementation
            # Real implementation would need to handle Exploit-DB's actual API/scraping
            
            params = {
                "q": query,
                "draw": 1,
                "columns[0][data]": "date_published",
                "columns[1][data]": "download",
                "order[0][column]": 0,
                "order[0][dir]": "desc",
                "start": (page - 1) * 25,
                "length": 25,
            }
            
            if exploit_type:
                params["type"] = exploit_type
            if platform:
                params["platform"] = platform
                
            async with self.session.get(
                f"{self.BASE_URL}/search",
                params=params
            ) as response:
                if response.status == 200:
                    data = await response.json()
                    
                    for item in data.get("data", []):
                        exploit = Exploit(
                            exploit_id=f"EDB-{item.get('id')}",
                            title=item.get('description', ''),
                            description=item.get('description', ''),
                            exploit_type=ExploitType.REMOTE,
                            platform=self._parse_platform(item.get('platform', '')),
                            author=item.get('author', ''),
                            source=ExploitSource.EXPLOITDB,
                            source_url=f"{self.BASE_URL}/exploits/{item.get('id')}",
                            published_date=item.get('date_published', ''),
                            verified=item.get('verified', False),
                        )
                        exploits.append(exploit)
                        
        except Exception as e:
            print(f"ExploitDB search error: {e}")
            
        return exploits
        
    async def get_exploit(self, exploit_id: str) -> Optional[Exploit]:
        """Get full exploit details including code"""
        try:
            # Extract numeric ID
            numeric_id = exploit_id.replace("EDB-", "")
            
            async with self.session.get(
                f"{self.BASE_URL}/exploits/{numeric_id}",
                headers={"Accept": "text/html"}
            ) as response:
                if response.status == 200:
                    html = await response.text()
                    
                    # Parse exploit details from HTML
                    # Simplified parsing
                    title_match = re.search(r'<h1[^>]*>([^<]+)</h1>', html)
                    code_match = re.search(r'<code[^>]*>(.*?)</code>', html, re.DOTALL)
                    
                    return Exploit(
                        exploit_id=exploit_id,
                        title=title_match.group(1) if title_match else "",
                        description="",
                        source=ExploitSource.EXPLOITDB,
                        source_url=f"{self.BASE_URL}/exploits/{numeric_id}",
                        code=code_match.group(1) if code_match else "",
                    )
                    
        except Exception:
            pass
            
        return None
        
    def _parse_platform(self, platform_str: str) -> Platform:
        """Parse platform string to enum"""
        platform_map = {
            "linux": Platform.LINUX,
            "windows": Platform.WINDOWS,
            "macos": Platform.MACOS,
            "mac os x": Platform.MACOS,
            "bsd": Platform.BSD,
            "unix": Platform.UNIX,
            "android": Platform.ANDROID,
            "ios": Platform.IOS,
            "hardware": Platform.HARDWARE,
            "multiple": Platform.MULTIPLE,
            "web": Platform.WEB,
            "webapps": Platform.WEB,
        }
        return platform_map.get(platform_str.lower(), Platform.MULTIPLE)


class NVDSearcher:
    """
    NVD (National Vulnerability Database) API searcher
    """
    
    BASE_URL = "https://services.nvd.nist.gov/rest/json"
    
    def __init__(self, api_key: Optional[str] = None):
        self.api_key = api_key
        self.session: Optional[aiohttp.ClientSession] = None
        
    async def __aenter__(self):
        await self.start()
        return self
        
    async def __aexit__(self, *args):
        await self.close()
        
    async def start(self):
        """Initialize session"""
        headers = {"Accept": "application/json"}
        if self.api_key:
            headers["apiKey"] = self.api_key
            
        self.session = aiohttp.ClientSession(headers=headers)
        
    async def close(self):
        """Close session"""
        if self.session:
            await self.session.close()
            
    async def search_cve(self, 
                         keyword: Optional[str] = None,
                         cve_id: Optional[str] = None,
                         start_date: Optional[str] = None,
                         end_date: Optional[str] = None) -> List[Dict[str, Any]]:
        """Search NVD for CVEs"""
        vulnerabilities = []
        
        try:
            params = {}
            
            if keyword:
                params["keywordSearch"] = keyword
            if cve_id:
                params["cveId"] = cve_id
            if start_date:
                params["pubStartDate"] = start_date
            if end_date:
                params["pubEndDate"] = end_date
                
            async with self.session.get(
                f"{self.BASE_URL}/cves/2.0",
                params=params
            ) as response:
                if response.status == 200:
                    data = await response.json()
                    
                    for item in data.get("vulnerabilities", []):
                        cve = item.get("cve", {})
                        
                        # Extract CVSS score
                        cvss_score = 0.0
                        metrics = cve.get("metrics", {})
                        if "cvssMetricV31" in metrics:
                            cvss_score = metrics["cvssMetricV31"][0].get("cvssData", {}).get("baseScore", 0.0)
                        elif "cvssMetricV2" in metrics:
                            cvss_score = metrics["cvssMetricV2"][0].get("cvssData", {}).get("baseScore", 0.0)
                            
                        vuln = {
                            "cve_id": cve.get("id"),
                            "description": cve.get("descriptions", [{}])[0].get("value", ""),
                            "cvss_score": cvss_score,
                            "published": cve.get("published"),
                            "references": [ref.get("url") for ref in cve.get("references", [])],
                            "cwe": [w.get("description", [{}])[0].get("value") for w in cve.get("weaknesses", [])],
                        }
                        vulnerabilities.append(vuln)
                        
        except Exception as e:
            print(f"NVD search error: {e}")
            
        return vulnerabilities
        
    async def get_cve(self, cve_id: str) -> Optional[Dict[str, Any]]:
        """Get specific CVE details"""
        results = await self.search_cve(cve_id=cve_id)
        return results[0] if results else None


class GitHubExploitSearcher:
    """
    Search GitHub for exploit PoCs
    """
    
    def __init__(self, token: Optional[str] = None):
        self.token = token
        self.session: Optional[aiohttp.ClientSession] = None
        
    async def __aenter__(self):
        await self.start()
        return self
        
    async def __aexit__(self, *args):
        await self.close()
        
    async def start(self):
        """Initialize session"""
        headers = {"Accept": "application/vnd.github.v3+json"}
        if self.token:
            headers["Authorization"] = f"token {self.token}"
            
        self.session = aiohttp.ClientSession(headers=headers)
        
    async def close(self):
        """Close session"""
        if self.session:
            await self.session.close()
            
    async def search(self, 
                     query: str,
                     language: Optional[str] = None,
                     sort: str = "stars",
                     limit: int = 50) -> List[Exploit]:
        """Search GitHub for exploits"""
        exploits = []
        
        try:
            # Add exploit-related keywords
            search_query = f"{query} exploit OR poc OR vulnerability"
            
            if language:
                search_query += f" language:{language}"
                
            params = {
                "q": search_query,
                "sort": sort,
                "order": "desc",
                "per_page": min(limit, 100),
            }
            
            async with self.session.get(
                "https://api.github.com/search/repositories",
                params=params
            ) as response:
                if response.status == 200:
                    data = await response.json()
                    
                    for repo in data.get("items", []):
                        # Create exploit from repo
                        exploit = Exploit(
                            exploit_id=f"GH-{repo['id']}",
                            title=repo.get("name", ""),
                            description=repo.get("description", "") or "",
                            author=repo.get("owner", {}).get("login", ""),
                            source=ExploitSource.GITHUB,
                            source_url=repo.get("html_url", ""),
                            published_date=repo.get("created_at", ""),
                            tags=[repo.get("language", "")] if repo.get("language") else [],
                        )
                        
                        # Try to extract CVE from name/description
                        cve_pattern = r'CVE-\d{4}-\d+'
                        text = f"{repo.get('name', '')} {repo.get('description', '')}"
                        cves = re.findall(cve_pattern, text, re.IGNORECASE)
                        exploit.cve_ids = list(set(cves))
                        
                        exploits.append(exploit)
                        
        except Exception as e:
            print(f"GitHub search error: {e}")
            
        return exploits
        
    async def get_repo_contents(self, 
                                owner: str, 
                                repo: str,
                                path: str = "") -> List[Dict[str, Any]]:
        """Get repository contents"""
        try:
            async with self.session.get(
                f"https://api.github.com/repos/{owner}/{repo}/contents/{path}"
            ) as response:
                if response.status == 200:
                    return await response.json()
        except Exception:
            pass
        return []


class ExploitBrowser:
    """
    Unified exploit browser - searches multiple sources
    """
    
    def __init__(self, 
                 db_path: str = "exploits.db",
                 nvd_api_key: Optional[str] = None,
                 github_token: Optional[str] = None):
        self.database = ExploitDatabase(db_path)
        self.nvd_api_key = nvd_api_key
        self.github_token = github_token
        
    async def search(self,
                     query: str,
                     sources: Optional[List[ExploitSource]] = None,
                     exploit_type: Optional[ExploitType] = None,
                     platform: Optional[Platform] = None,
                     limit: int = 50) -> SearchResult:
        """
        Search all sources for exploits
        """
        start_time = datetime.now()
        all_exploits = []
        sources_searched = []
        
        # Default to all sources
        if not sources:
            sources = [ExploitSource.LOCAL, ExploitSource.EXPLOITDB, 
                      ExploitSource.GITHUB, ExploitSource.NVD]
                      
        # Search local database
        if ExploitSource.LOCAL in sources:
            sources_searched.append("local")
            local_results = self.database.search(query, exploit_type, platform, limit)
            all_exploits.extend(local_results)
            
        # Search Exploit-DB
        if ExploitSource.EXPLOITDB in sources:
            sources_searched.append("exploitdb")
            async with ExploitDBSearcher() as searcher:
                edb_results = await searcher.search(query, 
                    exploit_type.value if exploit_type else None,
                    platform.value if platform else None)
                all_exploits.extend(edb_results[:limit])
                
        # Search GitHub
        if ExploitSource.GITHUB in sources:
            sources_searched.append("github")
            async with GitHubExploitSearcher(self.github_token) as searcher:
                gh_results = await searcher.search(query, limit=limit)
                all_exploits.extend(gh_results)
                
        # Enrich with NVD data
        if ExploitSource.NVD in sources:
            sources_searched.append("nvd")
            async with NVDSearcher(self.nvd_api_key) as nvd:
                # Search NVD for keyword
                nvd_results = await nvd.search_cve(keyword=query)
                
                # Create exploit entries for CVEs
                for vuln in nvd_results[:limit]:
                    exploit = Exploit(
                        exploit_id=vuln["cve_id"],
                        title=vuln["cve_id"],
                        description=vuln["description"],
                        cve_ids=[vuln["cve_id"]],
                        source=ExploitSource.NVD,
                        cvss_score=vuln["cvss_score"],
                        published_date=vuln["published"],
                        references=vuln["references"],
                    )
                    all_exploits.append(exploit)
                    
        # Deduplicate by CVE
        seen_cves = set()
        unique_exploits = []
        for exploit in all_exploits:
            if exploit.cve_ids:
                key = tuple(sorted(exploit.cve_ids))
                if key not in seen_cves:
                    seen_cves.add(key)
                    unique_exploits.append(exploit)
            else:
                unique_exploits.append(exploit)
                
        # Sort by CVSS score
        unique_exploits.sort(key=lambda x: x.cvss_score, reverse=True)
        
        search_time = (datetime.now() - start_time).total_seconds()
        
        return SearchResult(
            query=query,
            total_results=len(unique_exploits),
            results=unique_exploits[:limit],
            sources_searched=sources_searched,
            search_time=search_time
        )
        
    async def search_by_cve(self, cve_id: str) -> SearchResult:
        """Search for exploits by CVE ID"""
        return await self.search(cve_id)
        
    async def search_by_product(self, 
                                product: str,
                                version: Optional[str] = None) -> SearchResult:
        """Search for exploits by product name/version"""
        query = product
        if version:
            query = f"{product} {version}"
        return await self.search(query)
        
    async def enrich_exploit(self, exploit: Exploit) -> Exploit:
        """Enrich exploit with additional data from NVD"""
        if exploit.cve_ids:
            async with NVDSearcher(self.nvd_api_key) as nvd:
                for cve_id in exploit.cve_ids:
                    cve_data = await nvd.get_cve(cve_id)
                    if cve_data:
                        exploit.cvss_score = max(exploit.cvss_score, cve_data.get("cvss_score", 0))
                        exploit.references.extend(cve_data.get("references", []))
                        if cve_data.get("description"):
                            exploit.description = cve_data["description"]
                            
        return exploit
        
    def save_exploit(self, exploit: Exploit) -> bool:
        """Save exploit to local database"""
        return self.database.add_exploit(exploit)
        
    def get_stats(self) -> Dict[str, Any]:
        """Get database statistics"""
        return self.database.get_stats()


class ExploitMatcher:
    """
    Match vulnerabilities to available exploits
    """
    
    def __init__(self, browser: ExploitBrowser):
        self.browser = browser
        
    async def match_vulnerability(self, 
                                   cve_id: Optional[str] = None,
                                   product: Optional[str] = None,
                                   version: Optional[str] = None,
                                   port: Optional[int] = None,
                                   service: Optional[str] = None) -> List[Exploit]:
        """
        Find exploits matching vulnerability criteria
        """
        matches = []
        
        # Search by CVE if available
        if cve_id:
            result = await self.browser.search_by_cve(cve_id)
            matches.extend(result.results)
            
        # Search by product/service
        if product or service:
            query = product or service
            if version:
                query = f"{query} {version}"
            result = await self.browser.search(query)
            matches.extend(result.results)
            
        # Deduplicate
        seen = set()
        unique = []
        for exploit in matches:
            if exploit.exploit_id not in seen:
                seen.add(exploit.exploit_id)
                unique.append(exploit)
                
        # Sort by reliability and CVSS
        unique.sort(key=lambda x: (x.verified, x.cvss_score), reverse=True)
        
        return unique
        
    async def match_scan_results(self, 
                                  scan_results: List[Dict[str, Any]]) -> Dict[str, List[Exploit]]:
        """
        Match exploits to scan results (from nmap, etc.)
        """
        matches = {}
        
        for result in scan_results:
            host = result.get("host", "unknown")
            matches[host] = []
            
            # Check each service
            for service in result.get("services", []):
                port = service.get("port")
                service_name = service.get("name")
                product = service.get("product")
                version = service.get("version")
                cpe = service.get("cpe")
                
                # Extract CVEs if available
                cves = service.get("cves", [])
                
                for cve_id in cves:
                    exploits = await self.match_vulnerability(cve_id=cve_id)
                    matches[host].extend(exploits)
                    
                # Search by product/service
                if product:
                    exploits = await self.match_vulnerability(
                        product=product,
                        version=version,
                        port=port,
                        service=service_name
                    )
                    matches[host].extend(exploits)
                    
        return matches


# Helper functions
async def search_exploits(query: str, **kwargs) -> SearchResult:
    """Convenience function to search for exploits"""
    browser = ExploitBrowser()
    return await browser.search(query, **kwargs)


async def find_exploit_for_cve(cve_id: str) -> List[Exploit]:
    """Convenience function to find exploits for a CVE"""
    browser = ExploitBrowser()
    result = await browser.search_by_cve(cve_id)
    return result.results


if __name__ == "__main__":
    async def main():
        print("="*60)
        print("Exploit Browser - Search Multiple Sources")
        print("="*60)
        
        browser = ExploitBrowser()
        
        # Search for exploits
        query = "apache struts"
        print(f"\n[*] Searching for: {query}")
        
        result = await browser.search(
            query,
            sources=[ExploitSource.LOCAL, ExploitSource.GITHUB],
            limit=10
        )
        
        print(f"[+] Found {result.total_results} results in {result.search_time:.2f}s")
        print(f"[+] Sources: {', '.join(result.sources_searched)}")
        
        for exploit in result.results[:5]:
            print(f"\n  [{exploit.exploit_id}] {exploit.title}")
            print(f"    Source: {exploit.source.value}")
            print(f"    CVEs: {', '.join(exploit.cve_ids) if exploit.cve_ids else 'N/A'}")
            print(f"    CVSS: {exploit.cvss_score}")
            print(f"    URL: {exploit.source_url}")
            
        # Get stats
        print("\n[*] Database Statistics:")
        stats = browser.get_stats()
        print(f"    Total exploits: {stats['total_exploits']}")
        
    asyncio.run(main())
